1
00:00:07,516 --> 00:00:17,500
[ Music ]


2
00:00:23,446 --> 00:00:24,676
>> So hi, everybody.


3
00:00:25,516 --> 00:00:30,526
[ Applause ]


4
00:00:31,026 --> 00:00:33,336
I'm Melissa, I'm one of
the core data engineers


5
00:00:33,796 --> 00:00:35,966
and this literally the first
year that no one has told me


6
00:00:35,966 --> 00:00:39,236
to break a leg before I go out
on stage, because frankly I did


7
00:00:39,236 --> 00:00:40,756
that a month ago and
this my first day


8
00:00:40,756 --> 00:00:41,986
without a cast [laughter].


9
00:00:42,046 --> 00:00:43,966
So if I'm limping around
you'll know what happened.


10
00:00:45,516 --> 00:00:47,546
[ Applause ]


11
00:00:48,046 --> 00:00:49,536
So one of the best
parts of working


12
00:00:49,536 --> 00:00:50,896
on core data is actually
being able to get


13
00:00:50,896 --> 00:00:53,926
up on stage here every year
and tell you guys like what new


14
00:00:53,926 --> 00:00:56,336
and interesting stuff
we've been doing and boy,


15
00:00:56,336 --> 00:00:58,726
this year we have a lot of it,
and it's really useful and we,


16
00:00:58,936 --> 00:01:00,216
we hope you're going to love it.


17
00:01:01,236 --> 00:01:03,386
So I'm going to talk about a
new feature, query generations,


18
00:01:03,386 --> 00:01:05,796
some changes in the core
data concurrency world.


19
00:01:05,916 --> 00:01:09,046
I'm going to talk about some
new stuff we've done in the area


20
00:01:09,046 --> 00:01:12,206
of core data stack configuration
and some new APIs we've added.


21
00:01:12,806 --> 00:01:15,606
And we're going to talk a
bit about what we've done


22
00:01:15,606 --> 00:01:18,826
to integrate more neatly and
cleanly with Swift and some


23
00:01:18,826 --> 00:01:19,896
of the improvements we've made


24
00:01:19,896 --> 00:01:21,786
in the area of Xcode
integration.


25
00:01:22,666 --> 00:01:26,096
And that's a lot so, on with
the first, query generations.


26
00:01:27,566 --> 00:01:29,416
Query generations is a
new feature we've added


27
00:01:29,506 --> 00:01:31,276
but before I sort
of get into talking


28
00:01:31,276 --> 00:01:32,626
about query generations
I need to talk


29
00:01:32,626 --> 00:01:33,526
about faults a little bit.


30
00:01:34,336 --> 00:01:37,266
Core data uses faults a lot,
as some of you may know.


31
00:01:37,946 --> 00:01:39,966
Manage objects can be faults,


32
00:01:40,036 --> 00:01:41,556
their relationships
can be faults,


33
00:01:41,696 --> 00:01:43,196
and if you're using
batch fetching,


34
00:01:43,566 --> 00:01:44,876
then the array you get back


35
00:01:44,996 --> 00:01:47,816
from NSManagedObjectContext
execute fetch request,


36
00:01:47,816 --> 00:01:49,276
is going to be a very
specialized fault.


37
00:01:49,936 --> 00:01:52,526
So that being said,
what is a fault?


38
00:01:53,026 --> 00:01:56,336
Well, up here on the
screen I've got a picture


39
00:01:56,336 --> 00:01:59,246
of an object graph, I've got
a country, the United States.


40
00:01:59,916 --> 00:02:01,816
State, California,
couple of counties,


41
00:02:01,956 --> 00:02:03,296
Santa Clara and San Francisco.


42
00:02:03,806 --> 00:02:07,726
And some cities in Santa
Clara, San Jose and Cupertino.


43
00:02:08,656 --> 00:02:09,726
And some of this is a piece


44
00:02:09,726 --> 00:02:12,906
of like a tourist guide a
guidebook, something you can go


45
00:02:12,906 --> 00:02:15,536
in and navigate through
to find points of interest


46
00:02:15,586 --> 00:02:18,306
in a city you're planning
on going and visiting.


47
00:02:19,106 --> 00:02:22,376
But just based on what we
know about the United States,


48
00:02:22,606 --> 00:02:24,996
this isn't a full object
graph, this is actually a piece


49
00:02:24,996 --> 00:02:26,806
of an object graph, sub graph.


50
00:02:26,876 --> 00:02:29,106
Because we know that the
United States has other states,


51
00:02:29,366 --> 00:02:31,286
and those states
have other counties,


52
00:02:31,616 --> 00:02:33,806
and those counties
have other cities.


53
00:02:34,476 --> 00:02:35,806
And you know, beyond
that we know


54
00:02:35,806 --> 00:02:38,516
that the United States is
only one of many countries.


55
00:02:40,426 --> 00:02:42,956
And even in a guidebook I'm only
interested in sort of looking


56
00:02:42,956 --> 00:02:44,526
at one set of data at a time.


57
00:02:44,526 --> 00:02:47,036
If I'm planning a trip to
San Jose, I don't really care


58
00:02:47,036 --> 00:02:49,496
about Oregon or Washington,
or anything like that.


59
00:02:49,496 --> 00:02:51,356
I don't even really care
about San Francisco.


60
00:02:52,116 --> 00:02:54,036
I need to be able to
get to those object,


61
00:02:54,066 --> 00:02:56,756
to those destinations
if I'm interested


62
00:02:56,996 --> 00:02:59,236
and change my mind later about
what I'm interested in browsing.


63
00:02:59,236 --> 00:03:01,966
But for the immediate short
term, while I'm looking


64
00:03:01,966 --> 00:03:05,266
and planning my trip to Santa
Clara County, I don't care.


65
00:03:06,396 --> 00:03:09,716
And that not caring
is represented by,


66
00:03:09,716 --> 00:03:12,916
in memory a fault, it's an
object that knows how to go off


67
00:03:12,916 --> 00:03:16,146
and retrieve data
later, at some point


68
00:03:16,656 --> 00:03:17,756
if I decide I want to use it.


69
00:03:18,156 --> 00:03:19,986
So say I find out my
friend is getting married


70
00:03:20,316 --> 00:03:22,456
and her wedding's in
Seattle and I want to go,


71
00:03:22,456 --> 00:03:23,606
you know plan a trip to Seattle.


72
00:03:24,276 --> 00:03:26,466
So at this point I'm going to
navigate back up to the U.S.


73
00:03:26,466 --> 00:03:28,036
and come down, I want
to look at Washington


74
00:03:28,356 --> 00:03:31,426
and core data will automatically
retrieve the information


75
00:03:31,506 --> 00:03:34,896
for Washington even
though it wasn't in memory


76
00:03:35,286 --> 00:03:37,086
when I first loaded
the sub graph.


77
00:03:37,756 --> 00:03:40,986
And you know, I can navigate
down from that and so on.


78
00:03:40,986 --> 00:03:45,166
And that's what a fault is,
it's that future or promise,


79
00:03:45,166 --> 00:03:47,866
or lazy loading, these
are all different names


80
00:03:47,866 --> 00:03:50,156
for the same kind of
thing, that core data does


81
00:03:50,156 --> 00:03:52,086
to help minimize the
amount of data you have


82
00:03:52,086 --> 00:03:53,336
in memory at any given point.


83
00:03:54,616 --> 00:03:55,676
Why do we use faults?


84
00:03:55,676 --> 00:03:57,106
Well performance, performance,


85
00:03:57,106 --> 00:03:58,506
performance, and
also performance.


86
00:04:00,006 --> 00:04:02,406
The best most performing
application is one


87
00:04:02,406 --> 00:04:03,866
that doesn't do any
work you don't need.


88
00:04:04,696 --> 00:04:07,916
You don't load objects over
the iobus, that you don't need.


89
00:04:08,016 --> 00:04:09,276
You don't spend any
time [inaudible]


90
00:04:09,276 --> 00:04:11,066
on objects that you don't need.


91
00:04:11,546 --> 00:04:14,646
You don't want to have those
objects sitting around pushing


92
00:04:14,646 --> 00:04:16,505
up your heaps high water mark


93
00:04:16,505 --> 00:04:18,916
if your user's never
going to look at them.


94
00:04:19,136 --> 00:04:21,326
But there is kind of
one issue with faults,


95
00:04:22,256 --> 00:04:23,336
and it's sort of this.


96
00:04:23,796 --> 00:04:27,516
Here we have that object
graph again, and in this case,


97
00:04:27,566 --> 00:04:28,536
we've got a lot of faults.


98
00:04:29,366 --> 00:04:31,936
And I'm navigating down my
tree and I go to Santa Clara


99
00:04:31,936 --> 00:04:34,036
and I want to fire
the Cupertino fault.


100
00:04:34,506 --> 00:04:38,176
But in the meantime, an external
process has been importing data


101
00:04:38,176 --> 00:04:40,756
from the web and for whatever
reason it's deleted Cupertino.


102
00:04:41,296 --> 00:04:42,786
Well, what happens?


103
00:04:42,786 --> 00:04:44,586
I have a fault that's
supposed to go off


104
00:04:44,586 --> 00:04:47,266
and retrieve information
about Cupertino


105
00:04:47,266 --> 00:04:49,036
but there's no information
there anymore.


106
00:04:50,376 --> 00:04:53,186
I said, I talked a lot about
not loading data you don't need,


107
00:04:53,186 --> 00:04:55,136
but in this case, you
find yourself wondering,


108
00:04:55,246 --> 00:04:58,196
well did I actually need
that data after all?


109
00:04:59.516 --> 00:04:59.886 A:middle
Oops.


110
00:05:02,476 --> 00:05:04,696
In core data right
now, you handle this


111
00:05:04,696 --> 00:05:06,656
by using the
shouldDeleteInaccessibleFaults


112
00:05:06,656 --> 00:05:08,456
property on
NSManagedObjectContext.


113
00:05:09,136 --> 00:05:11,536
If you set that then
when the context notices


114
00:05:11,536 --> 00:05:13,866
that you're trying to fire a
fault for a deleted object,


115
00:05:14,176 --> 00:05:16,826
it will mark the fault as
being deleted and populate all


116
00:05:16,826 --> 00:05:18,716
of its properties with nils.


117
00:05:19,216 --> 00:05:20,496
This is mostly what
you're going to want


118
00:05:20,896 --> 00:05:22,216
but sometimes it
can be inconvenient


119
00:05:22,216 --> 00:05:23,796
because your UI doesn't
know how to deal


120
00:05:23,796 --> 00:05:25,526
with you know, a nil identifier.


121
00:05:26,346 --> 00:05:28,216
The other alternative is
to prefetch everything,


122
00:05:28,666 --> 00:05:31,056
use relationship keypads
for prefetching to load all


123
00:05:31,056 --> 00:05:33,706
of the objects you think
your user might want.


124
00:05:34,086 --> 00:05:35,676
That moves you into
an escalating battle


125
00:05:35,676 --> 00:05:37,946
with your user trying
to figure out exactly,


126
00:05:38,566 --> 00:05:40,996
predict what they're going
to want, that can be tricky,


127
00:05:40,996 --> 00:05:42,656
users are unpredictable,
we all know that.


128
00:05:43,266 --> 00:05:45,016
The other alternative,
there is a third one,


129
00:05:45,016 --> 00:05:47,096
there's always a third
one, write lots of code,


130
00:05:47,456 --> 00:05:49,416
starting with using
existing object with ID


131
00:05:49,416 --> 00:05:51,986
on the manage object context
to make sure that the object is


132
00:05:51,986 --> 00:05:53,726
in the database before
you try the fault.


133
00:05:54,476 --> 00:05:57,046
Write lots of try catch,
exceptional handlers


134
00:05:57,086 --> 00:05:58,656
around all your fault firing


135
00:05:58,976 --> 00:06:01,076
and frankly that's not
really fun code to write,


136
00:06:01,126 --> 00:06:03,576
you'd really rather be
writing interesting features


137
00:06:03,576 --> 00:06:05,766
for your users to use,
because that's why they come


138
00:06:05,766 --> 00:06:07,506
to your application,
because it does neat stuff.


139
00:06:08,646 --> 00:06:10,516
But let's step back
for a second and think


140
00:06:10,516 --> 00:06:13,006
about your user interacting
with your application.


141
00:06:13,416 --> 00:06:16,586
The user view and the
UI often doesn't care


142
00:06:16,586 --> 00:06:18,386
about seeing the
absolute latest,


143
00:06:18,386 --> 00:06:19,786
freshest, snappiest data.


144
00:06:20,246 --> 00:06:21,116
How do we know this?


145
00:06:22,496 --> 00:06:24,016
Let's think about gas
pumps for a second.


146
00:06:24,976 --> 00:06:27,306
Most of you are familiar
with them, you've put gas


147
00:06:27,306 --> 00:06:28,096
in a car at some point.


148
00:06:28,816 --> 00:06:30,956
Gas pumps have a display that
tells you how many gallons


149
00:06:30,956 --> 00:06:33,616
or how many liters you've
actually put in your car.


150
00:06:34,116 --> 00:06:36,486
And that display has
a thousandths field,


151
00:06:37,136 --> 00:06:39,256
and I'd like a show of hands
for everybody who's capable


152
00:06:39,256 --> 00:06:42,076
of reading that field,
in real time,


153
00:06:42,076 --> 00:06:43,246
as they put gas in their car.


154
00:06:44,086 --> 00:06:46,316
That's about what I expected,
none of you can process it,


155
00:06:46,316 --> 00:06:48,766
the human brain wants data
sort of batched up neatly


156
00:06:48,826 --> 00:06:50,396
in intervals that
it can understand.


157
00:06:51,096 --> 00:06:53,376
So the user doesn't really
need latest, freshest data,


158
00:06:53,376 --> 00:06:54,386
they just need it
to be, you know,


159
00:06:55,566 --> 00:06:56,636
reasonably, quickly updated.


160
00:06:56,636 --> 00:07:00,326
And a user who's saving
data, also doesn't care,


161
00:07:00,416 --> 00:07:02,076
this is why core data
has merge policies,


162
00:07:02,376 --> 00:07:03,796
they want to make a bunch
of edits and they want


163
00:07:03,796 --> 00:07:05,916
to have those edits saved
and mingled with whatever's


164
00:07:05,916 --> 00:07:07,916
in the database and have
the right thing happen.


165
00:07:08,536 --> 00:07:09,816
You pick the merge
policy you want


166
00:07:09,816 --> 00:07:12,856
because you know your
users better than we do.


167
00:07:13,106 --> 00:07:16,406
So what if we could take
this insight and build on it?


168
00:07:16,766 --> 00:07:20,086
What if we could provide a way
to give your UI a stable view


169
00:07:20,086 --> 00:07:21,276
of data in the database?


170
00:07:22,466 --> 00:07:24,426
What if we could give you
a way to handle changes,


171
00:07:24,426 --> 00:07:25,786
update changes
deterministically?


172
00:07:25,786 --> 00:07:28,636
And what if we could
do all of this


173
00:07:28,696 --> 00:07:29,856
so that you would
never see this again?


174
00:07:32,516 --> 00:07:36,126
[ Applause ]


175
00:07:36,626 --> 00:07:38,526
And now I can talk
about query generations.


176
00:07:39,666 --> 00:07:40,996
Query generations are a way


177
00:07:40,996 --> 00:07:44,236
of giving your manage object
context a basically a read


178
00:07:44,236 --> 00:07:46,236
transaction on data
in the database.


179
00:07:46,836 --> 00:07:49,166
All reads into that manage
object context are going


180
00:07:49,166 --> 00:07:52,386
to see the same view of data
until you choose to advance it,


181
00:07:52,516 --> 00:07:55,266
and you'll never see could
not fulfill a fault again.


182
00:07:55,266 --> 00:07:57,666
And the important part is
we do this efficiently,


183
00:07:58,336 --> 00:07:59,816
that's always been
the tricky bit.


184
00:08:00,716 --> 00:08:01,946
How do they work?


185
00:08:02,256 --> 00:08:04,026
Well, I've got a
database, it has an object


186
00:08:04,026 --> 00:08:05,916
in it, id 1, name fred.


187
00:08:06,156 --> 00:08:09,106
And because these are
slides, I'm going to cut those


188
00:08:09,106 --> 00:08:11,226
down because I need all the real
estate I can get for this built.


189
00:08:12,846 --> 00:08:15,166
In a traditional database
that's what you've got,


190
00:08:15,316 --> 00:08:17,706
you have one file, it has one
view of data in the world.


191
00:08:18,146 --> 00:08:19,516
Using query generations though,


192
00:08:20,356 --> 00:08:22,356
that becomes the
first generation


193
00:08:22,356 --> 00:08:23,576
of data in your database.


194
00:08:25,056 --> 00:08:27,686
And processes come along,
this can be your application,


195
00:08:27,686 --> 00:08:30,896
it can be an importer, it can
be an extension on a watch,


196
00:08:31,036 --> 00:08:32,885
something modifies the database.


197
00:08:34,596 --> 00:08:36,196
A new generation is created.


198
00:08:37,645 --> 00:08:40,456
And, more data is
created, new objects.


199
00:08:40,996 --> 00:08:44,226
And at this point, the user
launches your application,


200
00:08:47,206 --> 00:08:49,496
creates manage object
context and you load data.


201
00:08:50,136 --> 00:08:52,656
And that context now
knows what generation


202
00:08:52,656 --> 00:08:54,396
in the database it
loaded data from.


203
00:08:54,956 --> 00:08:59,386
So as other processes or
contexts or whatever come along


204
00:08:59,386 --> 00:09:02,936
and modify the database
some more,


205
00:09:03,166 --> 00:09:04,366
more generations are created,


206
00:09:05,126 --> 00:09:06,726
that context still
knows its generation.


207
00:09:06,956 --> 00:09:11,376
Second context comes up, loads
some data, makes some edits,


208
00:09:12,636 --> 00:09:16,236
and saves and in saving it
creates a new generation


209
00:09:16,286 --> 00:09:19,256
and tracks that it's now
representing generation,


210
00:09:19,566 --> 00:09:21,186
in this case 6, in the database.


211
00:09:21,826 --> 00:09:24,876
And at this point if we
fire a fault, in context 1,


212
00:09:25,396 --> 00:09:26,846
even though the object
underlining


213
00:09:26,846 --> 00:09:29,356
that fault may have been
deleted in generation 6,


214
00:09:29,646 --> 00:09:32,046
it's still visible to the
context because it's still


215
00:09:32,046 --> 00:09:34,146
in the database under
the label generation 3.


216
00:09:35,186 --> 00:09:39,336
And at this point the user can
go make some edits in context 1,


217
00:09:39,376 --> 00:09:43,286
delete some objects, change some
objects, insert new objects.


218
00:09:43,676 --> 00:09:46,286
And when they save that context
core data will use the merge


219
00:09:46,346 --> 00:09:49,086
policy to merge all of those
changes with whatever's


220
00:09:49,086 --> 00:09:53,146
in the database and
create a new generation 7.


221
00:09:53,726 --> 00:09:56,976
In the same way that context 1.


222
00:09:57,516 --> 00:09:59,836
[ Applause ]


223
00:10:00,336 --> 00:10:03,746
In the same way that context 1
had visibility onto generation 3


224
00:10:03,746 --> 00:10:05,626
when it was pinned
to generation 3.


225
00:10:06,226 --> 00:10:09,756
Context 2 can do whatever it
would like with its objects,


226
00:10:09,866 --> 00:10:11,996
turn them back into
faults, refire those faults,


227
00:10:12,306 --> 00:10:14,496
and it will still see
the data as it existed


228
00:10:14,496 --> 00:10:16,466
in generation 6 in the database.


229
00:10:17,686 --> 00:10:20,466
So basically it's full
read transactionality


230
00:10:20,466 --> 00:10:21,906
at the manage object
context level.


231
00:10:22,306 --> 00:10:25,636
We've talked a lot
about how context have,


232
00:10:26,456 --> 00:10:27,986
are essentially right
transactions


233
00:10:27,986 --> 00:10:29,756
and now we've made them
read transactions as well.


234
00:10:30,076 --> 00:10:32,676
So allows you to immediately
isolate your work on a context


235
00:10:32,676 --> 00:10:35,086
by context level,
and minimize stuff


236
00:10:35,086 --> 00:10:37,076
like preventive prefetching
which means,


237
00:10:37,076 --> 00:10:39,786
you know, everybody wins.


238
00:10:40,546 --> 00:10:43,386
Basics. An individual context
can choose what behavior it


239
00:10:43,386 --> 00:10:46,986
wants, it can decide that it
wants the current behavior


240
00:10:46,986 --> 00:10:51,166
that you're used to
in iOS 9 and macOS 11.


241
00:10:51,556 --> 00:10:55,306
We call unpinned, see top
of tree when you load data.


242
00:10:55,436 --> 00:10:57,736
You can also specify
that a context should pin


243
00:10:57,736 --> 00:10:59,756
to whatever generation is
current in the database


244
00:10:59,956 --> 00:11:02,136
when data is first
loaded into that context.


245
00:11:02,376 --> 00:11:04,376
Or you can specify
that you want it to pin


246
00:11:04,376 --> 00:11:05,606
to a specific generation


247
00:11:05,916 --> 00:11:08,096
if you have another context
pinned to that generation.


248
00:11:09,616 --> 00:11:10,546
Nested contacts are going


249
00:11:10,546 --> 00:11:12,446
to inherit their
parents' generation,


250
00:11:12,926 --> 00:11:15,726
they're implicitly unpinned
but they'll see data as viewed


251
00:11:15,726 --> 00:11:17,846
through the, the
generation of their parent,


252
00:11:18,206 --> 00:11:20,666
plus whatever pending changes
their parent has sitting


253
00:11:20,666 --> 00:11:21,726
around unsaved.


254
00:11:24,536 --> 00:11:27,076
Updates are kind of important,
we've all acknowledged that,


255
00:11:27,246 --> 00:11:28,556
the user doesn't
want to see updates,


256
00:11:28,556 --> 00:11:30,636
eventually they don't want to
see, you know 10 year-old data.


257
00:11:32,536 --> 00:11:35,246
Generations are updated when
you explicitly tell a context


258
00:11:35,316 --> 00:11:37,386
to update by setting a
new generation token.


259
00:11:37,726 --> 00:11:39,966
They're updated on
save, they're updated


260
00:11:39,966 --> 00:11:42,206
if you call mergeChanges,
will update to top of tree


261
00:11:42,206 --> 00:11:44,066
at that point since you've
told the context that,


262
00:11:44,426 --> 00:11:46,576
you know it should be looking
at a new set of changes


263
00:11:46,576 --> 00:11:48,916
in the database,
and it's updated


264
00:11:49,236 --> 00:11:50,456
as a result of calling reset.


265
00:11:51,046 --> 00:11:55,096
Thing to note though is that,


266
00:11:56,016 --> 00:11:57,696
registered objects
aren't refreshed


267
00:11:57,696 --> 00:12:00,196
when you update the generation,
you may not want that,


268
00:12:00,656 --> 00:12:03,486
and it's easy for us to let
you do it, it's a lot harder


269
00:12:03,486 --> 00:12:05,526
to let you undo it if we
choose to do it for you.


270
00:12:05,786 --> 00:12:09,146
If you want to refresh the data
you'll have to call a fetch


271
00:12:09,146 --> 00:12:12,356
or refreshAllObjects, but it
gives you control over when


272
00:12:12,356 --> 00:12:14,116
that data actually gets updated.


273
00:12:14,556 --> 00:12:18,386
If you want to use query
generations you'll need


274
00:12:18,386 --> 00:12:20,766
to be using and SQL store and
it needs to be in wall mode.


275
00:12:21,226 --> 00:12:22,916
Although if you try and
use query generations


276
00:12:22,916 --> 00:12:24,836
and you haven't met those
two requirements it will sort


277
00:12:24,836 --> 00:12:27,606
of fail gracefully and just
revert to the unpinned behavior.


278
00:12:27,606 --> 00:12:29,966
How did we do it?


279
00:12:30,276 --> 00:12:33,486
Well, there's an now opaque
token that you can use


280
00:12:33,486 --> 00:12:34,766
to track a query generation.


281
00:12:34,766 --> 00:12:37,076
This will tell the
context, you know when


282
00:12:37,076 --> 00:12:39,046
and what store it
loaded data from.


283
00:12:39,296 --> 00:12:43,336
The query generation token
has a method current,


284
00:12:43,516 --> 00:12:45,456
you can use to retrieve
a token to indicate


285
00:12:45,456 --> 00:12:47,676
that a context should
pin when it loads data.


286
00:12:50,076 --> 00:12:52,516
ManagedObjectContext, we
have a few new methods,


287
00:12:52,516 --> 00:12:54,886
there's a property,
query generation token


288
00:12:54,886 --> 00:12:58,076
that will tell you what query
generation a context is using.


289
00:12:58,466 --> 00:13:00,266
It'll be nil if the
context is unpinned.


290
00:13:00,976 --> 00:13:03,306
And you can set a query
generation from a token,


291
00:13:03,356 --> 00:13:06,696
either the current token
from class property or,


292
00:13:07,356 --> 00:13:09,196
the result of calling
queryGenerationToken


293
00:13:09,196 --> 00:13:11,326
on another manage
object context.


294
00:13:12,716 --> 00:13:15,276
A generation won't include
stores that were added


295
00:13:15,406 --> 00:13:18,076
to the store coordinator after
the generation was created.


296
00:13:18,496 --> 00:13:21,016
If you load data into a
manage object context,


297
00:13:21,186 --> 00:13:23,216
add a store to the
coordinator and then do a fetch,


298
00:13:23,466 --> 00:13:25,266
you will not see results
from that new store.


299
00:13:25,716 --> 00:13:28,066
But it does not prevent
you from removing stores


300
00:13:28,066 --> 00:13:29,876
from the coordinator, although
you're going to see an error


301
00:13:29,876 --> 00:13:34,836
if you try and load data into a
context when you've removed all


302
00:13:34,836 --> 00:13:36,566
of the stores that it was
trying to load data from.


303
00:13:37,126 --> 00:13:41,066
And now I'm going to talk
about concurrency because,


304
00:13:41,646 --> 00:13:43,236
well we always talk
about concurrency.


305
00:13:45,096 --> 00:13:47,326
This is the current state
of affairs in core data,


306
00:13:47,726 --> 00:13:50,916
and it's manage object
context is an actor.


307
00:13:50,916 --> 00:13:54,156
You use perform and
performAndWait to interact


308
00:13:54,156 --> 00:13:56,236
with it, do schedule
blocks for execution


309
00:13:56,276 --> 00:13:57,946
on the managed object
context queue.


310
00:13:57,946 --> 00:14:00,626
There is a third model,
which, or another model,


311
00:14:00,626 --> 00:14:02,416
which is to use the
confinementConcurrencyType


312
00:14:02,726 --> 00:14:04,566
which allows you to
message the context directly


313
00:14:04,566 --> 00:14:06,836
but that's deprecated
because it turns


314
00:14:06,836 --> 00:14:08,116
out that that's really
hard to get right


315
00:14:08,536 --> 00:14:10,656
in any threading situation.


316
00:14:11,586 --> 00:14:14,866
The persistent store
coordinator is also an actor


317
00:14:14,866 --> 00:14:17,206
and has the same API
perform and performAndWait.


318
00:14:17,206 --> 00:14:20,156
And the coordinator will
serialize request coming


319
00:14:20,156 --> 00:14:22,996
in from individual managed
object context along


320
00:14:22,996 --> 00:14:25,446
with whatever request you've
directly scheduled using the


321
00:14:25,446 --> 00:14:28,246
perform and performAndWait
APIs on the coordinate.


322
00:14:28,646 --> 00:14:32,626
And at this point I'd like to
make an important announcement,


323
00:14:33,216 --> 00:14:35,556
we have added, for those of
you who are programming in ObjC


324
00:14:35,556 --> 00:14:39,276
and using manual retain
release, and auto release pool


325
00:14:39,276 --> 00:14:40,566
around perform, block and wait.


326
00:14:40,566 --> 00:14:43,216
This means that you're now
going to be responsible


327
00:14:43,216 --> 00:14:46,606
for extending the lifespan
of any objects created


328
00:14:46,606 --> 00:14:48,686
in the blocks you've
scheduled if you want


329
00:14:48,686 --> 00:14:50,406
to use those objects
outside the block.


330
00:14:50,406 --> 00:14:52,766
It's easy to remember to
do that for the results of,


331
00:14:52,766 --> 00:14:54,336
for example an execute fetch.


332
00:14:54,746 --> 00:14:57,496
It's a little bit less
immediately obvious


333
00:14:57,496 --> 00:14:59,526
that you also need to
do this for any NSErrors


334
00:14:59,526 --> 00:15:00,546
that may be being returned.


335
00:15:01,376 --> 00:15:03,906
This doesn't only affect people
using manual retain release


336
00:15:03,906 --> 00:15:06,366
and we have a link time check
so you won't see this behavior


337
00:15:06,366 --> 00:15:10,136
until you recompile
for iOS X or macOS 12.


338
00:15:10,866 --> 00:15:14,866
But let's talk about concurrency
as it exists in the world today.


339
00:15:15,736 --> 00:15:18,786
Or, as it exists in the
world until yesterday.


340
00:15:20,186 --> 00:15:24,596
Context 1 tries to do
something that requires going


341
00:15:24,596 --> 00:15:27,376
to the persistent store, so
it messages the coordinator.


342
00:15:28,236 --> 00:15:30,886
Which, because its sterilizing
requests, takes a lock.


343
00:15:30,886 --> 00:15:32,136
And at this point context 2,


344
00:15:32,136 --> 00:15:35,536
which may be your UIContext
wants to do something and tries


345
00:15:35,536 --> 00:15:36,626
to message the coordinator.


346
00:15:37,076 --> 00:15:40,296
But because the coordinator is
locked, context 2 has to wait,


347
00:15:40,826 --> 00:15:45,346
as the request from context 1 is
passed down to persistent store


348
00:15:45,726 --> 00:15:49,526
and whatever work is necessary
to evaluate, evaluates.


349
00:15:49,986 --> 00:15:52,436
And it's only when that
work finishes and the thread


350
00:15:52,436 --> 00:15:56,526
of execution returns that
context 2 can take a lock


351
00:15:56,526 --> 00:15:58,956
on the coordinator and
have its work dispatched


352
00:15:58,956 --> 00:15:59,646
down to the store.


353
00:15:59,996 --> 00:16:02,266
And this means that context 2
is basically going to be blocked


354
00:16:02,266 --> 00:16:04,516
on whatever work it is
that context 1 is doing.


355
00:16:05,126 --> 00:16:07,356
And eventually it will return


356
00:16:07,356 --> 00:16:08,806
but in the meantime
your IU might have,


357
00:16:08,866 --> 00:16:10,136
you know been a little bit slow.


358
00:16:11,976 --> 00:16:16,436
New stuff, the SQL store now has
a connection pool and is capable


359
00:16:16,436 --> 00:16:18,406
of handling multiple
concurrent requests.


360
00:16:18,736 --> 00:16:21,616
Specifically it can now
handle multiple readers


361
00:16:21,616 --> 00:16:24,786
and a single writer, size of
the connection pool varies


362
00:16:24,786 --> 00:16:25,926
from platform to platform.


363
00:16:26,646 --> 00:16:28,576
We've adopted it and
we'll show you how


364
00:16:28,576 --> 00:16:30,466
to change it in a couple slides.


365
00:16:30,936 --> 00:16:32,146
So how does this work now?


366
00:16:33,026 --> 00:16:36,036
Well context 1 dispatches
to the coordinator,


367
00:16:37,076 --> 00:16:38,926
and well no lock is taken.


368
00:16:39,776 --> 00:16:43,716
Context 2, which may still be
your UIContext also dispatches


369
00:16:43,746 --> 00:16:47,376
the coordinator and both
of those messages are sent


370
00:16:47,376 --> 00:16:49,596
down to the persistent
store at the same time.


371
00:16:50,566 --> 00:16:52,916
Persistent store then does
whatever work it needs to figure


372
00:16:52,916 --> 00:16:55,246
out what messages
it needs to SQLite


373
00:16:55,896 --> 00:16:57,496
and those are sent
down to SQLite.


374
00:16:57,496 --> 00:16:59,696
And it's only at that
point that a lock is taken,


375
00:16:59,696 --> 00:17:01,996
and this is the standard
SQLite file block.


376
00:17:03,076 --> 00:17:07,246
SQLite does whatever it needs
to do, begin opens transaction,


377
00:17:07,246 --> 00:17:09,726
right it's a bunch of SQL,
closes the transaction,


378
00:17:11,146 --> 00:17:14,526
ends at that point returns.


379
00:17:15,146 --> 00:17:17,366
So you can see at this point
that we've really, really,


380
00:17:17,366 --> 00:17:19,756
really decreased the scope of
the critical section there.


381
00:17:20,236 --> 00:17:22,026
And why do you care?


382
00:17:22,306 --> 00:17:24,406
This is going to make your
UI a lot more responsive,


383
00:17:24,786 --> 00:17:27,806
you can fault and
fetch in, for example,


384
00:17:27,986 --> 00:17:31,356
a main UI while background
work is happening


385
00:17:31,476 --> 00:17:32,776
on a separate context.


386
00:17:33,536 --> 00:17:34,786
And the immediate fallout


387
00:17:34,786 --> 00:17:36,746
from this is it really
simplifies application


388
00:17:36,746 --> 00:17:38,856
architecture, a fairly
standard pattern,


389
00:17:38,856 --> 00:17:43,186
has been that people will have
an importer context that's


390
00:17:43,186 --> 00:17:45,126
loading data for
example, from the web.


391
00:17:45,496 --> 00:17:49,186
And another, a main UIContext
is vending data to the main UI.


392
00:17:50,486 --> 00:17:52,686
And they end up having
these on separate stacks


393
00:17:52,826 --> 00:17:54,576
because the UI needs
to be responsive


394
00:17:54,576 --> 00:17:57,006
and they need the
critical section locking


395
00:17:57,006 --> 00:17:58,106
to be as small as possible.


396
00:17:59,416 --> 00:18:01,626
And the only way to get
that before when you had


397
00:18:01,626 --> 00:18:04,896
to lock the entire stack, was
to have two separate stacks.


398
00:18:05,256 --> 00:18:07,736
And that introduced an issue
with doing hand offs between,


399
00:18:07,736 --> 00:18:10,166
okay there's a manage object
context did save notification


400
00:18:10,166 --> 00:18:12,176
but it's coming from an entirely
separate persistent store


401
00:18:12,176 --> 00:18:14,026
coordinator and I need
to migrate that over.


402
00:18:15,046 --> 00:18:18,436
That's no longer an issue there,
you can now attach both context


403
00:18:18,436 --> 00:18:21,866
to the same persistent store
coordinator, they'll execute


404
00:18:21,866 --> 00:18:25,716
in parallel and you can
just do standard merging,


405
00:18:25,716 --> 00:18:28,866
and as a huge bonus this means
they're sharing the row cache


406
00:18:29,146 --> 00:18:31,086
which is really going to
decrease your memory footprint.


407
00:18:31,086 --> 00:18:33,246
It's going to divide
it by 2, since well,


408
00:18:33,636 --> 00:18:41,296
we've only got one
row cache nowadays.


409
00:18:41,616 --> 00:18:47,216
It's on by default, it's for SQL
stores only, and it only works


410
00:18:47,216 --> 00:18:48,636
if all coordinated stores


411
00:18:48,636 --> 00:18:50,936
on a persistent store
coordinator are SQL stores.


412
00:18:51,816 --> 00:18:53,266
You can configure the size


413
00:18:53,266 --> 00:18:55,726
of the connection pool
using the NSPersistentStore


414
00:18:55,726 --> 00:18:58,206
ConnectionPoolMax
SizeKey, that allows you


415
00:18:58,346 --> 00:19:01,556
to specify the maximum
size the connection pool.


416
00:19:01,856 --> 00:19:03,776
If you want serial
request handling,


417
00:19:03,776 --> 00:19:05,336
the old behavior,
you can set it to 1.


418
00:19:05,856 --> 00:19:08,266
We do reserve the right
to say you tried to set it


419
00:19:08,266 --> 00:19:10,566
to one million and that's
kind of silly so we're going


420
00:19:10,566 --> 00:19:11,626
to use a more reasonable number.


421
00:19:12,056 --> 00:19:17,166
It should be transparent to
most of you right off the bat,


422
00:19:17,166 --> 00:19:19,416
your UIs will possibly get
a little more responsive.


423
00:19:20,346 --> 00:19:22,646
The big thing we noticed
internally once we turned this


424
00:19:22,646 --> 00:19:25,666
on, was a whole bunch of
people said, hey, wow I can rip


425
00:19:25,666 --> 00:19:28,776
out a couple hundred, couple
thousand lines of code.


426
00:19:29,246 --> 00:19:31,346
And you should do it because man
is that satisfying [laughter].


427
00:19:32,186 --> 00:19:34,976
A few of you.


428
00:19:35,516 --> 00:19:38,846
[ Applause ]


429
00:19:39,346 --> 00:19:43,786
A few of you may notice,
some minor timing issues.


430
00:19:43,786 --> 00:19:47,136
If you had a context, context
1 that had a perform block


431
00:19:47,136 --> 00:19:49,626
and wait and context 2 that also
had a perform block and wait,


432
00:19:49,876 --> 00:19:53,116
originally context 2 would
not start executing its block


433
00:19:53,436 --> 00:19:56,776
until context 1's block had
returned, that's no longer true.


434
00:19:56,776 --> 00:20:00,026
So for the like .1% of you
who are in that situation,


435
00:20:00,336 --> 00:20:01,906
your timing's going to
change and you may need


436
00:20:01,906 --> 00:20:04,326
to decrease the bandwidth
connection pool,


437
00:20:04,326 --> 00:20:05,046
the rearchitect.


438
00:20:05,436 --> 00:20:08,456
The rest of you, you'll
just get to build new


439
00:20:08,456 --> 00:20:09,646
and interesting and
simpler code.


440
00:20:10,496 --> 00:20:12,646
And at this point I'm
going to drag my co-worker,


441
00:20:12,646 --> 00:20:14,476
Scott up on stage and
he's going to talk


442
00:20:14,476 --> 00:20:15,566
about a bunch of other stuff.


443
00:20:16,516 --> 00:20:22,336
[ Applause ]


444
00:20:22,836 --> 00:20:23,386
>> Thanks Melissa.


445
00:20:26,066 --> 00:20:31,006
Good morning, let's talk
about setting up core data,


446
00:20:32,656 --> 00:20:34,186
starting with adding
a persistent store.


447
00:20:34,186 --> 00:20:36,776
To add a persistent
store to a coordinator,


448
00:20:36,776 --> 00:20:38,946
you need four pieces
of data and,


449
00:20:39,226 --> 00:20:41,216
to do most operations
you need at least two.


450
00:20:42,166 --> 00:20:45,386
New this year, core data has
introduced a new type called


451
00:20:45,386 --> 00:20:48,266
NSPersistentStoreDescription
that encapsulates all


452
00:20:48,266 --> 00:20:49,816
of the data needed
to describe a store


453
00:20:50,206 --> 00:20:53,746
and also includes convenience
API for common options


454
00:20:53,746 --> 00:20:55,866
like whether the store
should be opened read only,


455
00:20:56,336 --> 00:20:59,866
the timeout that the coordinator
should use, automatic migration


456
00:20:59,866 --> 00:21:02,526
and mapping options which are
both enabled by default now.


457
00:21:02,926 --> 00:21:05,556
And a new option, for adding
stores asynchronously,


458
00:21:07,506 --> 00:21:09,316
this new type works
with a new method


459
00:21:09,316 --> 00:21:10,796
on the persistent
store coordinator


460
00:21:11,226 --> 00:21:13,976
that takes a trail
enclosure with parameters


461
00:21:13,976 --> 00:21:17,596
for the store description and an
optional NSError that is non-nil


462
00:21:17,596 --> 00:21:18,616
if the operation failed.


463
00:21:19,736 --> 00:21:21,856
If you're adding a store
asynchronously you can extend


464
00:21:21,856 --> 00:21:24,226
the conditional in a
call back for things


465
00:21:24,226 --> 00:21:27,526
like posting a notification or
pushing your application's UI


466
00:21:27,526 --> 00:21:29,286
after the store has
been successfully added.


467
00:21:30,096 --> 00:21:33,636
This way your app's model setup
can happen off the main thread


468
00:21:33,826 --> 00:21:36,046
which is especially useful
when your application launches


469
00:21:36,046 --> 00:21:37,716
since a migration
may cause a delay.


470
00:21:38,316 --> 00:21:41,136
Remember, if iOS notices that
your app hasn't been responsive


471
00:21:41,136 --> 00:21:43,466
for a while after launch,
then it will kill the app.


472
00:21:44,166 --> 00:21:46,846
This can prevent a migration
from ever finishing but,


473
00:21:46,846 --> 00:21:48,326
it's not a problem anymore


474
00:21:48,326 --> 00:21:49,766
if you're adding a
store asynchronously.


475
00:21:50,346 --> 00:21:54,226
So that's persistent
store descriptions but,


476
00:21:54,226 --> 00:21:56,706
there's a lot more involved
in setting up core data stack.


477
00:21:57,426 --> 00:21:59,716
To represent a core data stack
you need at least three objects,


478
00:22:00,056 --> 00:22:02,396
plus the boiler plate to
associate them with each other.


479
00:22:03,746 --> 00:22:06,106
New this year, core data
has yet another type


480
00:22:06,106 --> 00:22:08,136
that encapsulates
those objects and most


481
00:22:08,136 --> 00:22:10,446
of the boiler plate called
NSPersistentContainer,


482
00:22:10,446 --> 00:22:12,316
not only does it [laughter].


483
00:22:13,516 --> 00:22:17,076
[ Applause ]


484
00:22:17,576 --> 00:22:19,786
I realized a lot of you have
written this type yourselves


485
00:22:19,786 --> 00:22:23,266
maybe but [laughter] this one
not only encapsulates modeling


486
00:22:23,266 --> 00:22:25,516
configuration it
also has a name,


487
00:22:26,296 --> 00:22:28,666
a list of store descriptions,
and a method


488
00:22:28,666 --> 00:22:31,326
to load store descriptions
from that list


489
00:22:31,326 --> 00:22:33,106
that haven't already been
added to the coordinator.


490
00:22:34,106 --> 00:22:35,996
This means that the
project boiler plated needed


491
00:22:35,996 --> 00:22:38,366
to setup core data goes
from an entire page of code


492
00:22:38,826 --> 00:22:40,846
to just a couple of lines.


493
00:22:42,516 --> 00:22:50,816
[ Applause ]


494
00:22:51,316 --> 00:22:53,156
So there's a lot of
code missing here now,


495
00:22:53,156 --> 00:22:54,676
let's take a look
at how it all works.


496
00:22:55,206 --> 00:22:57,516
The container guarantees that
its properties are always valid


497
00:22:57,516 --> 00:23:00,366
so the getters for things like
the coordinator and the model,


498
00:23:00,366 --> 00:23:03,176
will always return new
objects that are safe to use.


499
00:23:04,086 --> 00:23:06,876
The container's initializer
finds a model based on the name


500
00:23:06,876 --> 00:23:08,146
that you pass into
the initializer,


501
00:23:09,186 --> 00:23:10,476
there's also another initializer


502
00:23:10,476 --> 00:23:12,206
that takes an explicit
model argument.


503
00:23:13,646 --> 00:23:16,856
By default, new containers
have a single store description


504
00:23:16,856 --> 00:23:19,786
in the list, it's an
SQLite with default options


505
00:23:20,016 --> 00:23:23,016
and a file name based on
the name of the container.


506
00:23:23,636 --> 00:23:27,056
And it's stored in a directory
that's defined by a class method


507
00:23:27,056 --> 00:23:29,656
on the container, and
a persistent container,


508
00:23:29,656 --> 00:23:33,396
by default will return
you a directory based


509
00:23:33,396 --> 00:23:34,446
on the platform that you're on.


510
00:23:34,446 --> 00:23:36,946
So it will use the application
support directory on macOS,


511
00:23:37,456 --> 00:23:40,516
your container document
structure on iOS and launchOS,


512
00:23:40,566 --> 00:23:43,276
and your containers
caches directory on tvOS.


513
00:23:43,276 --> 00:23:47,896
If you want to set your own
directory then you can subclass


514
00:23:47,896 --> 00:23:50,026
in this persistent container
and override the direct,


515
00:23:50,226 --> 00:23:52,826
sorry the defaulted
directory URL class method.


516
00:23:54,406 --> 00:23:56,616
We think container's really
helpful for setting up core data


517
00:23:56,856 --> 00:23:58,486
but they also provide
convenience


518
00:23:58,486 --> 00:23:59,596
for common operations.


519
00:24:00,196 --> 00:24:03,376
Containers have a main queue
context property called view


520
00:24:03,376 --> 00:24:05,916
context that you can
use to drive your UI.


521
00:24:06,246 --> 00:24:09,196
There's also a factory method
that vends background contexts


522
00:24:09,196 --> 00:24:11,576
that are ready to use
but most of the time,


523
00:24:12,006 --> 00:24:14,216
you'll probably want to
use the container's method


524
00:24:14,216 --> 00:24:15,706
for performing background tasks


525
00:24:15,706 --> 00:24:17,606
which is called
performBackgroundTask.


526
00:24:18,246 --> 00:24:22,026
So instead of having to setup a
new background context and wire


527
00:24:22,026 --> 00:24:23,486
up and then a queue a
block just to do something


528
00:24:23,486 --> 00:24:25,876
in the background you can just
pass a block to the container.


529
00:24:27,156 --> 00:24:28,966
Using performBackgroundTask
can have a benefit to the


530
00:24:28,966 --> 00:24:31,826
on code concision using it
gives core data the ability


531
00:24:31,826 --> 00:24:33,706
to reduce the number of
contexts that are created


532
00:24:33,706 --> 00:24:36,696
to do your work, and also can
work with connection pooling


533
00:24:36,696 --> 00:24:38,236
to ensure that your
app stays responsive,


534
00:24:38,276 --> 00:24:39,266
even under heavy load.


535
00:24:41,806 --> 00:24:43,566
Speaking of common
context work flows,


536
00:24:43,966 --> 00:24:47,106
the NSManagedObjectContext has
a new property this year called


537
00:24:47,106 --> 00:24:49,796
automatically merges
changes from parent.


538
00:24:49,796 --> 00:24:51,166
It's a Boolean and
when you set it


539
00:24:51,166 --> 00:24:52,946
to true the context will
automatically merge,


540
00:24:52,946 --> 00:24:54,616
save the change the
data of its parent.


541
00:24:55,376 --> 00:24:56,076
This works for [laughter].


542
00:24:57,516 --> 00:25:00,086iddle
[ Applause ]


543
00:24:57,516 --> 00:25:00,086
[ Applause ]


544
00:25:00,586 --> 00:25:03,126
This is really handy, it
works for child context


545
00:25:03,126 --> 00:25:06,676
when the parent saves its
changes, and it also works


546
00:25:06,676 --> 00:25:09,476
for top level context when a
sibling saves up to the store.


547
00:25:09,936 --> 00:25:12,336
It works especially well
with generation tokens


548
00:25:12,336 --> 00:25:13,706
which Melissa talked
about earlier.


549
00:25:14,746 --> 00:25:18,566
So your UIs can be maintenance
free if you pin your UI context


550
00:25:18,566 --> 00:25:20,846
to the latest generation and
then enable automatic merging,


551
00:25:21,156 --> 00:25:23,306
your faults will be safe
and your object bindings


552
00:25:23,306 --> 00:25:25,686
and fetch results controllers
will keep themselves


553
00:25:27,196 --> 00:25:28,596
up to date [laughter].


554
00:25:30,426 --> 00:25:34,966
Alright. Let's talk
about generics.


555
00:25:36,156 --> 00:25:38,616
Core data has adopted generics
this year and they work great


556
00:25:38,616 --> 00:25:39,646
in both ObjC and Swift.


557
00:25:39,646 --> 00:25:43,666
There is a new protocol
called NSFetchRequestResult,


558
00:25:44,156 --> 00:25:48,246
and it is adopted by all of the
types that you'd ever expect


559
00:25:48,246 --> 00:25:51,226
to see back from the fetch
request like NSManagedObject


560
00:25:51,226 --> 00:25:52,846
or all the entity subclasses.


561
00:25:53,346 --> 00:25:57,146
Object IDs, NSDictionary
and NSNumber.


562
00:25:58,146 --> 00:26:01,206
NSFetchRequest is now
parameterized based on the type


563
00:26:01,206 --> 00:26:02,816
of the results which
is restricted


564
00:26:02,816 --> 00:26:05,806
by protocol conformance and
in Swift, the fetch method


565
00:26:05,806 --> 00:26:08,236
on NSManagedObjectContext
plums the type


566
00:26:08,236 --> 00:26:11,056
of fetch request all the
way out to your results.


567
00:26:11,796 --> 00:26:13,646
[Background noise] Finally,
a fetch results controller


568
00:26:13,706 --> 00:26:14,956
who adopt the parameterization


569
00:26:14,956 --> 00:26:18,016
of the fetch request
used to create it.


570
00:26:18,876 --> 00:26:20,446
Speaking of
NSFetchResultsController,


571
00:26:20,666 --> 00:26:23,856
if you're using UICollection
view, sorry there we go,


572
00:26:23,856 --> 00:26:25,606
UICollection view,
it's really easy


573
00:26:25,606 --> 00:26:27,846
to adopt the new data
source prefetching feature


574
00:26:28,306 --> 00:26:29,306
if you're using core data.


575
00:26:29,716 --> 00:26:31,386
All you need is an
asynchronous fetch request,


576
00:26:31,386 --> 00:26:34,196
to get the request off the main
thread and you want to make sure


577
00:26:34,196 --> 00:26:35,846
that you're not returning
objects as faults.


578
00:26:36,966 --> 00:26:39,316
For more information about
data source prefetching,


579
00:26:39,316 --> 00:26:41,196
check out Steve and
Peter's talk from yesterday,


580
00:26:41,356 --> 00:26:42,666
what's new in UICollection view.


581
00:26:43,156 --> 00:26:46,896
If you're a Mac developer I
also have good news for you.


582
00:26:47,356 --> 00:26:49,846
The fetch results controller
is now available on macOS.


583
00:26:51,516 --> 00:26:54,556
[ Applause ]


584
00:26:55,056 --> 00:26:58,156
Okay, so let's talk about some
common operations in core data,


585
00:26:58,416 --> 00:27:00,576
starting with getting
an entity description.


586
00:27:01,596 --> 00:27:03,406
Oops this, there we go.


587
00:27:04,456 --> 00:27:06,796
For this you need the
entity's name as a string


588
00:27:06,796 --> 00:27:08,376
and a managed object context.


589
00:27:09,466 --> 00:27:11,786
Creating a fetch request also
requires a string constant


590
00:27:11,906 --> 00:27:13,246
as well as a type
cast if you want


591
00:27:13,246 --> 00:27:14,766
to take advantage
of the new generics.


592
00:27:15,546 --> 00:27:18,146
And finally, there is
creating a new managed object


593
00:27:18,146 --> 00:27:20,106
which has all three
things, a string constant,


594
00:27:20,236 --> 00:27:23,096
a context parameter,
and a type cast.


595
00:27:23,956 --> 00:27:25,886
These operations are all
getting easier this year


596
00:27:25,886 --> 00:27:28,506
through improvements we've made
to manage object subclasses.


597
00:27:29,446 --> 00:27:32,236
The entity description is now
a class method on the subclass.


598
00:27:34,516 --> 00:27:38,586
[ Applause ]


599
00:27:39,086 --> 00:27:39,976
Don't worry this gets
better [laughter].


600
00:27:40,636 --> 00:27:42,886
The class also has
a factory method


601
00:27:42,886 --> 00:27:44,906
for creating new fetch
requests that are fully typed.


602
00:27:46,516 --> 00:27:50,186
[ Applause ]


603
00:27:50,686 --> 00:27:53,226
And finally, you can
create a new manage object,


604
00:27:53,406 --> 00:27:55,976
object using just the
subclass's initializer directly.


605
00:27:57,516 --> 00:28:03,846e
[ Applause ]


606
00:27:57,516 --> 00:28:03,846
[ Applause ]


607
00:28:04,346 --> 00:28:06,256
There's one more thing
that's worth talking


608
00:28:06,256 --> 00:28:08,036
about which is performing
a fetch request.


609
00:28:08,386 --> 00:28:10,546
I mentioned earlier that
the context fetch method is


610
00:28:10,546 --> 00:28:13,926
parameterized in Swift but ObjC
doesn't support method level


611
00:28:13,926 --> 00:28:15,916
generics, so we've
also added actor


612
00:28:15,916 --> 00:28:17,606
like semantics to
fetch requests.


613
00:28:17,996 --> 00:28:19,856
So you can just call
its execute method


614
00:28:20,116 --> 00:28:22,076
from inside a block
submitted to a context


615
00:28:22,076 --> 00:28:24,226
and it will return
properly typed results.


616
00:28:26,516 --> 00:28:29,036
[ Applause ]


617
00:28:29,536 --> 00:28:31,806
All this new API for model
subclasses should make a lot


618
00:28:31,806 --> 00:28:33,736
of things much easier
but I'm guessing


619
00:28:33,736 --> 00:28:35,616
that you're not really looking
forward to regenerating all


620
00:28:35,616 --> 00:28:38,726
of your subclasses, but
don't worry because,


621
00:28:38,726 --> 00:28:41,326
this should be the last year you
have to do anything with them.


622
00:28:41,966 --> 00:28:44,726
Because Xcode 8 can now generate
that code for you automatically.


623
00:28:46,516 --> 00:28:49,556
[ Applause ]


624
00:28:50,056 --> 00:28:51,766
You can configure code
generation per entity


625
00:28:51,906 --> 00:28:53,596
and Xcode will write
the generated code


626
00:28:53,596 --> 00:28:54,936
to your project's derived data


627
00:28:54,936 --> 00:28:56,476
so it doesn't pollute
your source tree


628
00:28:56,476 --> 00:28:57,406
with code you didn't write.


629
00:28:58,226 --> 00:28:59,596
You don't want to
edit these files


630
00:28:59,596 --> 00:29:01,346
since the code is
automatically regenerated


631
00:29:01,346 --> 00:29:04,576
when you change your model
but if you want to do things


632
00:29:04,576 --> 00:29:06,306
like add your own instance
variables or something


633
00:29:06,306 --> 00:29:08,626
to the subclass, then
you can also tell Xcode


634
00:29:08,626 --> 00:29:10,526
to only generate a
category or extension


635
00:29:10,526 --> 00:29:12,066
and then you can own
the class itself.


636
00:29:14,896 --> 00:29:16,796
In Swift all you need to do


637
00:29:16,796 --> 00:29:18,616
to use this feature
is import the module


638
00:29:18,616 --> 00:29:21,046
that your entities belong to
which is often the same module


639
00:29:21,046 --> 00:29:23,536
as your code, but
in ObjC you'll need


640
00:29:23,536 --> 00:29:25,356
to know a bit more
about how this works.


641
00:29:26,206 --> 00:29:27,466
The most important file in,


642
00:29:27,466 --> 00:29:30,916
to know about in ObjC is the
core data model header file.


643
00:29:31,706 --> 00:29:34,046
Each model has its own header
file and you need to import it


644
00:29:34,046 --> 00:29:36,536
to get access to all of that
model's generated classes.


645
00:29:37,626 --> 00:29:39,976
If we zoom in for a look at
the other generated files


646
00:29:40,096 --> 00:29:42,216
for entities configured
to generate classes,


647
00:29:42,216 --> 00:29:45,066
Xcode creates two headers that
you probably already recognize


648
00:29:45,066 --> 00:29:46,496
from generating classes
yourself.


649
00:29:46,936 --> 00:29:48,366
One declares the class interface


650
00:29:48,366 --> 00:29:50,466
and the other declares
the managed properties.


651
00:29:51,526 --> 00:29:53,886
This is mostly important
to know for ObjC


652
00:29:53,886 --> 00:29:55,876
because if you're
generating a category,


653
00:29:55,876 --> 00:29:58,076
then Xcode will not
generate a class interface,


654
00:29:58,366 --> 00:30:00,946
and the model's header will
import the category directly.


655
00:30:02,336 --> 00:30:04,566
Categories can't be declared
without a class interface


656
00:30:04,566 --> 00:30:06,856
so the generated code
expects to find a header


657
00:30:06,856 --> 00:30:09,396
in your project that's
named after the class.


658
00:30:09,726 --> 00:30:12,056
This is a file that you
own, and if it doesn't exist


659
00:30:12,056 --> 00:30:14,126
in your project then your
target will fail to build.


660
00:30:16,076 --> 00:30:18,286
So let's take a quick break
from slides and have a look


661
00:30:18,286 --> 00:30:19,786
at what all this new
stuff means for you.


662
00:30:19,906 --> 00:30:26,766
I have Xcode 8 open
here and we're going


663
00:30:26,766 --> 00:30:28,116
to create a new Xcode project.


664
00:30:28,756 --> 00:30:32,186
And use iOSes master
detail application.


665
00:30:33,146 --> 00:30:36,096
We've updated the templates
this year to use the new UI.


666
00:30:36,416 --> 00:30:42,496
So if we, save this somewhere
and go to the app delegate,


667
00:30:43,226 --> 00:30:44,756
then we can see that,


668
00:30:45,706 --> 00:30:48,846
we're using a persistent
container here and we're wiring


669
00:30:48,846 --> 00:30:51,886
up the master view controller


670
00:30:52,336 --> 00:30:54,136
with the container's
view context.


671
00:30:54,136 --> 00:30:57,356
If we go to the master
view controller,


672
00:30:57,906 --> 00:31:01,016
we can see where it
creates a new object


673
00:31:01,136 --> 00:31:04,846
that we're already using
subclass initializers


674
00:31:05,636 --> 00:31:07,136
that are generated by core data.


675
00:31:07,536 --> 00:31:11,356
And we're not using KVC anymore
we can set properties directly


676
00:31:11,426 --> 00:31:14,456
on the manage object and if
we command click we get taken


677
00:31:14,456 --> 00:31:15,816
to the generated file.


678
00:31:16,216 --> 00:31:20,136
If we come back and we look


679
00:31:20,136 --> 00:31:22,076
at how the fetch results
controller is set up,


680
00:31:22,946 --> 00:31:23,416
there we are.


681
00:31:23,996 --> 00:31:28,176
We can see that raising the
fetch request factory method


682
00:31:28,176 --> 00:31:29,486
on the event subclass


683
00:31:30,056 --> 00:31:33,996
and there's no extra
explicit typing here


684
00:31:33,996 --> 00:31:37,246
when we create the fetch
results controller but its type,


685
00:31:38,126 --> 00:31:39,936
which is really tiny,
but if we zoom in here,


686
00:31:41,106 --> 00:31:42,706
is passed through from
the fetch request.


687
00:31:43,966 --> 00:31:47,506
This means that elsewhere,
in the sub,


688
00:31:47,696 --> 00:31:52,916
prepare for segue, there we go.


689
00:31:53,576 --> 00:31:55,856
When we get an object from the
fetch results controller it


690
00:31:55,856 --> 00:31:56,896
comes back with the right type.


691
00:31:58,506 --> 00:32:01,006
So that's all great we
have no type cast anymore.


692
00:32:01,646 --> 00:32:06,816
And, but I don't want this
app to show timestamps


693
00:32:06,816 --> 00:32:08,816
in the master view controller
like it does by default.


694
00:32:08,816 --> 00:32:14,616
So let's add a title attribute
to our event entity here.


695
00:32:15,256 --> 00:32:19,796
And we want it to
be a string type.


696
00:32:20,506 --> 00:32:22,826
Alright so we've
rebuilt, saved our model,


697
00:32:22,916 --> 00:32:25,896
and if we go back here
and go to configure cell,


698
00:32:25,986 --> 00:32:29,306
and we can delete
this code here.


699
00:32:29,916 --> 00:32:33,496
And take advantage of
Xcode's auto completion


700
00:32:33,496 --> 00:32:36,136
to get a new property that
we just set up in our model.


701
00:32:38,516 --> 00:32:42,596
[ Applause ]


702
00:32:43,096 --> 00:32:44,626
And again if we command
click on it,


703
00:32:45,086 --> 00:32:46,326
all of the code has
been updated.


704
00:32:47,516 --> 00:32:52,186
[ Applause ]


705
00:32:52,686 --> 00:32:54,836
One of the best hidden
benefits of this is


706
00:32:54,836 --> 00:32:56,856
if you're using manually
generated subclasses


707
00:32:56,856 --> 00:33:00,046
or even KVC, if you change
the name of an attribute,


708
00:33:00,286 --> 00:33:01,916
you can wind up with
some really weird bugs


709
00:33:01,956 --> 00:33:05,796
because your project
compiles but when it comes


710
00:33:05,796 --> 00:33:08,876
to actually making the calls
you get a run time error,


711
00:33:08,876 --> 00:33:10,676
because the key path
doesn't exist anymore.


712
00:33:10,676 --> 00:33:13,156
Automatically subclass
generation takes care


713
00:33:13,156 --> 00:33:13,956
of all of this.


714
00:33:15,366 --> 00:33:19,106
So let's automatic
subclass generation as well


715
00:33:19,106 --> 00:33:21,486
as some working examples
of core data's new API.


716
00:33:24,916 --> 00:33:27,336
Last, let's talk about
what's new in SQLite.


717
00:33:28,806 --> 00:33:30,206
The SQLite library that comes


718
00:33:30,206 --> 00:33:31,996
with the operating
system has some new tricks


719
00:33:31,996 --> 00:33:33,356
that you won't find
anywhere else.


720
00:33:33,416 --> 00:33:35,736
The first of which is
multi-threading assertions.


721
00:33:37,046 --> 00:33:40,366
SQLite on Apple platforms does
not have thread safe connections


722
00:33:40,656 --> 00:33:42,876
and multi-threading bugs
can be hard to diagnose,


723
00:33:43,116 --> 00:33:45,806
sometimes because they usually
manifest as a crash report


724
00:33:45,806 --> 00:33:48,366
with a single thread
deep inside SQLite.


725
00:33:49,506 --> 00:33:51,106
To make these issues
easier to identify


726
00:33:51,106 --> 00:33:53,586
and reproduce the system
SQLite supports new environment


727
00:33:53,586 --> 00:33:55,886
variable that enables
multi-threading assertions


728
00:33:56,176 --> 00:33:58,866
when they fire you'll see
two threads in SQLite,


729
00:33:59,246 --> 00:34:01,016
and they're both using
the same connection.


730
00:34:01,886 --> 00:34:06,496
SQLite has always supported
user defined logging functions


731
00:34:06,496 --> 00:34:09,656
through a configuration that
you can set using SQLite3 config


732
00:34:10,005 --> 00:34:11,126
but that function needs


733
00:34:11,126 --> 00:34:13,216
to be called before the
library is initialized


734
00:34:13,216 --> 00:34:14,436
which may have already happened.


735
00:34:15,416 --> 00:34:17,176
SQLite configurability is great


736
00:34:17,176 --> 00:34:18,726
but we're running
a modeling system


737
00:34:18,726 --> 00:34:20,295
that has built-in
logging facilities


738
00:34:20,295 --> 00:34:22,176
so there's now another
environment variable


739
00:34:22,545 --> 00:34:24,726
that chimes SQLite
logging to the system log.


740
00:34:26,496 --> 00:34:30,735
Finally, I want to talk
about file operations.


741
00:34:32,096 --> 00:34:34,806
All databases are represented
by a combination of files


742
00:34:34,806 --> 00:34:37,076
and file operations
cannot be atomic


743
00:34:37,565 --> 00:34:38,606
when they're in multiple files.


744
00:34:39,096 --> 00:34:41,286
The result of this is that
all file operations are


745
00:34:41,286 --> 00:34:42,386
inherently unsafe.


746
00:34:42,926 --> 00:34:45,696
Unix file APIs to
NSFileManager, everything.


747
00:34:46,616 --> 00:34:48,916
This is really important
and I want to share a couple


748
00:34:48,916 --> 00:34:50,936
of concrete examples of
how things can go wrong.


749
00:34:52,426 --> 00:34:55,025
Let's say I notice two database
files in the directory and,


750
00:34:56,295 --> 00:34:58,786
my code wants to do some clean
up so it deletes them but in


751
00:34:58,786 --> 00:35:00,066
between deleting the database


752
00:35:00,066 --> 00:35:02,116
and the journal something
connects to the database file.


753
00:35:03,256 --> 00:35:04,846
That database doesn't have
access to the journal,


754
00:35:05,526 --> 00:35:07,346
so it can't make
sense of the database,


755
00:35:07,536 --> 00:35:09,376
so it starts reporting
errors immediately


756
00:35:09,486 --> 00:35:10,606
which affects your app.


757
00:35:11,776 --> 00:35:13,976
Unless you can guarantee
that nothing is currently


758
00:35:13,976 --> 00:35:16,096
or it will ever try to
connect to a database,


759
00:35:16,096 --> 00:35:17,886
it's not safe to
delete its files.


760
00:35:19,256 --> 00:35:21,126
Let's say I have a
database in wall mode


761
00:35:21,666 --> 00:35:23,146
and something is using it,


762
00:35:23,766 --> 00:35:26,106
and the database finally gets
moved aside for some reason.


763
00:35:26,646 --> 00:35:29,466
When it gets open
in its new location


764
00:35:29,466 --> 00:35:31,556
that connection creates a
new journal and lock file,


765
00:35:32,286 --> 00:35:33,206
now you have two connections


766
00:35:33,206 --> 00:35:34,836
that are using different
journals and locks,


767
00:35:34,976 --> 00:35:37,346
it's not long before they wind
up corrupting the database.


768
00:35:39,276 --> 00:35:42,316
These examples may seem
contrived or rare, but there are


769
00:35:42,316 --> 00:35:45,336
over a billion devices out there
with potential for problems


770
00:35:45,336 --> 00:35:47,726
with every possible operation
on every possible file,


771
00:35:47,856 --> 00:35:49,676
something will happen to
someone using your app


772
00:35:49,676 --> 00:35:52,216
and they'll be very upset when
they wind up losing their data.


773
00:35:53,676 --> 00:35:55,016
Hard links are especially bad,


774
00:35:55,556 --> 00:35:58,626
don't use hard links
with database files.


775
00:35:59,116 --> 00:36:02,366
So, new this year the
SQLite library that comes


776
00:36:02,366 --> 00:36:04,966
with the operating system takes
advantage of dispatch sources


777
00:36:05,416 --> 00:36:07,506
and database connections
will report errors


778
00:36:07,566 --> 00:36:10,056
after an illegal operation
affects their files.


779
00:36:10,836 --> 00:36:13,436
On its own the system solve
data corruption problems


780
00:36:13,466 --> 00:36:15,436
in most cases the damages
has already been done.


781
00:36:15,856 --> 00:36:17,316
So to help you identify


782
00:36:17,316 --> 00:36:20,066
and debug these issues we've
added another environment


783
00:36:20,066 --> 00:36:22,916
variable that causes
connections to assert as soon


784
00:36:22,916 --> 00:36:24,786
as they detect an illegal
operation has affected


785
00:36:24,786 --> 00:36:25,346
their files.


786
00:36:26,766 --> 00:36:27,696
If you're curious for more ways


787
00:36:27,696 --> 00:36:29,116
that your database
can get corrupted,


788
00:36:29,116 --> 00:36:31,006
SQLite has an instructional
manual


789
00:36:31,006 --> 00:36:32,626
on their website called how


790
00:36:32,626 --> 00:36:34,046
to corrupt a SQLite
database file [laughter].


791
00:36:39,866 --> 00:36:41,566
Luckily these problems
are avoidable.


792
00:36:42,326 --> 00:36:44,226
If you're using SQLite
directly, you want to make sure


793
00:36:44,226 --> 00:36:46,486
that there's only one piece of
code that owns that database


794
00:36:46,866 --> 00:36:49,516
and that code needs to go
into the exclusive file access


795
00:36:49,516 --> 00:36:51,146
so files can't be
changed when they're open.


796
00:36:52,246 --> 00:36:54,066
If you're using core
data, and you should,


797
00:36:54,306 --> 00:36:56,256
there's API in the
persistent store coordinator


798
00:36:56,346 --> 00:36:58,436
that is always safe to
use with SQLite databases,


799
00:36:58,436 --> 00:36:59,376
whether they're open or not.


800
00:36:59,916 --> 00:37:02,876
There's replacePersistentStore
which replaces one database


801
00:37:02,876 --> 00:37:03,926
with the contents of another.


802
00:37:04,046 --> 00:37:05,886
And there's also
destroyPersistentStore


803
00:37:05,886 --> 00:37:08,016
which safely deletes
everything in the database


804
00:37:08,016 --> 00:37:09,616
and leaves an empty
database behind.


805
00:37:10,086 --> 00:37:15,906
Alright, that's it for what's
new in core data this year.


806
00:37:16,246 --> 00:37:18,986
To recap, we have a new
feature called query generations


807
00:37:18,986 --> 00:37:21,816
which gives you a stable view of
your data at a snapshot in time.


808
00:37:23,106 --> 00:37:24,186
We use support connection
pooling


809
00:37:24,186 --> 00:37:25,636
and a persistent
store coordinator now


810
00:37:25,736 --> 00:37:27,796
which allows multiple
readers at the same time


811
00:37:27,796 --> 00:37:30,576
as a single writer, allowing
you to keep snappy interfaces


812
00:37:30,576 --> 00:37:32,176
at the same time that you're
doing a lot of data work.


813
00:37:33,806 --> 00:37:35,576
Setting up core data
is a lot easier


814
00:37:35,636 --> 00:37:37,866
and then using it is also
a lot easier with new API,


815
00:37:38,016 --> 00:37:39,626
that works especially
well in Swift.


816
00:37:40,376 --> 00:37:43,056
This is all supported by great
new integration with Xcode


817
00:37:43,396 --> 00:37:45,946
and we also have new
features in SQLite


818
00:37:46,386 --> 00:37:48,886
that should make debugging
common problems much easier.


819
00:37:52,196 --> 00:37:53,756
For more information,
please check


820
00:37:53,756 --> 00:37:56,716
out the developer website,
this was session 242.


821
00:37:57,986 --> 00:38:00,196
If you want to know more,
there's what's new in Swift


822
00:38:00,366 --> 00:38:01,556
as well as what's new in Cocoa.


823
00:38:02,086 --> 00:38:02,976
Thanks for coming.


824
00:38:03,516 --> 00:38:13,730
[ Applause ]

