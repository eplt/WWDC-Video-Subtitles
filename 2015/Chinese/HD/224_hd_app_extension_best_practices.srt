1
00:00:29,596 --> 00:00:30,564
<br/> 
下午好


2
00:00:34,301 --> 00:00:36,570
欢迎来到应用程序扩展
最佳实践


3
00:00:37,571 --> 00:00:39,239
我是索菲娅·多伊彻
我是一名工程师


4
00:00:39,306 --> 00:00:41,008
我在UIKit框架团队


5
00:00:41,475 --> 00:00:43,177
稍后我的同事会加入
本届会议


6
00:00:43,243 --> 00:00:44,778
来自CoreOS的伊恩 拜特


7
00:00:46,213 --> 00:00:49,183
在会议的第一部分


8
00:00:49,249 --> 00:00:52,119
我想谈两个iOS的扩展主要类型


9
00:00:52,819 --> 00:00:54,188
动作和共享的扩展


10
00:00:55,756 --> 00:00:57,691
在稍后的会议上
伊恩将加入我们


11
00:00:57,758 --> 00:00:59,293
来谈今天的小工具的增强功能


12
00:01:00,460 --> 00:01:02,996
在整个会议期间 
我们将告诉您许多现实世界的例子


13
00:01:03,063 --> 00:01:04,364
以帮助您最大限度地


14
00:01:04,431 --> 00:01:05,966
利用这些类型的扩展


15
00:01:08,602 --> 00:01:10,470
现在　应用程序扩展和分享


16
00:01:10,971 --> 00:01:15,642
让我向您简单介绍一下
这两种类型的扩展


17
00:01:15,709 --> 00:01:17,444
有何不同


18
00:01:19,413 --> 00:01:23,750
动作扩展
都关于不断变化的内容


19
00:01:24,384 --> 00:01:26,920
而共享扩展
都关于移动内容


20
00:01:27,087 --> 00:01:28,655
从当前主机应用程序


21
00:01:28,956 --> 00:01:31,024
到应用程序或Web服务


22
00:01:32,893 --> 00:01:33,727
现在


23
00:01:34,194 --> 00:01:35,762
我要给您举更多的例子


24
00:01:36,730 --> 00:01:37,865
正如我刚才提到的


25
00:01:37,998 --> 00:01:40,300
动作扩展作用于当前的内容


26
00:01:41,301 --> 00:01:43,704
正因为如此
它们使用的内容


27
00:01:43,770 --> 00:01:45,272
将作为主用户界面


28
00:01:46,373 --> 00:01:48,342
稍后我将展示一个有关它的例子


29
00:01:50,244 --> 00:01:51,578
但您也有机会


30
00:01:51,845 --> 00:01:54,781
在执行该操作之前
提出附加选项


31
00:01:57,017 --> 00:01:58,018
此外


32
00:01:58,952 --> 00:02:01,421
您的应用程序功能可以被分开


33
00:02:01,488 --> 00:02:03,690
在不同的动作扩展


34
00:02:03,757 --> 00:02:06,460
存在的容器应用程序中


35
00:02:08,562 --> 00:02:10,564
现在让我举一个例子


36
00:02:12,232 --> 00:02:15,335
我们在用Safari浏览器
我点击右上方动作件


37
00:02:15,836 --> 00:02:18,572
弹出共享表与两种类型的扩展


38
00:02:19,439 --> 00:02:20,574
共享扩展在顶部


39
00:02:21,275 --> 00:02:22,910
动作扩展在底部


40
00:02:23,844 --> 00:02:25,979
我们做这个翻译扩展


41
00:02:26,613 --> 00:02:27,481
当我们点击它


42
00:02:27,681 --> 00:02:28,782
下面Safari浏览器


43
00:02:29,583 --> 00:02:32,186
就会将
网页转移到该扩展


44
00:02:32,653 --> 00:02:35,155
在那里
它会被翻译


45
00:02:35,455 --> 00:02:38,692
然后翻译角会移回
Safari浏览器原位


46
00:02:42,229 --> 00:02:43,664
下面是同样的一个变化


47
00:02:44,264 --> 00:02:46,867
当您点击翻译
您带了这种形式的表


48
00:02:46,934 --> 00:02:48,902
在这里用户可以选择一种语言


49
00:02:49,536 --> 00:02:53,140
然后当您点击语言时
我们的网页将传送到扩展


50
00:02:53,207 --> 00:02:55,242
然后它会再次被翻译


51
00:02:55,309 --> 00:02:58,679
并搬回到位于Safari中的


52
00:03:01,682 --> 00:03:02,983
这么多的
关于动作的扩展


53
00:03:03,050 --> 00:03:05,219
那么共享扩展有何不同？


54
00:03:09,923 --> 00:03:12,326
正如我刚才所说的
共享扩展


55
00:03:12,392 --> 00:03:15,562
是所有关于共享的内容
从主机应用程序


56
00:03:15,762 --> 00:03:17,264
到您的应用程序或Web服务


57
00:03:19,399 --> 00:03:20,968
正因为如此
这很重要


58
00:03:21,034 --> 00:03:24,204
您所提供的
用户验证和编辑之前的内容


59
00:03:24,271 --> 00:03:26,673
将移出到
您的Web服务


60
00:03:28,442 --> 00:03:29,776
我们为您提供的是一个API


61
00:03:29,843 --> 00:03:31,545
之后我会告诉您几个例子


62
00:03:34,581 --> 00:03:37,951
此外您的共享扩展
代表您的应用程序


63
00:03:38,018 --> 00:03:40,587
在共享表中
为了防止混乱


64
00:03:40,654 --> 00:03:43,056
我们只允许
您把一个共享扩展


65
00:03:43,123 --> 00:03:44,258
包含在一个应用程序里


66
00:03:46,627 --> 00:03:49,196
现在让我
举一个共享扩展的例子


67
00:03:50,163 --> 00:03:51,965
我们有底部共享


68
00:03:52,266 --> 00:03:53,667
和顶端共享扩展


69
00:03:55,002 --> 00:03:57,171
现在我们可选择四种照片
而当我们


70
00:03:57,271 --> 00:03:59,173
点击iCloud照片共享扩展


71
00:04:00,874 --> 00:04:01,775
接下来


72
00:04:03,043 --> 00:04:06,113
我们得到一个小预览表
用户可以在其中添加评论


73
00:04:06,580 --> 00:04:10,584
可能点击共享相册 
并在右侧出现一个小预览


74
00:04:10,884 --> 00:04:12,586
但是我们还没有
转移任何数据


75
00:04:14,288 --> 00:04:17,324
现在如果该信息是正确的
用户可以决定


76
00:04:17,391 --> 00:04:20,560
要么抵消
要么点击发布实际执行操作


77
00:04:21,762 --> 00:04:24,965
现在让我们来仔细看一下
在中心的这个表


78
00:04:26,366 --> 00:04:28,769
这实际上是我早先提到的API


79
00:04:29,002 --> 00:04:30,003
这就是所谓的


80
00:04:30,070 --> 00:04:31,705
SLComposeService
ViewController


81
00:04:31,772 --> 00:04:33,307
这是它的外观平直框


82
00:04:34,508 --> 00:04:36,777
有一个文本框 
一个右侧的小预览


83
00:04:38,345 --> 00:04:41,415
然而这是特别为我们定制的
特色服务


84
00:04:41,481 --> 00:04:43,450
例如我们喜欢自定义


85
00:04:43,650 --> 00:04:45,352
使它看起来更像这一点


86
00:04:47,454 --> 00:04:49,356
我们增加了一个占位符
我们甚至还添加了


87
00:04:49,423 --> 00:04:50,390
一个字符余留属性


88
00:04:50,557 --> 00:04:52,292
我们甚至改变预览视图


89
00:04:52,826 --> 00:04:55,329
在底部我们有一些选择


90
00:04:59,166 --> 00:05:02,836
现在
让我们通过一些例子来构建


91
00:05:04,605 --> 00:05:05,973
首先


92
00:05:06,540 --> 00:05:10,077
要设置一个占位符
在该表上设置占位属性


93
00:05:13,146 --> 00:05:14,047
开始了


94
00:05:15,983 --> 00:05:18,852
而您的Web服务可能
有一个最大字符限制


95
00:05:19,319 --> 00:05:21,154
所以我们有一个小指示灯
在左下角


96
00:05:21,388 --> 00:05:23,423
要更新它
只需设置一个属性


97
00:05:26,360 --> 00:05:28,762
再次我们为您提供了d
一个预览视图框


98
00:05:28,829 --> 00:05:30,030
但您可以有您自己的一个


99
00:05:30,731 --> 00:05:34,368
为了支持简单的
构成控制器


100
00:05:34,701 --> 00:05:36,370
并重写装入预览视图


101
00:05:36,837 --> 00:05:40,440
然后返回
您自定义视图控制器的预览


102
00:05:41,742 --> 00:05:43,610
但有一点要记住


103
00:05:43,677 --> 00:05:46,480
请确保该视图有


104
00:05:46,547 --> 00:05:50,517
否则可能无法
在纸张上显示出来


105
00:05:54,354 --> 00:05:58,058
现在这些选项在底部


106
00:05:59,092 --> 00:06:02,196
这些仅仅是单元格
一个值在左边


107
00:06:02,262 --> 00:06:05,499
一个值在右边
点击他们


108
00:06:05,599 --> 00:06:07,067
我们通过一个
选项视图控制器


109
00:06:07,134 --> 00:06:12,372
可以选择您的选项
您的自定义选项


110
00:06:13,307 --> 00:06:15,142
让我来告诉您
如何设置它的代码


111
00:06:16,243 --> 00:06:17,177
很简单


112
00:06:17,344 --> 00:06:19,680
子类SL - 构成


113
00:06:20,781 --> 00:06:22,716
然后重写 - 方法


114
00:06:23,784 --> 00:06:28,522
每一行表示
为一个SL构成表配置项目


115
00:06:28,956 --> 00:06:29,823
（太拗口了）


116
00:06:32,292 --> 00:06:34,027
左边是标题


117
00:06:34,595 --> 00:06:37,731
右手边是值


118
00:06:40,167 --> 00:06:44,271
现在如果用户点击一个单元格
我们在这里调用点击处理


119
00:06:44,972 --> 00:06:46,240
而且您应该


120
00:06:46,306 --> 00:06:48,141
创建自定义视图控制器


121
00:06:48,208 --> 00:06:49,877
为您的自定义选项


122
00:06:51,245 --> 00:06:53,881
而推动它只需调用
推送配置视图控制器就可以


123
00:06:54,448 --> 00:06:56,917
这种工作方式与API相同


124
00:06:57,050 --> 00:06:59,152
即您的导航控制器


125
00:07:01,355 --> 00:07:04,258
然后最后返回项目区域


126
00:07:08,562 --> 00:07:11,298
现在我们甚至能为您提供
自动完成支持


127
00:07:11,365 --> 00:07:12,332
在构成表上


128
00:07:13,233 --> 00:07:14,935
要自动完成


129
00:07:15,002 --> 00:07:16,370
您可以设置一个视图控制器


130
00:07:16,436 --> 00:07:17,871
在这里更新按钮部分


131
00:07:18,772 --> 00:07:21,675
在这种情况下它是一个表视图
我们自动填充名称


132
00:07:21,875 --> 00:07:23,010
但它可能是真的什么


133
00:07:24,711 --> 00:07:27,748
要设置它
只需设置自动完成视图属性就可以


134
00:07:28,215 --> 00:07:29,750
我们为您做所有动画


135
00:07:30,117 --> 00:07:31,318
当您做完自动完成


136
00:07:31,385 --> 00:07:32,853
您将其设置回零


137
00:07:35,856 --> 00:07:36,690
一切都非常简单


138
00:07:37,424 --> 00:07:38,258
再次


139
00:07:38,325 --> 00:07:39,226
我们的


140
00:07:39,293 --> 00:07:40,527
SLComposeService
ViewController


141
00:07:40,594 --> 00:07:42,162
提供了一致和熟悉的
用户界面


142
00:07:42,729 --> 00:07:46,099
这是完全可自定义的
您可以在应用程序采用它


143
00:07:47,067 --> 00:07:48,602
但是
如果您有不同的需求


144
00:07:48,669 --> 00:07:50,971
为您服务扩展


145
00:07:51,271 --> 00:07:54,174
您可以
随时通过您的视图


146
00:07:54,374 --> 00:07:55,375
直接返回


147
00:07:57,344 --> 00:07:58,178
现在


148
00:07:58,245 --> 00:08:00,814
我只是告诉您
如何让动作共享扩展


149
00:08:01,548 --> 00:08:02,816
那么让我们改变齿轮
一点点


150
00:08:02,950 --> 00:08:04,585
并讨论


151
00:08:04,651 --> 00:08:07,721
如何支持别人做扩展


152
00:08:08,121 --> 00:08:09,523
在主机应用程序里


153
00:08:11,325 --> 00:08:14,595
举例来说假设我们
做了一个文本编辑应用程序


154
00:08:15,229 --> 00:08:17,297
我们想与大家分享文本文档


155
00:08:17,364 --> 00:08:18,565
以及纯文本


156
00:08:19,600 --> 00:08:22,469
然而
某些扩展可能不理解文字


157
00:08:23,170 --> 00:08:24,671
他们可能只支持PDF文件


158
00:08:25,572 --> 00:08:27,941
或者其他的扩展
可能只支持HTML


159
00:08:29,343 --> 00:08:31,345
现在
您想支持尽可能多的扩展


160
00:08:31,411 --> 00:08:35,115
所以好方法是提供
所有这三个文件类型


161
00:08:36,817 --> 00:08:38,519
但是您知道


162
00:08:39,052 --> 00:08:41,188
这三个都不是真正的
独立的文件


163
00:08:41,255 --> 00:08:43,123
当您共享一个文本文档时


164
00:08:43,756 --> 00:08:46,593
您真正拥有的
是一个单一的文件


165
00:08:46,660 --> 00:08:48,228
它支持不同的
文件格式


166
00:08:49,930 --> 00:08:51,999
而正因此我们有一个
叫做


167
00:08:52,299 --> 00:08:54,101
NSItemProvider
的API


168
00:08:55,302 --> 00:08:56,637
简单来说


169
00:08:56,703 --> 00:08:58,972
NSItem
Provider是单个条目


170
00:08:59,039 --> 00:09:00,541dle
有多种表示方法


171
00:08:59,039 --> 00:09:00,541
有多种表示方法


172
00:09:01,675 --> 00:09:04,278
让我告诉您一个代码示例
来更好地解释它


173
00:09:05,779 --> 00:09:07,814
现在我们创建
NSItemProvider


174
00:09:09,149 --> 00:09:10,784
调用注册项目类型标识符


175
00:09:10,851 --> 00:09:14,087
来添加新的表示


176
00:09:14,154 --> 00:09:15,189
到该项目提供者


177
00:09:16,156 --> 00:09:17,491
在这种情况下它是纯文本


178
00:09:19,126 --> 00:09:22,896
现在如果扩展请求
采用纯文本表示


179
00:09:23,330 --> 00:09:26,099
该系统将在这里
调用这种装载处理程序块


180
00:09:27,534 --> 00:09:30,170
还有
您应该动态创建文本文档


181
00:09:30,237 --> 00:09:32,673
并调用完成处理程序


182
00:09:32,739 --> 00:09:34,975
来将数据返回到扩展


183
00:09:37,010 --> 00:09:38,445
PDF格式同样


184
00:09:38,779 --> 00:09:41,582
只要扩展要求一个PDF 


185
00:09:42,015 --> 00:09:45,485
表示我们调用加载处理程序
您在动态创建PDF


186
00:09:45,552 --> 00:09:47,654
并调用完成
让其将数据


187
00:09:48,121 --> 00:09:49,089
返回到该扩展


188
00:09:51,992 --> 00:09:53,160
要显示共享表


189
00:09:53,493 --> 00:09:55,662
简单地创建一个
UI活动视图控制器


190
00:09:56,296 --> 00:09:58,866
并提供了初始的项目
来提供程序选项


191
00:10:03,270 --> 00:10:04,104
现在


192
00:10:04,638 --> 00:10:06,974
您看到的是
构成表中的第一个例子


193
00:10:07,441 --> 00:10:09,209
我们在右上角有这个小预览


194
00:10:09,810 --> 00:10:11,812
该主机
应该也提供预览


195
00:10:13,347 --> 00:10:15,682
这些预览
代表着什么将被共享 


196
00:10:17,084 --> 00:10:19,720
而且
它们需要被简单而有效的创建


197
00:10:19,786 --> 00:10:21,021
它们不能过大


198
00:10:22,890 --> 00:10:23,790
对于这点


199
00:10:23,857 --> 00:10:26,493
我们有一个NSItem
Provider API也是如此


200
00:10:26,560 --> 00:10:28,161
这就是所谓的
预览图像处理程序


201
00:10:29,263 --> 00:10:31,999
并且
一旦扩展要求一个预览


202
00:10:32,299 --> 00:10:34,801
我们调用这个块
在这里


203
00:10:34,868 --> 00:10:37,804
您应该
创建缩略图或预览


204
00:10:37,871 --> 00:10:39,573
表示为动态的图像


205
00:10:39,840 --> 00:10:40,874
并调用完成处理程序


206
00:10:40,941 --> 00:10:41,842
来返回数据


207
00:10:42,809 --> 00:10:44,945
现在我们需要再次
改变我们的观点


208
00:10:45,512 --> 00:10:47,614
我们首先谈到了
实现扩展


209
00:10:48,682 --> 00:10:51,518
然后我们谈到了
支持扩展为主机应用程序


210
00:10:52,152 --> 00:10:53,187
现在让我们来看看


211
00:10:53,253 --> 00:10:55,556
再次成为扩展开发是什么感觉
以及


212
00:10:55,622 --> 00:10:57,224
如何声明您的支持
用哪种数据


213
00:10:57,291 --> 00:11:00,127
主机应用程序
可以提供给您的扩展


214
00:11:01,562 --> 00:11:02,529
例如


215
00:11:02,729 --> 00:11:04,498
也许您想拥有完整的共享服务


216
00:11:04,565 --> 00:11:07,100
并要声明您共享扩展


217
00:11:07,201 --> 00:11:08,869
支持图像和视频


218
00:11:11,905 --> 00:11:12,739
现在


219
00:11:12,806 --> 00:11:15,042
在这种情况下
让我们做三种扩展名


220
00:11:16,109 --> 00:11:20,247
一个扩展支持图像


221
00:11:20,881 --> 00:11:22,416
另一个支持处理电影


222
00:11:22,749 --> 00:11:25,352
而第三个
处理图像和短片


223
00:11:27,287 --> 00:11:28,689
现在让我们看看会发生什么


224
00:11:28,755 --> 00:11:30,357
如果主机应用程序
共享单一的图像


225
00:11:31,892 --> 00:11:33,260
在这种情况下 


226
00:11:33,327 --> 00:11:35,462
第一和第三种扩展将
出现在共享表


227
00:11:37,364 --> 00:11:39,533
现在相同的方式
在处理电影的情况下


228
00:11:40,167 --> 00:11:41,902
如果主机应用程序


229
00:11:41,969 --> 00:11:43,170
共享
一个电影


230
00:11:44,304 --> 00:11:47,341
第二和第三种扩展将出现在共享表
这是有道理的


231
00:11:48,275 --> 00:11:49,109
但是


232
00:11:49,176 --> 00:11:50,844
如果主机的共享


233
00:11:51,278 --> 00:11:53,046
支持图像和电影
会发生什么？


234
00:11:53,280 --> 00:11:55,349
您可能会认为所有的
扩展将出现在工作表中


235
00:11:55,415 --> 00:11:56,316
然而


236
00:11:56,383 --> 00:11:58,785
目前的情况并非如此


237
00:11:58,852 --> 00:12:02,155
因为在iOS 8中的实现
需要


238
00:12:02,289 --> 00:12:07,995
扩展可以处理
所有两种类型的文件格式


239
00:12:09,062 --> 00:12:10,230
有一点可惜


240
00:12:10,330 --> 00:12:14,201
因为用户扩展开发人员
可能会想支持尽可能多的扩展


241
00:12:14,268 --> 00:12:17,804
而要做到这一点
您应该


242
00:12:17,871 --> 00:12:19,873
提供尽可能多的意见
及其可能带来的结果


243
00:12:20,440 --> 00:12:21,708
但是在这种情况下


244
00:12:21,775 --> 00:12:23,143
您实际上会得到比刚才的共享


245
00:12:23,210 --> 00:12:25,879
更少的扩展
只能单一表示


246
00:12:25,946 --> 00:12:27,514
比如电影或图像


247
00:12:29,183 --> 00:12:30,918
所以我们在iOS 9中
添加了新的功能


248
00:12:32,986 --> 00:12:37,524
您也可以选择通过添加
NSExtension 


249
00:12:37,591 --> 00:12:38,559
激活词典版


250
00:12:38,792 --> 00:12:40,827
把新的扩展名信息info
和plistu


251
00:12:41,328 --> 00:12:42,429
设置为两个之后


252
00:12:43,130 --> 00:12:46,767
您的扩展就会出现
即使


253
00:12:46,834 --> 00:12:49,069
主机应用程序共享
图像和电影


254
00:12:49,136 --> 00:12:51,905
即使
您只关心电影或图像


255
00:12:54,241 --> 00:12:56,543
如今 
这些都是高一级的激活规则


256
00:12:57,177 --> 00:13:00,547
但是我们也支持
激活只有谓词的规则


257
00:13:01,882 --> 00:13:04,284
再次
谓词可以是非常简单的


258
00:13:04,351 --> 00:13:05,886
但也非常强大的 
像这里这个一样


259
00:13:06,787 --> 00:13:08,555
我就不赘述了
现在


260
00:13:08,655 --> 00:13:10,624
我们可以
参考应用程序扩展开发者指南


261
00:13:10,691 --> 00:13:11,925
去了解更多信息


262
00:13:17,397 --> 00:13:20,167
接下来
我们来谈一谈图标扩展


263
00:13:23,036 --> 00:13:23,871
正如我前面提到的


264
00:13:24,004 --> 00:13:26,807
分享扩展
代表您的应用程序


265
00:13:26,874 --> 00:13:28,509
它是一个共享表中的
Web服务


266
00:13:29,276 --> 00:13:31,979
因此 
我们只需使用您的应用程序图标


267
00:13:32,045 --> 00:13:33,714
或在共享表中的


268
00:13:33,780 --> 00:13:35,082
包含应用程序图标的其他图标


269
00:13:35,148 --> 00:13:37,150
所以
不需要做额外的工作


270
00:13:37,217 --> 00:13:38,185
对您来说


271
00:13:41,488 --> 00:13:44,491
动作扩展
相反地需要模板图像


272
00:13:46,627 --> 00:13:47,828
我们需要两个尺寸


273
00:13:47,895 --> 00:13:50,097
一个用于iPad
一个用于iPhone


274
00:13:52,199 --> 00:13:53,734
它们
被存储在扩展套件里


275
00:13:54,768 --> 00:13:57,671
现在 
我来介绍一下模板是如何工作的


276
00:13:59,173 --> 00:14:00,974
比如把它想像成一个模版


277
00:14:02,009 --> 00:14:04,211
模板的图像
是黑白的代表


278
00:14:04,711 --> 00:14:07,314
具有透明的背景
然后


279
00:14:07,381 --> 00:14:09,316
系统把那模板
与那黑与白的图像


280
00:14:10,150 --> 00:14:14,188
一起来创建实际的图标
用于共享表


281
00:14:16,590 --> 00:14:17,424
再次


282
00:14:17,858 --> 00:14:19,326
需要两种尺寸


283
00:14:19,693 --> 00:14:21,495
60点的iPhone


284
00:14:21,995 --> 00:14:23,530
和76点的iPad


285
00:14:25,832 --> 00:14:30,070
不过我建议您在您的扩展中
使用图像资源


286
00:14:30,237 --> 00:14:33,407
并提供各种不同 - 
所有不同的图标大小


287
00:14:33,507 --> 00:14:35,075
这将用于应用程序图标


288
00:14:35,742 --> 00:14:39,112
这样您的应用程序扩展
将更适应未来的需要


289
00:14:42,883 --> 00:14:45,052
这么多动作
能共享扩展


290
00:14:45,118 --> 00:14:46,820
让我们邀请伊恩
上台说说


291
00:14:46,887 --> 00:14:48,121
今天小插件的增强功能


292
00:14:57,331 --> 00:14:58,799e
谢谢索菲娅


293
00:15:00,701 --> 00:15:03,537
您好我是伊恩·拜特
CoreOS工程师


294
00:15:03,837 --> 00:15:06,974
现在我准备向您介绍
今天小插件的增强功能


295
00:15:08,575 --> 00:15:09,543
首先快速回顾一下


296
00:15:10,143 --> 00:15:11,378
您还记得去年


297
00:15:11,845 --> 00:15:14,982
今天小插件
让您对快捷信息一目了然


298
00:15:15,849 --> 00:15:18,252
所以有了您的股票价格
和您的体育成绩


299
00:15:18,685 --> 00:15:20,654
它会告诉您
下班后您需要花多久


300
00:15:20,721 --> 00:15:22,389
才能到家


301
00:15:24,424 --> 00:15:26,493
所以今天
我要和您谈谈


302
00:15:26,560 --> 00:15:28,462
如何提高您今天小插件


303
00:15:28,762 --> 00:15:30,898
如何确保该模型的数据


304
00:15:30,964 --> 00:15:33,100
始终是最新的
并同步到


305
00:15:33,200 --> 00:15:34,334
您包含的应用程序


306
00:15:35,235 --> 00:15:37,804
我还要给大家介绍一下
如何确保


307
00:15:38,005 --> 00:15:40,807
您的视觉表现
是最新的


308
00:15:40,874 --> 00:15:42,976
并也反映了
您的小插件的内容


309
00:15:44,011 --> 00:15:47,381
然后
我会介绍一些通用的最佳做法


310
00:15:47,481 --> 00:15:49,850
您可以
用于您所有的扩展


311
00:15:50,083 --> 00:15:52,152
包括您的今天小插件


312
00:15:53,720 --> 00:15:54,788
让我们开始吧


313
00:15:55,322 --> 00:15:57,624
这是Notification
 Center的景色


314
00:15:57,958 --> 00:16:00,260
它填充的是今天小插件


315
00:16:00,861 --> 00:16:03,063
您可以通过滚动
看到所有的小部件


316
00:16:03,697 --> 00:16:06,066
如果您想了解更多信息


317
00:16:06,133 --> 00:16:07,968
您可以在这里看到


318
00:16:08,368 --> 00:16:09,469
您可以简单地


319
00:16:10,604 --> 00:16:11,572
在部件上点击


320
00:16:11,638 --> 00:16:15,142
它会带您到达应用程序
了解更多信息


321
00:16:16,143 --> 00:16:18,545
现在 
我们应该如何促进


322
00:16:18,745 --> 00:16:21,515
今天小插件
及其所包含的应用程序之间的这种互动


323
00:16:22,249 --> 00:16:25,252
我们可以使用
URL schemes


324
00:16:25,919 --> 00:16:28,121
现在我要告诉您一点点
关于这些交互使用


325
00:16:28,822 --> 00:16:31,358
这些URL方案


326
00:16:31,425 --> 00:16:35,696
和一些开放URL
API NSExtension环境


327
00:16:35,762 --> 00:16:37,631
可以带用户进入应用程序


328
00:16:38,632 --> 00:16:41,535
现在我们有一些很好的做法
想与你们分享


329
00:16:41,602 --> 00:16:44,771
是关于控制这些
URL schemes的


330
00:16:45,706 --> 00:16:48,942
首先我们非常希望您能使用


331
00:16:49,009 --> 00:16:51,612
并且专注于您App的
注册URL schemes上


332
00:16:52,212 --> 00:16:53,080
太棒了


333
00:16:54,214 --> 00:16:55,916
接下来您要使用的是


334
00:16:55,983 --> 00:16:58,085
您可以使用系统
URL schemes


335
00:16:58,652 --> 00:17:00,254e
例如HTTPS


336
00:16:58,652 --> 00:17:00,254
例如HTTPS


337
00:17:00,654 --> 00:17:03,023
那么接下来就会在
Safari上打开一个网页


338
00:17:03,490 --> 00:17:06,960
您也可以写信息、打电话


339
00:17:07,361 --> 00:17:10,797
或进行其他交互并且在系统组件中


340
00:17:10,998 --> 00:17:12,332
开始进行有趣的工作流


341
00:17:12,833 --> 00:17:14,268
那么接下来告诉您应该怎样做


342
00:17:15,368 --> 00:17:19,772
您可以注意到
我正在展示一个表格


343
00:17:19,839 --> 00:17:22,209
我选择了一排索引路径回调


344
00:17:22,276 --> 00:17:24,111
因为许多小部件只是简单的表格


345
00:17:25,112 --> 00:17:26,313
我们要做的第一件事


346
00:17:26,380 --> 00:17:29,016
实际上是构建一个URL


347
00:17:29,583 --> 00:17:32,953
我们接下来用我的App
URL scheme来做这件事


348
00:17:33,253 --> 00:17:34,821
只是用来举例


349
00:17:35,055 --> 00:17:37,925
这将会把我们带到我的主体App里


350
00:17:38,825 --> 00:17:40,027
接下来我们想要做的事是


351
00:17:40,127 --> 00:17:42,296
调用开放的URL API


352
00:17:42,362 --> 00:17:47,768
这个您可以在
扩展内容中找到


353
00:17:48,068 --> 00:17:50,571
它可能与您的视力控制器相连


354
00:17:51,572 --> 00:17:54,975
现在这跟在UI应用上的曝光有些不同


355
00:17:55,042 --> 00:17:56,276
在UI应用中


356
00:17:56,343 --> 00:17:58,846
它需要一个调回版块


357
00:17:59,179 --> 00:18:02,349
但是这个调回版块有一个布尔参数


358
00:18:02,482 --> 00:18:04,117
我接下来就讲讲这个布尔参数


359
00:18:05,519 --> 00:18:09,256
需要将成功参数设为是


360
00:18:09,489 --> 00:18:12,459
如果我们要把你们带进我的主体App


361
00:18:12,960 --> 00:18:14,828
或者进入


362
00:18:15,095 --> 00:18:17,097
已经注册了
URL scheme的系统组件


363
00:18:17,698 --> 00:18:20,934
如果我们不能够做到
它将被设置为否


364
00:18:21,502 --> 00:18:24,037
就像用户还没有解锁电话


365
00:18:24,104 --> 00:18:25,572
和当电话还被锁住的时候下拉


366
00:18:25,639 --> 00:18:27,474
Notification 
Center


367
00:18:29,877 --> 00:18:31,812
有很多办法


368
00:18:31,912 --> 00:18:34,982
可以跟容器应用互动和分享数据


369
00:18:35,048 --> 00:18:36,717
今天我想讲述


370
00:18:36,884 --> 00:18:37,885
如何使用默认值


371
00:18:39,386 --> 00:18:40,320
和您的容器应用


372
00:18:42,155 --> 00:18:43,423
或Keychain项目


373
00:18:45,058 --> 00:18:46,093
和框架数据


374
00:18:46,159 --> 00:18:49,296
框架数据将潦草地进入共享容器


375
00:18:49,396 --> 00:18:52,065
系统框架会以您的名义


376
00:18:52,766 --> 00:18:56,503
把所有这些整齐地分成应用程序组


377
00:18:58,772 --> 00:19:00,307
首先用户默认


378
00:19:00,707 --> 00:19:02,543
您可能知道用户默认是什么


379
00:19:02,609 --> 00:19:05,445
如果您曾经开发过一段Cocoa
或Cocoa Touch


380
00:19:05,946 --> 00:19:08,248
那里有多个很小的设置数据


381
00:19:08,649 --> 00:19:11,919
它们像小的字符串、数字、
布尔值和其他


382
00:19:12,186 --> 00:19:14,955
它们影响您应用程序的设置


383
00:19:15,789 --> 00:19:18,225
您可以分享这些设置数据


384
00:19:18,625 --> 00:19:20,194
在您的容器应用程序


385
00:19:20,260 --> 00:19:21,528
和您的扩展之间


386
00:19:21,828 --> 00:19:24,498
通过使用NSUser默认初始值的


387
00:19:24,565 --> 00:19:26,934
套件名称的API


388
00:19:27,601 --> 00:19:31,672
您将传递应用组的标识符
去完成这个API


389
00:19:32,272 --> 00:19:34,641
现在记住这件重要的事情


390
00:19:35,042 --> 00:19:39,646
这个API不仅仅
解锁您容器应用的默认值


391
00:19:39,813 --> 00:19:42,583
即您的标准用户在您应用里的默认值


392
00:19:42,983 --> 00:19:45,986
它还产生一个新的默认套件


393
00:19:46,253 --> 00:19:49,289
您的容器应用也能有其访问权限


394
00:19:49,356 --> 00:19:53,293
如果它也参与到应用组的话
所以这个非常重要


395
00:19:53,527 --> 00:19:56,463
当您用这个API时
不但在您的扩展里


396
00:19:56,663 --> 00:19:58,398
而且在您的容器应用里


397
00:19:58,465 --> 00:20:01,401
当您想要改变这些设置项目的默认值时


398
00:20:03,437 --> 00:20:06,006
我想讲述的下一件事情是


399
00:20:06,073 --> 00:20:08,842
您能用到共享容器的内部


400
00:20:09,710 --> 00:20:14,181
当容器应用和它的扩展
都有其访问权限时


401
00:20:14,748 --> 00:20:17,217
第一是您能保持的是模型数据


402
00:20:17,885 --> 00:20:22,856
模型数据是比如SQLite文档 


403
00:20:23,190 --> 00:20:26,360
甚至可能模型对象想要


404
00:20:26,426 --> 00:20:28,161
持久地将核心数据持久保存为预设文档


405
00:20:28,228 --> 00:20:30,464
您可以把所有这些保存在共享的容器里


406
00:20:30,864 --> 00:20:32,332
您的容器应用和它的扩展


407
00:20:32,599 --> 00:20:35,435
都有访问权限


408
00:20:37,271 --> 00:20:39,006
您可以在那里存入文件


409
00:20:39,139 --> 00:20:42,176
刚刚索菲娅讲述了
一个文字处理应用


410
00:20:42,543 --> 00:20:45,746
可能这个文字处理应用
应该把它的文字文件


411
00:20:46,079 --> 00:20:49,082
保存这个共享的容器里
在那里


412
00:20:49,483 --> 00:20:51,151
扩展能修改它们


413
00:20:53,587 --> 00:20:54,421
接下来


414
00:20:54,488 --> 00:20:57,558
您也能存您想存的媒体项目


415
00:20:57,758 --> 00:20:59,159
例如图像、


416
00:20:59,226 --> 00:21:00,661
录影片段、


417
00:21:00,727 --> 00:21:01,962
音频文档


418
00:21:02,029 --> 00:21:03,764
和其他


419
00:21:03,830 --> 00:21:06,633
它们有访问您的容器应用


420
00:21:07,100 --> 00:21:08,302
和它的扩展的权限


421
00:21:09,069 --> 00:21:11,805
现在如果您把可以缓存的项目


422
00:21:11,872 --> 00:21:14,374
缓存在共享的容器里
可能不太好


423
00:21:14,441 --> 00:21:16,977
我想
您更愿意缓存在一个可以清除的地方


424
00:21:17,044 --> 00:21:19,713
当您程序的运行空间
变得很低的时候


425
00:21:21,849 --> 00:21:26,220
现在
来设置核心数据以使用共享的容器


426
00:21:26,653 --> 00:21:28,922
我想给您演示一个小的样本代码


427
00:21:29,089 --> 00:21:31,692
您可以把它应用于容器应用


428
00:21:31,758 --> 00:21:34,428
和它的任何扩展


429
00:21:35,128 --> 00:21:38,966
您可以简单地通过模板


430
00:21:39,032 --> 00:21:40,634
修改Xcode已经为您产生的代码


431
00:21:41,168 --> 00:21:43,904
因此您要做的第一件事是
建立一个新的属性


432
00:21:44,171 --> 00:21:45,672
或者改变一个现有的属性


433
00:21:46,106 --> 00:21:47,541
在这种情况下 
我们叫它


434
00:21:47,608 --> 00:21:50,677
安全应用组展示存储URL


435
00:21:52,112 --> 00:21:53,847
当然首先要做的是


436
00:21:53,914 --> 00:21:56,316
拿到一个NS文档管理员的实例


437
00:21:57,217 --> 00:22:01,522
然后作为文档管理员 
我们将调用


438
00:22:01,622 --> 00:22:04,992
容器URL对于安全应用组的标识符
然后再一次传递


439
00:22:05,259 --> 00:22:08,662
我们之前已经设置好的
应用组标识符


440
00:22:09,997 --> 00:22:11,164
在这之后 


441
00:22:11,231 --> 00:22:15,035
我们将把存储文件名字附加到URL


442
00:22:15,402 --> 00:22:18,272
那个URL指向共享的容器


443
00:22:18,472 --> 00:22:21,742
容器应用程序和扩展程序
都可以访问它


444
00:22:23,243 --> 00:22:25,913
现在我们需要用到这个存储URL 
因此


445
00:22:25,979 --> 00:22:27,948
我们要设置我们的永久存储协调员


446
00:22:28,215 --> 00:22:29,283
我们要用这些


447
00:22:29,349 --> 00:22:31,852
首先产生一个存储协调员


448
00:22:32,686 --> 00:22:34,588
用我们的管理对象模型


449
00:22:35,355 --> 00:22:37,057
然后我们将拿到


450
00:22:37,124 --> 00:22:39,259
我们刚刚建立的那个
存储URL的实例


451
00:22:40,527 --> 00:22:43,830
最后我们将这个永久存储


452
00:22:44,131 --> 00:22:47,467
加入到存储协调员中
用我们刚刚产生的URL


453
00:22:47,534 --> 00:22:49,102
这将指向


454
00:22:49,169 --> 00:22:52,472
后台支持这个的
SQLite 文档


455
00:22:52,873 --> 00:22:53,974
在共享的容器里


456
00:22:54,908 --> 00:22:56,910
然后我们把它返回给调用者


457
00:22:59,246 --> 00:23:03,183
最后我们实际想要设置管理对象语境


458
00:23:03,250 --> 00:23:06,286
我们通过拿到永久存储的协调员


459
00:23:06,920 --> 00:23:09,456
产生一个管理对象语境


460
00:23:09,957 --> 00:23:12,259
然后我们将设置这个协调员


461
00:23:12,326 --> 00:23:14,194
成为管理


462
00:23:14,494 --> 00:23:16,263
对象语境的存储协调员


463
00:23:16,730 --> 00:23:18,131
然后返回它


464
00:23:18,599 --> 00:23:22,769
这就是所有您需要做的
在您的容器应用和任何一个它的扩展里


465
00:23:22,836 --> 00:23:24,471
设置核心数据


466
00:23:24,705 --> 00:23:29,042
来使用共享的永久存储


467
00:23:29,309 --> 00:23:30,444
在共享的容器里


468
00:23:32,846 --> 00:23:37,351
因此核心数据有可能
不是您的应用程序需要的


469
00:23:37,751 --> 00:23:40,621
假设您正在用刚才提到的预设文档


470
00:23:40,687 --> 00:23:43,357
来把您的模型对象


471
00:23:43,657 --> 00:23:44,958
序列化到共享容器


472
00:23:45,592 --> 00:23:47,494
在这一点上


473
00:23:47,561 --> 00:23:51,832
您要考虑同步和访问权限这些事情


474
00:23:52,199 --> 00:23:56,170
在共享容器里
因为


475
00:23:56,603 --> 00:23:58,639
潜在的您的扩展和您的应用


476
00:23:58,705 --> 00:24:01,141
会企图同时改变这些文档


477
00:24:01,408 --> 00:24:03,310
这对数据一致性不是件好事


478
00:24:04,344 --> 00:24:05,179
所以


479
00:24:05,245 --> 00:24:08,282
您实际上不得不使用排它锁


480
00:24:08,582 --> 00:24:10,517
您需要真的特别小心地


481
00:24:10,584 --> 00:24:13,420
在共享容器里的数据使用排它锁


482
00:24:13,921 --> 00:24:16,390
因为一个扩展被清除
和并被当天暂停的同时


483
00:24:16,757 --> 00:24:20,127
拥有一个排它锁


484
00:24:20,761 --> 00:24:23,163
对数据的一致性不是个好事情


485
00:24:24,264 --> 00:24:26,733
那么您需要怎么做呢？


486
00:24:27,467 --> 00:24:29,436
嗯关于任务断言


487
00:24:29,503 --> 00:24:30,938
我最好多讲一些


488
00:24:31,338 --> 00:24:34,608
任务断言是您的扩展统治操作系统的


489
00:24:34,975 --> 00:24:37,244
非常好的方式嘿


490
00:24:37,945 --> 00:24:38,979
我正在做一些事情


491
00:24:39,046 --> 00:24:40,981
您最好不要打扰


492
00:24:41,648 --> 00:24:43,250
如果您想要中断它


493
00:24:44,418 --> 00:24:46,386
我喜欢拿某种回调函数


494
00:24:46,453 --> 00:24:48,455
首先我能清理干净


495
00:24:49,690 --> 00:24:52,793
记住扩展被暂停是非常具有侵略性的


496
00:24:52,860 --> 00:24:54,294
当它们不再被应用


497
00:24:54,828 --> 00:24:57,231
当用户下拉进入


498
00:24:57,297 --> 00:24:59,099
Notification
 Center


499
00:24:59,333 --> 00:25:01,502
然后上拉来取消


500
00:25:01,935 --> 00:25:05,772
我们可以在那时暂停
所有正在运行的扩展


501
00:25:06,373 --> 00:25:07,875
所以那样可能需要非常快速


502
00:25:09,576 --> 00:25:12,346
您要快速地


503
00:25:12,446 --> 00:25:13,847
保护序列化和另一个清理任务


504
00:25:13,981 --> 00:25:16,083
用这些后台断言


505
00:25:17,284 --> 00:25:19,720
我会演示给您看如何去做


506
00:25:19,786 --> 00:25:22,523
它用NSProcess 信息API


507
00:25:23,590 --> 00:25:25,325
您要做的第一件事是


508
00:25:25,425 --> 00:25:28,729
拿到NAPRocess 信息实例


509
00:25:28,996 --> 00:25:31,765
通过调用进程信息工厂的方法


510
00:25:33,901 --> 00:25:35,202
接下来您将调用API


511
00:25:35,269 --> 00:25:38,772
去调用一个结束的活动


512
00:25:38,872 --> 00:25:41,742
我将向您介绍
如何设置此呼叫


513
00:25:44,111 --> 00:25:44,945
第一个变量


514
00:25:45,012 --> 00:25:46,613
您将通过这个方法得到


515
00:25:46,680 --> 00:25:49,116
它是非常短的字符串


516
00:25:49,683 --> 00:25:51,285
这个短字符串


517
00:25:51,351 --> 00:25:52,286
是为您


518
00:25:52,352 --> 00:25:53,987
而不是为操作系统的


519
00:25:54,321 --> 00:25:56,623
它告诉您


520
00:25:56,690 --> 00:25:58,025
要在被保护的任务内部做什么


521
00:25:58,926 --> 00:26:00,561
下一件事是


522
00:26:02,029 --> 00:26:04,965
通过这个API得到一个回调函数


523
00:26:05,632 --> 00:26:08,869
回调函数能在两种方式之一中使用


524
00:26:09,136 --> 00:26:11,038
我将和您走过第一种


525
00:26:11,538 --> 00:26:14,842
第一它将被调用


526
00:26:14,908 --> 00:26:17,978
如果我能以您的名义断言
得到一个后台任务


527
00:26:18,245 --> 00:26:20,080
并把过期设定为否


528
00:26:20,514 --> 00:26:23,083
这意味着它对您是安全的


529
00:26:23,283 --> 00:26:26,920
可以去执行一些序列化任务数据的


530
00:26:26,987 --> 00:26:28,589
您不想被打断的任务


531
00:26:29,790 --> 00:26:33,961
既然任务断言不能无限制地被拿到


532
00:26:34,628 --> 00:26:37,130
当任务断言快要过期的时候


533
00:26:37,197 --> 00:26:39,600
它的顶峰就过去了


534
00:26:41,201 --> 00:26:44,671
操作系统会再一次调用您的回调函数


535
00:26:44,872 --> 00:26:47,374
这一次将过期设定为是


536
00:26:47,908 --> 00:26:50,210
这意味着您需要取消


537
00:26:50,277 --> 00:26:51,912
无论什么任务


538
00:26:51,979 --> 00:26:55,048
并准备被暂停


539
00:26:57,251 --> 00:26:58,085
现在


540
00:26:59,152 --> 00:27:01,555
当您退出版块时


541
00:27:01,622 --> 00:27:04,224
我们将为您释放任务断言


542
00:27:04,491 --> 00:27:06,460
您不需要做任何事


543
00:27:07,895 --> 00:27:09,930
还有第二种可以工作的方式就是


544
00:27:10,297 --> 00:27:14,434
我们完全不能为您获得任务断言


545
00:27:15,435 --> 00:27:17,638
在这种情况下


546
00:27:17,704 --> 00:27:20,607
我们将会立即调用您的版块


547
00:27:20,908 --> 00:27:22,743
把它的过期设为是


548
00:27:23,710 --> 00:27:26,813
您可能不希望使用排它锁


549
00:27:26,880 --> 00:27:28,549
在这个点上在分享容器中


550
00:27:28,715 --> 00:27:31,985
因为如果您被暂停了
就没有保护您的东西了


551
00:27:33,587 --> 00:27:34,621
这样一来


552
00:27:35,522 --> 00:27:36,857
您将会被清理


553
00:27:37,191 --> 00:27:38,792
并做好暂停的准备


554
00:27:38,959 --> 00:27:40,827
您只有几秒钟的时间


555
00:27:40,894 --> 00:27:43,363
来决定是否彻底清理


556
00:27:47,868 --> 00:27:48,869
因此


557
00:27:48,936 --> 00:27:50,470
那是一个复杂的话题


558
00:27:50,537 --> 00:27:51,972
但是我认为有三件事


559
00:27:52,039 --> 00:27:55,309
您需要搞明白
通过今天讲的关于任务断言的内容


560
00:27:56,443 --> 00:27:58,745
第一是它们会被释放


561
00:27:58,812 --> 00:28:01,215
当您的代码退出调用时


562
00:28:02,082 --> 00:28:05,485
一开始我们就执行一个任务断言
如果一切顺利的话


563
00:28:05,552 --> 00:28:08,288
我们把过期设为否
然后


564
00:28:08,355 --> 00:28:10,390
我们会为您保持这个任务断言


565
00:28:10,724 --> 00:28:13,327
直到您的代码退出版块范围


566
00:28:16,530 --> 00:28:17,998
第二个需要记住的是


567
00:28:18,065 --> 00:28:19,299
您有可能需要


568
00:28:19,366 --> 00:28:22,336
重新进入并执行您的调用


569
00:28:22,402 --> 00:28:25,205
来通知您关于过期的信息


570
00:28:25,839 --> 00:28:28,575
再次我们可以再一次调用您的版块


571
00:28:28,642 --> 00:28:31,778
将其过期设为是
来给您一个提醒


572
00:28:31,845 --> 00:28:34,181
这个任务断言将要过期


573
00:28:34,248 --> 00:28:35,682
您应该去清理


574
00:28:36,984 --> 00:28:37,818
最后


575
00:28:37,918 --> 00:28:41,121
您的扩展并不总是可以进行任务断言


576
00:28:41,522 --> 00:28:44,525
有时您调用之后 


577
00:28:44,591 --> 00:28:47,227
过期会立即被设成是
您调用的版块将会按那种方式运行


578
00:28:47,294 --> 00:28:51,665
而且您没有机会去执行一些关键操作


579
00:28:51,732 --> 00:28:53,567
您需要做好准备去处理这些情况


580
00:28:54,401 --> 00:28:55,402
因为它们确实会发生


581
00:28:57,004 --> 00:28:57,838
接下来


582
00:28:58,138 --> 00:28:59,339
这些任务断言


583
00:28:59,406 --> 00:29:01,775
仅仅保护
版块范围内的代码


584
00:29:02,109 --> 00:29:04,945
因此它们一般被用于简单的事情


585
00:29:05,012 --> 00:29:06,480
例如快速序列化


586
00:29:06,547 --> 00:29:07,681
和一些同步的内容


587
00:29:08,382 --> 00:29:11,785
如果您需要与另一个工作序列协同


588
00:29:11,852 --> 00:29:13,420
您该怎么做？


589
00:29:13,954 --> 00:29:17,024
因为您知道任务断言


590
00:29:17,090 --> 00:29:18,325
是在那个调用版块范围内的


591
00:29:20,894 --> 00:29:23,197
那么调用版块


592
00:29:23,263 --> 00:29:25,032
必须与其他序列中受保护的工作同步


593
00:29:25,365 --> 00:29:26,200
例如


594
00:29:26,266 --> 00:29:29,136
如果在主线程中


595
00:29:29,703 --> 00:29:32,773
您想保护一些东西
那么您需要确定


596
00:29:32,940 --> 00:29:36,310
调用版块没有退出原始保护范围


597
00:29:36,376 --> 00:29:39,112
在这个工作完成之前


598
00:29:39,980 --> 00:29:42,683
这里我用一个例子展示如何


599
00:29:43,250 --> 00:29:47,054
在板块中通过调用异步到主线程上


600
00:29:47,621 --> 00:29:50,090
执行将会从版块中退出


601
00:29:50,457 --> 00:29:53,460
很可能在进行之前
暂停就会生效


602
00:29:53,994 --> 00:29:55,062
完成


603
00:29:55,362 --> 00:29:56,296
太糟糕了


604
00:29:56,964 --> 00:29:58,966
因此在这种情况下
您的版块


605
00:29:59,032 --> 00:30:02,803
需要通过发送同步或信号


606
00:30:02,870 --> 00:30:06,340
或者无论哪个您在队列里选择的方法


607
00:30:06,640 --> 00:30:08,942
来记住在您分配去另一个队列里时


608
00:30:09,510 --> 00:30:11,578
它是工作的


609
00:30:11,645 --> 00:30:14,114
它不是必须为主队列
需要被取消


610
00:30:14,348 --> 00:30:18,418
因为我们可能会同时赋值过期变量
来回调您的模块


611
00:30:18,785 --> 00:30:20,521
在这种时候


612
00:30:20,587 --> 00:30:24,324
您需要清理您正在做的事情
跳出回到程序模块 


613
00:30:24,591 --> 00:30:26,226
退出释放断言任务


614
00:30:29,730 --> 00:30:31,732
实际上您这样做是安全的


615
00:30:31,798 --> 00:30:34,401
因为这个回调函数


616
00:30:34,468 --> 00:30:36,003
正在私有系统队列里执行


617
00:30:36,370 --> 00:30:37,504
您不会产生死锁定


618
00:30:37,571 --> 00:30:39,406
因为我们不会往那里回调


619
00:30:42,075 --> 00:30:43,810
现在这已经很多了


620
00:30:44,645 --> 00:30:45,579
我明白


621
00:30:47,614 --> 00:30:48,682
从这里继续


622
00:30:50,884 --> 00:30:53,287
在我们新的多任务的世界里


623
00:30:53,687 --> 00:30:55,556
我们现在碰到很多情况


624
00:30:55,923 --> 00:30:59,092
在您的扩展和包含的应用程序


625
00:30:59,159 --> 00:31:00,594
同时执行的时候


626
00:31:01,195 --> 00:31:02,029
这意味着


627
00:31:02,095 --> 00:31:04,665
如果什么事情在您所包含的
应用程序里发生


628
00:31:04,965 --> 00:31:06,967
这件事改变了您数据模型的状态


629
00:31:07,701 --> 00:31:10,771
潜在的是您的扩展可能就


630
00:31:11,271 --> 00:31:13,373
不会和模型的状态同步了
这是不好的


631
00:31:14,107 --> 00:31:16,977
因此有一种您可以用来保持


632
00:31:17,044 --> 00:31:18,879
每个人在同一个状态的途径


633
00:31:18,946 --> 00:31:21,148
就是进化Notification
center


634
00:31:21,348 --> 00:31:22,182
API和


635
00:31:22,249 --> 00:31:24,651
NSNotification
Center非常相像


636
00:31:25,319 --> 00:31:27,988
但它更加简单


637
00:31:28,055 --> 00:31:30,023
它适用的用例数量更小


638
00:31:30,424 --> 00:31:32,759
对于您的包含的应用和它的扩展来说


639
00:31:33,794 --> 00:31:35,028
例如今天


640
00:31:35,095 --> 00:31:36,129
我们将向您展示


641
00:31:36,196 --> 00:31:38,098
如何用它去暗示您的扩展


642
00:31:38,398 --> 00:31:39,466
去重新加载模型


643
00:31:40,434 --> 00:31:41,435
以下是您要如何去做


644
00:31:42,102 --> 00:31:44,004
第一在那个包含的应用里面


645
00:31:44,371 --> 00:31:45,639
您要取得


646
00:31:45,706 --> 00:31:46,673
一个进化


647
00:31:46,740 --> 00:31:48,909
Notification 
Center 的实例


648
00:31:48,976 --> 00:31:50,544
您将调用CF


649
00:31:50,611 --> 00:31:52,412
Notification
Center


650
00:31:52,479 --> 00:31:54,114
拿到进化 
notify Center


651
00:31:54,948 --> 00:31:58,819
然后您将传递这个通知的实例


652
00:31:59,119 --> 00:32:01,688
给CFNotification
Center发布通知


653
00:32:03,223 --> 00:32:06,260
下一件您要做的事是挑拣出一个字符串


654
00:32:06,393 --> 00:32:08,962
这个字符串将用来代表您的通知


655
00:32:09,363 --> 00:32:11,565
您会在您包含的应用里


656
00:32:11,932 --> 00:32:15,802
用它和任何一个扩展去观察这个通知


657
00:32:16,770 --> 00:32:17,971
然后您要传递是


658
00:32:20,641 --> 00:32:21,942
在您的扩展里


659
00:32:22,009 --> 00:32:24,211
您将再一次用它去得到一个


660
00:32:24,278 --> 00:32:26,613
进化Notification
 Center 的实例


661
00:32:27,648 --> 00:32:28,949
您将把这个


662
00:32:29,016 --> 00:32:29,850
传递给


663
00:32:29,917 --> 00:32:31,818
CFNotification
Center的观察者


664
00:32:31,885 --> 00:32:35,088
这个准许您去观察这个通知


665
00:32:36,290 --> 00:32:38,559
下一件您想做的事


666
00:32:38,625 --> 00:32:40,027
是传递一个回调模块


667
00:32:40,460 --> 00:32:43,096
这是回调模块正在被执行的样子


668
00:32:43,463 --> 00:32:45,132
当系统注意到


669
00:32:45,265 --> 00:32:47,601
这个通知被发送了


670
00:32:48,802 --> 00:32:50,637
您想要传递那个短字串


671
00:32:52,573 --> 00:32:54,875
最后立刻交付


672
00:32:56,009 --> 00:32:58,912
这能确定所有事情都始终保持最新


673
00:32:59,146 --> 00:33:01,849
并让您的扩展内部的模型重新加载


674
00:33:01,982 --> 00:33:04,284
在包含的应用传递这个暗示的时候


675
00:33:04,852 --> 00:33:08,021
现在记得我叫它暗示
因此您可能


676
00:33:08,088 --> 00:33:09,823
不想用这个去协调


677
00:33:09,890 --> 00:33:13,126
您的扩展和您包含的应用之间的锁


678
00:33:13,594 --> 00:33:16,830
因为它不总是保证


679
00:33:17,097 --> 00:33:18,565
您的扩展


680
00:33:18,632 --> 00:33:20,834
能收到这些通知


681
00:33:25,172 --> 00:33:28,075
这就是如何保持您的模型始终最新


682
00:33:28,342 --> 00:33:29,376
如何保持


683
00:33:29,443 --> 00:33:31,678
您的小工具的视觉展示最新？


684
00:33:32,045 --> 00:33:33,680
下一步我将告诉您


685
00:33:34,615 --> 00:33:37,150
我要用的这个叫做后台刷新


686
00:33:39,486 --> 00:33:42,122
后台刷新是一个系统


687
00:33:42,189 --> 00:33:44,858
它和您的小工具一起工作
来保持它最新的途径


688
00:33:44,925 --> 00:33:47,594
去保持视觉展示的最新状态


689
00:33:49,730 --> 00:33:50,564
再一次


690
00:33:50,631 --> 00:33:52,833
我们回到Notification
Center


691
00:33:52,900 --> 00:33:54,835
在这里
您能看到我们的股票小工具


692
00:33:55,169 --> 00:33:58,405
股票小工具
显示的是最新的股价


693
00:34:02,643 --> 00:34:08,649
在一天里苹果的股票变化了
会发生什么呢？


694
00:34:09,349 --> 00:34:12,786
嗯这个通知


695
00:34:12,853 --> 00:34:17,123
可能将被发射到您的手机
同时包含的应用程序


696
00:34:17,190 --> 00:34:19,293
可能被希望做一些事情


697
00:34:20,393 --> 00:34:23,864
您的小工具视觉上的表现


698
00:34:23,931 --> 00:34:24,898
可能改换


699
00:34:25,899 --> 00:34:26,967
不幸的是


700
00:34:27,034 --> 00:34:28,302
我们会注意到


701
00:34:28,368 --> 00:34:31,438
小工具现在和股价不一致了


702
00:34:31,505 --> 00:34:33,774
它显示$130.12


703
00:34:33,841 --> 00:34:36,243
而实际应该是$132.12


704
00:34:36,877 --> 00:34:37,844
我们如何修补呢？


705
00:34:37,978 --> 00:34:40,781
我们如何确定我们的视觉展示


706
00:34:40,848 --> 00:34:41,681
总是最新的呢？


707
00:34:42,516 --> 00:34:44,618
嗯对初学者 


708
00:34:44,685 --> 00:34:47,420
系统将随机地刷新这个内容


709
00:34:47,754 --> 00:34:50,123
它将和小工具对话


710
00:34:50,190 --> 00:34:51,123
去看看是否需要更新


711
00:34:51,190 --> 00:34:52,292
而不必去下拉


712
00:34:52,359 --> 00:34:54,161
Notification
 Center


713
00:34:55,161 --> 00:34:58,832
每一个今天小工具的视图控制器
都符合


714
00:34:58,899 --> 00:35:00,467
NC 小工具的提供


715
00:35:01,235 --> 00:35:04,004
如果小工具的视图控制器


716
00:35:04,438 --> 00:35:05,539
实现了授权方法更新


717
00:35:05,606 --> 00:35:08,976
它将参与到这个系统里来


718
00:35:09,076 --> 00:35:10,377
现在我将向您展示如何来完成


719
00:35:11,879 --> 00:35:13,780
我们要做的第一件事


720
00:35:13,847 --> 00:35:17,150
是在我们的今天小工具视图
控制器加小工具


721
00:35:17,551 --> 00:35:20,521
来处理程序执行更新


722
00:35:20,721 --> 00:35:22,456
以符合NC小工具的提供


723
00:35:23,991 --> 00:35:26,727
第一步我们将刷新模型


724
00:35:27,227 --> 00:35:29,429
这能为我们做一件事


725
00:35:29,496 --> 00:35:30,797
一件非常重要的事


726
00:35:31,098 --> 00:35:34,201
它会告诉我们模型里是否有变化


727
00:35:34,268 --> 00:35:35,636
而这个变化


728
00:35:35,702 --> 00:35:39,540
将实质影响小工具的视觉展示


729
00:35:40,607 --> 00:35:41,975
如果有变化


730
00:35:42,042 --> 00:35:43,944
我们会告诉视图阶层


731
00:35:44,011 --> 00:35:45,212
它需要重新画图


732
00:35:46,647 --> 00:35:49,116
最后我们在里面


733
00:35:49,183 --> 00:35:52,052
会拿到传递给我们的完成处理程序


734
00:35:52,553 --> 00:35:54,955
如果有视觉上的变化


735
00:35:55,289 --> 00:35:56,657
我们就会传递新的数据


736
00:35:57,491 --> 00:35:59,960
如果没有实质性的变化


737
00:36:00,027 --> 00:36:02,496
影响到我们小工具的视觉展示


738
00:36:02,563 --> 00:36:04,264
那么没有数据将被传递


739
00:36:04,698 --> 00:36:07,067
这会让我们的小工具在


740
00:36:07,134 --> 00:36:08,936
Notification 
Center 里


741
00:36:09,002 --> 00:36:09,937
是一个好公民


742
00:36:10,003 --> 00:36:12,372
因为在这一点上
我们暗示操作系统


743
00:36:12,439 --> 00:36:14,208
它不需要扩展任何资源


744
00:36:14,575 --> 00:36:17,344
去更新我们的今天小工具的


745
00:36:17,744 --> 00:36:18,879
视觉展示


746
00:36:20,380 --> 00:36:23,050
既然我们已经做了这个
我们的小工具已经被更新了


747
00:36:23,383 --> 00:36:25,986
您会注意到股价是正确的


748
00:36:31,291 --> 00:36:32,993
下一个


749
00:36:34,194 --> 00:36:36,897
网络扩展是短暂的目标


750
00:36:37,030 --> 00:36:38,465
是真正的短暂的过程


751
00:36:38,532 --> 00:36:39,666
它们来来去去


752
00:36:39,733 --> 00:36:41,935
记住我谈的是用户下拉


753
00:36:42,002 --> 00:36:43,203
然后迅速地向上划回


754
00:36:43,837 --> 00:36:46,139
这对于一些花时间的事
可能是场浩劫


755
00:36:46,206 --> 00:36:48,442
例如网络会话


756
00:36:48,976 --> 00:36:53,146
小工具可能会调用云服务


757
00:36:53,213 --> 00:36:56,316
还有一些网上其他事情
以便进行处理数据


758
00:36:56,984 --> 00:36:58,452
那么我们如何处理这种情况呢？


759
00:36:59,419 --> 00:37:00,988
嗯我建议您


760
00:37:01,054 --> 00:37:03,524
尝试用NSURLsession


761
00:37:03,590 --> 00:37:04,625
后台会话


762
00:37:05,025 --> 00:37:06,093
这些是什么？


763
00:37:06,760 --> 00:37:10,163
这些是任务被执行的网络任务


764
00:37:10,230 --> 00:37:12,499
是以您的名义被系统执行的


765
00:37:14,768 --> 00:37:18,338
更新和事件会被快递到您的扩展


766
00:37:18,405 --> 00:37:20,107
只要它还保持活跃


767
00:37:20,774 --> 00:37:23,544
但是如果您的扩展被暂停或清除了


768
00:37:23,610 --> 00:37:25,179
或因为什么原因电话被挂掉了


769
00:37:25,245 --> 00:37:27,781
用这个关键系统


770
00:37:28,782 --> 00:37:33,453
或这个系统的部件包含的应用


771
00:37:33,520 --> 00:37:35,489
来接管错误和处理事件
以它的名义


772
00:37:36,557 --> 00:37:38,025
我将展示如何在您的扩展里设置


773
00:37:39,092 --> 00:37:40,394
首先


774
00:37:40,727 --> 00:37:42,896
您要创建


775
00:37:42,963 --> 00:37:45,365
一个NSURLSession
配置后台会话


776
00:37:45,799 --> 00:37:48,836
用标识符目标配置


777
00:37:49,570 --> 00:37:50,737
哦对不起用方法


778
00:37:51,538 --> 00:37:55,309
再一次跟随模式


779
00:37:55,375 --> 00:37:58,412
您要创建一个标识符


780
00:37:58,745 --> 00:38:00,981
它会被正在参与这个后台会话的


781
00:38:01,048 --> 00:38:03,417
扩展应用和包含应用使用到


782
00:38:04,218 --> 00:38:05,586
像我们这种情况
我们在用


783
00:38:05,719 --> 00:38:07,654
com.example.my 
下载会话


784
00:38:08,989 --> 00:38:10,090
下一件事


785
00:38:10,157 --> 00:38:13,527
您要在会话的配置中


786
00:38:14,027 --> 00:38:15,963
建立一个分享的容器标识符


787
00:38:16,463 --> 00:38:18,131
不然的话您将有很大


788
00:38:18,198 --> 00:38:21,101
您的所有会话都可能在我们调试的时候
因为不合法而被退回


789
00:38:21,168 --> 00:38:22,369
如果您是刚开始一个任务


790
00:38:22,870 --> 00:38:24,171
至少我知道我就做过这样的事


791
00:38:25,372 --> 00:38:26,373
下一步


792
00:38:26,907 --> 00:38:29,843
您要创建一个
NSURLSession


793
00:38:30,511 --> 00:38:32,412
传递这个会话的配置


794
00:38:32,846 --> 00:38:33,881
到初始器


795
00:38:33,981 --> 00:38:36,250
现在您注意到
我们正在和初始器用同一个授权表格


796
00:38:36,316 --> 00:38:39,486
因为完成处理程序形式的初始器


797
00:38:39,553 --> 00:38:42,623
和后台URL会话一起用


798
00:38:42,689 --> 00:38:44,391
是不合法的


799
00:38:45,592 --> 00:38:48,095
下一步
为了举例


800
00:38:48,161 --> 00:38:50,697
我们要下载Apple.com 网站


801
00:38:52,132 --> 00:38:55,502
我们要产生一个任务
并且消费它


802
00:38:56,103 --> 00:38:57,104
现在我们的扩展


803
00:38:57,171 --> 00:38:59,573
已经成功在后台创建了
一个NSURLSession


804
00:38:59,640 --> 00:39:03,177
并交给了系统


805
00:39:03,477 --> 00:39:06,380
系统将用开始快递事件去扩展


806
00:39:08,081 --> 00:39:11,218
下一步在我们的包含应用中
正如我以前讲的


807
00:39:11,285 --> 00:39:15,556
我们需要准备它对任何情况


808
00:39:15,756 --> 00:39:19,092
例如扩展被暂停或清除了


809
00:39:19,159 --> 00:39:22,596
或被挂断而不能处理


810
00:39:22,896 --> 00:39:25,399
从系统和网络部件发来的事件


811
00:39:25,899 --> 00:39:29,236
我们用加入应用程序
对我们的UI应用授权


812
00:39:29,369 --> 00:39:33,273
来处理后台URL会话事件的方法来做


813
00:39:34,441 --> 00:39:35,809
第一步我要做的


814
00:39:35,909 --> 00:39:38,745
举例来说


815
00:39:39,079 --> 00:39:41,748
是确认一个标识符


816
00:39:41,815 --> 00:39:43,083
就是一个我们期待的标识符


817
00:39:43,150 --> 00:39:46,653
系统将导入
和NSURLSession


818
00:39:46,854 --> 00:39:51,058
有关联的标识符


819
00:39:51,191 --> 00:39:53,260
对于您处理的应用授权事件


820
00:39:54,695 --> 00:39:57,831
就像和扩展一样


821
00:39:57,898 --> 00:40:00,901
我们将设置一个
NSURLSession 配置项目


822
00:40:01,168 --> 00:40:03,403
通过调用后台会话配置


823
00:40:03,470 --> 00:40:05,639
和标识符工厂的方法


824
00:40:07,140 --> 00:40:10,010
我们需要再次设置分享容器标识符


825
00:40:11,578 --> 00:40:14,214
然后我们需要调用
NSURLSession


826
00:40:14,481 --> 00:40:17,050
传递这个分享的配置 


827
00:40:17,150 --> 00:40:19,620
然后再次用授权形式的初始器


828
00:40:20,754 --> 00:40:23,690
最后非常重要的


829
00:40:23,757 --> 00:40:25,259
如果您不仔细看就会错过的


830
00:40:25,959 --> 00:40:28,829
是我们将保存这个完成出来程式


831
00:40:28,962 --> 00:40:31,532
我们将把它保存回我们的属性里


832
00:40:31,765 --> 00:40:33,166
当我们完成的时候


833
00:40:33,233 --> 00:40:37,504
当我们处理
关于这个URL会话事件的时候


834
00:40:37,871 --> 00:40:39,006
您也许会问


835
00:40:39,072 --> 00:40:41,575
您如何知道什么时候事件处理完成了呢
好我来演示给您看


836
00:40:43,110 --> 00:40:47,214
在我们的NSURLSession
授权里我们需要用这个方法


837
00:40:47,581 --> 00:40:50,617
URL会话的确会完成
后台URL会话事件


838
00:40:50,751 --> 00:40:52,953
它将被调用到您的容器应用程序


839
00:40:53,020 --> 00:40:54,755
或者在这个情况下


840
00:40:55,622 --> 00:40:59,359
您的容器应用程序


841
00:40:59,426 --> 00:41:04,031
会任命它去管理这些事件
去解决所有的URL会话事件


842
00:41:04,164 --> 00:41:06,300
从后台URL会话里


843
00:41:07,134 --> 00:41:08,335
我们要做的第一件事


844
00:41:08,402 --> 00:41:10,470
是拿到这个配置对象


845
00:41:11,305 --> 00:41:12,706
然后我们将确认


846
00:41:12,773 --> 00:41:15,742
会话配置的标识符


847
00:41:15,809 --> 00:41:17,244
是否匹配我们期待的标识符


848
00:41:18,946 --> 00:41:21,048
然后我们将调用完成处理程式


849
00:41:21,114 --> 00:41:22,416
就是我们早前保存的


850
00:41:23,851 --> 00:41:25,552
并发行我们对会话的引用


851
00:41:26,086 --> 00:41:27,154
这时我们完成了


852
00:41:27,621 --> 00:41:32,025
我们成功地处理了


853
00:41:32,159 --> 00:41:35,329
到我们的容器应用程式的任何事件


854
00:41:35,562 --> 00:41:38,899
从我们先前
到扩展开始的系统组件


855
00:41:40,300 --> 00:41:42,636
现在您能用这个技术


856
00:41:42,703 --> 00:41:45,439
应对任何一种扩展类型
不只是今天小工具


857
00:41:45,506 --> 00:41:47,040
这真是个伟大的技术


858
00:41:47,508 --> 00:41:49,977
但是有一个地方您不能用


859
00:41:50,043 --> 00:41:52,079
那是对您的
Watch OS 1 扩展


860
00:41:52,946 --> 00:41:55,015
作为代替


861
00:41:55,082 --> 00:41:57,417
我们建议您用后台任务断言


862
00:41:57,618 --> 00:42:01,221
去保护这些小的任务
您可以发现


863
00:42:01,288 --> 00:42:04,825
更多关于WatchKit
的技巧和窍门


864
00:42:05,459 --> 00:42:08,195
明天早上10点在Presidio


865
00:42:08,629 --> 00:42:10,330
由夹克 贝伦斯主讲


866
00:42:15,002 --> 00:42:18,338
接下来
在您网络交易时


867
00:42:18,405 --> 00:42:21,942
您会不可避免地要挑战您的凭证


868
00:42:22,676 --> 00:42:27,381
如何能安全可靠地保护
您用户的隐私


869
00:42:28,482 --> 00:42:31,218
从而秘密地分享这些信息


870
00:42:31,752 --> 00:42:33,053
在您的容器应用程序和扩展中


871
00:42:33,654 --> 00:42:36,757
我们建议您用Keychain访问组
对于这个


872
00:42:36,823 --> 00:42:38,425
就像这里演示的


873
00:42:39,359 --> 00:42:43,197
您在您的扩展


874
00:42:43,597 --> 00:42:44,932
和您的容器应用程序中设置


875
00:42:45,866 --> 00:42:48,535
然后用这个您设置的标识符


876
00:42:48,602 --> 00:42:51,271
就是您在您的容器应用程式中和
它的扩展中设置的


877
00:42:52,573 --> 00:42:56,543
您简单地传递这个标识符
作为一个值


878
00:42:56,610 --> 00:43:01,248
无论什么时候您在Keychain
里加一个项目就可以


879
00:43:03,984 --> 00:43:04,885
就像这里演示的一样


880
00:43:06,687 --> 00:43:07,588
下一件事


881
00:43:07,821 --> 00:43:11,091
告诉您这里有一个自动查询行为


882
00:43:11,291 --> 00:43:14,094
对采用Keychain 
API的询问API


883
00:43:14,628 --> 00:43:16,396
因此可靠项目的更新


884
00:43:17,130 --> 00:43:18,365
可靠项目的删减


885
00:43:19,032 --> 00:43:23,203
可靠项目的复制
都自动做了正确的事情


886
00:43:23,337 --> 00:43:26,373
就是通过寻找每一个
关于您的Keychain


887
00:43:26,440 --> 00:43:29,676
因此您不用传递
Keychain 访问组标识符


888
00:43:30,010 --> 00:43:32,412
到这些API里
这就是个需要记住的技巧


889
00:43:33,380 --> 00:43:35,616
您可以发现更多关于这些API的内容


890
00:43:35,816 --> 00:43:38,485
通过观看安全录像和
您的应用程式的录像


891
00:43:43,857 --> 00:43:47,694
总结一下
今天索菲娅讲述了所有关于


892
00:43:47,761 --> 00:43:48,829
动作和分享的扩展


893
00:43:49,396 --> 00:43:51,431
关于它们意味着什么


894
00:43:51,565 --> 00:43:54,801
和如何才能更好地
利用它们去分享数据


895
00:43:54,968 --> 00:43:57,104
与您的应用程序和网络


896
00:43:58,805 --> 00:44:02,142
她也演示了如何
把NS项目提供器


897
00:44:02,509 --> 00:44:04,845
使用到它的最大可能


898
00:44:04,912 --> 00:44:08,849
这是她
为您分享数据类型而努力的工作


899
00:44:10,617 --> 00:44:14,488
她也演示了
如何让您的主程序拥有伟大的环境


900
00:44:14,555 --> 00:44:18,258
对动作和分享扩展来说
您知道吗


901
00:44:18,692 --> 00:44:22,162
这将提升
您主程序的价值


902
00:44:23,163 --> 00:44:27,401
然后我演示了如何加强
您的今天小工具


903
00:44:27,668 --> 00:44:31,738
通过确定您的模板
和它的视觉展示


904
00:44:31,805 --> 00:44:33,574
总是保持到最新状态


905
00:44:35,442 --> 00:44:37,511
然后我们演示了
一些


906
00:44:37,578 --> 00:44:41,515
最佳的实践
比如如何安全地分享秘密


907
00:44:41,582 --> 00:44:43,150
和保护您客户的隐私


908
00:44:46,153 --> 00:44:48,455
那里有一些相关的讲座
我早些时候引用的


909
00:44:48,622 --> 00:44:51,892
Watchkit的技巧和安全


910
00:44:51,959 --> 00:44:53,794
以及您的应用程序


911
00:44:56,263 --> 00:44:58,966
明天您能浏览关于更多的信息 


912
00:44:59,032 --> 00:45:01,902
我建议您去读App延伸项目导航
或者


913
00:45:02,002 --> 00:45:04,671
去和我们的宣传员科特 罗斯特交谈


914
00:45:07,474 --> 00:45:08,342
谢谢

