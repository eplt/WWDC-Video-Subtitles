
1
00:00:07,040 --> 00:00:15,949
(音楽)

2
00:00:19,386 --> 00:00:23,657
こんにちは
tvOSチームのジェレミーです

3
00:00:23,790 --> 00:00:29,630
tvOS 12に追加した
最新のTVMLKitを紹介します

4
00:00:30,163 --> 00:00:34,034
TVMLKitは
ハイレベルなフレームワークで

5
00:00:34,134 --> 00:00:37,838
tvOSアプリケーションを
素早く構築できます

6
00:00:38,105 --> 00:00:41,542
Human Interface Guidelinesにも
準拠し

7
00:00:41,642 --> 00:00:45,112
快適なアプリケーションを
実現します

8
00:00:45,646 --> 00:00:48,582
アプリケーションロジックは
JavaScript

9
00:00:48,682 --> 00:00:52,152
ユーザインターフェイスの
レンダリングは

10
00:00:52,986 --> 00:00:55,622
独自のマークアップ言語です

11
00:00:57,124 --> 00:01:00,427
おなじみのアプリケーションにも

12
00:00:57,124 --> 00:01:00,427
おなじみのアプリケーションにも

13
00:01:00,827 --> 00:01:03,497
TVMLKitが使われています

14
00:01:04,096 --> 00:01:07,401
App Storeにも
数千とあるでしょう

15
00:01:08,902 --> 00:01:12,773
早速 TVMLKitの強化点から―

16
00:01:13,106 --> 00:01:15,976
３つのことをお話しします

17
00:01:16,376 --> 00:01:19,279
まず 強化されたWebインスペクタ

18
00:01:19,379 --> 00:01:24,785
より高度なデバッグと
イントロスペクションを提供します

19
00:01:25,986 --> 00:01:30,023
追加した機能や強化点は
数多くありますが

20
00:01:30,123 --> 00:01:33,060
今回は その中の３つです

21
00:01:33,927 --> 00:01:38,298
高度なデバックを可能にした
Webインスペクタ

22
00:01:38,799 --> 00:01:42,736
強化された
データバインディング

23
00:01:43,070 --> 00:01:47,508
再生エクスペリエンスの
新しいカスタマイズ方法です

24
00:01:48,742 --> 00:01:50,878
まずWebインスペクタから

25
00:01:51,078 --> 00:01:53,881
tvOS 11のWebインスペクタも

26
00:01:53,981 --> 00:01:57,584
イントロスペクションに
優れていました

27
00:01:57,885 --> 00:02:00,888
そこから更に強化しました

28
00:01:57,885 --> 00:02:00,888
そこから更に強化しました

29
00:02:02,389 --> 00:02:07,995
tvOS 11.3では
イベントリスナーの表示に加え

30
00:02:08,095 --> 00:02:10,297
一時的に無効にもできます

31
00:02:10,864 --> 00:02:16,470
この切り替えで デバックの効率が
大きく上昇します

32
00:02:20,340 --> 00:02:25,846
こちらはNetworkタブ内
XHRで通信中の画像リソースです

33
00:02:26,046 --> 00:02:28,949
画像がロード中であること

34
00:02:29,049 --> 00:02:32,886
そして その所要時間が
確認できます

35
00:02:34,454 --> 00:02:37,658
ロード中の画像を見ることも

36
00:02:37,758 --> 00:02:40,594
オプションで可能になりました

37
00:02:40,827 --> 00:02:45,566
これはWebインスペクタに
接続時の機能であり

38
00:02:45,732 --> 00:02:48,335
ロード済みの画像は対象外です

39
00:02:49,837 --> 00:02:53,774
お勧めは
インスペクタボタンです

40
00:02:54,107 --> 00:02:59,513
クリックすると
フォーカス中の要素を表示します

41
00:03:00,814 --> 00:03:04,751
要素が折りたたまれていれば
展開し

42
00:03:04,918 --> 00:03:07,321
ハイライトで表示します

43
00:03:09,790 --> 00:03:11,358
Webインスペクタは

44
00:03:11,525 --> 00:03:17,331
Safari Technology Preview
または最新のmacOSで利用できます

45
00:03:17,798 --> 00:03:20,467
詳しい利用方法は

46
00:03:20,567 --> 00:03:25,272
Using Web Inspector with
tvOS Appsをご覧ください

47
00:03:28,709 --> 00:03:31,011
続いてデータバインディング

48
00:03:33,580 --> 00:03:38,986
新しい機能の説明の前に
概要をお話しします

49
00:03:39,152 --> 00:03:43,891
これはデータを
ユーザインターフェイス要素へ

50
00:03:43,991 --> 00:03:46,426
簡単に変換する機構です

51
00:03:47,561 --> 00:03:52,766
利点はアプリケーションや
レイアウトのロジックと

52
00:03:52,866 --> 00:03:55,469
データを分離できることです

53
00:03:57,538 --> 00:04:01,808
テンプレートにより
JavaScriptの記述を軽減でき

54
00:03:57,538 --> 00:04:01,808
テンプレートにより
JavaScriptの記述を軽減でき

55
00:04:01,909 --> 00:04:06,513
データの変換は
フレームワークが行います

56
00:04:06,914 --> 00:04:10,150
最適な形で変換を行うため

57
00:04:10,317 --> 00:04:15,389
APIの種類を
気にする必要がありません

58
00:04:16,822 --> 00:04:19,660
実例を見ながら説明します

59
00:04:19,793 --> 00:04:23,964
タイトルと説明を載せた
バナーの生成を

60
00:04:24,298 --> 00:04:28,769
データバインディングなしで
行ってみます

61
00:04:30,971 --> 00:04:34,675
まず ユーザに表示する
データをフェッチ

62
00:04:34,775 --> 00:04:37,177
今回はタイトルと説明です

63
00:04:38,579 --> 00:04:43,250
このデータを
JavaScriptコードへ渡すと

64
00:04:43,350 --> 00:04:48,021
データが処理され
ドキュメントが生成されます

65
00:04:49,223 --> 00:04:54,194
データバインディングでは
JavaScriptの処理が不要です

66
00:04:54,328 --> 00:04:57,831
バインディングの仕様を
提供すれば

67
00:04:57,931 --> 00:05:02,169
TVMLKitが指示どおりに
ドキュメントを追加します

68
00:04:57,931 --> 00:05:02,169
TVMLKitが指示どおりに
ドキュメントを追加します

69
00:05:02,703 --> 00:05:07,908
必要なのは
データのフェッチと操作のみ

70
00:05:08,008 --> 00:05:10,210
DOMの編集は不要です

71
00:05:10,911 --> 00:05:15,215
こうして
コードの記述が軽減されます

72
00:05:17,384 --> 00:05:22,489
既存のデータバインディングの
主な概念はこちらです

73
00:05:22,589 --> 00:05:27,427
要素の属性に
要素のテキストコンテンツ

74
00:05:27,928 --> 00:05:32,833
シェルフ グリッド リスト
各セクションのアイテムです

75
00:05:33,433 --> 00:05:37,137
他の例を見ながら
要点をまとめます

76
00:05:39,673 --> 00:05:42,910
画像要素をバインドする
テンプレートは

77
00:05:43,010 --> 00:05:45,579
式にが含まれます

78
00:05:45,679 --> 00:05:49,016
次に属性名と
プロパティが続きます

79
00:05:50,150 --> 00:05:54,755
次は要素のテキストコンテンツの
生成例です

80
00:05:55,823 --> 00:06:01,461
今回は実際に充てんされる
データを持つタイトル要素です

81
00:05:55,823 --> 00:06:01,461
今回は実際に充てんされる
データを持つタイトル要素です

82
00:06:03,564 --> 00:06:06,200
このテンプレートに含まれるのは

83
00:06:06,300 --> 00:06:10,170
textContentと
マップするプロパティです

84
00:06:13,106 --> 00:06:15,642
次はアイテムのバインディングです

85
00:06:15,742 --> 00:06:21,181
前のケースと少し異なり
表示データはグループであり

86
00:06:21,481 --> 00:06:25,085
各セクション単位で機能します

87
00:06:26,553 --> 00:06:31,124
例えば ツリー状の
リストアイテムの最終表現は

88
00:06:31,258 --> 00:06:35,996
ツリー状のlistItemLockupの
セクションとなります

89
00:06:37,130 --> 00:06:40,968
今回テンプレートに含まれるのは

90
00:06:41,101 --> 00:06:43,904
itemsとマップするプロパティです

91
00:06:44,471 --> 00:06:49,376
更に配列内の各データを
変換するプロトタイプ―

92
00:06:49,543 --> 00:06:54,114
listItemLockupが含まれます

93
00:06:55,883 --> 00:06:59,586
以上はtvOS 11の
バインディング機構です

94
00:06:59,686 --> 00:07:05,392
詳細はAdvances in TVMLKitで
ご確認ください

95
00:06:59,686 --> 00:07:05,392
詳細はAdvances in TVMLKitで
ご確認ください

96
00:07:08,128 --> 00:07:11,832
今年は語彙を拡張しました

97
00:07:11,999 --> 00:07:16,136
まず 子要素をバインドする
包括的な方式

98
00:07:16,236 --> 00:07:18,172
子要素のバインディングを追加

99
00:07:19,673 --> 00:07:23,377
更にDOMの構成を助ける
要素を追加

100
00:07:23,477 --> 00:07:25,612
fragmentとrulesです

101
00:07:25,812 --> 00:07:29,416
まず 子要素のバインディングから

102
00:07:32,152 --> 00:07:35,455
これは より包括的な
バインド方式です

103
00:07:35,989 --> 00:07:39,393
アイテムのバインディングは

104
00:07:39,493 --> 00:07:43,130
シェルフなどの
セクションに最適です

105
00:07:43,497 --> 00:07:46,266
大きなデータセットに効果的ですが

106
00:07:46,867 --> 00:07:49,136
他の要素にも使えます

107
00:07:49,603 --> 00:07:52,139
子要素のバインディングは
さらに包括的

108
00:07:54,007 --> 00:07:55,976
理由は簡単です

109
00:07:56,076 --> 00:08:00,013
要素の子要素を
生成し機能するからです

110
00:07:56,076 --> 00:08:00,013
要素の子要素を
生成し機能するからです

111
00:08:02,616 --> 00:08:05,319
挙動はアイテムの場合と同じです

112
00:08:05,486 --> 00:08:11,458
まずプロトタイプで
データが変換される要素を定義

113
00:08:12,826 --> 00:08:17,364
それをテンプレートとし
最終DOMを生成します

114
00:08:20,300 --> 00:08:22,636
実例を見てみます

115
00:08:23,470 --> 00:08:27,274
再びツリー状のアイテムです

116
00:08:27,474 --> 00:08:29,109
データ構成は同じですが

117
00:08:29,209 --> 00:08:33,914
今回は異なる３つの
メニューアイテムです

118
00:08:34,847 --> 00:08:36,717
メニューバーで使われます

119
00:08:37,851 --> 00:08:39,553
最終表現は

120
00:08:39,653 --> 00:08:43,957
メニューバーツリーの
menuBarItemです

121
00:08:45,893 --> 00:08:50,030
テンプレートの記述は
とても簡単です

122
00:08:50,731 --> 00:08:54,568
アイテムのバインディングと
似ています

123
00:08:54,801 --> 00:08:57,704
データをマップするプロトタイプと

124
00:08:57,805 --> 00:08:59,840
バインディングの式です

125
00:09:00,440 --> 00:09:04,778
違いは要素が
セクション上にないこと

126
00:09:04,945 --> 00:09:07,347
子要素のバインディングは
要素を問いません

127
00:09:10,083 --> 00:09:14,988
すべての子要素を生成するのに
適していますが

128
00:09:15,455 --> 00:09:19,293
一部を生成したい場合も
あるでしょう

129
00:09:19,793 --> 00:09:23,730
ストリーミングアプリケーションを
例に考えます

130
00:09:24,064 --> 00:09:29,002
nowPlayingMenuItemは
メニューバーの必須アイテムですが

131
00:09:29,369 --> 00:09:34,241
バックグラウンドで再生中の時のみ
表示されます

132
00:09:36,610 --> 00:09:40,547
しかし menuBarItemの
バインドは必要です

133
00:09:40,881 --> 00:09:44,618
そのため データを動作中か否かで

134
00:09:44,718 --> 00:09:47,387
区分する必要があります

135
00:09:47,554 --> 00:09:49,957
ここでfragmentが使えます

136
00:09:51,859 --> 00:09:53,293
fragmentとは？

137
00:09:54,294 --> 00:09:57,898
レンダラに見えない非表示要素で

138
00:09:58,098 --> 00:10:00,400
DOMの構成を助けます

139
00:09:58,098 --> 00:10:00,400
DOMの構成を助けます

140
00:10:01,568 --> 00:10:05,672
しかし その子要素は
表示要素です

141
00:10:08,141 --> 00:10:12,813
子要素のバインディングは
要素を問わないため

142
00:10:13,313 --> 00:10:16,116
fragmentにも作用します

143
00:10:18,519 --> 00:10:23,090
まずはデータの最終形を確認します

144
00:10:23,290 --> 00:10:27,828
menuBarItemが
fragmentにカプセル化され

145
00:10:28,495 --> 00:10:32,032
子要素のバインディングが
行われています

146
00:10:34,701 --> 00:10:39,006
これはバインドしたデータを
fragment内に移動し

147
00:10:39,106 --> 00:10:42,643
nowPlayingMenuItemを
残すという処理です

148
00:10:42,943 --> 00:10:46,580
レンダラはfragmentの
子要素だけを見て

149
00:10:46,914 --> 00:10:49,917
適切にメニューバーを生成します

150
00:10:52,486 --> 00:10:58,125
ユーザインターフェイス要素へ
マップするデータにも

151
00:10:58,258 --> 00:11:00,027
似たケースがあります

152
00:10:58,258 --> 00:11:00,027
似たケースがあります

153
00:11:00,127 --> 00:11:04,865
静的なデータと動的なデータが
混在するからです

154
00:11:05,532 --> 00:11:09,169
例えば 次のようなデータです

155
00:11:09,536 --> 00:11:13,373
ビデオの
ポスター画像とタイトル―

156
00:11:13,807 --> 00:11:15,843
そして再生状況です

157
00:11:17,644 --> 00:11:22,950
ユーザインターフェイスの表示は
情報により異なります

158
00:11:24,184 --> 00:11:28,755
再生開始前
すなわちゼロの状況では―

159
00:11:29,356 --> 00:11:34,862
ビデオのポスター画像とタイトルを
表示します

160
00:11:36,330 --> 00:11:40,567
再生開始で
再生状況はゼロ以上になります

161
00:11:41,034 --> 00:11:43,937
ポスター画像とタイトルは

162
00:11:44,438 --> 00:11:46,206
引き続き表示します

163
00:11:47,040 --> 00:11:51,111
しかし 再生中を明確に示すため

164
00:11:51,311 --> 00:11:55,916
プログレスバーに
再生状況を表示します

165
00:11:57,684 --> 00:12:01,188
このようにデータの異なる事例は

166
00:11:57,684 --> 00:12:01,188
このようにデータの異なる事例は

167
00:12:01,822 --> 00:12:04,792
異なる表示となるべきです

168
00:12:05,058 --> 00:12:09,096
最初の例はlockup内に
画像とタイトルがあり

169
00:12:09,863 --> 00:12:14,301
次の例はoverlayと
progressBarが付加されています

170
00:12:16,937 --> 00:12:22,209
アプリケーションの
アウトプット数は様々です

171
00:12:22,676 --> 00:12:26,413
rulesで
１つの静的テンプレートから

172
00:12:26,513 --> 00:12:29,817
異なるドキュメントが
生成できます

173
00:12:31,118 --> 00:12:32,953
ではrulesとは？

174
00:12:33,921 --> 00:12:36,623
rulesはデータ状態に応じ

175
00:12:36,723 --> 00:12:40,527
UI用のドキュメントを
再定義します

176
00:12:42,062 --> 00:12:45,032
レンダラには見えない
要素ですが

177
00:12:45,232 --> 00:12:47,601
どう記述するかに作用します

178
00:12:49,169 --> 00:12:51,471
rules内のオペレーションは

179
00:12:51,705 --> 00:12:55,809
いずれも
その兄弟要素に作用します

180
00:12:56,510 --> 00:13:00,581
セットアップ方法を例に説明します

181
00:12:56,510 --> 00:13:00,581
セットアップ方法を例に説明します

182
00:13:02,716 --> 00:13:06,253
先ほどの例のとおり
プロトタイプを

183
00:13:06,587 --> 00:13:10,357
rulesを使い構成してみます

184
00:13:10,724 --> 00:13:13,961
まず ユーザインターフェイスの
共通項目で

185
00:13:14,061 --> 00:13:16,697
プロトタイプを定義します

186
00:13:17,531 --> 00:13:20,334
今回は画像とタイトルです

187
00:13:21,935 --> 00:13:26,240
プログレスバーの
placeholderもあります

188
00:13:26,573 --> 00:13:30,077
placeholderも
特別な非表示要素で

189
00:13:30,177 --> 00:13:35,749
データ状態が一致した際
代替ターゲットになります

190
00:13:37,718 --> 00:13:39,386
早速 記述します

191
00:13:40,020 --> 00:13:44,558
兄弟要素に働くrulesのグループは
rulesタグでカプセル化

192
00:13:47,494 --> 00:13:53,100
そして 個別のrulesは
specializeの要素としてカプセル化

193
00:13:54,535 --> 00:13:59,473
specializeの要素は
状態に応じアクティブになります

194
00:14:00,307 --> 00:14:04,812
状態の判断は
状態の属性のクエリに基づきます

195
00:14:07,214 --> 00:14:11,985
データ状態が一致した場合
specializeの子要素が

196
00:14:12,319 --> 00:14:16,456
rulesの兄弟要素に作用する
オペレーションリストです

197
00:14:17,124 --> 00:14:22,196
今回はplaceholderを
overlayとその子要素に置換します

198
00:14:25,866 --> 00:14:31,205
TVMLKitは要素のタグの属性で
置換する要素を見つけます

199
00:14:31,538 --> 00:14:35,576
タグを確認してから
要素名を比べることで

200
00:14:35,676 --> 00:14:37,678
効果的に置換します

201
00:14:38,245 --> 00:14:41,715
要素名が不一致なら
要素のホールを置換

202
00:14:41,815 --> 00:14:45,152
今回はplaceholderが
overlayになります

203
00:14:45,652 --> 00:14:47,955
要素名が一致した場合は

204
00:14:48,055 --> 00:14:51,792
新しいものが
既存の要素へ追加されます

205
00:14:53,360 --> 00:14:56,029
rulesは１つのテンプレートから

206
00:14:56,129 --> 00:15:00,701
異なる２つのアウトプットを
生成してくれます

207
00:14:56,129 --> 00:15:00,701
異なる２つのアウトプットを
生成してくれます

208
00:15:02,002 --> 00:15:06,740
実際の表示は
アプリケーションで処理します

209
00:15:06,840 --> 00:15:11,411
ユーザインターフェイス要素の
コンテキスト内の

210
00:15:11,512 --> 00:15:14,548
静的テンプレートへの表示です

211
00:15:15,449 --> 00:15:18,785
続いてはTVMLKitの再生について

212
00:15:19,286 --> 00:15:21,788
TVMLKitの拡張ポイントで

213
00:15:21,889 --> 00:15:25,192
インターフェイスを
カスタマイズできます

214
00:15:25,392 --> 00:15:28,529
ビューや
テンプレートにも対応します

215
00:15:29,029 --> 00:15:32,866
今回 拡張ポイントを
再生パイプラインへ広げ

216
00:15:32,966 --> 00:15:37,771
ユーザ体験につながる
再生の管理を可能にしました

217
00:15:40,974 --> 00:15:43,343
様々な再生スタイルに対応し

218
00:15:43,544 --> 00:15:48,982
埋め込み画面か
フルスクリーンかは問いません

219
00:15:51,552 --> 00:15:54,454
カスタマイズに必要なのが

220
00:15:54,555 --> 00:15:58,292
TVPlayerとUIViewControllerです

221
00:16:01,061 --> 00:16:04,431
TVMLKit JSのAPIに酷似し

222
00:16:04,531 --> 00:16:08,569
JavaScript開発者には
混乱が少ないでしょう

223
00:16:09,803 --> 00:16:13,507
更に限定のJavaScriptブリッジで

224
00:16:13,607 --> 00:16:18,212
ネイティブコードとJavaScriptの
対話が可能です

225
00:16:20,614 --> 00:16:23,183
TVPlayerの説明をします

226
00:16:23,784 --> 00:16:28,121
TVPlayerはカスタマイズした
再生動作に必要です

227
00:16:28,989 --> 00:16:34,695
そして 再生パイプラインへの
AVPlayerのアダプタです

228
00:16:35,295 --> 00:16:39,867
AVPlayerのコールバックを効果的に

229
00:16:39,967 --> 00:16:42,035
JavaScript用に変換します

230
00:16:45,239 --> 00:16:49,910
カスタムイベントの
ディスパッチも可能です

231
00:16:50,878 --> 00:16:55,449
AVPlayerの再生イベントは
デフォルトで処理します

232
00:16:55,549 --> 00:16:58,452
必要なのはディスパッチのみ

233
00:17:01,889 --> 00:17:05,425
JavaScriptによる変更は
KVOが監視するので

234
00:17:05,526 --> 00:17:08,628
いつ変更されたかを把握できます

235
00:17:09,730 --> 00:17:14,166
更に TVPlayerはプレイリスト順に

236
00:17:14,268 --> 00:17:18,505
メディアを連続再生します

237
00:17:20,874 --> 00:17:25,646
TVApplicationController
DelegateによるTVPlayerの要求に

238
00:17:25,746 --> 00:17:30,851
インスタンスを返し
再生パイプラインへ参加します

239
00:17:33,954 --> 00:17:39,526
次はユーザインターフェイス上の
再生表示についてです

240
00:17:39,626 --> 00:17:45,232
再生はフルスクリーンか
埋め込み画面で随時行われます

241
00:17:45,666 --> 00:17:48,769
ユーザインターフェイスの
仕様も様々です

242
00:17:50,070 --> 00:17:52,339
TVMLKitは再生の際

243
00:17:52,439 --> 00:17:55,976
TVInterfaceFactoryで
View Controllerを要求します

244
00:17:56,210 --> 00:18:02,149
そして 再生用のリファレンスを
TVPlayerへ渡します

245
00:17:56,210 --> 00:18:02,149
そして 再生用のリファレンスを
TVPlayerへ渡します

246
00:18:04,618 --> 00:18:10,924
ここで TVPlayerの注意点を
いくつかお伝えします

247
00:18:12,159 --> 00:18:15,495
まず“should”イベントへの
対応が必要です

248
00:18:15,996 --> 00:18:20,434
インタースティシャルのケースが
多いため

249
00:18:20,534 --> 00:18:23,704
ネイティブコードで処理します

250
00:18:25,806 --> 00:18:29,276
再生にFairPlayの暗号化を使う場合

251
00:18:29,643 --> 00:18:33,814
AVContentKeySessionが必要です

252
00:18:34,948 --> 00:18:37,584
関連セッションは次の２つです

253
00:18:37,684 --> 00:18:41,555
Advances in HTTP Live Streaming

254
00:18:41,655 --> 00:18:45,526
そしてAVContentKeySession
Best Practicesです

255
00:18:47,661 --> 00:18:52,966
最後に overlayと
interactiveOverlayには

256
00:18:53,066 --> 00:18:55,135
対応していません

257
00:18:55,502 --> 00:19:00,274
インターフェイスのため
個別の対応が必要です

258
00:18:55,502 --> 00:19:00,274
インターフェイスのため
個別の対応が必要です

259
00:19:04,111 --> 00:19:05,212
まとめです

260
00:19:05,379 --> 00:19:11,185
TVMLKitおよび
tvOS 12の変更点は次の２つ

261
00:19:11,285 --> 00:19:14,054
まず データバインディングが
強化され

262
00:19:14,188 --> 00:19:20,260
データ駆動型テンプレートの構成が
可能になったこと

263
00:19:21,395 --> 00:19:25,899
そして ネイティブの
再生エクスペリエンスを実装し

264
00:19:26,033 --> 00:19:29,770
カスタマイズが
可能になったことです

265
00:19:31,238 --> 00:19:35,576
詳細はこちらのURLをご覧ください

266
00:19:37,211 --> 00:19:41,815
WWDC 2018へのご参加
ありがとうございました