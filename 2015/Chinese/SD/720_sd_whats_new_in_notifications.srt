1
00:00:19,720 --> 00:00:22,389
有关通知的新内容


2
00:00:31,798 --> 00:00:33,700
大家下午好 谢谢


3
00:00:34,301 --> 00:00:36,170
美国的同仁们已经利用通知功能


4
00:00:36,236 --> 00:00:37,871
完成了一些很不错的工作


5
00:00:38,205 --> 00:00:40,607
今天我们将通过一个完整的系统


6
00:00:40,674 --> 00:00:43,977
介绍其工作原理并且会看一些
为你们创建的新功能


7
00:00:45,179 --> 00:00:47,080
通知是一个由两个部分组成的系统


8
00:00:47,147 --> 00:00:49,983
我们有iOS通知和APNS


9
00:00:50,884 --> 00:00:53,720
我是Michele就职于
iOS Notifications


10
00:00:53,787 --> 00:00:55,689
我们首先介绍iOS通知


11
00:00:56,657 --> 00:00:59,259
然后我们将介绍静默通知


12
00:00:59,560 --> 00:01:02,095
和用户通知以及


13
00:01:02,162 --> 00:01:03,163
二者之间的区别


14
00:01:03,530 --> 00:01:08,202
我们将看一些通知操作和一项新功能


15
00:01:08,268 --> 00:01:10,871
我希望你们喜欢这项功能


16
00:01:12,472 --> 00:01:14,141
在本讲座的后半部分


17
00:01:14,441 --> 00:01:16,143
我的同事Gokul


18
00:01:16,210 --> 00:01:18,812
将会介绍Apple推送通知服务中的


19
00:01:18,879 --> 00:01:21,281
一些新的功能 这些功能


20
00:01:22,015 --> 00:01:26,687
将会让你的工作变得更轻松
为你节省大量时间


21
00:01:28,989 --> 00:01:31,859
让我们从静默通知开始


22
00:01:32,893 --> 00:01:34,928
静默通知是静默的


23
00:01:35,128 --> 00:01:37,130
它们不会向用户显示UI


24
00:01:37,531 --> 00:01:39,867
不会触发手机提示音


25
00:01:40,267 --> 00:01:42,269
因此你不会使用它们来通知用户


26
00:01:42,336 --> 00:01:43,904
你应该使用它们来通知APP


27
00:01:45,072 --> 00:01:46,273
它们是远程通知


28
00:01:46,340 --> 00:01:48,075
因此它们来自于互联网


29
00:01:48,475 --> 00:01:50,244
这是你的服务器和你的APP


30
00:01:50,811 --> 00:01:53,780
你的服务器发送一个通知给你的APP


31
00:01:54,848 --> 00:01:57,985
如果你发送可用内容标记给APP


32
00:01:58,285 --> 00:02:00,754
你的APP就知道


33
00:02:00,821 --> 00:02:04,291
有新的内容可供下载并且开始下载


34
00:02:06,727 --> 00:02:09,363
默认情况下静默通知被启用


35
00:02:09,997 --> 00:02:13,166
用户不需要批准你的...


36
00:02:13,400 --> 00:02:16,570
不会为APP提供许可权限以使用它们


37
00:02:17,237 --> 00:02:18,739
你可以直接开始使用它们


38
00:02:18,805 --> 00:02:21,141
而无需请求用户批准


39
00:02:22,376 --> 00:02:27,314
但是静默通知是
后台APP刷新所使用的机制


40
00:02:27,881 --> 00:02:30,150
在任何时候 用户都可以


41
00:02:30,217 --> 00:02:31,818
进入设置并禁用它们


42
00:02:32,252 --> 00:02:35,489
你不应该期望它们始终可用


43
00:02:35,556 --> 00:02:38,091
你不知道用户是否已经关闭它们


44
00:02:38,158 --> 00:02:40,527
也不知道你是否还会收到通知


45
00:02:42,829 --> 00:02:48,335
另外 静默通知是是尽力发送的


46
00:02:48,702 --> 00:02:51,772
这意味着当通知到达


47
00:02:51,972 --> 00:02:55,676
用户设备时系统将会进行一些选择


48
00:02:55,742 --> 00:02:59,079
它会根据设备和用户行为


49
00:02:59,146 --> 00:03:02,182
来使用不同的信号
例如根据电量情况和时间


50
00:03:02,716 --> 00:03:04,985
来决定在合适的时间


51
00:03:05,252 --> 00:03:07,487
发送通知，
并启动你的APP


52
00:03:08,822 --> 00:03:10,591
它会尝试节约电池电量


53
00:03:10,657 --> 00:03:14,995
或尝试根据用户习惯在用户需要时


54
00:03:15,062 --> 00:03:16,830
提供他们想要的内容


55
00:03:19,499 --> 00:03:21,635
接下来我们介绍用户通知


56
00:03:22,669 --> 00:03:25,839
顾名思义主要差别在于
你使用这些通知来通知用户


57
00:03:25,939 --> 00:03:29,643
当你想要向用户通知某些事项


58
00:03:29,910 --> 00:03:32,779
当你想要向用户通知服务器最新状态


59
00:03:32,846 --> 00:03:35,883
或APP的其他用户的操作时
可以发送这些通知


60
00:03:36,783 --> 00:03:39,887
它们显示在用户页面上如显示在信息条


61
00:03:39,953 --> 00:03:41,622
锁屏和通知中心


62
00:03:44,091 --> 00:03:46,426
由于这些通知面向用户


63
00:03:46,493 --> 00:03:48,595
因此它们可能中断用户正在进行的操作


64
00:03:48,862 --> 00:03:50,163
而且可能促发电话提示音


65
00:03:50,531 --> 00:03:52,065
因此我们需要许可


66
00:03:52,132 --> 00:03:55,702
你应该确定用户确实需要接收通知


67
00:03:55,769 --> 00:03:57,905
而且他们知道将会收到通知


68
00:03:59,606 --> 00:04:03,210
这还意味着
用户可以在任何时间禁用通知，


69
00:04:03,677 --> 00:04:05,212
而且用户可以更改设置


70
00:04:05,312 --> 00:04:09,683
因此如果你将通知设置为横幅和徽章


71
00:04:09,750 --> 00:04:12,319
用户可能会禁止一部分通知


72
00:04:12,619 --> 00:04:15,022
他们可能接收徽章而不接收横幅


73
00:04:19,026 --> 00:04:21,595
有两种不同类型的用户通知


74
00:04:22,829 --> 00:04:25,032
第一种是远程通知


75
00:04:25,098 --> 00:04:27,267
第二种是本地通知


76
00:04:28,235 --> 00:04:30,137
让我们先来看远程通知


77
00:04:31,905 --> 00:04:34,575
远程通知意味着它们来自于互联网


78
00:04:34,942 --> 00:04:36,276
其来源地是你的服务器


79
00:04:36,944 --> 00:04:39,580
服务器发送通知给用户设备


80
00:04:41,281 --> 00:04:46,486
现在你看到你的APP还没显示出来


81
00:04:46,553 --> 00:04:48,989
因为你的APP没有运行


82
00:04:50,457 --> 00:04:54,595
只有当用户点击通知时
你的APP才会启动


83
00:04:55,229 --> 00:04:58,365
APP将会启动，


84
00:04:58,866 --> 00:05:01,568
这时你能够处理


85
00:05:01,635 --> 00:05:05,005
你刚才发送的通知


86
00:05:07,307 --> 00:05:11,945
现在在用户远程通知中


87
00:05:12,279 --> 00:05:17,284
可设置与静默通知中相同内容用于标记


88
00:05:17,684 --> 00:05:19,453
这将让你的APP


89
00:05:19,820 --> 00:05:23,023
有时间下载内容


90
00:05:23,090 --> 00:05:26,927
或更新它想要显示的内容


91
00:05:26,994 --> 00:05:28,829
这样当用户点击通知时


92
00:05:29,663 --> 00:05:31,798
你的内容就可以使用了


93
00:05:32,032 --> 00:05:33,901
用户将会看到响应过程


94
00:05:35,002 --> 00:05:40,874
它通过这种方法
在用户通知中实现静默通知


95
00:05:43,977 --> 00:05:46,813
第二种是本地通知


96
00:05:47,381 --> 00:05:51,185
本地通知是你自己的APP的安排


97
00:05:51,385 --> 00:05:53,153
直接在用户设备上


98
00:05:53,554 --> 00:05:55,055
没有服务器 也没有互联网


99
00:05:56,890 --> 00:05:59,626
和前面一样你的APP安排通知


100
00:06:00,160 --> 00:06:05,299
系统将它显示给用户
当用户点击通知时


101
00:06:05,365 --> 00:06:08,535
你的APP收到App委派中的


102
00:06:08,602 --> 00:06:09,736
一个回调


103
00:06:11,038 --> 00:06:14,875
这时你可以处理通知 而且你知道


104
00:06:14,942 --> 00:06:17,110
用户点击了通知


105
00:06:17,177 --> 00:06:18,612
并且想要处理通知


106
00:06:21,215 --> 00:06:23,684
我说过你可以在APP中安排通知


107
00:06:23,951 --> 00:06:24,852
那么应该怎么做呢？


108
00:06:25,319 --> 00:06:27,120
你可以通过两种不同的方式


109
00:06:27,187 --> 00:06:28,422
来安排通知


110
00:06:29,022 --> 00:06:30,490
你可以按时间安排


111
00:06:31,191 --> 00:06:35,028
这样在延迟一定的时间之后


112
00:06:35,762 --> 00:06:37,865
将会发送通知


113
00:06:38,065 --> 00:06:44,505
或者也可以
在未来的特定日期和时间发送通知


114
00:06:46,874 --> 00:06:48,842
另一种安排通知的方法


115
00:06:49,209 --> 00:06:50,844
称为地理围栏


116
00:06:50,944 --> 00:06:55,816
你可以规定当用户到达或离开


117
00:06:55,883 --> 00:06:58,719
你设置的特定位置时发送通知


118
00:07:00,954 --> 00:07:02,723
这是从用户角度来阐述的通知工作原理


119
00:07:02,789 --> 00:07:03,924
通知就是这样实现的


120
00:07:04,358 --> 00:07:06,693
在iOS 8，我们引入通知操作


121
00:07:07,661 --> 00:07:08,929
通知操作使得


122
00:07:09,196 --> 00:07:12,065
通知具有更好的可交互性


123
00:07:12,699 --> 00:07:15,469
这样用户可以与你的APP进行交互


124
00:07:15,536 --> 00:07:18,839
而不需启动APP这样可以提高效率


125
00:07:18,906 --> 00:07:21,975
因为用户已经收到通知
他们可以原地处理通知


126
00:07:22,042 --> 00:07:25,412
而不需启动APP
也不会中断他们正在做的事情


127
00:07:28,949 --> 00:07:31,919
操作按类别进行分组


128
00:07:32,719 --> 00:07:35,956
可以使用不同类别来分组你想要发送的


129
00:07:36,089 --> 00:07:37,991
不同类型的通知


130
00:07:38,392 --> 00:07:40,994
这样你就可以为不同类型的通知


131
00:07:41,295 --> 00:07:43,063
设置不同的操作


132
00:07:43,530 --> 00:07:49,069
比如说 你有一个照片APP
用户可以使用它分享照片


133
00:07:49,636 --> 00:07:52,105
你可以设置一组不同的操作
当用户发布照片


134
00:07:52,172 --> 00:07:55,909
或发布评论时将会执行这些操作


135
00:08:01,381 --> 00:08:04,484
这里介绍的所有这些通知功能


136
00:08:04,551 --> 00:08:08,155
已在Apple Watch中实现


137
00:08:08,989 --> 00:08:11,625
当你戴着Apple Watch时
你并不需要做任何事情


138
00:08:11,892 --> 00:08:13,894
Apple Watch
为自动为你进行处理


139
00:08:13,994 --> 00:08:16,463
Apple Watch可与设备配对


140
00:08:17,998 --> 00:08:22,102
你只需要正确设置你的通知


141
00:08:22,269 --> 00:08:24,571
你就会获得基本和默认的处理操作


142
00:08:24,838 --> 00:08:28,275
如果你想要自定义通知的外观


143
00:08:28,342 --> 00:08:30,444
或通知的处理操作


144
00:08:31,111 --> 00:08:34,948
我建议你观看WatchKit讲座


145
00:08:35,015 --> 00:08:37,885
本周早些时候我们举行了这个讲座


146
00:08:37,951 --> 00:08:39,019
介绍了很多有用的内容


147
00:08:42,222 --> 00:08:46,326
如果你并不像我在讲座中所做的那样


148
00:08:46,393 --> 00:08:50,864
只用emojis与你的朋友进行交流


149
00:08:52,132 --> 00:08:56,637
我们在iOS 8中推出的新通知功能


150
00:08:57,404 --> 00:09:00,274
即文本回复功能


151
00:09:01,975 --> 00:09:04,811
当你收到一条文本消息时
可以直接在下拉通知界面中


152
00:09:05,979 --> 00:09:08,348
回复文字信息


153
00:09:09,883 --> 00:09:13,220
我们收集了一些反馈意见


154
00:09:13,287 --> 00:09:17,324
表明用户也喜欢与朋友进行文字交流


155
00:09:17,391 --> 00:09:19,726
而不是仅使用emojis


156
00:09:20,928 --> 00:09:25,232
在iOS 9我们推出了
用户通知文本输入功能


157
00:09:25,966 --> 00:09:28,202
这样你可以在相同的用户界面中


158
00:09:28,335 --> 00:09:31,138
在你的APP中处理同一个交互式通知


159
00:09:32,606 --> 00:09:33,607
让我们来看看


160
00:09:34,708 --> 00:09:36,677
它看起来是这样的


161
00:09:37,911 --> 00:09:39,646
你可以在你的APP中发送一个通知


162
00:09:40,948 --> 00:09:43,750
用户可以下拉并输入文字


163
00:09:45,252 --> 00:09:49,256
输入文字而不是emojis
它看起来是这样的


164
00:09:51,625 --> 00:09:56,063
让我们来看应该怎样操作
了解它们是如何工作的


165
00:09:57,998 --> 00:10:01,468
文本输入操作是一种新型操作


166
00:10:01,635 --> 00:10:07,407
输入文本并进行与以往一样的文本操作


167
00:10:08,842 --> 00:10:10,711
文本的显示位置


168
00:10:11,111 --> 00:10:16,083
与所有其他操作的显示位置相同


169
00:10:16,149 --> 00:10:20,654
在这些幻灯片中你会看到
它们与其他操作配合工作


170
00:10:20,754 --> 00:10:24,925
可以进行多项操作其中一项或多项操作


171
00:10:24,992 --> 00:10:27,294
可以是文本输入操作


172
00:10:27,628 --> 00:10:29,596
这是消息所不能企及的


173
00:10:31,899 --> 00:10:32,966
如何创建它们呢？


174
00:10:34,968 --> 00:10:37,271
我们说过它们仅仅是操作而已


175
00:10:37,938 --> 00:10:40,374
与iOS 8之前的版本中的
操作并没有什么区别


176
00:10:41,508 --> 00:10:43,710
因此创建它们的方法


177
00:10:43,777 --> 00:10:46,246
与创建通知的方法相同


178
00:10:47,514 --> 00:10:52,953
唯一的差别在于
应该将行为设置为文本输入行为


179
00:10:54,254 --> 00:10:57,324
这样当设备接收通知


180
00:10:57,391 --> 00:11:00,627
而且新设备具有文本输入行为时


181
00:11:00,694 --> 00:11:01,929
可以显示文本字段


182
00:11:03,330 --> 00:11:05,032
我们已经创建操作


183
00:11:05,632 --> 00:11:09,002
然后创建自己的类别以注册这些操作


184
00:11:09,670 --> 00:11:11,371
本例是一个简单的示例


185
00:11:11,738 --> 00:11:15,008
我们只有一个回复操作
但是可以添加更多的操作


186
00:11:15,442 --> 00:11:16,910
它们将显示在信息条


187
00:11:16,977 --> 00:11:18,612
提醒或锁屏之中


188
00:11:19,780 --> 00:11:21,682
然后我们创建自己的设置


189
00:11:22,149 --> 00:11:24,117
将它们注册到APP


190
00:11:25,619 --> 00:11:29,089
这样 APP将会提示用户


191
00:11:29,223 --> 00:11:32,492
询问是否允许使用用户通知


192
00:11:33,560 --> 00:11:37,164
如果通知你的APP中的一个选项


193
00:11:37,231 --> 00:11:42,269
当APP启动时
并不需要将它们注册到APP


194
00:11:42,336 --> 00:11:44,838
你可以在用户
确定想要接收通知时


195
00:11:44,905 --> 00:11:46,373
注册这些通知


196
00:11:46,440 --> 00:11:47,341
将会设置一个按钮


197
00:11:50,677 --> 00:11:54,114
你如何接收这些文本输入通知呢？


198
00:11:55,482 --> 00:11:59,052
你的APP委派中
有一个新的委派一个新方法


199
00:12:00,020 --> 00:12:04,992
它类似于我们用于旧类型操作的委派


200
00:12:05,325 --> 00:12:08,428
唯一的差别在于现在有一个新参数


201
00:12:08,762 --> 00:12:11,164
向你告知用户反馈


202
00:12:12,099 --> 00:12:15,435
这个参数来自于远程通知


203
00:12:16,069 --> 00:12:18,105
这个参数来自于本地通知


204
00:12:18,472 --> 00:12:21,775
它们之间只有细微的差异
但是它们是两个不同的方法


205
00:12:26,413 --> 00:12:30,150
你应该如何处理 用户反馈的数据呢？


206
00:12:31,485 --> 00:12:32,553
我们使用委派方法 


207
00:12:34,021 --> 00:12:36,056
当我们注册通知时


208
00:12:36,523 --> 00:12:39,860
我们就在类别中设置了一个标识符 


209
00:12:41,461 --> 00:12:45,732
我们获得反馈信息
此信息包含一个字典


210
00:12:46,166 --> 00:12:49,236
其内含有通知发回的信息


211
00:12:49,770 --> 00:12:52,272
在这个例子中
由于它是一个文本输入操作


212
00:12:52,339 --> 00:12:55,275
它将含有用户输入的文本


213
00:12:57,578 --> 00:13:01,014
这段代码检查标识符是否确实是


214
00:13:01,582 --> 00:13:04,918
用于我创建的意见反馈操作的标识符


215
00:13:06,119 --> 00:13:10,791
然后我从字典中提取文本


216
00:13:11,458 --> 00:13:13,193
需要进行一些对话


217
00:13:13,460 --> 00:13:16,930
在我获取字符串之后
我就可以进行任何操作


218
00:13:16,997 --> 00:13:22,836
在这个例子中我可以在视图控制器中
将它添加到我的聊天APP


219
00:13:23,670 --> 00:13:27,774
Apple Watch支持所有功能


220
00:13:28,976 --> 00:13:30,143
其原理就是这样的


221
00:13:30,310 --> 00:13:31,578
你创建一个通知


222
00:13:32,279 --> 00:13:33,347
然后创建操作


223
00:13:33,447 --> 00:13:37,484
你获得文本反馈
用户通过标准Apple


224
00:13:37,551 --> 00:13:40,854
Watch Quickboard
回复通知


225
00:13:41,722 --> 00:13:44,391
如前所述


226
00:13:45,025 --> 00:13:49,296
如果你想自定义通知的外观或行为


227
00:13:49,363 --> 00:13:53,033
可以自定义反馈列表


228
00:13:53,100 --> 00:13:54,968
用户可以点击这时在


229
00:13:55,569 --> 00:13:59,706
让我们来回顾本周早些时候
举行的WatchKit讲座


230
00:14:03,710 --> 00:14:05,712
我还有另外一件事情要讲


231
00:14:06,813 --> 00:14:09,149
这件事件并不是像新iPod那么重要


232
00:14:09,449 --> 00:14:10,817
也不会让人感到兴奋 


233
00:14:10,951 --> 00:14:12,819
这个主题是iOS 8兼容性


234
00:14:13,787 --> 00:14:17,424
虽然这是一件小事
你是需要引起注意 因为


235
00:14:18,692 --> 00:14:23,330
假设你的APP运行
在iOS 8之中且含有操作


236
00:14:23,764 --> 00:14:28,902
而且你有一个响应操作
因为你设置了聊天功能


237
00:14:29,403 --> 00:14:31,738
当用户收到通知时你希望...


238
00:14:33,073 --> 00:14:36,343
如果他们点击回复按钮能够直接进入


239
00:14:36,410 --> 00:14:38,378
他们正在进行的聊天


240
00:14:38,445 --> 00:14:40,814
这样当你在聊天过程中打开APP时


241
00:14:40,881 --> 00:14:42,115
他们可以立即开始输入文字


242
00:14:43,550 --> 00:14:47,988
在这个例子中这是前台操作


243
00:14:48,322 --> 00:14:51,925
当我们启动APP


244
00:14:52,092 --> 00:14:53,927
当用户点击操作按钮时
可以执行这个操作


245
00:14:57,464 --> 00:15:00,801
如果你在iOS 9中实现这个功能


246
00:15:01,335 --> 00:15:07,274
以使用文本输入操作
你将需要使用后台操作


247
00:15:07,341 --> 00:15:09,443
因为你不希望启动APP


248
00:15:09,510 --> 00:15:13,614
你希望直接进行输入
而且当用户输入和发送消息后


249
00:15:13,680 --> 00:15:15,482
信息条消失


250
00:15:16,216 --> 00:15:22,689
为了实现这一点
你需要通过两种不同的方式


251
00:15:22,756 --> 00:15:23,857
注册你的操作


252
00:15:23,924 --> 00:15:28,462
这取决于你的APP运行在
iOS 8上还是在iOS 9上


253
00:15:29,463 --> 00:15:33,734
因此 当你注册你的操作时


254
00:15:33,967 --> 00:15:36,637
你需要检查你的代码


255
00:15:37,771 --> 00:15:39,540
将在哪个版本的iOS上运行


256
00:15:39,840 --> 00:15:42,843
你可以检查API是否可用


257
00:15:42,910 --> 00:15:45,913
并决定用不同的方法进行注册


258
00:15:48,448 --> 00:15:50,851
我们介绍了文本输入操作


259
00:15:52,753 --> 00:15:57,057
我们介绍了iOS通知
以及它们如何在系统中工作


260
00:15:58,592 --> 00:16:01,628
我们看到 你可以


261
00:16:02,129 --> 00:16:05,165
使用静默通知来更新内容


262
00:16:05,232 --> 00:16:06,466
使内容可供用户使用


263
00:16:07,401 --> 00:16:10,304
我们介绍了用户通知和操作


264
00:16:12,673 --> 00:16:15,742
还介绍了新的文本输入功能


265
00:16:16,043 --> 00:16:18,745
我希望你们使用这些功能


266
00:16:20,814 --> 00:16:23,884
你们应该了解如何将所有这些
功能转移到Apple Watch


267
00:16:24,318 --> 00:16:26,353
了解它们如何在
Apple Watch上运行


268
00:16:27,287 --> 00:16:31,725
现在 请我的同事
colleague Gokul上台


269
00:16:32,125 --> 00:16:33,760
他将介绍Apple推送通知服务


270
00:16:34,528 --> 00:16:37,731
Push Notification
Service的一些改进功能


271
00:16:37,798 --> 00:16:38,832
谢谢


272
00:16:46,640 --> 00:16:48,642
下午好 我是Gokul


273
00:16:49,176 --> 00:16:52,379
我从事Apple推送通知服务
或称APNS的开发工作


274
00:16:53,847 --> 00:16:55,883
很高兴来到这里和大家分享


275
00:16:55,949 --> 00:16:58,685
我们今年所取得的APNS开发新成果


276
00:16:58,752 --> 00:16:59,753
我们开始吧


277
00:17:01,555 --> 00:17:04,925
我们将介绍APNS的工作原理


278
00:17:05,058 --> 00:17:10,364
可能对iOS远程通知
或称APNS感到陌生


279
00:17:11,031 --> 00:17:13,800
然后我们将讨论新的提供者API


280
00:17:13,867 --> 00:17:16,670
它们是一些很不错的API
我很高兴将它们介绍给你们


281
00:17:17,871 --> 00:17:19,906
通过APNS发送的远程通知


282
00:17:19,973 --> 00:17:23,844
由四个相似的部分组成


283
00:17:23,911 --> 00:17:29,750
右下角是客户端APP运行在操作系统
左下角和左上角是APNS


284
00:17:30,717 --> 00:17:36,156
右上角是提供者
提供者负责发送远程通知


285
00:17:37,591 --> 00:17:39,927
这个流程启始于注册操作


286
00:17:39,993 --> 00:17:41,495
结束于客户端APP


287
00:17:42,162 --> 00:17:43,931
通过操作系统接收通知


288
00:17:45,232 --> 00:17:48,502
当执行此流程时操作系统通过APAN


289
00:17:48,569 --> 00:17:51,438
专门用于你的客户端APP的设备令牌


290
00:17:52,639 --> 00:17:54,308
这个令牌被返回给你的客户端APP


291
00:17:55,375 --> 00:17:59,079
然后你将它注册到提供者


292
00:17:59,213 --> 00:18:02,115
也就是你的服务器


293
00:18:02,416 --> 00:18:04,051
这个服务器负责发送远程通知


294
00:18:06,320 --> 00:18:09,857
提供者负责发送远程通知


295
00:18:09,923 --> 00:18:11,491
第一步工作是


296
00:18:11,692 --> 00:18:15,462
Apple开发站门户中注册你的主题


297
00:18:16,029 --> 00:18:18,699
并获得一个证书


298
00:18:18,932 --> 00:18:21,101
使你能够与APNS安全地对话


299
00:18:22,436 --> 00:18:23,804
在获得证书之后


300
00:18:24,238 --> 00:18:29,343
可建立与APNS间客户端SSL连接


301
00:18:29,643 --> 00:18:33,914
使用APNS
提供者API发送远程通知


302
00:18:35,682 --> 00:18:39,219
APNS提供的API是一种速度极快


303
00:18:39,353 --> 00:18:44,324
性能很强的服务器API其开销非常低


304
00:18:45,325 --> 00:18:47,427
你只需要使用一个连接


305
00:18:47,494 --> 00:18:49,730
就可以发送大量的推送通知


306
00:18:50,898 --> 00:18:52,165
要获得更高的吞吐量


307
00:18:52,232 --> 00:18:54,568
你可以创建多个APNS连接


308
00:18:57,604 --> 00:19:00,073
在完成通知发送之后 你可以保持连接


309
00:19:00,807 --> 00:19:02,109
并且可以重新使用连接


310
00:19:02,176 --> 00:19:04,578
APNS不会立即断开连接


311
00:19:05,612 --> 00:19:06,747
这样 你就不需要在以后


312
00:19:06,813 --> 00:19:08,448
花费资源重新建立连接


313
00:19:11,051 --> 00:19:13,320
如果连接有错误


314
00:19:13,620 --> 00:19:15,989
APNS将返回错误代码并关闭连接


315
00:19:16,557 --> 00:19:20,027
我们来看一些现有的API


316
00:19:21,361 --> 00:19:26,600
如果设备上卸载APP将会发生什么？


317
00:19:26,667 --> 00:19:28,268
如何发现已经


318
00:19:28,335 --> 00:19:30,170
已经停用的设备令牌？


319
00:19:31,171 --> 00:19:32,706
这时就需要使用反馈服务


320
00:19:34,007 --> 00:19:36,076
利用反馈服务


321
00:19:37,544 --> 00:19:40,781
可发现APP已经不再使用的设备令牌


322
00:19:40,848 --> 00:19:42,516
这样你就不会浪费资源


323
00:19:42,649 --> 00:19:45,552
来发送将会被丢弃的通知


324
00:19:47,788 --> 00:19:51,859
当你发送通知到设备令牌时


325
00:19:52,960 --> 00:19:54,561
此服务将会启动APNS将会发现


326
00:19:54,628 --> 00:19:56,630
不再使用的设备令牌


327
00:19:57,898 --> 00:20:00,167
并将它存储在APNS反馈服务之中


328
00:20:02,102 --> 00:20:05,339
提供者会定期调用APNS反馈服务


329
00:20:05,405 --> 00:20:07,407
发现无效的令牌


330
00:20:07,474 --> 00:20:08,642
并清理数据库


331
00:20:10,210 --> 00:20:14,014
这是反馈服务概览


332
00:20:15,916 --> 00:20:17,451
让我们来看未来的计划


333
00:20:17,818 --> 00:20:20,320
明年将会有大字节令牌


334
00:20:21,355 --> 00:20:23,457
现在的设备令牌是32字节


335
00:20:24,391 --> 00:20:28,862
明年，也就是2016年
它们将会增大到100字节


336
00:20:30,163 --> 00:20:32,999
如果你在考虑
在你的代码或你的服务器API中


337
00:20:33,066 --> 00:20:36,703
设定合适的设备令牌


338
00:20:37,237 --> 00:20:40,140
现在可以重新进行考虑


339
00:20:42,176 --> 00:20:44,711
大字节设备令牌将于2016年引入


340
00:20:46,713 --> 00:20:50,317
现在我们来
看提供者API和明年的工作计划


341
00:20:50,551 --> 00:20:51,952
先说说我们今年所做的工作


342
00:20:54,721 --> 00:20:57,057
我们推出了全新的提供者API


343
00:20:57,124 --> 00:20:58,725
你们肯定会喜欢


344
00:21:00,527 --> 00:21:05,465
这个新提供者API基于四个主要功能


345
00:21:08,168 --> 00:21:11,371
我们认为它会帮助你更可靠地发送通知


346
00:21:11,672 --> 00:21:16,310
而不会降低


347
00:21:17,678 --> 00:21:19,479
你的APP速度和效率


348
00:21:21,849 --> 00:21:27,487
新提供者API
的第一个功能是HTTP/2


349
00:21:29,323 --> 00:21:31,158
新提供者API...


350
00:21:35,996 --> 00:21:38,532
新提供者API基于


351
00:21:38,866 --> 00:21:41,969
全新的HTTP/2工业标准


352
00:21:43,704 --> 00:21:48,842
HTTP/2是广受欢迎的
HTTP协议的最新升级版本


353
00:21:49,843 --> 00:21:52,813
新提供者API以其为基础


354
00:21:54,314 --> 00:21:57,684
我们为什么选择将HTTP/2
作为新提供者API的基础呢？


355
00:21:57,951 --> 00:21:59,887
这对你们开发者有什么好处呢？


356
00:22:01,021 --> 00:22:04,124
我们认为
HTTP/2有三个主要的特性


357
00:22:04,191 --> 00:22:05,359
值得我们探讨


358
00:22:07,494 --> 00:22:09,930
首先它是一个请求响应


359
00:22:10,097 --> 00:22:11,031
这与HTTP一样


360
00:22:11,999 --> 00:22:15,869
从提供者发送至APNS的每个通知


361
00:22:16,603 --> 00:22:18,672
将会得到服务器的响应


362
00:22:20,908 --> 00:22:25,379
这类似于你正在使用的HTTP语义


363
00:22:25,746 --> 00:22:27,614
例如URI 标头


364
00:22:27,915 --> 00:22:30,350
响应代码等
你可以操作和处理它们


365
00:22:32,686 --> 00:22:36,423
我们认为这将帮助你
构建更可靠的提供者


366
00:22:37,057 --> 00:22:38,625
以发送推送通知


367
00:22:39,626 --> 00:22:41,261
因此它是一种请求响应机制


368
00:22:41,662 --> 00:22:45,032
其次HTTP/2是一种多路复用协议


369
00:22:45,899 --> 00:22:46,900
这一点很像


370
00:22:46,967 --> 00:22:49,136
现有的提供者协议


371
00:22:50,437 --> 00:22:52,172
因此速度不会降低


372
00:22:53,307 --> 00:22:55,776
HTTP/2多路复用意味着


373
00:22:55,843 --> 00:22:59,546
你可以通过单个连接


374
00:22:59,613 --> 00:23:01,048
同时发送多个请求至服务器


375
00:23:02,082 --> 00:23:03,717
因此你不会浪费资源


376
00:23:03,951 --> 00:23:06,420
为每个请求或类似任务设置新的连接


377
00:23:08,755 --> 00:23:12,626
每个多路复用请求响应被称为一个流


378
00:23:13,360 --> 00:23:15,662
然后我们会讲解它


379
00:23:17,030 --> 00:23:18,899
因此它是一种请求响应和多路复用机制


380
00:23:19,433 --> 00:23:22,236
HTTP/2第二个优点是 二进制的


381
00:23:23,036 --> 00:23:24,438
十分类似于我们现有的协议


382
00:23:25,772 --> 00:23:28,075
采用新的HTTP/2提供者API


383
00:23:28,742 --> 00:23:31,445
不会降低效率


384
00:23:32,646 --> 00:23:38,952
利用二进制通过网络传输的HTTP
数据帧不是HTTP文本而是二进制


385
00:23:39,686 --> 00:23:42,222
你还可以使用
其他一些有用的功能


386
00:23:42,289 --> 00:23:44,391
例如HPACK标头压缩


387
00:23:46,026 --> 00:23:47,594
这三个特性使得


388
00:23:47,661 --> 00:23:50,931
HTTP/2成为
新提供者API的理想选择


389
00:23:51,765 --> 00:23:54,735
除此这外还有其他一些好处


390
00:23:54,935 --> 00:23:57,237
例如已经成为工业标准等


391
00:23:57,504 --> 00:23:58,639
你可以使用


392
00:23:58,705 --> 00:24:02,409
HTTP/2的库和工具等资源


393
00:24:03,710 --> 00:24:08,115
总体来说我们这是一项十分不错的功能


394
00:24:09,583 --> 00:24:13,220
HTTP/2数据流提供者API


395
00:24:13,487 --> 00:24:17,658
与现有的数据流相似


396
00:24:18,091 --> 00:24:21,528
只是提供者与APNS
之间的连接协议是HTTP/2


397
00:24:21,828 --> 00:24:24,364
因此不需要修改
客户端APP和APP与操作系统或


398
00:24:24,431 --> 00:24:27,201
提供者之间的通信方式


399
00:24:27,434 --> 00:24:29,403
就可以使用这个新API
所有具有的好处


400
00:24:29,736 --> 00:24:33,407
你可以使用这个API并且立即受益


401
00:24:35,742 --> 00:24:37,678
让我们来探入这个流程


402
00:24:37,845 --> 00:24:40,380
第一步是建立


403
00:24:40,447 --> 00:24:43,450
提供者与APNS之间的连接


404
00:24:45,085 --> 00:24:46,553
当你建立连接时


405
00:24:46,620 --> 00:24:49,389
将会使用与你现有提供者API


406
00:24:49,523 --> 00:24:53,126
相同的客户端证书


407
00:24:54,695 --> 00:24:55,896
利用这个证书


408
00:24:55,963 --> 00:24:58,966
可以建立与APNS之间的


409
00:24:59,499 --> 00:25:03,570
客户端验证SSL连接建立连接之后


410
00:25:03,971 --> 00:25:07,541
HTTP/2开始交换设置帧


411
00:25:10,644 --> 00:25:13,313
设置帧含有一些详细信息


412
00:25:13,580 --> 00:25:16,250
例如可以通过此连接
发送的并发请求数量


413
00:25:16,783 --> 00:25:19,353
或标头表参数大小等


414
00:25:20,621 --> 00:25:22,523
当交换设置帧之后


415
00:25:22,723 --> 00:25:24,791
当你从提供者发送设置帧之后


416
00:25:25,092 --> 00:25:28,195
就可以开始发送通知数据


417
00:25:28,262 --> 00:25:29,530
和你的通知请求


418
00:25:31,698 --> 00:25:34,034
请我们来看看通知是如何工作的


419
00:25:36,236 --> 00:25:38,272
你发送给APNS的每个通知请求


420
00:25:38,338 --> 00:25:40,340
都是一个post请求


421
00:25:41,675 --> 00:25:44,411
这个post请求被提交给URI


422
00:25:44,645 --> 00:25:46,180
它包含设备令牌和


423
00:25:47,381 --> 00:25:52,352
JSON正文
类似于现在所使用的现有提供者API


424
00:25:53,253 --> 00:25:57,090
JSON负载被原封不动地发送至设备


425
00:26:00,360 --> 00:26:03,530
现在为了利用
HTTP/2多路复用的优点


426
00:26:04,364 --> 00:26:08,001
如果你想要发送多个请求 多个通知


427
00:26:09,102 --> 00:26:10,737
可通过同一个连接 发送所有通知


428
00:26:13,273 --> 00:26:14,708
这就是请求的工作原理


429
00:26:14,842 --> 00:26:16,476
那么系统如何响应请求呢？


430
00:26:19,146 --> 00:26:22,616
这个新提供者API响应请求


431
00:26:22,683 --> 00:26:24,818
如果一切正常 没有问题


432
00:26:25,219 --> 00:26:26,920
将会返回200状态


433
00:26:27,855 --> 00:26:28,856
整个流程一切顺利


434
00:26:28,922 --> 00:26:31,458
你可以继续发送通知


435
00:26:33,660 --> 00:26:34,995
如果发生失败呢？


436
00:26:35,062 --> 00:26:41,835
如果设备令牌错误APNS
不能处理你的消息 将会发生什么？


437
00:26:43,570 --> 00:26:45,072
系统将会返回400错误请求


438
00:26:45,973 --> 00:26:47,841
此请求的响应正文


439
00:26:47,941 --> 00:26:53,881
包含JSON内容
和请求失败原因信息


440
00:26:54,681 --> 00:26:58,752
它将提示设备令牌错误
将会保持连接状态


441
00:26:58,819 --> 00:27:00,521
你可以通过这个HTTP连接


442
00:27:00,587 --> 00:27:05,526
继续向服务器发送更多请求
其他一切正常


443
00:27:06,894 --> 00:27:08,629
请求响应的原理就是这样的


444
00:27:10,430 --> 00:27:12,399
现在我们可以通过一个例子


445
00:27:12,466 --> 00:27:17,404
来了解使用这个新提供者API的
请求响应是如何运作的


446
00:27:17,604 --> 00:27:22,075
如果还没见过HTTP/2请求响应


447
00:27:22,142 --> 00:27:24,378
你会发现它含有很多文本内容


448
00:27:24,444 --> 00:27:25,913
但是我会为你进行解释


449
00:27:26,914 --> 00:27:28,015
这是一个例子


450
00:27:29,383 --> 00:27:31,919
请注意 这是一个HTTP/2请求


451
00:27:32,386 --> 00:27:34,955
请求数据流中有两个帧


452
00:27:35,756 --> 00:27:37,357
第一个帧是标头帧


453
00:27:37,624 --> 00:27:39,426
第二个帧是数据帧


454
00:27:41,295 --> 00:27:45,532
标头帧含有Post方法或URI


455
00:27:45,933 --> 00:27:49,870
而URI含有APP指定的设备令牌


456
00:27:49,937 --> 00:27:52,372
你希望将通知发送给该设备


457
00:27:54,575 --> 00:27:57,244
标头帧还有可选参数


458
00:27:57,477 --> 00:28:01,849
例如有效期、ID和优先级等


459
00:28:06,286 --> 00:28:08,856
数据帧含有实际JSON有效内容


460
00:28:09,122 --> 00:28:11,525
你想要将这些内容发送给设备


461
00:28:12,192 --> 00:28:13,961
在本例中它是一个简单的文字提醒


462
00:28:14,027 --> 00:28:16,263
它的内容是hello HTTP/2


463
00:28:17,764 --> 00:28:19,132
这就是请求的工作原理


464
00:28:19,199 --> 00:28:21,235
让我们来看本例的请求是如何工作的


465
00:28:22,603 --> 00:28:25,839
在本例中响应一切正常
你获得200正常状态


466
00:28:26,139 --> 00:28:27,908
不需要做其他的事情 快速而又顺利


467
00:28:30,077 --> 00:28:33,013
如果发生故障 比如说设备令牌错误


468
00:28:34,948 --> 00:28:36,683
响应将会是这样的


469
00:28:37,351 --> 00:28:40,020
同样地 两个帧
一个标头帧和一个数据帧


470
00:28:41,321 --> 00:28:43,290
请注意状态现在是400


471
00:28:44,458 --> 00:28:46,927
正文是JSON有效内容


472
00:28:47,661 --> 00:28:50,030
含有请求失败原因


473
00:28:50,297 --> 00:28:51,932
在本例中失败原因是设备令牌错误


474
00:28:53,934 --> 00:28:56,203
因此你可以对此响应采取措施


475
00:28:56,270 --> 00:28:57,838
然后继续处理其它通知


476
00:29:00,374 --> 00:29:01,909
让我们来快速了解一下


477
00:29:02,342 --> 00:29:06,880
新HTTP/2请求响应提供者API


478
00:29:07,347 --> 00:29:09,716
它是这个新提供者API的第一项功能


479
00:29:12,953 --> 00:29:15,589
第二项功能是反馈


480
00:29:16,056 --> 00:29:17,257
那么 反馈是什么呢？


481
00:29:18,525 --> 00:29:19,826
利用新提供者API


482
00:29:20,227 --> 00:29:21,995
我们引入即时反馈功能


483
00:29:23,330 --> 00:29:25,966
利用即时反馈功能你不需要


484
00:29:26,033 --> 00:29:29,636
与单独的反馈服务通信
来获得你的APP


485
00:29:29,870 --> 00:29:31,905
已不再使用的设备令牌


486
00:29:33,340 --> 00:29:35,776
你可以通过响应消息


487
00:29:35,843 --> 00:29:37,611
立即获得它们


488
00:29:38,846 --> 00:29:41,315
让我们回到反馈服务数据流


489
00:29:43,183 --> 00:29:46,887
不同于定时轮询APNS反馈服务


490
00:29:46,954 --> 00:29:47,788
和轮询提供者


491
00:29:49,623 --> 00:29:53,393
现在你可以从响应消息中获得反馈


492
00:29:55,429 --> 00:29:57,631
对于反馈响应消息中的


493
00:29:58,298 --> 00:30:03,203
HTTP状态代码是410
410的含义是不再使用


494
00:30:03,403 --> 00:30:06,907
即你的APP已经
不再使用此设备令牌


495
00:30:08,809 --> 00:30:10,477
除了表示设备令牌已停用


496
00:30:10,544 --> 00:30:12,646
的状态代码之外


497
00:30:13,580 --> 00:30:18,752
你可以还可以获得
APNS最近一次知道


498
00:30:19,052 --> 00:30:21,622
设备令牌被你的APP停用的时间标记


499
00:30:22,623 --> 00:30:24,591
让我们来看一个例子


500
00:30:24,992 --> 00:30:26,593
你发送一个通知


501
00:30:26,660 --> 00:30:27,561
你发送一个请求


502
00:30:29,296 --> 00:30:32,099
但发现设备令牌已经被你的APP停用


503
00:30:32,432 --> 00:30:33,767
因此你可以清空它


504
00:30:33,834 --> 00:30:35,569
不再向它发送通知


505
00:30:36,770 --> 00:30:38,539
响应消息可能是这样的


506
00:30:38,872 --> 00:30:43,377
注意这里有状态代码
410和时间标记


507
00:30:43,477 --> 00:30:46,146
这是APNS最近一次确认


508
00:30:46,446 --> 00:30:49,850
设备令牌被你的APP停用


509
00:30:52,819 --> 00:30:56,623
这就是HTTP/2提供者API
和即时反馈的原理


510
00:30:58,859 --> 00:31:02,796
这个新提供者API的
第三个特性是简化了证书处理


511
00:31:04,798 --> 00:31:07,401
我们知道 如果你想要开发
具有丰富功能的APP


512
00:31:08,368 --> 00:31:11,338
在开发和生产阶段


513
00:31:11,538 --> 00:31:14,041
你需要创建许多证书


514
00:31:16,443 --> 00:31:17,811
我们简化证书处理...


515
00:31:20,080 --> 00:31:23,083
在介绍简化证书处理之前
我们来看一下


516
00:31:23,150 --> 00:31:24,751
你需要处理的证书例子


517
00:31:25,419 --> 00:31:27,387
根据你的APP的性能


518
00:31:27,454 --> 00:31:31,091
你可能需要一个证书来用于VOIP


519
00:31:33,193 --> 00:31:37,965
一个证书用于手表附加信息
如果你使用


520
00:31:38,031 --> 00:31:40,100
开发和生产环境


521
00:31:40,501 --> 00:31:43,570
这些功能可能各需要一个证书


522
00:31:45,672 --> 00:31:47,274
利用简化的证书处理


523
00:31:47,908 --> 00:31:52,980
你只需要
为你的应用创建一个证书就可以了


524
00:32:01,088 --> 00:32:02,022
这很不错


525
00:32:04,858 --> 00:32:08,862
因此HTTP/2提供者API
即时反馈


526
00:32:09,730 --> 00:32:11,231
和简化证书处理


527
00:32:11,698 --> 00:32:14,134
是新提供者API的新特性


528
00:32:15,836 --> 00:32:21,842
去年我们将
推送通知内容容量从256B


529
00:32:22,242 --> 00:32:24,211
增大到2KB 受到广泛好评


530
00:32:26,480 --> 00:32:30,117
今年我们会将它增大到4KB


531
00:32:35,789 --> 00:32:40,727
4KBKB限制将适用于
所有版本的iOS 和OS X


532
00:32:41,228 --> 00:32:46,400
因此它并不是iOS 9或
OS X El Capitan专用


533
00:32:48,468 --> 00:32:52,005
它将成为新提供者API的一部分


534
00:32:53,740 --> 00:32:55,409
这就是新提供者API的特性


535
00:32:55,642 --> 00:33:00,080
总结来说现在我们有新的
请求响应机制、HTTP/2接口


536
00:33:02,249 --> 00:33:03,917
还有即时反馈功能


537
00:33:03,984 --> 00:33:05,919
让你知道已经被停用的设备令牌


538
00:33:07,754 --> 00:33:09,156
还有简化证书处理


539
00:33:09,356 --> 00:33:14,528
让你的所有主题的推送通知
只需要一个证书即可


540
00:33:16,196 --> 00:33:17,998
还有新的4KB通知内容限制


541
00:33:20,567 --> 00:33:22,202
今年夏天新提供者API


542
00:33:23,070 --> 00:33:27,040
将可以在APNS部署环境中使用


543
00:33:28,108 --> 00:33:31,044
今年晚些时候
我们将会把它引入生产环境


544
00:33:32,646 --> 00:33:34,481
与前一样新提供API


545
00:33:34,681 --> 00:33:40,120
可用于发送通知到
所有版本的iOS和OS X


546
00:33:41,121 --> 00:33:43,223
你们不用创建任何专用逻辑


547
00:33:43,290 --> 00:33:44,391
来确保版本兼容性


548
00:33:46,260 --> 00:33:47,761
关于新提供者API就是这些


549
00:33:49,897 --> 00:33:52,199
如果想更详细了解Michele关于


550
00:33:52,299 --> 00:33:54,701
iOS通知和APNS的技术讲座


551
00:33:55,435 --> 00:33:58,372
请参考APNS开发者文档


552
00:33:59,339 --> 00:34:02,009
新提供者API文档
将于今年晚些时候发布


553
00:34:04,144 --> 00:34:07,181
你也可以访问技术支持和开发者论坛


554
00:34:07,748 --> 00:34:10,050
请将你的咨询问题发送给我们的


555
00:34:10,117 --> 00:34:11,351
主要技术讲师Paul


556
00:34:13,754 --> 00:34:15,889
有一些相关的讲座 你可能会感兴趣


557
00:34:16,556 --> 00:34:18,792
特别是关于ClockKit和
Watch


558
00:34:18,859 --> 00:34:21,562
connectivity
还有Michel进行的一些演示


559
00:34:22,563 --> 00:34:26,934
NSURL网络通信讲座
更详细地讨论了HTTP/2


560
00:34:27,835 --> 00:34:29,770
非常感谢 晚安

