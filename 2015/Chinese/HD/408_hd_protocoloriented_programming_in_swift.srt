1
00:00:20,120 --> 00:00:25,392
面向协议 编程序Swift


2
00:00:34,234 --> 00:00:39,473
大家好 我叫戴夫·亞伯拉罕
我是Swift标准库的技术主管


3
00:00:39,540 --> 00:00:44,144
今天站在这里同你们一起是我的荣幸


4
00:00:44,678 --> 00:00:46,113
很高兴看到房间里的你们


5
00:00:47,548 --> 00:00:49,283
接下来的40分钟请


6
00:00:49,983 --> 00:00:53,320
丢掉你们通常思考编程的方式


7
00:00:55,122 --> 00:00:58,659
我们接下来要一起做的事情不一定容易


8
00:00:58,725 --> 00:01:02,162
但我向你们保证如果你们跟着
我的思路这一定是值得的


9
00:01:04,331 --> 00:01:06,400
我现在来和你们谈一谈


10
00:01:06,733 --> 00:01:11,705
Swift设计核心的主题
并介绍一种编程方式


11
00:01:11,905 --> 00:01:13,607
这种编程方式有可能改变一切


12
00:01:15,075 --> 00:01:17,845
但首先请允许我先向你们
介绍我的一位朋友


13
00:01:20,581 --> 00:01:21,748
他是 Crusty


14
00:01:23,483 --> 00:01:26,286
现在可能你们每个人
都正在使用这个家伙的某一个版本


15
00:01:26,453 --> 00:01:29,256
Crusty是个老式的程序员


16
00:01:29,723 --> 00:01:34,761
他不相信调试器不使用集成开发环境


17
00:01:35,028 --> 00:01:37,564
不 他喜欢 80x24的终端窗口


18
00:01:37,631 --> 00:01:39,366
和纯文本 非常感谢


19
00:01:42,736 --> 00:01:45,506
他对最近的编程时尚不以为然


20
00:01:46,773 --> 00:01:49,309
现在我已经学会期待 Crusty 


21
00:01:49,376 --> 00:01:51,979
有点愤世嫉俗脾气古怪


22
00:01:52,446 --> 00:01:55,382
但是即便如此有时仍会令我惊讶


23
00:01:55,883 --> 00:01:59,253
比如上个月我们正在讨论应用开发


24
00:01:59,753 --> 00:02:03,090
他坦率地说“我不做面向对象”


25
00:02:05,158 --> 00:02:06,627
我不敢相信我的耳朵


26
00:02:07,060 --> 00:02:09,830
我的意思是面向对象程序设计


27
00:02:09,896 --> 00:02:11,298
大约起源于20世纪70年代


28
00:02:11,865 --> 00:02:15,269
所以它并不能算是新奇的编程时尚


29
00:02:15,769 --> 00:02:22,242
此外我们一起构建的
很多神奇的东西 我 你 还有那些


30
00:02:22,876 --> 00:02:26,947
我们所站在其肩膀上的工程师们
都由对象构建而成


31
00:02:28,949 --> 00:02:31,952
“来吧”我边走向他的老式黑板边说


32
00:02:32,286 --> 00:02:35,489
“面向对象程序设计棒极了
看看你可以使用类做些什么”


33
00:02:41,161 --> 00:02:41,995
是的


34
00:02:43,697 --> 00:02:47,234
所以首先你可以把
相关数据和操作进行分组


35
00:02:48,202 --> 00:02:53,207
然后就可以建造墙壁将我们的代码内外


36
00:02:53,607 --> 00:02:56,076
分开这样就可以使我们保持不变量


37
00:02:58,879 --> 00:03:05,118
然后我们使用类来
表达相关想法如窗口或通信信道


38
00:03:07,988 --> 00:03:12,326
它们给我们一个命名空间用于帮助
避免随着软件扩展所带来的冲突


39
00:03:15,796 --> 00:03:18,031
它们有惊人的表达语法


40
00:03:18,332 --> 00:03:22,769
所以我们可以写方法调用和属性
并把它们链接起来


41
00:03:23,003 --> 00:03:24,304
我们可以做下标


42
00:03:25,339 --> 00:03:27,741
我们甚至可以做属性用于计算


43
00:03:30,244 --> 00:03:32,946
最后类的扩展性是开放的


44
00:03:33,280 --> 00:03:36,149
所以如果类作者遗漏了
一些我需要用到的东西


45
00:03:36,483 --> 00:03:38,085
我可以继续向前并在后续将其添加上


46
00:03:39,019 --> 00:03:41,588
此外这些事物一起


47
00:03:42,990 --> 00:03:44,725
这些事物使我们能够管理复杂的事物


48
00:03:45,392 --> 00:03:47,561
而这正是程序设计中最主要的挑战


49
00:03:49,496 --> 00:03:54,301
这些属性它们直接解决了
我们正在努力解决的软件开发中的问题


50
00:03:55,702 --> 00:03:57,838
在这一点上我自己颇受启发


51
00:03:58,172 --> 00:04:02,409
然而 Crusty
只是哼了一声叹了口气


52
00:04:05,812 --> 00:04:07,214
他让我十分泄气


53
00:04:09,516 --> 00:04:12,753
如果这还不够糟糕的话
片刻之后他完成了这个句子


54
00:04:15,389 --> 00:04:17,357
因为这是真的在Swift


55
00:04:17,891 --> 00:04:21,195
任何一种你可以说出的
类型都是一等公民


56
00:04:21,562 --> 00:04:24,898
它能够利用所有这些功能


57
00:04:26,800 --> 00:04:28,335
所以我后退了一步并试图


58
00:04:29,002 --> 00:04:34,875
找出使我们完成的所有事情运行的
核心功能在面向对象程序设计中


59
00:04:36,777 --> 00:04:42,382
很显然它一定是来自于只能用
类来处理的某些事物


60
00:04:42,716 --> 00:04:44,084
比如继承


61
00:04:46,253 --> 00:04:48,021
这让我特别考虑


62
00:04:48,088 --> 00:04:51,491
这些结构是如何做到代码共享


63
00:04:51,825 --> 00:04:53,393
及细密定制的


64
00:04:54,761 --> 00:04:58,565
因此，举个例子一个超类可以定义
一个实质的具有复杂逻辑的方法


65
00:04:58,632 --> 00:05:03,470
而子类无偿得到超类已完成的所有工作


66
00:05:04,938 --> 00:05:06,039
它们只是继承了这些内容


67
00:05:07,207 --> 00:05:10,911
但真正不可思议的事
发生在当超类的作者


68
00:05:10,978 --> 00:05:12,980
把这个操作的一小部分断为


69
00:05:13,413 --> 00:05:15,282
独立的定制点


70
00:05:17,651 --> 00:05:18,952
这些定制点可被子类覆盖


71
00:05:20,087 --> 00:05:23,690
且这种定制被覆盖在继承的实现上


72
00:05:25,559 --> 00:05:27,060
这使得困难的逻辑


73
00:05:27,127 --> 00:05:31,798
在具备开放的灵活性
和特殊变化的同时可被重新使用


74
00:05:32,099 --> 00:05:33,800
现在我确信我可以说服他


75
00:05:34,401 --> 00:05:35,936
“哈”我对 Crusty 说


76
00:05:36,170 --> 00:05:39,673
“很显然现在你不得不
臣服于类的力量了”


77
00:05:42,976 --> 00:05:45,412
“再坚持该死的一分钟”他回答说


78
00:05:46,180 --> 00:05:50,350
“首先我用你一直说的结构做定制


79
00:05:51,084 --> 00:05:55,055
其次 对 类是很厉害
但让我们来谈一谈用类所需要的代价


80
00:06:00,427 --> 00:06:04,565
我已经有三个重要的
关于类的牢骚”Crusty 说


81
00:06:05,632 --> 00:06:07,367
然后他从列表上开始了抱怨


82
00:06:08,769 --> 00:06:10,537
“首先你有了你的自动共享”


83
00:06:11,638 --> 00:06:13,106
现在你们都知道这是什么样子的


84
00:06:14,174 --> 00:06:18,178
A传递给B一些看起来完全清晰的数据


85
00:06:20,013 --> 00:06:21,882
然后B想“好 会话结束”


86
00:06:22,983 --> 00:06:25,886
但现在我们有一种情形


87
00:06:26,286 --> 00:06:32,359
A和B都有他们自己非常合理的世界观
而这恰好是错误的


88
00:06:33,994 --> 00:06:39,466
因为现实是这样的 最终A厌恶了


89
00:06:39,533 --> 00:06:42,069
严肃的数据取而代之喜欢小马


90
00:06:42,936 --> 00:06:44,137
谁不喜欢一匹好的小马？


91
00:06:46,440 --> 00:06:50,911
一切都很好直到B之后发现了这些数据


92
00:06:51,044 --> 00:06:53,113
很久之后她从A那里得到


93
00:06:54,014 --> 00:06:55,415
且已有一个令人吃惊的变化


94
00:06:57,284 --> 00:06:59,353
B 想要的是她的数据
而不是 A 的小马


95
00:07:01,054 --> 00:07:03,824
好 Crusty 激昂地讲着
这是如何结束的


96
00:07:06,460 --> 00:07:09,296
“首先”他说“你开始疯狂地复制一切


97
00:07:09,363 --> 00:07:10,864
镇压你代码中的错误


98
00:07:11,131 --> 00:07:12,833
但现在你现在做了太多的副本


99
00:07:13,300 --> 00:07:14,701
而这拖慢了代码的运行速度


100
00:07:15,068 --> 00:07:17,571
然后有一天你正在处理
某个调度队列中的事情


101
00:07:17,838 --> 00:07:19,873
突然你进入了一种紊乱状态下


102
00:07:20,107 --> 00:07:21,975
因为线程正在共享可变状态


103
00:07:22,442 --> 00:07:25,312
所以你开始添加锁以保护不变量


104
00:07:26,180 --> 00:07:28,382
但是这些锁更加拖延了代码的运行速度


105
00:07:28,682 --> 00:07:30,083
甚至可能导致死锁


106
00:07:30,350 --> 00:07:32,286
所有的这些都在增加复杂度


107
00:07:32,586 --> 00:07:36,290
其结果可总结为一个词 故障”


108
00:07:39,259 --> 00:07:41,595
不过这些对于Cocoa的
程序员来说都不是新闻


109
00:07:50,304 --> 00:07:54,041
这不是新闻这些年我们已经
在应用一种语言特征的组合


110
00:07:54,107 --> 00:07:56,910
像@property(copy)和编码约定


111
00:07:56,977 --> 00:07:58,879
来解决这个问题


112
00:08:01,114 --> 00:08:02,216
而我们仍然被咬


113
00:08:03,183 --> 00:08:04,418
举个例子


114
00:08:05,118 --> 00:08:07,321
在Cocoa文件中有这样一个警告


115
00:08:07,521 --> 00:08:10,791
关于修改一个可变集合
在你通过它进行迭代时


116
00:08:12,092 --> 00:08:16,330
对吧 所有这些都是由


117
00:08:16,430 --> 00:08:19,600
从类中继承的可变状态的
隐式共享导致的


118
00:08:21,468 --> 00:08:23,470
但这并不适用于Swift


119
00:08:25,272 --> 00:08:30,878
为什么不适用呢？
这是因为Swift集合都是数值类型


120
00:08:31,512 --> 00:08:32,679
所以你正在迭代的这些


121
00:08:32,746 --> 00:08:34,481
和你正在修改的这些是截然不同的


122
00:08:36,616 --> 00:08:39,385
好 Crusty 列表上的第二条


123
00:08:40,554 --> 00:08:42,222
类继承太具有侵入性


124
00:08:44,157 --> 00:08:48,795
首先 它太庞大你有且仅有一个超类


125
00:08:49,897 --> 00:08:52,232
那么假使你需要塑造
多个抽象将会怎样？


126
00:08:52,699 --> 00:08:56,103
可以是一个集合并序列化吗？


127
00:08:57,137 --> 00:08:59,973
当然 除非集合和序列化是类


128
00:09:01,508 --> 00:09:04,211
因为类继承是单继承


129
00:09:04,745 --> 00:09:08,715
类变得臃肿随着所有
相关的事情被放在一起


130
00:09:09,349 --> 00:09:14,922
你也不得不选择超类在你定义类时
而非在后续某些扩展时


131
00:09:16,790 --> 00:09:20,027
其次如果超类存储了属性


132
00:09:22,596 --> 00:09:23,463
你必须接受它们


133
00:09:24,531 --> 00:09:25,399
并且别无选择


134
00:09:26,733 --> 00:09:29,736
然后因为它存储了属性


135
00:09:30,337 --> 00:09:31,271
你必须将其初始化


136
00:09:32,506 --> 00:09:36,009
然后就像 Crusty 所说
“指定便利是必须的 噢天哪”


137
00:09:37,578 --> 00:09:39,713
因此你又必须确信你理解如何


138
00:09:39,780 --> 00:09:43,383
与超类相互作用而不破坏它的常量


139
00:09:44,218 --> 00:09:48,856
对吗 最后对于类作者来说这很自然


140
00:09:49,523 --> 00:09:53,627
写代码就好像他们知道他们的方法


141
00:09:54,862 --> 00:10:00,501
将会做些什么 不用对
方法可能被覆盖负责任


142
00:10:02,402 --> 00:10:06,573
因此经常有至关紧要却有不成文的约定


143
00:10:06,874 --> 00:10:08,709
关于哪些实际是允许


144
00:10:08,775 --> 00:10:13,480
覆盖的以及比如你是否需要
链接到超类方法


145
00:10:13,747 --> 00:10:16,016
如果你要链接到超类方法


146
00:10:16,316 --> 00:10:19,019
那么位置是在方法的开头还是在结尾
抑或是在中间的某处呢


147
00:10:23,624 --> 00:10:26,693
所以，再一次对于Cocoa的
程序设计员来说仍然不是新闻 对吗


148
00:10:26,994 --> 00:10:30,464
这就是为什么我们到处使用
委托模式在Cocoa


149
00:10:33,033 --> 00:10:35,335
好 Crusty 列表上的最后一条


150
00:10:36,803 --> 00:10:42,776
类被证明完全不适合于
类型关系很重要的问题


151
00:10:44,611 --> 00:10:46,880
所以如果你曾经尝试过使用类


152
00:10:47,214 --> 00:10:51,752
来表达一个对称操作
比如比较你知道我的意思


153
00:10:53,020 --> 00:10:56,857
举个例子假设你打算写通用分类


154
00:10:56,924 --> 00:11:00,327
或二进位检索类似这样
你需要一种方法来比较两个元素


155
00:11:00,928 --> 00:11:03,664
使用类你最终得到像这样的一些结果


156
00:11:05,566 --> 00:11:08,602
当然你不能用这种
方法只写Ordered


157
00:11:08,969 --> 00:11:11,371
因为Swift会预先要求方法体


158
00:11:13,707 --> 00:11:14,908
那么我们可以放些什么呢？


159
00:11:16,143 --> 00:11:20,347
请记得我们对于Ordered
的任意示例还一无所知


160
00:11:21,715 --> 00:11:24,318
所以如果这个方法没有由子类实现


161
00:11:25,352 --> 00:11:27,688
那么除了陷阱我们什么都做不了


162
00:11:29,857 --> 00:11:33,493
现在这是表明我们可以
对抗类型系统的第一个迹象


163
00:11:35,095 --> 00:11:36,463
如果我们没有认识到这一点


164
00:11:36,930 --> 00:11:38,932
这也是我们欺骗自己的开始


165
00:11:40,734 --> 00:11:43,136
因为我们对这个问题置之不理告诉自己


166
00:11:43,203 --> 00:11:45,038
只要每个Ordered子类


167
00:11:45,105 --> 00:11:47,307
预先执行一切都会好的


168
00:11:48,809 --> 00:11:51,445
对吗？让它成为子类的问题


169
00:11:52,779 --> 00:11:55,883
如此我们继续进行
执行Ordered的一个例子


170
00:11:57,951 --> 00:11:59,019
所以这就是子类


171
00:11:59,386 --> 00:12:01,121
它得到一个双精度类型值


172
00:12:01,455 --> 00:12:04,925
我们覆盖优先来做比较


173
00:12:06,927 --> 00:12:08,529
当然除去它不起作用的情况


174
00:12:11,231 --> 00:12:14,067
看“其它”只是某些任意的
Ordered


175
00:12:14,434 --> 00:12:16,970
不是一个数字因此我们不知道


176
00:12:17,037 --> 00:12:19,806
“其他”有数值属性


177
00:12:20,440 --> 00:12:22,543
事实上它可能是个标签


178
00:12:23,143 --> 00:12:24,311
具有文本属性


179
00:12:26,013 --> 00:12:28,215
所以现在我们需要向
下转型以得到正确的类型


180
00:12:30,984 --> 00:12:34,121
但是等一下假设“其它”
结果是一个标签？


181
00:12:35,989 --> 00:12:36,990
现在我们将要陷阱


182
00:12:39,059 --> 00:12:42,930
对吗 所以这听起来很像


183
00:12:43,030 --> 00:12:47,267
我们在预先写方法体时
遇到的问题在超类中


184
00:12:49,937 --> 00:12:52,272
并且我们现在没有比之前更好的答案


185
00:12:53,674 --> 00:12:55,242
这是静态类型安全漏洞


186
00:12:56,643 --> 00:12:57,878
它为什么会发生？


187
00:12:58,745 --> 00:13:02,282
这是因为类不让我们表达
这种至关紧要的类型关系


188
00:13:02,349 --> 00:13:05,853
自身的类型和其他的类型之间的关系


189
00:13:07,688 --> 00:13:09,590
事实上你可以把这个用作
“代码异味”


190
00:13:10,591 --> 00:13:13,794
所以任何时候你在
代码中看到强制的向下转型


191
00:13:14,561 --> 00:13:17,998
这很好地象征了有些重要的
类型关系已经丢失


192
00:13:18,632 --> 00:13:21,535
而这通常是由于抽象类的使用所造成的


193
00:13:23,904 --> 00:13:28,675
好 显然我们需要的是更好的抽象机制


194
00:13:30,711 --> 00:13:33,614
不强制我们接受隐式共享


195
00:13:34,147 --> 00:13:35,983
不丢失类型关系


196
00:13:36,750 --> 00:13:39,586
不强制我们只选择一种抽象且


197
00:13:39,653 --> 00:13:41,321
在定义类型时进行选择


198
00:13:42,456 --> 00:13:45,626
不强制我们接受不想要的实例数据


199
00:13:46,193 --> 00:13:48,862
以及相关的初始化复杂度


200
00:13:51,398 --> 00:13:55,335
最后不会留下模棱两可
关于需要覆盖什么


201
00:13:57,304 --> 00:13:58,705
当然我正在讲述的便是协议


202
00:13:59,940 --> 00:14:03,544
协议有所有这些优势这就是为什么


203
00:14:03,777 --> 00:14:07,981
我们创造Swift时也就是我们创造
第一个面向协议的程序设计语言


204
00:14:17,791 --> 00:14:21,195
是的 Swift是很棒的
面向对象程序设计


205
00:14:21,762 --> 00:14:25,399
但从循环和字符串的工作方式


206
00:14:25,799 --> 00:14:28,502
到泛型标准库的重点


207
00:14:28,936 --> 00:14:31,238
其核心Swift是面向协议的


208
00:14:33,040 --> 00:14:34,608
希望到你离开时


209
00:14:35,042 --> 00:14:36,977
你可以更加面向协议


210
00:14:40,447 --> 00:14:42,182
所以为使你迈出右脚开始


211
00:14:42,616 --> 00:14:43,917
我们在Swift有一种说法


212
00:14:44,451 --> 00:14:45,552
不要从类开始


213
00:14:46,086 --> 00:14:47,254
而要从协议开始


214
00:14:48,856 --> 00:14:50,424
那么让我们来做一下上一个例子


215
00:14:53,393 --> 00:14:58,165
好 首先我们需要一个协议
Swift马上会说


216
00:14:58,332 --> 00:15:00,200
我们不可以在这儿放方法体


217
00:15:01,468 --> 00:15:03,437
而这实际上是很好的因为这意味着


218
00:15:03,504 --> 00:15:07,541
我们要以动态运行时间检查换


219
00:15:08,041 --> 00:15:09,076
静态检查


220
00:15:10,577 --> 00:15:12,412
对 在完成时预先执行


221
00:15:15,282 --> 00:15:20,487
好 接下来它会说我们
没有覆盖任何东西


222
00:15:21,388 --> 00:15:22,222
当然我们没有


223
00:15:22,689 --> 00:15:24,558
我们不再有基类 对吗


224
00:15:24,658 --> 00:15:26,059
没有超类 没有覆盖


225
00:15:27,461 --> 00:15:29,696
我们可能根本不希望数字首先是类


226
00:15:29,763 --> 00:15:31,832
因为我们希望它像数字一样操作


227
00:15:32,699 --> 00:15:37,571
对吗 那么让我们马上来做
两件事情把这做成一个结构


228
00:15:39,940 --> 00:15:43,043
好 我想在这儿暂停一下


229
00:15:43,110 --> 00:15:46,046
欣赏一下我们现在来到何处
因为这又是完全有效的代码了


230
00:15:48,081 --> 00:15:51,051
好 协议正完全扮演着相同的角色


231
00:15:51,585 --> 00:15:55,556
就像在我们这个例子的
第一个版本中类的角色一样


232
00:15:56,223 --> 00:15:57,491
这绝对更好


233
00:15:57,658 --> 00:16:00,294
我的意思是我们不再有那致命的错误


234
00:16:01,328 --> 00:16:04,164
但是我们没有定位潜在的
静态类型安全漏洞


235
00:16:04,798 --> 00:16:07,100
因为我们仍然需要强制的向下转型


236
00:16:07,601 --> 00:16:10,838
因为“其他”仍然是
某些任意的Ordered


237
00:16:12,606 --> 00:16:16,643
那么让我们用数字替代丢掉类型转换


238
00:16:19,346 --> 00:16:22,416
现在Swift要说签名不匹配


239
00:16:25,452 --> 00:16:30,324
为解决这个问题 我们需要在协议签名
中用Self来替代Ordered


240
00:16:33,126 --> 00:16:34,661
我们称之为Self要求


241
00:16:35,729 --> 00:16:39,132
因此当你在协议中看到Self


242
00:16:39,433 --> 00:16:42,736
它是类型的占位符用来符合
那个协议模型类型


243
00:16:45,005 --> 00:16:46,573
如此现在我们又有了有效的代码了


244
00:16:47,641 --> 00:16:49,843
现在让我们看一下如何使用协议


245
00:16:53,580 --> 00:16:57,584
所以这是二进位检索


246
00:16:58,919 --> 00:17:03,223
它也能够完美运行在我们向
Ordered加入Self要求之前


247
00:17:04,724 --> 00:17:08,795
这里的Ordered数组是一个声明


248
00:17:10,163 --> 00:17:14,268
声明我们要处理
Ordered类型的异构数组


249
00:17:14,734 --> 00:17:18,638
因此这个数组可以混合包含数字


250
00:17:19,138 --> 00:17:21,141
与标签 对吧


251
00:17:23,010 --> 00:17:26,146
由于我们对
Ordered做了这个改变


252
00:17:26,213 --> 00:17:28,482
向其添加了Self需求编译器将


253
00:17:28,549 --> 00:17:33,754
强制将其变为同构的 像这样


254
00:17:35,923 --> 00:17:41,662
这个人说“我在使用任意一个
Ordered类型T的同构数组”


255
00:17:43,864 --> 00:17:45,666
现在你可能会想强制使数组


256
00:17:45,732 --> 00:17:48,702
成为同构数组这太限制了 


257
00:17:48,769 --> 00:17:51,939
或者有些失去了泛函性或灵活性或其他


258
00:17:52,339 --> 00:17:53,407
但是如果你想一下


259
00:17:54,041 --> 00:17:56,310
原始的签名真的是个谎言


260
00:17:56,910 --> 00:18:00,981
我们从没真正处理过异构情况
除了通过陷阱的方式


261
00:18:01,515 --> 00:18:05,485
对吧 同构数组正是我们要的


262
00:18:08,589 --> 00:18:11,725
那么一旦你在协议中添加Self要求


263
00:18:12,192 --> 00:18:15,462
这将使协议进入一个非常不同的世界


264
00:18:16,230 --> 00:18:21,134
在这里功能中大大减少了类的重复


265
00:18:22,703 --> 00:18:24,638
它不再作为类型使用


266
00:18:26,073 --> 00:18:30,444
集合从异构变为同构


267
00:18:32,012 --> 00:18:37,951
实例之间的相互作用不再意味着
所有模型类型之间的相互作用


268
00:18:40,020 --> 00:18:43,323
我们以动多态换静多态


269
00:18:43,891 --> 00:18:47,060
但是作为我们传递给
编译器的额外的类型信息的回报


270
00:18:47,127 --> 00:18:49,029
这样更具可优化性


271
00:18:50,697 --> 00:18:52,165
所以 两个世界


272
00:18:54,101 --> 00:18:56,236
在后续的演讲中我将向你们演示如何


273
00:18:56,303 --> 00:18:58,272
在两者之间搭桥至少一种方式


274
00:18:59,606 --> 00:19:01,074
好


275
00:19:02,442 --> 00:19:07,247
我理解了协议静态方面的工作原理


276
00:19:07,314 --> 00:19:11,585
但我还不确定是否
要相信Crusty


277
00:19:11,652 --> 00:19:14,421
协议真的可以取代类


278
00:19:14,855 --> 00:19:18,492
所以我给他设了一个挑战


279
00:19:19,092 --> 00:19:22,496
构建我们通常使用面向
对象程序设计的事物但是要用协议


280
00:19:24,965 --> 00:19:26,567
我脑海中浮现一个小的图表应用


281
00:19:26,834 --> 00:19:31,772
你可以在绘图界面拖拽落成形状
然后可以与它们交互


282
00:19:32,806 --> 00:19:36,310
所以我让 Crusty 
构建文档并显示模型


283
00:19:37,344 --> 00:19:38,345
这是他想出来的


284
00:19:41,281 --> 00:19:43,016
首先他构建了一些基本绘图


285
00:19:43,650 --> 00:19:44,852
现在你可以想象


286
00:19:44,918 --> 00:19:46,620
Crusty并不是在做图形用户界面


287
00:19:46,920 --> 00:19:47,988
相较而言他更倾向文本


288
00:19:48,989 --> 00:19:52,626
他的基本绘图只是
输出了你提出的绘图命令 对吗？


289
00:19:53,126 --> 00:19:56,330
我不情愿地承认了这很可能足以


290
00:19:56,396 --> 00:20:01,435
证明他的观点
然后他新建了Drawable协议


291
00:20:01,835 --> 00:20:05,873
为我们的所有绘图元素提供通用接口


292
00:20:06,840 --> 00:20:08,242
好 这很简单了


293
00:20:09,610 --> 00:20:12,279
然后他开始创建形状比如多边形


294
00:20:14,114 --> 00:20:17,484
现在这里需要注意的第一件事
关于多边形这是一个数值类型


295
00:20:18,218 --> 00:20:19,786
由其他数值类型创建而成


296
00:20:20,487 --> 00:20:23,056
这是一个包含多点数组的结构


297
00:20:24,191 --> 00:20:27,761
为了画一个多边形
我们来到最后一个拐角


298
00:20:28,195 --> 00:20:30,931
然后我们在所有交角处重复循环 画线


299
00:20:32,966 --> 00:20:33,834
好 下面是圆


300
00:20:35,335 --> 00:20:38,639
同样的圆也是一个数值类型
由其他数值类型创建而成


301
00:20:38,705 --> 00:20:42,042
它是包含中心和半径的结构


302
00:20:43,310 --> 00:20:46,513
现在为了画一个圆


303
00:20:46,613 --> 00:20:48,215
我们从0到2π弧度拽出一个弧形


304
00:20:51,818 --> 00:20:55,822
那么现在我们就可以
通过圆和多边形来创建图表了


305
00:20:59,092 --> 00:21:01,361
“好的” Crusty 说
“我们来将她做个旋转”


306
00:21:05,365 --> 00:21:06,200
他这么做了


307
00:21:07,568 --> 00:21:08,402
接下来就是图表


308
00:21:10,003 --> 00:21:13,207
图表就是一个Drawable类
这是另一个数值类型


309
00:21:14,241 --> 00:21:17,044
它为什么是数值类型呢？这是因为所有
Drawable类都是数值类型


310
00:21:17,110 --> 00:21:19,479
因此Drawable类的
数组也是数值类型


311
00:21:19,680 --> 00:21:20,848
让我们回到之前的话题


312
00:21:26,486 --> 00:21:27,354
好 这里


313
00:21:28,422 --> 00:21:34,995
因此由于这是我的图表中唯一的事物
这个图表也是数值类型


314
00:21:36,663 --> 00:21:38,899
因此要绘制它我们只需要遍历所有


315
00:21:38,966 --> 00:21:41,969
元素并画下来每一个元素


316
00:21:43,737 --> 00:21:45,639
好 现在来作一个旋转


317
00:21:47,040 --> 00:21:48,175
那么 我们要测试一下


318
00:21:52,646 --> 00:21:54,948
所以Crusty新建了一个圆


319
00:21:55,015 --> 00:21:58,652
以非常特别的中心和半径


320
00:21:59,086 --> 00:22:02,389
然后以神秘的Spock一般的精度


321
00:22:02,923 --> 00:22:03,891
他添加了一个三角形


322
00:22:05,092 --> 00:22:09,263
最后他在其周围创建了
一个图表并让它绘制


323
00:22:13,133 --> 00:22:14,801
“瞧”Crusty 耀武扬威地说


324
00:22:15,135 --> 00:22:20,674
“就像你能明白地看到的
这是一个带圆的等边三角形内切于圆”


325
00:22:21,808 --> 00:22:25,612
也许我不擅长在脑海中做三角学问题


326
00:22:25,679 --> 00:22:29,449
不像 Crusty 那样
但是“不 Crusty ”我说


327
00:22:29,516 --> 00:22:30,984
“我不能很明白地看到这些


328
00:22:31,385 --> 00:22:33,487
我会觉得这个延时更加有趣


329
00:22:33,554 --> 00:22:35,689
如果我做一些实际有用的


330
00:22:35,889 --> 00:22:38,592
比如给我们的应用 画到屏幕上”


331
00:22:40,460 --> 00:22:41,995
我从烦恼中恢复过来之后


332
00:22:42,429 --> 00:22:46,266
我决定使用
CoreGraphics重写渲染器


333
00:22:49,970 --> 00:22:51,371
我告诉他我将要做这些


334
00:22:51,705 --> 00:22:54,208
他说“再等一会儿猴小子


335
00:22:55,676 --> 00:22:58,078
如果你这样做了
我还怎样测试我代码呢？”


336
00:23:01,348 --> 00:23:04,051
然后他展现了一个很有说服力的案例


337
00:23:04,117 --> 00:23:06,286
在测试中使用纯文本


338
00:23:06,720 --> 00:23:09,723
如果我们正在做的
事情中发生了某些改变


339
00:23:10,190 --> 00:23:12,726
我们可以立马在输出中看到


340
00:23:14,127 --> 00:23:16,129
然而他提出我们做一点


341
00:23:16,330 --> 00:23:17,631
面向协议的程序设计


342
00:23:19,533 --> 00:23:23,136
然后他复制了他的
渲染器然后将其写入协议中


343
00:23:28,942 --> 00:23:32,613
然后你必须删除主体 好


344
00:23:33,080 --> 00:23:37,918
这就是了 然后他重命名了
原始的渲染器并将它改为一致


345
00:23:41,455 --> 00:23:43,924
现在 所有的代码重构使得
我变得不耐烦


346
00:23:43,991 --> 00:23:46,560
因为我很想在屏幕上看到这些东西


347
00:23:47,861 --> 00:23:50,998
我想抢过来实现
CoreGraphics的渲染器


348
00:23:51,765 --> 00:23:54,601
但我必须等到
Crusty 再次测试他的代码


349
00:23:56,069 --> 00:23:58,172
等到他终于满意了他说“好了


350
00:23:59,640 --> 00:24:01,141
你打算在渲染器中放些什么呢？”


351
00:24:02,809 --> 00:24:04,778
我说“一个CGContext


352
00:24:05,212 --> 00:24:08,649
CGContext
基本有渲染器需要的一切”


353
00:24:09,816 --> 00:24:13,020
实际上在纯C语言接口范围内


354
00:24:13,587 --> 00:24:14,755
它基本就是一个渲染器


355
00:24:16,690 --> 00:24:18,659
“好” Crusty 说
“把键盘给我”


356
00:24:18,859 --> 00:24:20,794
他从我这儿夺去某样东西然后


357
00:24:20,861 --> 00:24:23,730
极快地做了某些事情
太快以至于我都没有看到做了些什么


358
00:24:32,673 --> 00:24:33,774
“等一下”我说


359
00:24:35,742 --> 00:24:39,446
“你刚刚只是把每个
CGContext写入渲染器吗？”


360
00:24:41,615 --> 00:24:44,251
他...我是说它什么也没做


361
00:24:45,118 --> 00:24:48,222
但是这有些令人吃惊
我甚至不需要添加一种新的类型


362
00:24:51,058 --> 00:24:52,559
“你还在等什么？Crusty说


363
00:24:52,626 --> 00:24:53,927
“在那些大括号中填入内容”


364
00:24:55,028 --> 00:24:57,631
所以我把必要的
CoreGraphics粘着都倒了进去


365
00:24:57,931 --> 00:25:01,368
把所有都扔进了游戏场 这就是了


366
00:25:02,736 --> 00:25:04,638
现在你可以下载这个游戏场


367
00:25:05,072 --> 00:25:07,708
它演示了我在这儿演讲的所有内容


368
00:25:07,774 --> 00:25:09,710
在我们结束之后


369
00:25:12,713 --> 00:25:13,814
不过还是回到我们的例子


370
00:25:14,915 --> 00:25:17,618
为了干扰我Crusty之后做了这些


371
00:25:20,754 --> 00:25:23,257
现在我需要花一点时间了解为什么绘制


372
00:25:23,323 --> 00:25:25,025
在这个点上没有进入无线循环


373
00:25:26,226 --> 00:25:27,694
如果你想了解更多的话


374
00:25:28,095 --> 00:25:31,031
你可以听一下周五的讲习会


375
00:25:34,234 --> 00:25:36,270
但这也并没有改变显示


376
00:25:37,471 --> 00:25:39,873
最终Crusty决定向我
演示正在发生的事情


377
00:25:39,940 --> 00:25:41,341
在他的纯文本输出中


378
00:25:42,242 --> 00:25:45,946
然后事实证明它只
重复了相同的绘制命令


379
00:25:48,382 --> 00:25:49,216
两次


380
00:25:49,750 --> 00:25:52,686
所以作为一个更面向图形的家伙


381
00:25:52,753 --> 00:25:54,788
我很想看到结果


382
00:25:55,355 --> 00:25:59,793
所以我创建了一个小
比例的适配器并用它包裹住图表


383
00:26:00,761 --> 00:26:03,564
这就是结果


384
00:26:04,031 --> 00:26:08,268
你可以在游戏场看到这些所以我不打算
在这儿深究小比例适配器


385
00:26:11,471 --> 00:26:13,173
不过这也是一种


386
00:26:14,241 --> 00:26:16,543
使用协议的演示我们可以做到所有


387
00:26:16,610 --> 00:26:18,378
与使用类可以做到的相同的事情


388
00:26:18,712 --> 00:26:21,114
适配器通常设计模式


389
00:26:22,816 --> 00:26:25,819
好 现在我想反思一下


390
00:26:25,886 --> 00:26:27,921
使用TestRenderer
都做了些什么


391
00:26:28,522 --> 00:26:29,957
因为它事实上是有些杰出的


392
00:26:32,526 --> 00:26:36,363
通过从特定的渲染器中解耦文件模型


393
00:26:36,964 --> 00:26:40,100
他能够插入检测组件


394
00:26:40,534 --> 00:26:44,905
以显示我们正在做的一切
我们的代码正在做的一切详细地


395
00:26:46,773 --> 00:26:49,209
后来我们就在我们的
代码中应用了这种方法


396
00:26:50,244 --> 00:26:53,146
我们发现我们使用协议解耦的事物越多


397
00:26:53,514 --> 00:26:54,982
所有的事物的可测性就越强


398
00:26:56,517 --> 00:26:57,551
这种测试与


399
00:26:57,951 --> 00:27:01,822
使用mock测试得到的结果很像
但这样做更好


400
00:27:03,090 --> 00:27:04,958
mock测试本质上是脆弱的


401
00:27:07,327 --> 00:27:08,996
你需要结合测试中的代码


402
00:27:09,062 --> 00:27:11,465
测试代码的实现细节


403
00:27:13,100 --> 00:27:16,003
正因这种脆弱性它们无法与


404
00:27:16,069 --> 00:27:18,105
Swift 强大的静态类型
系统很好地融合


405
00:27:20,641 --> 00:27:23,510
协议给我们提供了有原则的接口


406
00:27:23,810 --> 00:27:26,146
以供使用这由语言进行实施


407
00:27:26,680 --> 00:27:30,450
但仍会给我们hook以插入所有
我们所需要的检测设备


408
00:27:32,853 --> 00:27:36,790
好 回到我们的例子
因为我们现在需要认真地


409
00:27:36,857 --> 00:27:37,958
讨论一下Bubbles


410
00:27:40,027 --> 00:27:42,396
好我们希望这个图表
应用受孩子们的欢迎


411
00:27:42,462 --> 00:27:44,631
当然孩子们喜欢
Bubbles(气泡)


412
00:27:45,132 --> 00:27:51,138
因此在图表中Bubbles
只是一个内部圆圈偏移量


413
00:27:51,972 --> 00:27:54,308
围绕外围圆圈中心


414
00:27:55,475 --> 00:27:57,010
以此来表现加亮区


415
00:27:57,845 --> 00:27:58,745
所以你有两个圆


416
00:27:59,479 --> 00:28:00,314
就像这样


417
00:28:02,015 --> 00:28:03,917
当我把这段代码放到上下文


418
00:28:03,984 --> 00:28:06,086
Crusty 开始变得很激动


419
00:28:07,120 --> 00:28:09,056
所有的代码副本都使他抓狂


420
00:28:09,723 --> 00:28:11,859
如果 Crusty 不高兴
那么没有人可以高兴


421
00:28:15,095 --> 00:28:18,165
“瞧 他们都是完整的圆”他喊道
“我只想写这段”


422
00:28:19,166 --> 00:28:21,335
我说“冷静Crusty冷静


423
00:28:22,069 --> 00:28:22,903
我们可以这么做


424
00:28:24,171 --> 00:28:28,208
我们需要做的就是
再添加一个协议的要求


425
00:28:29,810 --> 00:28:32,880
然后当然我们更新模型来供应它


426
00:28:33,780 --> 00:28:34,882
我们有测试渲染器


427
00:28:36,250 --> 00:28:37,684
然后还有 CGContext”


428
00:28:39,720 --> 00:28:42,556
现在这个点上
Crusty 脱掉了鞋子


429
00:28:42,623 --> 00:28:45,926
拿它敲着桌子因为这里
我们又一次在重复代码


430
00:28:47,194 --> 00:28:49,630
他从我这里把键盘夺了回来抱怨着


431
00:28:49,696 --> 00:28:51,498
说所有的事情都需要他自己完成


432
00:28:53,066 --> 00:28:55,936
他开始教我使用
Swift的一个新特征


433
00:29:00,440 --> 00:29:01,909
这就是协议扩展


434
00:29:03,277 --> 00:29:05,712
据说“渲染器的所有模型


435
00:29:05,779 --> 00:29:08,248
都有circleAt的这个实现”


436
00:29:09,516 --> 00:29:14,354
现在我们有一种实现
渲染器的所有模型都在共享这种实现


437
00:29:15,022 --> 00:29:18,859
注意到我们仍有这个
circleAt 要求在那里


438
00:29:19,493 --> 00:29:20,994
你可能会问“有要求意味着什么？


439
00:29:21,061 --> 00:29:25,165
这个要求也可以在扩展中立即实现”


440
00:29:26,366 --> 00:29:27,201
很好的问题


441
00:29:28,101 --> 00:29:32,472
答案是协议要求新建定制点


442
00:29:35,876 --> 00:29:38,178
为了见证这是如何表现的
让我们先推翻这种方法体


443
00:29:38,712 --> 00:29:40,547
而在扩展中添加另一种方法


444
00:29:40,848 --> 00:29:43,450
添加一种不被要求支持的方法


445
00:29:45,819 --> 00:29:48,755
现在我们可以扩展Crusty的 


446
00:29:49,022 --> 00:29:51,458
来实现这两个方法


447
00:29:54,862 --> 00:29:55,963
然后我们只需要调用它们


448
00:29:57,965 --> 00:30:01,702
好 现在发生的事情完全不会令人吃惊


449
00:30:02,202 --> 00:30:04,872
我们直接调用
TestRender中的实现


450
00:30:05,806 --> 00:30:08,408
而协议并没有参与其中 对吧？


451
00:30:08,909 --> 00:30:12,312
如果我们删除这种一致性
我们将得到相同的结果


452
00:30:17,251 --> 00:30:18,919
不过现在我们修改下上下文


453
00:30:18,986 --> 00:30:22,289
这样Swift就只知道它是一个渲染器
而不是 TestRenderer


454
00:30:26,226 --> 00:30:27,160
来看一下发生了什么


455
00:30:28,228 --> 00:30:30,497
所以因为circleAt是要求


456
00:30:31,331 --> 00:30:34,001
我们的模型获得了定制它的特权


457
00:30:34,401 --> 00:30:35,769
然后定制被调用


458
00:30:39,239 --> 00:30:40,073
那个


459
00:30:44,378 --> 00:30:46,480
但是rectangleAt不是要求


460
00:30:46,547 --> 00:30:48,448
所以TestRenderer中的实现


461
00:30:48,849 --> 00:30:52,753
只覆盖到协议和上下文


462
00:30:53,453 --> 00:30:56,089
你只知道有渲染器而非
TestRenderer的时候


463
00:30:56,590 --> 00:30:58,125
协议实现被调用


464
00:30:59,660 --> 00:31:00,627
这有点奇怪 不是吗？


465
00:31:03,163 --> 00:31:05,999
那么 这是否意味着
rectangleAt应该是要求？


466
00:31:07,067 --> 00:31:08,402
也许在这种情况下它应该


467
00:31:08,635 --> 00:31:11,205
是因为有些渲染器非常有可能


468
00:31:11,271 --> 00:31:13,674
有更有效的方式来画矩形


469
00:31:13,907 --> 00:31:15,909
与坐标系相配合


470
00:31:17,578 --> 00:31:22,449
但是 协议扩展中的所有事物是否也
是由要求支持的呢？


471
00:31:22,883 --> 00:31:23,750
不一定


472
00:31:26,553 --> 00:31:29,990
我是说有些应用程序
界面并不打算作为定制点


473
00:31:30,724 --> 00:31:32,860
所以有时正确的解决方法是


474
00:31:32,926 --> 00:31:37,264
只覆盖到模型中的要求


475
00:31:38,031 --> 00:31:39,900
而不要覆盖到模型中的方法


476
00:31:44,872 --> 00:31:50,511
那么这种新特征偶然地变革了
我们在Swift标准库上的工作


477
00:31:51,845 --> 00:31:54,348
有时我们使用协议扩展所做的事情


478
00:31:55,349 --> 00:31:56,683
感觉很神奇


479
00:31:57,918 --> 00:32:01,188
我真心希望你们可以
享受使用最新的库进行工作


480
00:32:01,522 --> 00:32:03,123
就像我们享受应用这些到库


481
00:32:03,190 --> 00:32:08,228
以及更新库一样
我想先撇开我们的故事


482
00:32:08,295 --> 00:32:11,665
这样我就可以向你们展示我们使用
协议扩展在标准库上做的一些事情


483
00:32:11,999 --> 00:32:14,902
还有一些其他的技巧


484
00:32:16,570 --> 00:32:19,239
首先来讲一下新的indexOf方法


485
00:32:20,707 --> 00:32:23,043
这个方法遍历集合的指针


486
00:32:23,410 --> 00:32:26,613
直到它找到与我们
正在查找的相等的元素


487
00:32:26,947 --> 00:32:28,448
然后返回这个指针


488
00:32:28,982 --> 00:32:30,751
如果它没有找到结果那么返回空


489
00:32:31,552 --> 00:32:32,386
非常简单对吧？


490
00:32:34,488 --> 00:32:36,356
但是如果我们这样写
就会有一个问题


491
00:32:37,891 --> 00:32:40,527
一个任意集合的元素


492
00:32:41,161 --> 00:32:42,462
不能对等地比较


493
00:32:44,998 --> 00:32:48,602
因此为了解决这个问题
我们可以约束扩展


494
00:32:49,369 --> 00:32:51,638
这是这个新特征的另一方面


495
00:32:55,242 --> 00:33:00,180
所以这么说扩展应用于
集合元素类型是Equatable时


496
00:33:01,381 --> 00:33:05,986
我们已经给Swift传递了它所
需要的信息以允许等式比较


497
00:33:08,422 --> 00:33:10,324
现在我们已经看到了


498
00:33:10,390 --> 00:33:13,894
约束扩展的一个简单示例
让我们重温一下二进位检索


499
00:33:16,997 --> 00:33:18,732
我们将其应用到整型数组上


500
00:33:22,269 --> 00:33:24,671
好 整型不符合Ordered类


501
00:33:25,706 --> 00:33:26,874
这是一种简单的解决办法


502
00:33:27,374 --> 00:33:28,575
我们只要添加一致性


503
00:33:29,977 --> 00:33:31,278
好 那对于字符串又会怎样呢？


504
00:33:33,247 --> 00:33:35,983
当然 这对字符串并没有用
所以我们再做一次


505
00:33:36,683 --> 00:33:40,387
现在在Crusty开始敲桌子之前
我们很想分析出其中原因


506
00:33:41,889 --> 00:33:44,124
小于运算符出现在


507
00:33:44,191 --> 00:33:47,160
Comparable协议中
所以我们可以在


508
00:33:47,227 --> 00:33:48,829
Comparable协议中操作


509
00:33:53,300 --> 00:33:54,134
像这样


510
00:33:55,536 --> 00:33:58,438
现在我们正在预先提供那些一致性


511
00:33:58,739 --> 00:34:00,974
所以一方面这是很好的


512
00:34:01,842 --> 00:34:03,744
如果我想对双精度数据
进行二进位搜索


513
00:34:04,111 --> 00:34:07,481
我所需要做的就是添加
这个一致性我可以这么做


514
00:34:08,982 --> 00:34:12,152
另一方面这有些讨厌


515
00:34:12,485 --> 00:34:15,155
因为即使我去掉一致性


516
00:34:15,522 --> 00:34:18,559
我还是有这个被双精度获得的优先函数


517
00:34:19,025 --> 00:34:22,062
它已经有了足够的接口 对吗？


518
00:34:23,163 --> 00:34:28,534
我们可能想要更加有选择性地
在双精度数值上添加东西


519
00:34:30,871 --> 00:34:34,675
所以即使我可以这样做


520
00:34:34,741 --> 00:34:38,277
我不能用它来进行二进位检索所以这些
优先函数真的没有给我买入任何东西


521
00:34:39,813 --> 00:34:43,449
幸运的是我可以对哪些东西获得
优先函数应用程序界面更有选择性


522
00:34:44,251 --> 00:34:46,286
通过使用Ordered的约束扩展


523
00:34:48,222 --> 00:34:52,726
所以这就是说一个是
Comparable的类型并被声明


524
00:34:52,793 --> 00:34:57,164
为Ordered将能够
自动地满足优先要求


525
00:34:57,798 --> 00:34:59,066
而这正是我们想要的


526
00:35:00,567 --> 00:35:02,836
抱歉 但我觉得这很酷


527
00:35:03,237 --> 00:35:05,939
我们有了同样的抽象


528
00:35:07,007 --> 00:35:09,676
同样的逻辑抽象
来自于两个不同的地方


529
00:35:09,977 --> 00:35:12,312
而我们已经使它们无缝协作


530
00:35:13,013 --> 00:35:15,249
谢谢你们的掌声 
不过我只是我觉得这很酷


531
00:35:17,651 --> 00:35:19,586
好 做好准备来一个味蕾清新剂了吗？


532
00:35:24,391 --> 00:35:25,225
这显示它起作用了


533
00:35:25,792 --> 00:35:31,398
好 这是一个完全通用的
二进位检索的签名


534
00:35:32,032 --> 00:35:33,734
作用于任意一个集合


535
00:35:34,101 --> 00:35:36,236
带有适当的索引和元素类型


536
00:35:37,971 --> 00:35:40,374
现在我已经能听到
你们在那儿越来越不舒服了


537
00:35:40,641 --> 00:35:42,409
我并不准备在这里写主体


538
00:35:42,476 --> 00:35:44,811
因为这已经看起来很糟糕了 对吧


539
00:35:45,779 --> 00:35:48,782
Swift 1有很多像
这样的通用免费函数


540
00:35:49,983 --> 00:35:52,553
在Swift 2中我们像这样
使用协议扩展将它们


541
00:35:52,619 --> 00:35:55,822
变为方法 这很棒


542
00:35:57,724 --> 00:36:00,961
现在每个人都专注于在
这个调用站点的改善


543
00:36:01,762 --> 00:36:04,598
它现在很明显地充满了


544
00:36:04,898 --> 00:36:06,533
方法的精华


545
00:36:06,967 --> 00:36:08,902
但随着这个家伙写二进位检索


546
00:36:09,469 --> 00:36:11,038
我因其签名而爱上了它所做的事情


547
00:36:11,872 --> 00:36:15,309
通过分离情况
这些情况下该方法应用于


548
00:36:15,609 --> 00:36:17,110
声明的其余部分


549
00:36:17,811 --> 00:36:19,780
现在读起来只是一个常规方法


550
00:36:21,415 --> 00:36:22,816
不再有尖括号盲区


551
00:36:26,587 --> 00:36:27,421
非常感谢


552
00:36:31,191 --> 00:36:34,228
好 在我们回到我们的故事前
来讲一下最后一个技巧


553
00:36:35,829 --> 00:36:39,299
这是一个包含最小模型的游戏场


554
00:36:39,366 --> 00:36:41,768
关于Swift的心
OptionSetType协议


555
00:36:42,769 --> 00:36:45,038
它就是一个结构具有只读整型属性


556
00:36:46,006 --> 00:36:47,007
叫做rawValue


557
00:36:47,474 --> 00:36:53,580
现在来看一下一旦你昨晚
即可免费得到的广泛设置界面


558
00:36:55,249 --> 00:36:57,584
所有这些都来自于协议扩展


559
00:36:58,952 --> 00:37:00,988
如果你有机会的话
我邀请你来看一下


560
00:37:01,054 --> 00:37:02,856
那些扩展是怎样声明的


561
00:37:03,190 --> 00:37:05,959
在标准库中因为几个图层


562
00:37:06,026 --> 00:37:08,629
一起工作来提供这个丰富的
应用程序界面


563
00:37:11,331 --> 00:37:16,303
好 这些就是你可以
使用协议扩展做到的一些很酷的事情


564
00:37:17,371 --> 00:37:21,408
现在 我想回到我们的图表示例中


565
00:37:24,144 --> 00:37:25,846
使值类型可相等


566
00:37:27,681 --> 00:37:30,083
为什么？因为我是这么说的


567
00:37:30,817 --> 00:37:32,219
另外吃蔬菜


568
00:37:33,954 --> 00:37:35,989
不 事实上如果你想
知道为什么去听一下


569
00:37:36,056 --> 00:37:37,858
周五的讲习会我已经跟你们讲过这个


570
00:37:39,826 --> 00:37:43,397
这是一个很酷的演讲
他们准备详细探讨这个问题


571
00:37:44,965 --> 00:37:47,968
总之Equatable对于大多数
类型来说都是很容易的 对吧


572
00:37:48,035 --> 00:37:51,538
你只需要比较相应的部分
以求其对等性 就像这样


573
00:37:52,940 --> 00:37:55,242
但是现在我们来看一下图表发生了什么


574
00:37:58,612 --> 00:38:03,350
啊哦 我们不能对比两个
Drawable类型数组的对等性


575
00:38:06,286 --> 00:38:11,058
好吧 也许我们可以这么做
比较个体元素就好比这样


576
00:38:15,762 --> 00:38:19,032
好 我将给你们过一遍


577
00:38:19,166 --> 00:38:21,502
首先你去顶它们有相同数量的元素


578
00:38:21,635 --> 00:38:23,937
然后把两个数组压缩在一起


579
00:38:24,004 --> 00:38:25,772
如果它们有相同数量的元素


580
00:38:25,839 --> 00:38:28,575
那么你就找一对不相等的


581
00:38:29,009 --> 00:38:30,410
好的你可以相信我的话


582
00:38:30,477 --> 00:38:33,480
这还不是问题有趣的部分


583
00:38:36,250 --> 00:38:37,084
哦 对吧？


584
00:38:37,217 --> 00:38:40,153
这是我们无法比较数组的整个原因就是


585
00:38:40,220 --> 00:38:43,590
因为Drawable类是不对等的


586
00:38:43,891 --> 00:38:46,593
因此两个数组之间没有等于运算符


587
00:38:47,060 --> 00:38:49,963
我们没有等于运算符
给潜在的Drawable属性


588
00:38:50,030 --> 00:38:52,666
我们能不能把Drawable
改为Equatable？


589
00:38:53,200 --> 00:38:54,601
我们改变了设计像这样


590
00:39:00,274 --> 00:39:03,277
这里的问题在于
Equatable有Self要求


591
00:39:04,344 --> 00:39:07,214
这意味着Drawable
现在有了Self要求


592
00:39:08,382 --> 00:39:11,218
而Self要求正好将
Drawable


593
00:39:11,285 --> 00:39:14,721
放进了同构中静态分派的世界


594
00:39:16,256 --> 00:39:20,894
但是图表需要的是
Drawable异构数组


595
00:39:22,029 --> 00:39:25,232
因此我们可以将多边形
和圆放在同一个图表中


596
00:39:26,099 --> 00:39:29,303
那么Drawable必须待在异构的
动态分派的世界


597
00:39:30,370 --> 00:39:31,305
而这带来了矛盾


598
00:39:31,972 --> 00:39:34,474
将Drawable改为
Equatable是行不通的


599
00:39:37,811 --> 00:39:39,713
我们需要这样做


600
00:39:39,780 --> 00:39:43,350
就是说给Drawable添加
isEqualTo要求


601
00:39:45,919 --> 00:39:48,488
但是...不 我们不能用Self


602
00:39:49,857 --> 00:39:51,825
因为我们需要保持异构


603
00:39:52,192 --> 00:39:53,694
而没有了Self


604
00:39:54,328 --> 00:39:57,831
这就像用类完成Ordered一样


605
00:39:58,765 --> 00:40:00,834
现在我们要让所有 Drawable


606
00:40:01,134 --> 00:40:03,403
来处理异构比较情况


607
00:40:06,473 --> 00:40:08,041
幸运的是这次有一种方法可以做到


608
00:40:09,142 --> 00:40:13,280
与大多对称运算符不同
等式是特殊的


609
00:40:14,381 --> 00:40:16,617
因为有显而易见的默认的答案


610
00:40:16,683 --> 00:40:17,784
如果类型不匹配的话


611
00:40:18,385 --> 00:40:22,155
可以这么说如果有两个不同的类型
它们是不等的


612
00:40:24,424 --> 00:40:27,528
明白这一点我们可以实现
isEqualTo


613
00:40:27,594 --> 00:40:29,730
为所有Equatable的
Drawable


614
00:40:31,765 --> 00:40:32,599
就像这样


615
00:40:35,402 --> 00:40:36,370
让我来向你们演示


616
00:40:37,538 --> 00:40:38,906
扩展就是我们所说的


617
00:40:39,106 --> 00:40:41,508
它是给所有Equatable的
Drawable的


618
00:40:49,049 --> 00:40:53,887
好 首先我们有条件地将其他
类型向下转型到Self类型


619
00:40:54,488 --> 00:40:57,090
如果这成功了然后我们可以继续下去


620
00:40:57,157 --> 00:41:00,494
使用等式比较
因为我们有Equatable一致性


621
00:41:01,461 --> 00:41:04,064
否则实例会被认为不对等


622
00:41:09,169 --> 00:41:11,705
那么大图片这里刚刚发生了什么呢？


623
00:41:13,207 --> 00:41:16,009
我们与Drawable的
实现器达成协议


624
00:41:16,476 --> 00:41:22,516
我们说“如果你真的想
处理异构情况请做我的访客


625
00:41:22,916 --> 00:41:24,751
去实现isEqualTo


626
00:41:25,652 --> 00:41:30,057
但如果你只是想用我们


627
00:41:30,123 --> 00:41:32,826
表达同构比较的常规方式


628
00:41:33,093 --> 00:41:35,829
我们将为你处理所有异构比较的负担”


629
00:41:38,131 --> 00:41:41,201
所以在静态和动态世界之间建立桥梁


630
00:41:41,268 --> 00:41:44,338
是极好的设计空间


631
00:41:44,838 --> 00:41:47,307
我鼓励你们多多观察


632
00:41:47,875 --> 00:41:51,879
我们使用等式的特殊属性
解决了这个特别的问题


633
00:41:51,945 --> 00:41:54,915
但是问题并不都像这样


634
00:41:56,583 --> 00:41:58,018
你还可以做很多很酷的事情


635
00:42:01,889 --> 00:42:06,193
因此等式的这个属性不一定适用
但是什么才是普遍适用的呢？


636
00:42:07,694 --> 00:42:08,695
基于协议的设计


637
00:42:16,670 --> 00:42:19,473
所以我想在我们总结


638
00:42:19,973 --> 00:42:23,043
何时使用类之前说几句
因为他们有他们的位置


639
00:42:23,977 --> 00:42:26,713
好吗？有些时候你真的想要隐式共享


640
00:42:28,415 --> 00:42:31,318
例如值类型的基本操作


641
00:42:31,385 --> 00:42:33,053
没有任何意义时


642
00:42:33,520 --> 00:42:35,889
比如复制副本意味着什么呢？


643
00:42:35,956 --> 00:42:37,391
如果你不明白这是什么意思


644
00:42:38,025 --> 00:42:40,427
那么你可能想使它成为引用类型


645
00:42:42,095 --> 00:42:43,964
或者比较 一样的


646
00:42:44,031 --> 00:42:46,233
这是作为数值的另一个基础部分


647
00:42:46,800 --> 00:42:48,001
那么 比如窗口


648
00:42:48,969 --> 00:42:50,270
复制窗口意味着什么呢？


649
00:42:50,470 --> 00:42:51,738
你真的想看


650
00:42:52,506 --> 00:42:53,707
一个新的图形窗口吗？


651
00:42:54,041 --> 00:42:55,709
就在另一个窗口之上？ 不知道


652
00:42:57,110 --> 00:42:58,879
这不会是你视图层级的一部分


653
00:42:59,947 --> 00:43:00,781
毫无意义


654
00:43:01,815 --> 00:43:04,117
另外一种情况


655
00:43:04,184 --> 00:43:09,122
你的实例的生命周期依赖于
某些外部的副作用


656
00:43:09,489 --> 00:43:11,158
比如磁盘上出现的文件


657
00:43:13,093 --> 00:43:17,998
部分原因是编译器大量地创建值


658
00:43:18,599 --> 00:43:20,367
创建 再销毁


659
00:43:20,634 --> 00:43:22,769
我们试图尽可能地优化


660
00:43:23,604 --> 00:43:26,707
引用类型有这种稳定的特性


661
00:43:26,773 --> 00:43:28,942
所以如果你要做一些对应于


662
00:43:29,009 --> 00:43:30,110
外部实体的事情


663
00:43:30,844 --> 00:43:33,013
你可能会想使它为引用类型


664
00:43:33,580 --> 00:43:37,217
类 另一种情况是


665
00:43:37,518 --> 00:43:40,354
抽象实例是“水槽”


666
00:43:40,821 --> 00:43:42,523
比如渲染器


667
00:43:43,724 --> 00:43:47,794
我们灌注信息给它


668
00:43:47,861 --> 00:43:50,964
给渲染器 我们让它画线


669
00:43:52,132 --> 00:43:55,435
举个例子如果你想做一个
TestRenderer


670
00:43:55,502 --> 00:44:00,641
让它积累文本并将这些命令输出为


671
00:44:00,841 --> 00:44:03,610
字符串 而不是直接将它们倒给控制台


672
00:44:04,011 --> 00:44:05,012
你可以像这样做


673
00:44:06,914 --> 00:44:08,882
但要注意几件事情


674
00:44:09,416 --> 00:44:11,518
首先这是最后


675
00:44:13,153 --> 00:44:15,088
其次没有基类


676
00:44:15,422 --> 00:44:16,456
这仍然是一个协议


677
00:44:17,057 --> 00:44:18,992
我使用协议来表达抽象


678
00:44:23,530 --> 00:44:25,299
好 额外的几种情况


679
00:44:27,768 --> 00:44:30,704
我们生活在面向对象的世界 对吧？


680
00:44:30,871 --> 00:44:33,640
Cocoa 和
Cocoa Touch致力于对象


681
00:44:34,741 --> 00:44:37,411
他们会给你基类
并期望你将它们编入子类


682
00:44:37,845 --> 00:44:40,881
他们期望应用程序界面中的对象


683
00:44:41,715 --> 00:44:43,584
不要与系统对抗 好吗？


684
00:44:43,984 --> 00:44:45,085
这只会是徒劳的


685
00:44:46,420 --> 00:44:51,225
但是与此同时一定要谨慎


686
00:44:51,992 --> 00:44:55,062
你知道程序中任何事物都不能过大


687
00:44:55,529 --> 00:44:57,898
这对类和其他都适用


688
00:44:58,832 --> 00:45:02,469
所以当你从类中重构或分解时


689
00:45:03,303 --> 00:45:04,738
考虑使用值类型


690
00:45:07,574 --> 00:45:09,610
好了 总结一下


691
00:45:11,378 --> 00:45:14,214
协议 对于抽象来讲好过于超类


692
00:45:16,183 --> 00:45:21,121
第二协议扩展这个新特征


693
00:45:21,588 --> 00:45:23,290
让你做很神奇的事情


694
00:45:25,492 --> 00:45:27,728
第三我提到让你们来听周五的演讲吗？


695
00:45:29,796 --> 00:45:30,731
来参加周五的演讲


696
00:45:32,833 --> 00:45:33,667
吃蔬菜


697
00:45:34,801 --> 00:45:35,702
像Crusty一样


698
00:45:36,737 --> 00:45:37,571
非常感谢

