
1
00:00:07,007 --> 00:00:15,582
(音楽)

2
00:00:25,592 --> 00:00:26,660
おはようございます

3
00:00:26,760 --> 00:00:32,665
(拍手)

4
00:00:32,766 --> 00:00:34,434
セッション403へようこそ

5
00:00:34,535 --> 00:00:36,170
テストの最新情報です

6
00:00:36,370 --> 00:00:38,138
私はホンザ･ドボルスキーです

7
00:00:38,238 --> 00:00:41,842
同僚のイーサン･ボーンと
進めていきます

8
00:00:43,710 --> 00:00:46,680
コードカバレッジの
改良点から始めます

9
00:00:46,780 --> 00:00:48,782
Xcode 9.3の内容です

10
00:00:49,483 --> 00:00:54,321
次はXcode 10で改善された
テストの選択と順序化です

11
00:00:54,655 --> 00:00:57,824
最後にイーサンが登壇して

12
00:00:57,925 --> 00:01:01,328
並列テストについて話します

13
00:00:57,925 --> 00:01:01,328
並列テストについて話します

14
00:01:02,930 --> 00:01:04,998
まずはコードカバレッジです

15
00:01:06,700 --> 00:01:10,103
Xcode 9.3の改良を
全面的に行い

16
00:01:10,437 --> 00:01:14,541
動作や精度が大きく向上しました

17
00:01:14,875 --> 00:01:17,177
新機能も追加されました

18
00:01:17,277 --> 00:01:22,349
コードカバレッジを左右する
ターゲットを細かく指定できます

19
00:01:23,951 --> 00:01:27,321
xccovという
コマンドラインを作成し

20
00:01:28,121 --> 00:01:33,227
Source Editorで
ビジュアルを刷新しました

21
00:01:33,961 --> 00:01:36,063
細かく見ていきましょう

22
00:01:36,997 --> 00:01:41,034
まずは コードカバレッジの
改善について

23
00:01:41,134 --> 00:01:44,571
Appleの内部プロジェクトで
測定しました

24
00:01:46,173 --> 00:01:49,476
Xcodeでロードして
表示するまでに

25
00:01:49,576 --> 00:01:52,646
どれくらいの時間を要するか

26
00:01:54,348 --> 00:01:58,352
Xcode 9では
約6.5秒かかりました

27
00:01:59,853 --> 00:02:03,156
Xcode 9.3では
0.5秒弱になりました

28
00:01:59,853 --> 00:02:03,156
Xcode 9.3では
0.5秒弱になりました

29
00:02:03,257 --> 00:02:05,659
95％以上速いです

30
00:02:06,727 --> 00:02:11,198
(拍手)

31
00:02:12,065 --> 00:02:15,335
カバレッジファイルの
縮小も行いました

32
00:02:15,435 --> 00:02:18,071
テストが頻繁になれば
Xcodeからの―

33
00:02:18,172 --> 00:02:20,807
書き出しの量も
増えるからです

34
00:02:21,175 --> 00:02:24,978
大幅な改善ができて
うれしく思います

35
00:02:26,146 --> 00:02:29,883
Xcode 9では200MB以上でした

36
00:02:29,983 --> 00:02:31,652
かなりの容量ですが

37
00:02:31,752 --> 00:02:35,589
何千ものソースファイルが
あってのことです

38
00:02:37,758 --> 00:02:41,728
Xcode 9.3のファイルは
10分の1以下になりました

39
00:02:42,863 --> 00:02:46,934
(拍手)

40
00:02:47,067 --> 00:02:49,770
継続的インテグレーション時や

41
00:02:49,870 --> 00:02:53,740
ディスク領域が少ない時には
助かります

42
00:02:54,441 --> 00:02:59,913
カバレッジファイルが
縮小され速くなっただけでなく

43
00:03:00,013 --> 00:03:02,282
以前より正確になりました

44
00:03:03,717 --> 00:03:05,819
ヘッダファイルが１つの例です

45
00:03:05,919 --> 00:03:10,090
Xcode 9では
正確に収集し表示できず

46
00:03:10,190 --> 00:03:13,594
C++のコードで
問題になっていました

47
00:03:13,694 --> 00:03:18,866
ヘッダに多量の実行コードが
含まれることになるからです

48
00:03:19,666 --> 00:03:22,503
問題を抱えていた人もいるでしょう

49
00:03:22,603 --> 00:03:25,806
これで実装とヘッダの両方で

50
00:03:25,906 --> 00:03:28,575
コードカバレッジを
正しく示せます

51
00:03:29,476 --> 00:03:32,346
次はコードカバレッジの機能です

52
00:03:33,313 --> 00:03:35,749
まずターゲットを選択します

53
00:03:36,483 --> 00:03:41,622
コードカバレッジを有効にするか
無効にするかだけでなく

54
00:03:41,722 --> 00:03:43,023
有効にすれば

55
00:03:43,123 --> 00:03:47,294
実行する対象を
選ぶことが可能です

56
00:03:47,961 --> 00:03:51,865
サードパーティが関係する
プロジェクトで―

57
00:03:51,965 --> 00:03:54,368
テスト不要な
対象がある場合や

58
00:03:54,468 --> 00:03:56,103
自社内の作業でも

59
00:03:56,203 --> 00:04:00,340
テスト済みの箇所がある場合に
重要です

60
00:03:56,203 --> 00:04:00,340
テスト済みの箇所がある場合に
重要です

61
00:04:02,242 --> 00:04:04,545
ターゲットのカスタマイズは

62
00:04:04,645 --> 00:04:08,015
スキームのOptionsから可能です

63
00:04:08,682 --> 00:04:11,818
すべての対象を
含めることも可能ですし

64
00:04:11,919 --> 00:04:15,055
いくつかピックアップも可能です

65
00:04:17,190 --> 00:04:19,827
更に力強いワークフローとして

66
00:04:19,927 --> 00:04:22,763
xccovを作りました

67
00:04:24,198 --> 00:04:27,534
これで自動スクリプトを
簡単に統合でき

68
00:04:27,634 --> 00:04:31,538
人間と機械の
両方に向けた出力を生成します

69
00:04:32,306 --> 00:04:37,211
カバレッジデータの詳細を
見ることもできます

70
00:04:37,811 --> 00:04:40,380
そのデータについて

71
00:04:40,480 --> 00:04:42,716
実際に見てみましょう

72
00:04:43,851 --> 00:04:46,620
コードカバレッジを
有効にした場合

73
00:04:46,720 --> 00:04:49,089
Xcodeは
ファイルを２つ生成します

74
00:04:49,656 --> 00:04:51,892
１つはカバレッジレポート

75
00:04:51,992 --> 00:04:54,061
xccovreportの拡張子で

76
00:04:54,161 --> 00:04:58,398
ラインカバレッジの割合が
含まれています

77
00:04:58,499 --> 00:05:01,935
各ターゲットやソースファイル
などについてです

78
00:04:58,499 --> 00:05:01,935
各ターゲットやソースファイル
などについてです

79
00:05:03,337 --> 00:05:05,639
２つ目はカバレッジアーカイブです

80
00:05:05,739 --> 00:05:10,577
これは各ファイルの
実行カウントを含みます

81
00:05:13,280 --> 00:05:18,719
これらファイルは配信済みデータの
ディレクトリに保存され

82
00:05:18,819 --> 00:05:22,856
resultBundlePathを
xcodebuildに送ると

83
00:05:22,956 --> 00:05:26,493
結果のバンドルにも
配置されます

84
00:05:28,195 --> 00:05:29,897
例を見てみましょう

85
00:05:29,997 --> 00:05:35,002
カバレッジデータを
xccovで見た画面です

86
00:05:36,103 --> 00:05:39,072
各対象のカバレッジ全体が見えます

87
00:05:39,840 --> 00:05:42,543
しかし各ファイルの詳細や

88
00:05:43,110 --> 00:05:44,745
各メソッドも見えます

89
00:05:45,646 --> 00:05:50,517
また もちろん
フラグ識別をパスすることで

90
00:05:50,818 --> 00:05:54,621
JSONと同じデータを得られます

91
00:05:55,956 --> 00:05:58,926
これで統合が
より簡単になります

92
00:06:00,027 --> 00:06:02,262
xccovはフレキシブルです

93
00:06:02,362 --> 00:06:05,365
ドキュメンテーションも
ご覧ください

94
00:06:06,800 --> 00:06:12,406
コマンドラインでの
カバレッジの見方を説明しましたが

95
00:06:12,506 --> 00:06:16,944
最も便利な見方は
ソースコードの横にあります

96
00:06:18,445 --> 00:06:22,783
コードカバレッジの編集を選んで

97
00:06:22,883 --> 00:06:25,285
表示 非表示を選びます

98
00:06:28,555 --> 00:06:32,726
更新された
コードカバレッジがあります

99
00:06:33,193 --> 00:06:38,098
右の実行カウントにカーソルを重ね
ライン全体をハイライト

100
00:06:38,699 --> 00:06:41,134
これは とてもいい方法で

101
00:06:41,235 --> 00:06:46,173
テスト済みの箇所と
まだ作業中の箇所が分かります

102
00:06:47,608 --> 00:06:50,911
実際に見てもらいましょう

103
00:07:01,188 --> 00:07:03,957
Dev Castという
プロジェクトです

104
00:07:04,258 --> 00:07:08,795
去年iOS版を作った
単純なメッセージAppです

105
00:07:08,896 --> 00:07:11,465
今年はMac版を作成しました

106
00:07:12,099 --> 00:07:15,602
iOSとMacの
ビジネスロジックを共有するため

107
00:07:15,702 --> 00:07:19,006
DevCastKitという
フレームワークに入れました

108
00:07:19,306 --> 00:07:20,774
今日のゴールは

109
00:07:20,874 --> 00:07:24,912
コードカバレッジを
改善することです

110
00:07:25,612 --> 00:07:29,650
まだ収集していないので
オンにします

111
00:07:30,417 --> 00:07:35,022
そしてスキームの中の
Edit Schemeを選択し

112
00:07:35,355 --> 00:07:36,990
テストに入ります

113
00:07:37,758 --> 00:07:39,293
次にOptionsです

114
00:07:40,694 --> 00:07:43,597
コードカバレッジを有効にします

115
00:07:47,534 --> 00:07:50,737
ProductからTestで
テスト開始です

116
00:07:51,305 --> 00:07:56,477
テストバンドルと
Mac Appが構築され

117
00:07:56,577 --> 00:07:58,312
テストが行われています

118
00:07:59,880 --> 00:08:02,149
テスト結果を見てみましょう

119
00:07:59,880 --> 00:08:02,149
テスト結果を見てみましょう

120
00:08:02,249 --> 00:08:04,318
レポートナビゲータで

121
00:08:04,852 --> 00:08:07,421
最新のレポートを開きます

122
00:08:08,722 --> 00:08:12,659
ここに両方のターゲットが見えます

123
00:08:12,759 --> 00:08:15,596
Mac Appと
フレームワークです

124
00:08:15,896 --> 00:08:20,467
コードカバレッジですが
これはテストなので

125
00:08:20,567 --> 00:08:23,437
低くても問題ありません

126
00:08:23,537 --> 00:08:27,574
見たいのは そこではありません

127
00:08:28,675 --> 00:08:31,378
再びスキームを編集します

128
00:08:33,580 --> 00:08:35,182
テストを始めます

129
00:08:36,616 --> 00:08:39,586
全ターゲットを収集するのではなく

130
00:08:39,919 --> 00:08:42,022
いくつかの対象に絞ります

131
00:08:42,890 --> 00:08:45,626
リストが出てくるので

132
00:08:45,726 --> 00:08:49,663
調査対象のフレームワークのみを
追加します

133
00:08:53,734 --> 00:08:55,736
テストに戻ります

134
00:08:59,506 --> 00:09:01,875
新しいレポートを見ましょう

135
00:08:59,506 --> 00:09:01,875
新しいレポートを見ましょう

136
00:09:02,976 --> 00:09:06,613
これがフレームワークのみの
レポートです

137
00:09:06,713 --> 00:09:08,015
見たかったデータです

138
00:09:08,115 --> 00:09:10,984
１つの対象に集中できます

139
00:09:11,585 --> 00:09:14,655
カバレッジの割合は84％です

140
00:09:14,755 --> 00:09:17,591
悪くはないですが改善できます

141
00:09:17,691 --> 00:09:20,928
どのファイルに
集中すべきか知るため

142
00:09:21,028 --> 00:09:22,896
対象を調べましょう

143
00:09:23,630 --> 00:09:27,768
１つ目のファイルが66％と
低いですね

144
00:09:28,368 --> 00:09:31,505
この矢印をクリックして開きます

145
00:09:33,841 --> 00:09:37,578
ローカルサーバのクラスを見ます

146
00:09:38,245 --> 00:09:42,549
右側で実行カウントを
見ることができます

147
00:09:42,649 --> 00:09:47,788
実行可能な部分は
カバーされたと分かります

148
00:09:47,888 --> 00:09:49,022
いいですね

149
00:09:49,323 --> 00:09:52,726
残念ながら 簡易関数
getRecentMessagesが

150
00:09:52,826 --> 00:09:54,595
呼び出されておらず

151
00:09:54,695 --> 00:09:56,730
動作が正確か分かりません

152
00:09:57,731 --> 00:10:01,502
修復するため
関連テストファイルを見ます

153
00:09:57,731 --> 00:10:01,502
修復するため
関連テストファイルを見ます

154
00:10:03,637 --> 00:10:05,239
新しいテストを追加

155
00:10:07,641 --> 00:10:11,512
ローカルサーバに
メッセージをいくつか送り

156
00:10:11,612 --> 00:10:16,149
getRecentMessagesで
返答を検証します

157
00:10:17,251 --> 00:10:19,219
新しいテストを追加して

158
00:10:19,520 --> 00:10:21,822
もう一度 行いましょう

159
00:10:25,926 --> 00:10:27,161
完了しました

160
00:10:27,261 --> 00:10:30,130
カバレッジレポートを見ます

161
00:10:30,430 --> 00:10:33,100
フレームワークに集中してみると

162
00:10:33,200 --> 00:10:35,269
100％カバーできています

163
00:10:35,369 --> 00:10:37,204
求めていた結果です

164
00:10:38,205 --> 00:10:41,475
対象をフォーカスするための

165
00:10:41,575 --> 00:10:43,944
選択機能を紹介しました

166
00:10:44,411 --> 00:10:48,482
そしてカバレッジレポートも
見てもらいました

167
00:10:48,715 --> 00:10:52,152
コードカバレッジの統合も
行いました

168
00:10:52,252 --> 00:10:55,789
どのコードをカバーすべきか
知るためです

169
00:10:56,690 --> 00:10:59,026
これがXcodeの改善点です

170
00:11:06,433 --> 00:11:08,869
コードカバレッジの次は

171
00:11:09,670 --> 00:11:12,339
Xcode 10の新機能の説明です

172
00:11:12,973 --> 00:11:18,011
まず テストを適切な順番で
行う方法を見ます

173
00:11:19,279 --> 00:11:20,881
なぜ重要なのか？

174
00:11:21,014 --> 00:11:26,286
すべてのテストが
同じ目的ではありません

175
00:11:26,553 --> 00:11:32,059
1000の急ぎのユニットテストを
行う一方で―

176
00:11:32,159 --> 00:11:36,096
夜間は10だけ
長いUIテストを行ったりします

177
00:11:36,830 --> 00:11:40,868
スキーム内の特定のテストを
無効にすれば可能です

178
00:11:42,436 --> 00:11:45,839
無効なテストのリストを
エンコード

179
00:11:45,939 --> 00:11:49,143
XEテストでスキップします

180
00:11:49,843 --> 00:11:52,179
面白い副作用があります

181
00:11:52,279 --> 00:11:53,947
新しいテストを書くたびに

182
00:11:54,047 --> 00:11:58,819
対象を含む全スキームに
自動的に追加されます

183
00:11:59,153 --> 00:12:00,521
必要ない場合は

184
00:11:59,153 --> 00:12:00,521
必要ない場合は

185
00:12:00,621 --> 00:12:04,691
全スキームを見て
手動で無効にすることに

186
00:12:05,759 --> 00:12:06,727
Xcode 10では

187
00:12:06,827 --> 00:12:10,898
逆に 実行するテストを
エンコードします

188
00:12:12,599 --> 00:12:14,568
そのモードに切り替えると

189
00:12:14,668 --> 00:12:17,971
指定したテストのみ動作します

190
00:12:21,141 --> 00:12:24,444
これは
スキームエディタで操作でき

191
00:12:25,212 --> 00:12:28,415
新しいポップアップが表示されます

192
00:12:28,515 --> 00:12:32,586
新規テストの自動追加を
選択できます

193
00:12:33,487 --> 00:12:37,591
これで あらゆる新規テストを
実行するスキームと―

194
00:12:37,691 --> 00:12:41,328
選択したテストのみ行う
スキームを分けます

195
00:12:43,464 --> 00:12:48,202
どのテストをいつ行うかを
説明してきましたが

196
00:12:48,302 --> 00:12:51,672
テストの順序も重要な事項です

197
00:12:53,073 --> 00:12:56,777
デフォルトでは名前順で実行されます

198
00:12:57,477 --> 00:12:59,880
名称を変更しないと

199
00:12:59,980 --> 00:13:02,049
いつも同じ順番となります

200
00:12:59,980 --> 00:13:02,049
いつも同じ順番となります

201
00:13:02,783 --> 00:13:05,285
これはもろ刃の剣になり得ます

202
00:13:05,686 --> 00:13:08,789
テストの順序に
左右される状況では

203
00:13:08,889 --> 00:13:12,025
バグを見落としがちになります

204
00:13:13,393 --> 00:13:15,896
この例を見てみましょう

205
00:13:16,630 --> 00:13:19,099
テストＡ Ｂ Ｃがあるとします

206
00:13:19,299 --> 00:13:22,402
常にこの順番で実施され
パスします

207
00:13:22,536 --> 00:13:24,905
しかし詳しく見ていくと

208
00:13:25,005 --> 00:13:28,108
テストＡはデータベースを生成

209
00:13:29,176 --> 00:13:32,846
Ｂはデータの書き込みを行います

210
00:13:33,614 --> 00:13:37,151
Ｃは それを消去しています

211
00:13:40,687 --> 00:13:44,658
これらのテストは
この順序のみでパスします

212
00:13:44,758 --> 00:13:49,096
では 名前を変えるなどして
順番を入れ替えて

213
00:13:49,696 --> 00:13:51,265
テストすればどうか？

214
00:13:51,365 --> 00:13:54,701
Ｂはデータベースがないので

215
00:13:54,802 --> 00:13:56,803
テストは失敗します

216
00:13:57,671 --> 00:14:00,507
このような問題を防ぐには

217
00:13:57,671 --> 00:14:00,507
このような問題を防ぐには

218
00:14:00,607 --> 00:14:05,212
常に正しく設定･解除する
必要があります

219
00:14:06,280 --> 00:14:08,382
信頼性が増すだけでなく

220
00:14:08,482 --> 00:14:12,986
各テストは
独立して実行可能になります

221
00:14:13,854 --> 00:14:17,024
開発やデバッグ時に効果的です

222
00:14:18,492 --> 00:14:23,063
テスト同士の依存をなくすため

223
00:14:23,230 --> 00:14:27,267
Xcode 10はテストの
ランダム化ができます

224
00:14:28,235 --> 00:14:29,436
これを使えば

225
00:14:29,536 --> 00:14:33,273
テスト前にランダムで
シャッフルされます

226
00:14:34,241 --> 00:14:37,077
これを使ってもパスした場合

227
00:14:37,177 --> 00:14:40,714
各テストの安定と独立が
より信頼できます

228
00:14:42,616 --> 00:14:45,686
スキームエディタから設定可能です

229
00:14:45,786 --> 00:14:48,222
先ほど見せたものと同じです

230
00:14:50,290 --> 00:14:53,794
以上が
選択と順序化の新機能です

231
00:14:55,829 --> 00:14:58,232
次に紹介するのは

232
00:14:59,299 --> 00:15:02,536
並列テストの新機能です

233
00:14:59,299 --> 00:15:02,536
並列テストの新機能です

234
00:15:02,636 --> 00:15:05,239
イーサンを
呼びたいと思います

235
00:15:05,739 --> 00:15:11,712
(拍手)

236
00:15:12,279 --> 00:15:13,380
ありがとうホンザ

237
00:15:15,048 --> 00:15:19,453
多くの皆さんが
このような開発サイクルですよね

238
00:15:19,586 --> 00:15:22,156
コードを書いてデバッグして

239
00:15:22,256 --> 00:15:27,261
変更点をコミットする前に
テストを実行する

240
00:15:27,861 --> 00:15:29,963
プッシュ前にテストすることで

241
00:15:30,063 --> 00:15:33,534
ビルド前に不具合を発見できます

242
00:15:35,869 --> 00:15:38,505
しかしプロセスの障害の１つが

243
00:15:38,605 --> 00:15:41,675
テスト実行時間の長さです

244
00:15:42,075 --> 00:15:47,447
30分から数時間かけて実行する
テストスイートもあります

245
00:15:47,948 --> 00:15:51,852
作業を終えるまでに
時間がかかる場合

246
00:15:51,952 --> 00:15:54,955
ワークフローに問題があります

247
00:15:55,789 --> 00:15:59,426
なるべく速く
テストを実行することで

248
00:15:59,526 --> 00:16:02,963
この重要な作業を
短縮しましょう

249
00:15:59,526 --> 00:16:02,963
この重要な作業を
短縮しましょう

250
00:16:03,330 --> 00:16:07,568
そのために昨年
Xcode 9に機能を加えました

251
00:16:07,668 --> 00:16:11,972
Parallel Destination Testingです

252
00:16:12,272 --> 00:16:17,611
複数のデスティネーションを
同時にテストできます

253
00:16:18,078 --> 00:16:23,784
コマンドラインから指定子を
xcodebuildにパスします

254
00:16:25,552 --> 00:16:27,888
これまでのテストでは…

255
00:16:27,988 --> 00:16:30,924
iPhone XやiPadで
説明します

256
00:16:31,024 --> 00:16:34,428
iPhone Xで
すべてのテストを行い

257
00:16:34,528 --> 00:16:37,030
次にiPadで行う手順でした

258
00:16:37,264 --> 00:16:40,367
同時にはできませんでした

259
00:16:42,135 --> 00:16:44,705
Xcode 9では違います

260
00:16:44,805 --> 00:16:48,775
デフォルトで同時に
テストを行えるようにしました

261
00:16:49,009 --> 00:16:53,046
これで全体の実行時間を
大幅に短縮できます

262
00:16:54,481 --> 00:16:57,351
しかし これにも限界があります

263
00:16:58,785 --> 00:17:02,856
まず複数の
デスティネーションに限られます

264
00:16:58,785 --> 00:17:02,856
まず複数の
デスティネーションに限られます

265
00:17:03,390 --> 00:17:07,094
Mac Appで
ユニットテストを行う場合

266
00:17:07,194 --> 00:17:08,494
うまくいきません

267
00:17:09,762 --> 00:17:12,665
xcodebuildのみ可能で

268
00:17:12,766 --> 00:17:16,837
継続的インテグレーションの場合に
限られます

269
00:17:16,936 --> 00:17:19,373
Xcode ServerやJenkinsです

270
00:17:21,208 --> 00:17:24,645
しかし皆さんに朗報があります

271
00:17:24,744 --> 00:17:27,079
Parallel Distributed
Testingです

272
00:17:28,482 --> 00:17:33,921
これで１つのデスティネーションで
並列テストが可能になります

273
00:17:34,688 --> 00:17:38,158
以前のテストはこうでした

274
00:17:38,258 --> 00:17:42,596
１つのテストに対して１つの線です

275
00:17:44,231 --> 00:17:47,734
新機能は同時にテストが行えるので

276
00:17:47,834 --> 00:17:50,037
見え方はこうなります

277
00:17:50,971 --> 00:17:54,575
Xcodeとxcodebuildが
サポートしているので

278
00:17:54,675 --> 00:17:58,445
どこで実行しても
最善の効果が得られます

279
00:18:00,214 --> 00:18:03,817
では並列テストの
実行方法を話します

280
00:18:03,917 --> 00:18:07,087
まず どのように実行されるのかと

281
00:18:07,187 --> 00:18:08,922
ランタイムについて

282
00:18:10,591 --> 00:18:12,526
まずユニットテストです

283
00:18:12,926 --> 00:18:16,697
まずテストバンドルに
コンパイルされます

284
00:18:17,698 --> 00:18:21,235
ランタイム時に
テストランナーとして

285
00:18:21,335 --> 00:18:23,737
XcodeがAppを起動します

286
00:18:24,638 --> 00:18:28,475
ランナーはバンドルを
ロードして実行します

287
00:18:29,810 --> 00:18:31,745
これがユニットテストです

288
00:18:32,246 --> 00:18:33,747
次にUIテストです

289
00:18:34,181 --> 00:18:36,283
こちらも同様で

290
00:18:36,383 --> 00:18:39,152
バンドルに
コンパイルされますが

291
00:18:39,253 --> 00:18:42,990
バンドルがカスタムAppで
ロードされるので

292
00:18:43,290 --> 00:18:45,759
App自体はテストしません

293
00:18:46,560 --> 00:18:50,931
その代わり テストが
Appを起動し 各UIに作用して―

294
00:18:51,031 --> 00:18:53,700
自動的に処理を進めます

295
00:18:55,102 --> 00:18:57,604
この過程を更に学びたい人は

296
00:18:57,704 --> 00:19:02,643
2016年の我々の
セッションをご覧ください

297
00:18:57,704 --> 00:19:02,643
2016年の我々の
セッションをご覧ください

298
00:19:03,977 --> 00:19:06,914
テストの実行について
見てきましたが

299
00:19:07,014 --> 00:19:10,517
Xcodeの
並列テストについて話します

300
00:19:11,318 --> 00:19:12,619
以前と同じように

301
00:19:12,719 --> 00:19:16,256
テストランナーを使用します

302
00:19:17,124 --> 00:19:19,593
ですが１つのランナーではなく

303
00:19:19,693 --> 00:19:22,196
複数のランナーを起動します

304
00:19:22,329 --> 00:19:25,265
そして各々が
サブセットをテストします

305
00:19:26,266 --> 00:19:30,137
Xcodeはランナーに
テストを分配し

306
00:19:30,237 --> 00:19:33,674
その機器での作業効率を
高めます

307
00:19:35,242 --> 00:19:36,944
詳しく見てみましょう

308
00:19:37,978 --> 00:19:40,747
ランナーに分配する時は

309
00:19:40,848 --> 00:19:42,816
クラス単位で渡します

310
00:19:43,383 --> 00:19:46,286
各ランナーはテストを受け取り

311
00:19:46,520 --> 00:19:50,624
別クラスに移る前に
そのテストを実行します

312
00:19:51,225 --> 00:19:54,795
すべてのクラスを
実行すると完了です

313
00:19:56,430 --> 00:20:00,334
なぜクラスごとに
送るか疑問に思うでしょう

314
00:19:56,430 --> 00:20:00,334
なぜクラスごとに
送るか疑問に思うでしょう

315
00:20:00,434 --> 00:20:03,804
なぜ個々のテストメソッドを
送らないのか？

316
00:20:04,505 --> 00:20:06,406
いくつか理由があります

317
00:20:07,574 --> 00:20:11,445
１つ目はテスト間の
隠れた依存性です

318
00:20:11,545 --> 00:20:13,247
ホンザも言及しました

319
00:20:13,781 --> 00:20:16,417
Xcodeが同クラスのテストを

320
00:20:16,517 --> 00:20:18,719
違うランナーに送ると

321
00:20:18,819 --> 00:20:21,622
エラーの診断が
難しくなります

322
00:20:23,323 --> 00:20:24,358
２つ目です

323
00:20:24,458 --> 00:20:28,195
各テストクラスには
設定と解除メソッドがあり

324
00:20:28,295 --> 00:20:31,064
高度な計算を行うかもしれません

325
00:20:31,432 --> 00:20:34,668
ランナーを１つに制限することで

326
00:20:34,768 --> 00:20:37,905
XEテストは
一度の設定･解除で済み

327
00:20:38,005 --> 00:20:39,740
貴重な時間の節約です

328
00:20:42,376 --> 00:20:46,980
次にシミュレータ上の
並列テストについて話します

329
00:20:48,282 --> 00:20:50,951
並列テストを行うと

330
00:20:51,051 --> 00:20:54,188
指定のシミュレータが起動し

331
00:20:54,288 --> 00:20:58,091
複数のコピーや
クローンを生成します

332
00:20:58,892 --> 00:21:03,664
これらのクローンは
元のシミュレータと同じです

333
00:20:58,892 --> 00:21:03,664
これらのクローンは
元のシミュレータと同じです

334
00:21:04,665 --> 00:21:09,069
クローンは自動的に
作られたり削除されたりします

335
00:21:10,037 --> 00:21:12,439
何度かクローンを生成したあと

336
00:21:12,539 --> 00:21:16,009
Xcodeが 各クローン上で
ランナーを起動

337
00:21:16,109 --> 00:21:20,781
そのランナーが
テストクラスを実行します

338
00:21:22,483 --> 00:21:26,487
異なるクローンで
テストを実行する際に

339
00:21:26,587 --> 00:21:29,189
気を付けるポイントがあります

340
00:21:31,024 --> 00:21:35,295
元のシミュレータが
使われていないことです

341
00:21:35,796 --> 00:21:38,699
代わりにテンプレートとなります

342
00:21:39,066 --> 00:21:42,302
希望の設定とコンテンツを
適用すると

343
00:21:42,402 --> 00:21:46,006
そのコンテンツは
クローンに複製されます

344
00:21:47,608 --> 00:21:50,777
次にAppのコピーが複数でき

345
00:21:51,044 --> 00:21:55,382
各クローンと複製が
データコンテナを持ちます

346
00:21:55,949 --> 00:21:59,987
ファイルを修正する
テストクラスがあれば

347
00:22:00,087 --> 00:22:04,224
他のテストクラスでは
修正内容が見えません

348
00:22:04,324 --> 00:22:07,728
完全に別の
データコンテナだからです

349
00:22:08,896 --> 00:22:12,533
異なるクローンで
実行されるという事実は

350
00:22:12,633 --> 00:22:14,935
テストからは見えません

351
00:22:15,402 --> 00:22:16,970
しかし認識すべきです

352
00:22:18,939 --> 00:22:21,475
ではどこで並列テストが可能か

353
00:22:21,675 --> 00:22:24,511
macOSではユニットテストが

354
00:22:24,611 --> 00:22:27,114
iOSとtvOSシミュレータでは

355
00:22:27,214 --> 00:22:29,283
UIテストも同様に可能です

356
00:22:30,884 --> 00:22:35,422
では実際にテストのデモを
ご覧いただきます

357
00:22:48,135 --> 00:22:50,537
これはSolar SystemのAppで

358
00:22:50,637 --> 00:22:53,874
Dub-Dubのセッションで
見た人もいますね

359
00:22:54,241 --> 00:22:56,009
このデベロッパとして

360
00:22:56,109 --> 00:23:00,914
変更を確定する前に
全テストを行いましょう

361
00:22:56,109 --> 00:23:00,914
変更を確定する前に
全テストを行いましょう

362
00:23:01,548 --> 00:23:03,650
しかしテストが増えれば

363
00:23:03,750 --> 00:23:07,955
その分 時間がかかり
ワークフローに支障が…

364
00:23:08,388 --> 00:23:10,490
ここで並列テストです

365
00:23:11,558 --> 00:23:14,061
Xcodeプロジェクトに切り替え

366
00:23:14,461 --> 00:23:18,398
テストを実行し
所要時間を見てみます

367
00:23:21,535 --> 00:23:24,705
テストレポートを開きます

368
00:23:25,205 --> 00:23:27,174
ここで各メソッドを見ると

369
00:23:27,274 --> 00:23:30,644
それぞれに要した時間が
分かります

370
00:23:31,211 --> 00:23:32,980
各テストクラスでは

371
00:23:33,080 --> 00:23:36,283
合否の割合が分かります

372
00:23:36,550 --> 00:23:39,686
実行に要した時間も見れます

373
00:23:40,487 --> 00:23:42,022
最後に右側に

374
00:23:42,122 --> 00:23:45,826
すべてのテストに
要した時間があります

375
00:23:46,160 --> 00:23:48,829
14秒と書かれています

376
00:23:49,563 --> 00:23:51,865
次は並列テストを可能に

377
00:23:51,965 --> 00:23:54,034
スキームへ行きます

378
00:23:54,134 --> 00:23:57,271
Edit Schemeを選びます

379
00:23:57,738 --> 00:23:59,973
Testをクリックし

380
00:24:00,140 --> 00:24:03,710
ターゲット横の
Optionsをクリック

381
00:24:04,545 --> 00:24:07,948
“Execute in parallel”に
チェックを入れると

382
00:24:08,415 --> 00:24:11,185
実行が可能になります

383
00:24:11,985 --> 00:24:16,323
それでは
テストを実行してみましょう

384
00:24:19,560 --> 00:24:21,628
文書を見てみます

385
00:24:21,862 --> 00:24:24,832
Mac Appが複数のコピーを作り

386
00:24:24,932 --> 00:24:27,201
ユニットテストを並列で行います

387
00:24:27,668 --> 00:24:29,603
終わったようです

388
00:24:29,703 --> 00:24:31,939
レポートを見てみます

389
00:24:32,272 --> 00:24:34,441
最新のものを選びます

390
00:24:35,943 --> 00:24:39,279
先ほど14秒かかったテストが

391
00:24:39,379 --> 00:24:41,115
５秒で終わりました

392
00:24:41,215 --> 00:24:43,016
並列化によって

393
00:24:43,116 --> 00:24:46,753
50％以上の効率化を
実現できました

394
00:24:47,387 --> 00:24:53,393
(拍手)

395
00:24:53,727 --> 00:24:57,498
Solar Systemは
Macだけでなく

396
00:24:57,598 --> 00:24:59,833
iOSにもあります

397
00:25:00,134 --> 00:25:03,203
私はUIテストスイートを
書いていました

398
00:25:03,303 --> 00:25:06,874
iOS Appの様々な画面で
実行するためです

399
00:25:06,974 --> 00:25:10,878
iOSでの並列化も可能にしたので

400
00:25:10,978 --> 00:25:13,514
これから切り替えてみましょう

401
00:25:16,683 --> 00:25:19,353
プロダクトを選んで実行します

402
00:25:19,453 --> 00:25:20,387
Testへ

403
00:25:22,923 --> 00:25:25,759
今度はシミュレータに切り替えます

404
00:25:26,393 --> 00:25:28,128
ここにXcodeが

405
00:25:28,228 --> 00:25:31,999
クローンを
複数生成したのが見えます

406
00:25:32,299 --> 00:25:36,136
元のシミュレータにちなんで
名付けられているので

407
00:25:36,236 --> 00:25:38,472
識別は簡単です

408
00:25:39,206 --> 00:25:43,477
各シミュレータ上で
Xcodeはランナーを起動

409
00:25:43,744 --> 00:25:47,314
ランナーは
異なるテストクラスを実行します

410
00:25:59,927 --> 00:26:02,062
テストの実行中に

411
00:25:59,927 --> 00:26:02,062
テストの実行中に

412
00:26:02,162 --> 00:26:06,200
Xcodeに戻り
テストログをお見せします

413
00:26:06,500 --> 00:26:08,268
テストログは

414
00:26:08,368 --> 00:26:10,637
テストレポートに
関連付けられています

415
00:26:11,371 --> 00:26:13,207
ログを見ることで

416
00:26:13,307 --> 00:26:16,743
クラスの分配状況が分かります

417
00:26:18,212 --> 00:26:21,482
各ランナーのエントリーを
見ることができ

418
00:26:21,915 --> 00:26:26,887
ランナーの下で
実行中のテストクラスが見えます

419
00:26:28,021 --> 00:26:30,124
なので テストが完了後に―

420
00:26:30,224 --> 00:26:33,327
クラスの分配を確認するには
最適です

421
00:26:33,427 --> 00:26:36,330
並列テストの概要が分かります

422
00:26:37,331 --> 00:26:39,633
ではスライドに戻ります

423
00:26:42,436 --> 00:26:47,775
(拍手)

424
00:26:48,408 --> 00:26:51,178
ここでデモ内容をおさらいします

425
00:26:52,146 --> 00:26:56,417
１つはスキームエディタで並列化を
有効にする方法

426
00:26:57,351 --> 00:27:00,454
次にテストレポートの
見方を話しました

427
00:26:57,351 --> 00:27:00,454
次にテストレポートの
見方を話しました

428
00:27:00,554 --> 00:27:03,991
テストログで
クラス分配の様子も見ました

429
00:27:05,559 --> 00:27:09,563
XcodeがMac Appで
複数のクローンを作り

430
00:27:09,663 --> 00:27:11,865
並列でユニットテストを

431
00:27:12,966 --> 00:27:16,203
最後にシミュレータのクローンが

432
00:27:16,303 --> 00:27:18,639
並列でUIテストをしました

433
00:27:20,574 --> 00:27:22,276
先に述べたように

434
00:27:22,376 --> 00:27:25,846
xcodebuildも優れています

435
00:27:26,413 --> 00:27:28,415
新しいコマンドラインを追加し

436
00:27:28,515 --> 00:27:30,417
動作が制御可能になりました

437
00:27:30,517 --> 00:27:32,686
ここで２つお知らせします

438
00:27:34,087 --> 00:27:37,090
１つは“parallel-testing-
worker-count”で

439
00:27:37,191 --> 00:27:40,727
ワーカーやランナーの
数を調整します

440
00:27:40,828 --> 00:27:43,630
並列テスト中に行ってくれます

441
00:27:44,698 --> 00:27:48,402
通常 Xcodeはランナーの数を

442
00:27:48,502 --> 00:27:52,239
マシンのリソースや
作業量で決定します

443
00:27:52,840 --> 00:27:57,044
高度なマシンほど
多くのランナーが使われます

444
00:27:58,078 --> 00:28:01,181
しかしデフォルトの数が
機能しない時に

445
00:27:58,078 --> 00:28:01,181
しかしデフォルトの数が
機能しない時に

446
00:28:01,281 --> 00:28:03,851
コマンドラインから
オーバーライドできます

447
00:28:05,953 --> 00:28:08,121
次は“parallel-testing-enabled”

448
00:28:08,222 --> 00:28:10,657
オンオフを明確に切り替え

449
00:28:10,757 --> 00:28:13,894
設定をスキーム内で
オーバーライドします

450
00:28:16,797 --> 00:28:20,334
並列テストを実行したい場合は

451
00:28:20,434 --> 00:28:22,135
オンにするだけです

452
00:28:22,503 --> 00:28:24,271
しかし少しのコツで

453
00:28:24,371 --> 00:28:26,874
最大限に生かすことができます

454
00:28:28,041 --> 00:28:32,980
まず長時間のテストを
２つのクラスに分けます

455
00:28:34,214 --> 00:28:37,251
テストクラスは
並列で実行されるので

456
00:28:37,351 --> 00:28:40,854
最長のクラスより速くはなりません

457
00:28:41,822 --> 00:28:45,592
並列テストで
このような状況に気付きます

458
00:28:45,692 --> 00:28:49,730
１つのクラスが
全体の時間に影響するのです

459
00:28:50,330 --> 00:28:52,933
このクラスを２つに分けて

460
00:28:53,233 --> 00:28:58,539
各ランナーに
より均等に分配してみましょう

461
00:28:58,705 --> 00:29:01,308
大幅な時間短縮が可能です

462
00:28:58,705 --> 00:29:01,308
大幅な時間短縮が可能です

463
00:29:02,176 --> 00:29:06,046
すべてのクラスを
分配する必要はないです

464
00:29:06,313 --> 00:29:11,485
支障があれば
一度 試してみる価値はあります

465
00:29:13,854 --> 00:29:16,256
次は並列化を無効にして

466
00:29:16,356 --> 00:29:19,993
パフォーマンステストを
バンドルに入れます

467
00:29:20,627 --> 00:29:22,262
疑問に思うでしょう

468
00:29:22,362 --> 00:29:26,567
しかしパフォーマンステストは
システムに影響されやすく

469
00:29:26,667 --> 00:29:31,338
並行テストでは
ベースラインを下回りがちです

470
00:29:33,440 --> 00:29:37,845
最後に並列テストに
向かないものを紹介します

471
00:29:38,445 --> 00:29:41,315
ほとんどのテストは適しています

472
00:29:41,415 --> 00:29:45,919
しかしアクセス先が
共有のシステムリソースだと

473
00:29:46,220 --> 00:29:50,858
並列テストのために
明確な同期化が必要です

474
00:29:52,226 --> 00:29:57,197
詳しく知りたい人は
コードのテスト方法も聞けるので

475
00:29:57,297 --> 00:29:59,633
金曜のセッションを勧めます

476
00:29:59,733 --> 00:30:03,136
スチュアートとブライアンが
話します

477
00:29:59,733 --> 00:30:03,136
スチュアートとブライアンが
話します

478
00:30:05,372 --> 00:30:06,473
このセッションでは

479
00:30:06,573 --> 00:30:09,276
コードカバレッジを紹介しました

480
00:30:09,376 --> 00:30:12,479
動作や精度の向上についてもです

481
00:30:13,247 --> 00:30:17,351
そしてテストの
順序化について話しました

482
00:30:17,451 --> 00:30:20,521
どのテストを実行して

483
00:30:20,621 --> 00:30:22,923
どの順番で行うかの設定です

484
00:30:23,791 --> 00:30:26,827
Parallel Distributed Testingでは

485
00:30:26,927 --> 00:30:30,364
異なるランナーに
テストクラスを分配し

486
00:30:30,464 --> 00:30:32,232
並列化しました

487
00:30:33,433 --> 00:30:37,805
developer.apple.comで
スライドをダウンロードできます

488
00:30:37,905 --> 00:30:40,541
午後のラボにもお越しください

489
00:30:41,241 --> 00:30:43,110
皆さん 良い時間を

490
00:30:43,210 --> 00:30:46,747
(拍手)