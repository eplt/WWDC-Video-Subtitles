1
00:00:20,354 --> 00:00:22,422
App与新一代网络


2
00:00:29,997 --> 00:00:31,632
谢谢 上午好


3
00:00:32,665 --> 00:00:36,036
欢迎参加“App与新一代网络”讲座


4
00:00:37,004 --> 00:00:41,175
我是普拉巴卡尔·拉卡拉
另外还有我的同事斯图尔特·柴歇尔


5
00:00:42,743 --> 00:00:44,778
今天的讲座分为两个部分


6
00:00:47,614 --> 00:00:49,950
第一个主题关于IPv6


7
00:00:50,450 --> 00:00:52,886
在第二个主题中斯图尔特将会介绍


8
00:00:53,387 --> 00:00:55,956
如何让你的APP更快地运行


9
00:00:57,791 --> 00:00:59,426
我们首先讨论IPv6


10
00:01:02,763 --> 00:01:04,431
IPv6有哪些新特性呢？


11
00:01:05,799 --> 00:01:09,837
在大约17年以前
IPv6 RFC就已经发表


12
00:01:11,338 --> 00:01:15,642
你可能会想今天我们
为什么要讨论IPv6？


13
00:01:17,878 --> 00:01:23,250
我们看到IPv6越来越多地


14
00:01:23,784 --> 00:01:25,118
被部署到企业和蜂窝网络之中


15
00:01:26,186 --> 00:01:27,487
你需要确保你的APP


16
00:01:27,855 --> 00:01:30,724
能够在这些网络中运行


17
00:01:33,160 --> 00:01:38,198
因此你的APP应该强制兼容IPv6


18
00:01:39,466 --> 00:01:42,436
现在我们将讨论这个主题 
以及它对于开发者的意义


19
00:01:43,036 --> 00:01:44,371
但是在此之前


20
00:01:44,972 --> 00:01:46,940
请让我们先回顾一下历史


21
00:01:50,277 --> 00:01:53,380
在前些年客户端设备具有真实


22
00:01:53,614 --> 00:01:57,851
唯一的IPv4 那是以前的事情了


23
00:01:57,918 --> 00:01:59,953
你需要进行端对端网络连接


24
00:02:01,855 --> 00:02:04,057
但是我们很快发现


25
00:02:04,258 --> 00:02:06,293
IPv4地址就快要用完了


26
00:02:07,261 --> 00:02:09,496
因此我们在中间加入NAT


27
00:02:10,931 --> 00:02:15,169
这个方法是可行的
但是大规模的NAT设备


28
00:02:15,235 --> 00:02:17,137
不仅昂贵而且脆弱


29
00:02:18,672 --> 00:02:22,042
因此现在运营商
在他们的网络中部署IPv6


30
00:02:25,045 --> 00:02:28,949
利用IPv6以继续提供
端对端网络连接，


31
00:02:29,316 --> 00:02:31,351
不需要在数据路径中进行转换


32
00:02:33,420 --> 00:02:39,059
现在 让我们来看美国三个主要
蜂窝运营商的IPv6部署情况


33
00:02:42,196 --> 00:02:43,530
我们可以看到两个特点


34
00:02:44,264 --> 00:02:47,134
首先所有趋势线都是上升的


35
00:02:48,435 --> 00:02:51,271
其次一半以上的用户


36
00:02:51,338 --> 00:02:53,307
现在通过IPv6连接到


37
00:02:53,373 --> 00:02:55,742
蜂窝数据网络


38
00:02:57,477 --> 00:02:58,378
看起来不错是吧


39
00:02:59,313 --> 00:03:01,148
但是对于网络运营商来说


40
00:03:01,215 --> 00:03:03,350
实际情况比以前更加糟糕


41
00:03:04,284 --> 00:03:09,623
原因是他们的网络现在必须同时


42
00:03:10,023 --> 00:03:12,159
支持IPv4和IPv6


43
00:03:13,427 --> 00:03:16,830
他们真正需要的是消除通过IPv4


44
00:03:17,130 --> 00:03:18,198
访问他们的网络


45
00:03:19,233 --> 00:03:21,735
如果这样做将会导致


46
00:03:21,802 --> 00:03:23,937
完全依靠IPv4
连接网络的设备和用户流失


47
00:03:24,371 --> 00:03:25,606
但 他们仍然是主流


48
00:03:28,041 --> 00:03:31,745
现在运营商在他们的网络中
部署NS64和NAT64


49
00:03:32,312 --> 00:03:35,148
其实现方式是当客户端设备上的APP


50
00:03:35,215 --> 00:03:37,784
进行主机名称查询


51
00:03:38,218 --> 00:03:41,755
以获得IPv4-only服务器的
IPv6地址时


52
00:03:42,623 --> 00:03:47,194
DNS64和网络
将合成一个IPv6地址


53
00:03:47,327 --> 00:03:48,829
并提供给客户端设备


54
00:03:50,564 --> 00:03:53,967
现在客户端设备可以
使用这个IPv6地址


55
00:03:54,234 --> 00:03:56,303
发送流量至网络


56
00:03:57,638 --> 00:03:59,873
网络的配置方式


57
00:04:00,040 --> 00:04:03,710
使搜索数据包被发送给NAT64引擎


58
00:04:04,211 --> 00:04:06,880
NAT64引擎
将IPv6流量转换成为IPv4流量


59
00:04:07,314 --> 00:04:09,983
在客户端设备返回流量时
NAT64引擎将进行相反的转换


60
00:04:12,352 --> 00:04:14,354
在这里 必须注意的是


61
00:04:14,888 --> 00:04:17,457
对于客户端设备上运行的APP来说


62
00:04:18,559 --> 00:04:23,730
你的IPv4-only服务器
看去就你是IPv6-only服务器


63
00:04:24,565 --> 00:04:25,933
这个特性很重要


64
00:04:26,967 --> 00:04:29,303
因为你们一些人可能会认为


65
00:04:30,003 --> 00:04:32,272
我的服务器仅配置用于IPv4


66
00:04:32,773 --> 00:04:37,611
因此我不需要针对通过IPv6进行
访问的客户端来测试我的APP


67
00:04:39,046 --> 00:04:40,747
你的假设并不成立


68
00:04:42,416 --> 00:04:43,584
我们很快就会转换到


69
00:04:43,650 --> 00:04:46,753
到这种类型的网络 到那时


70
00:04:47,754 --> 00:04:51,325
我们希望为用户提供无缝的用户体验


71
00:04:52,292 --> 00:04:58,899
因此你的APP必须支持IPv6


72
00:05:00,200 --> 00:05:02,669
APP必须符合这项要求


73
00:05:04,538 --> 00:05:06,640
这是一项新的APP要求


74
00:05:07,007 --> 00:05:10,344
你可能会想我应该如何针对此网络
来测试我的APP呢?


75
00:05:11,011 --> 00:05:13,280
我可以在哪里找到这种
NAT64类型的网络?


76
00:05:14,348 --> 00:05:16,583
我有一个好消息告诉你们


77
00:05:19,086 --> 00:05:21,922
你可以使用基于
IPv4连接的Mac设备


78
00:05:22,322 --> 00:05:26,793
创建你自己的NAT64网络


79
00:05:27,060 --> 00:05:29,396
并可以开始测试你的APP


80
00:05:31,064 --> 00:05:33,367
这项新功能供开发人员使用


81
00:05:33,767 --> 00:05:37,337
它隐藏起来了
让我们来看清楚一点你只需要


82
00:05:37,404 --> 00:05:44,344
点击“Sharing”选项
然后点击


83
00:05:44,411 --> 00:05:48,549
“Internet Sharing”
选项其他保持不变


84
00:05:49,449 --> 00:05:51,451
这里有一个新复选框显示


85
00:05:51,852 --> 00:05:53,954
“create
NAT64 network” 


86
00:05:55,189 --> 00:05:58,158
选中之后 可以选择


87
00:05:58,225 --> 00:06:02,095
Internet共享接口
然后使用这个NAT64网络


88
00:06:03,230 --> 00:06:04,731
开始测试你的APP


89
00:06:05,866 --> 00:06:09,937
在这里举例来说我有一个
IPv4 Internet连接


90
00:06:10,070 --> 00:06:12,339
我想要使用NAT64/DNS64


91
00:06:12,573 --> 00:06:17,311
将这个连接作为
IPv6-only访问网络


92
00:06:17,644 --> 00:06:19,146
在我的Wi-Fi
接口上进行共享


93
00:06:19,813 --> 00:06:25,285
当我开始这样做时我看到
Wi-Fi图标变灰


94
00:06:25,586 --> 00:06:27,154
并且变成箭头


95
00:06:29,389 --> 00:06:31,225
这表明Wi-Fi接口


96
00:06:31,658 --> 00:06:33,827
转为接入点模式


97
00:06:34,528 --> 00:06:37,931
其意义在于它成为一个Wi-Fi热点


98
00:06:38,198 --> 00:06:40,067
你可以连接其他客户端设备


99
00:06:40,200 --> 00:06:41,502
并开始测试你的APP


100
00:06:42,503 --> 00:06:44,505
典型的测试平台是这样的


101
00:06:46,673 --> 00:06:49,843
在WAN侧 IPv4
Internet连接已经完成


102
00:06:50,077 --> 00:06:54,381
我的iMac已经在运行
DNS64/NAT64引擎


103
00:06:54,781 --> 00:06:58,852
成为使用Wi-Fi接口的
IPv6网络热点


104
00:07:00,087 --> 00:07:04,591
你想要测试的APP
已经安装在一台客户端机器上


105
00:07:05,192 --> 00:07:06,960
你也可以在其他Mac设备上


106
00:07:07,060 --> 00:07:09,530
运行的模拟器上测试你的APP


107
00:07:10,130 --> 00:07:12,666
这个Mac必须是 
此Internet共享环境的客户端


108
00:07:14,668 --> 00:07:17,237
现在 你已经可以


109
00:07:17,938 --> 00:07:21,308
在这种类型的网络进行测试 
你真正想做的事情是


110
00:07:21,675 --> 00:07:25,212
确保这种网络成为开发流程的组成部分


111
00:07:26,346 --> 00:07:28,815
也就是说在任何时候
当你编写新的APP


112
00:07:29,116 --> 00:07:31,385
或者编写APP更新版本时


113
00:07:31,785 --> 00:07:33,086
你需要在提交APP之前


114
00:07:33,153 --> 00:07:37,591
确保在NAT64网络环境下
测试你的APP


115
00:07:39,359 --> 00:07:43,997
现在对你们70%的人来说
这是一个好消息


116
00:07:44,064 --> 00:07:46,500
你的APP运行正常


117
00:07:46,767 --> 00:07:47,968
这很不错吧


118
00:07:48,735 --> 00:07:50,437
你可以放心地测试


119
00:07:50,737 --> 00:07:54,074
各个版本的APP
确保不会有功能受到影响


120
00:07:55,676 --> 00:07:57,244
但是有将近三分之一的人


121
00:07:58,178 --> 00:08:01,782
将会看到
在NAT64MQXT网络环境下


122
00:08:01,849 --> 00:08:05,752
你的APP要么受到严重的限制
或者根本无法运行


123
00:08:07,221 --> 00:08:09,790
幸运的是大多数问题都容易修复


124
00:08:10,724 --> 00:08:11,658
这里是一个例子


125
00:08:18,932 --> 00:08:23,203
现在如果你只使用
IPv4-only数据结构


126
00:08:23,437 --> 00:08:28,108
或IPv4-only API
或者你使用同时支持


127
00:08:28,175 --> 00:08:30,711
IPv4和IPv6的API


128
00:08:31,345 --> 00:08:34,414
但是你传递一个参数


129
00:08:34,881 --> 00:08:38,784
声明你只想获得IPv4结果


130
00:08:40,354 --> 00:08:43,657
这会导致你的APP仅支持IPv4


131
00:08:44,324 --> 00:08:48,896
这意味着 你的APP将无法在
IPv6-only网络环境下运行


132
00:08:50,797 --> 00:08:53,567
对于这些无法运行的APP


133
00:08:53,834 --> 00:08:56,203
我们看到另外一件有意思的事情


134
00:08:57,771 --> 00:09:00,107
有时候在尝试连接之前


135
00:09:00,207 --> 00:09:03,877
APP会预先选择IPv4连接


136
00:09:05,045 --> 00:09:08,949
因此有时候你会看到这样的错误信息


137
00:09:10,851 --> 00:09:14,621
在这种情况下我的iPhone
确实连接到我的Mac设备上


138
00:09:14,688 --> 00:09:17,724
创建的NAT64网络


139
00:09:18,492 --> 00:09:20,694
我可以使用Safari 
浏览互联网内容


140
00:09:20,761 --> 00:09:22,863
我可以观看视频 听音乐...


141
00:09:23,664 --> 00:09:25,132
我的Internet连接正常


142
00:09:25,666 --> 00:09:30,571
但是出于一些原因APP认为我没有
Internet连接


143
00:09:31,371 --> 00:09:34,308
你会看到提示信息


144
00:09:34,374 --> 00:09:36,410
说你的设备处于飞行模式


145
00:09:37,344 --> 00:09:40,647
但是顶部信息栏却不是这样显示的


146
00:09:42,382 --> 00:09:43,951
那么这是为什么呢？ 


147
00:09:44,418 --> 00:09:47,254
这是因为APP预先


148
00:09:47,321 --> 00:09:50,824
设置成为IPv4连接


149
00:09:51,291 --> 00:09:54,428
但是在IPv6-only访问网络中
例如NAT64网络


150
00:09:55,062 --> 00:09:57,364
并没有IPv4连接


151
00:09:57,664 --> 00:10:01,168
整个网络对你来说
完全是一个IPv6-only网络


152
00:10:01,535 --> 00:10:05,272
即使IPv4-only服务器
看上去像是IPv6-only服务器


153
00:10:05,672 --> 00:10:07,508
因此如果选择这样的设置
将会发生失败


154
00:10:08,375 --> 00:10:11,044
在这种情况下APP将会提示你重试


155
00:10:11,144 --> 00:10:13,881
我进行重试但是仍然会
显示相同的错误信息


156
00:10:14,381 --> 00:10:16,617
然后我再重试仍然显示相同的错误信息


157
00:10:17,251 --> 00:10:20,287
这个信息不会消失因此
无法使用APP进行其他操作


158
00:10:21,221 --> 00:10:22,823
对此有什么好方法吗？


159
00:10:24,391 --> 00:10:26,593
应该尝试连接


160
00:10:27,961 --> 00:10:30,163
如果能够连接成功当然是好了


161
00:10:30,464 --> 00:10:33,400
如果不能应该巧妙地进行处理


162
00:10:34,968 --> 00:10:36,603
第二个建议是


163
00:10:36,670 --> 00:10:40,474
使用更高级别的网络框架
例如NSURLSession


164
00:10:41,041 --> 00:10:42,809
或CFNetwork API


165
00:10:43,577 --> 00:10:50,450
原因是像iPhone
和Mac等多址设备的


166
00:10:51,351 --> 00:10:54,454
网络连接有一点复杂


167
00:10:55,989 --> 00:10:57,791
比如iPhone
不仅有Wi-Fi接口


168
00:10:57,858 --> 00:10:59,393
还有蜂窝网络接口


169
00:10:59,593 --> 00:11:02,029
多于Mac设备可能有多个以太网接口


170
00:11:02,162 --> 00:11:04,731
而且也有Wi-Fi接口


171
00:11:05,199 --> 00:11:07,467
在特定的时间


172
00:11:07,568 --> 00:11:09,870
所有这些接口可能有不同类型的连接


173
00:11:11,371 --> 00:11:16,009
你需要考虑使用哪个接口
如何进行这种类型的连接


174
00:11:16,076 --> 00:11:18,312
以连接到特定的目标


175
00:11:18,879 --> 00:11:22,082
自已编写代码可能会费时费力


176
00:11:22,716 --> 00:11:25,552
因此应该使用更高层次的网络框架


177
00:11:25,886 --> 00:11:29,289
这会让你的APP代码更加简洁明了


178
00:11:31,291 --> 00:11:34,862
如果出于某些原因
你不能使用更高层次的网络框架 


179
00:11:35,462 --> 00:11:37,030
而且你必须使用socket


180
00:11:37,965 --> 00:11:41,301
我们建议你阅读RFC 4038


181
00:11:42,202 --> 00:11:45,772
此RFC详细地介绍了如何在地址族


182
00:11:46,039 --> 00:11:47,908
不可知的情况下编写APP


183
00:11:50,611 --> 00:11:54,248
我们的最后建议是尽可能使用主机名


184
00:11:54,314 --> 00:11:57,117
而不是直接使用IP地址


185
00:11:57,284 --> 00:11:58,852
无论IPv4或IPv6


186
00:11:59,786 --> 00:12:02,222
当你编写自己的专用协议


187
00:12:02,289 --> 00:12:04,491
或者编写APP时


188
00:12:04,558 --> 00:12:08,161
应确保不要直接使用IP地址


189
00:12:08,562 --> 00:12:09,730
而应该优先使用主机名


190
00:12:10,364 --> 00:12:11,632
其原因是


191
00:12:11,999 --> 00:12:14,368
在NAT64/DNS64网络环境中


192
00:12:15,469 --> 00:12:17,871
客户端设备首先会发出DNS查询请求


193
00:12:18,405 --> 00:12:20,440
以获得IPv4服务器的IPv6地址


194
00:12:20,641 --> 00:12:22,943
因此你必须使用主机名


195
00:12:23,243 --> 00:12:25,512
如果你需要使用IPv4地址


196
00:12:26,113 --> 00:12:28,415
客户端设备将不会进行DNS查询


197
00:12:28,916 --> 00:12:32,853
DNS64网络将不会
为你合成IPv6地址


198
00:12:35,422 --> 00:12:37,758
我们知道有时候可能


199
00:12:38,725 --> 00:12:45,499
无法避免使用IPv4
例如使用Safari进行浏览时


200
00:12:46,200 --> 00:12:48,669
你打开一个网页显示正常


201
00:12:49,269 --> 00:12:52,139
但是在网页内可能有其他一些链接


202
00:12:53,841 --> 00:12:57,311
这些链接可能具有嵌入的IPv4地址


203
00:12:59,179 --> 00:13:02,249
在此之前在Safari浏览器中


204
00:13:02,316 --> 00:13:04,151
如果你点击这样的链接
将不会打开网页


205
00:13:06,053 --> 00:13:10,791
从iOS 9
和OS X 10.11开始


206
00:13:11,225 --> 00:13:13,393
不仅Safari而且任何


207
00:13:13,493 --> 00:13:18,265
NSURLSession或
CFNetwork API用户


208
00:13:18,632 --> 00:13:23,270
将能够在NAT64/DNS64
网络中使用IPv4地址


209
00:13:24,605 --> 00:13:26,740
其工作原理是当你使用主机名时


210
00:13:27,708 --> 00:13:31,111
网络中的DNS64将会
为你合成IPv6 地址


211
00:13:32,546 --> 00:13:35,816
但是当你直接使用IPv4地址


212
00:13:35,883 --> 00:13:38,118
并且使用一个更高层次网络API时


213
00:13:39,019 --> 00:13:42,823
操作系统将会发现网络行为


214
00:13:42,890 --> 00:13:45,425
并确定它将如何为你


215
00:13:45,492 --> 00:13:47,694
合成IPv6 地址
并在本地完成此工作


216
00:13:48,562 --> 00:13:51,565
这也是你为什么应该使用更高层次


217
00:13:51,632 --> 00:13:52,999
网络框架的另一个原因


218
00:13:53,634 --> 00:13:54,468
因此应该这样做


219
00:13:56,670 --> 00:14:00,641
希望你能够利用这些数据点


220
00:14:01,275 --> 00:14:05,312
和新工具找到并解决APP中的问题


221
00:14:07,748 --> 00:14:12,052
我们希望你做的事情是
在本讲座结束之后


222
00:14:12,419 --> 00:14:14,821
在你们的Mac设备上
安装seed build


223
00:14:15,222 --> 00:14:17,758
开始创建自己的NAT64网络


224
00:14:18,392 --> 00:14:20,160
然后使用它们测试你的APP


225
00:14:21,495 --> 00:14:24,798
请记住这是APP应该遵守的一项要求


226
00:14:25,732 --> 00:14:28,235
请将这个信息传达给


227
00:14:28,902 --> 00:14:31,638
未参加本讲座的其他开发人员


228
00:14:31,705 --> 00:14:35,909
并且把这个消息带回你的公司确保使用
NAT64网络测试你的APP


229
00:14:38,145 --> 00:14:43,016
现在请斯图尔特·柴歇尔上台


230
00:14:43,083 --> 00:14:45,352
为大家介绍其他的网络功能


231
00:14:45,752 --> 00:14:48,121
你们可以使用这些功能
更快速地开发APP


232
00:14:48,455 --> 00:14:50,490
并且提高APP的响应速度


233
00:14:51,358 --> 00:14:52,192
有请斯图尔特


234
00:14:59,132 --> 00:14:59,967
谢谢普拉巴卡尔


235
00:15:02,536 --> 00:15:07,074
我们想要讨论
如何让APP加快运行速度


236
00:15:09,109 --> 00:15:10,544
在过去的几十年里


237
00:15:10,611 --> 00:15:14,081
我们看到网络吞吐量飞速增长


238
00:15:15,048 --> 00:15:18,986
我还记得在以前
56k调制解调器就已经


239
00:15:19,052 --> 00:15:21,321
属于尖端科技而现在


240
00:15:21,388 --> 00:15:24,691
50Mb/s网速已经很常见


241
00:15:25,592 --> 00:15:27,761
但是我们并没有感觉到网速成千倍提升


242
00:15:28,629 --> 00:15:32,132
我们仍然需要花大量的时间来
等待网页打开


243
00:15:32,432 --> 00:15:33,267
这是为什么呢？


244
00:15:34,701 --> 00:15:38,305
这是因为我们的行业专注于


245
00:15:38,405 --> 00:15:40,107
提升吞吐量


246
00:15:41,175 --> 00:15:44,978
但是却忽略其他资源延迟


247
00:15:46,146 --> 00:15:48,148
光速不会变得更快


248
00:15:48,916 --> 00:15:52,019
对此我们无能为力但是我们可以


249
00:15:52,119 --> 00:15:55,355
消除其它方面的延迟
现在我们应该致力于这些工作


250
00:15:56,190 --> 00:15:58,492
这就是我今天要讨论的主题


251
00:15:59,560 --> 00:16:03,297
我想要讨论四种类型的资源延迟


252
00:16:03,897 --> 00:16:05,799
当用户使用APP可能会遇到这些延迟


253
00:16:06,967 --> 00:16:09,770
首先是当你遇到
信号较弱的WiFi连接


254
00:16:10,070 --> 00:16:12,940
而且连接不成功时


255
00:16:13,307 --> 00:16:14,975
会遇到的延迟


256
00:16:15,976 --> 00:16:19,780
第二个是使用“显式拥塞通知”


257
00:16:19,847 --> 00:16:21,949
即“Explicit Congestion
Notification”技术


258
00:16:22,015 --> 00:16:25,853
和智能队列功能来减少网络延迟


259
00:16:27,020 --> 00:16:32,092
TCP NOTSENT
Low-WaterMark选项


260
00:16:32,526 --> 00:16:35,429
减少发送机器中的延迟


261
00:16:35,495 --> 00:16:36,964
最后我们将了解


262
00:16:37,097 --> 00:16:39,900
一种名为TCP Fast Open的 
令人激动新的技术


263
00:16:40,734 --> 00:16:44,238
我们先开始讨论如何进行
可靠的网络回退操作


264
00:16:45,405 --> 00:16:48,709
我相信你们每个人都有这样的经历


265
00:16:49,076 --> 00:16:52,179
下班之后离开办公室


266
00:16:52,579 --> 00:16:55,048
走向你的汽车拿出手机


267
00:16:55,749 --> 00:17:01,421
然后想要查看地图
天气预报和邮件等


268
00:17:02,055 --> 00:17:06,859
你盯着手机但是
没有载入任何内容你走向汽车


269
00:17:06,926 --> 00:17:09,195
但是仍然没载入内容你感到烦躁不安


270
00:17:09,262 --> 00:17:11,164
于是你进入“设置“关闭Wi-Fi


271
00:17:11,698 --> 00:17:13,834
使用LTE数据连接网页瞬间打开了


272
00:17:15,068 --> 00:17:17,069
然后你忘记打开Wi-FI


273
00:17:17,137 --> 00:17:20,207
一周之后你收到巨额的数据流量账单
这可不是你想要的


274
00:17:20,374 --> 00:17:22,709
对于用户体验来说这是糟糕的事情


275
00:17:23,911 --> 00:17:28,147
现在我们要做的事情是


276
00:17:28,482 --> 00:17:30,150
设置并行连接数字逻辑


277
00:17:31,018 --> 00:17:33,520
这样如果你的iPhone
检测到它在使用Wi-Fi


278
00:17:34,821 --> 00:17:38,325
但是却无法建立TCP连接


279
00:17:38,892 --> 00:17:44,598
这时它会很快地通过蜂窝数据网络


280
00:17:44,665 --> 00:17:47,367
发起第二个并行连接


281
00:17:47,434 --> 00:17:49,803
但是它不会完全中止Wi-Fi连接


282
00:17:49,870 --> 00:17:51,371
并不会放弃Wi-Fi连接


283
00:17:51,438 --> 00:17:53,373
它会并行尝试Wi-Fi连接


284
00:17:53,907 --> 00:17:56,510
如果连接成功


285
00:17:56,710 --> 00:17:58,111
将会转到Wi-Fi连接


286
00:17:58,812 --> 00:18:02,349
如果连接不成功
蜂窝网络连接将率先完成


287
00:18:02,416 --> 00:18:05,752
这样APP的网络连接延将


288
00:18:06,954 --> 00:18:10,190
将会很短用户甚至不会发现


289
00:18:11,258 --> 00:18:13,460
当然此功能仅用于


290
00:18:13,527 --> 00:18:15,462
允许使用蜂窝网络的APP


291
00:18:15,963 --> 00:18:17,631
如果用户进入设置


292
00:18:17,698 --> 00:18:20,901
禁止APP连接数据网络
我们将不会进行这种回退


293
00:18:22,069 --> 00:18:25,172
如果我们进行回退将
会隐藏Wi-Fi图标


294
00:18:25,606 --> 00:18:28,509
让用户知道他们没有使用Wi-Fi


295
00:18:31,545 --> 00:18:32,946
如果你使用更高层次的API


296
00:18:33,347 --> 00:18:36,650
这并不会占用额外的资源


297
00:18:37,317 --> 00:18:40,921
而且这并不会影响


298
00:18:40,988 --> 00:18:42,656
用户获得良好的使用体验


299
00:18:44,024 --> 00:18:45,893
你还需要做另外一件事情


300
00:18:46,827 --> 00:18:50,631
也就是当你在蜂窝网络上运行时


301
00:18:52,099 --> 00:18:54,701
无论你首先连接到蜂窝网络


302
00:18:54,768 --> 00:18:56,537
还是回退到蜂窝网络


303
00:18:57,304 --> 00:19:01,041
用户最后还可能会
回到Wi-Fi范围之内


304
00:19:01,275 --> 00:19:04,044
那时，你将会看到
“Better Route”通知


305
00:19:04,611 --> 00:19:06,680
然后你可以决定应该怎么做


306
00:19:07,347 --> 00:19:11,418
你可能想要断开数据连接
重新连接到Wi-Fi


307
00:19:12,486 --> 00:19:15,055
或者如果你的邮件
发送进度已经达到99%


308
00:19:15,122 --> 00:19:17,357
你可能想要完成发送


309
00:19:17,424 --> 00:19:19,626
但是
“Better Route”通知


310
00:19:19,693 --> 00:19:21,161
让你能够进行


311
00:19:21,461 --> 00:19:23,130
智能化的决定


312
00:19:23,430 --> 00:19:26,333
从而尽量减少数据流量费用


313
00:19:31,205 --> 00:19:33,574
下一个主题是网络中的延迟


314
00:19:35,075 --> 00:19:39,546
这是我在Apple TV
开发中遇到的问题


315
00:19:39,646 --> 00:19:43,383
我们努力提高Apple TV的
响应速度


316
00:19:43,717 --> 00:19:45,686
和理解延迟来源


317
00:19:46,420 --> 00:19:50,224
我期望你们在座的每个人都听说过
“bufferbloat”即“缓存膨胀”


318
00:19:51,391 --> 00:19:54,728
我做过一些实验并且想和你们分享


319
00:19:54,795 --> 00:19:56,129
这些实验的结果


320
00:19:56,396 --> 00:20:02,302
让你们理解对于我们的
所有APP和产品来说


321
00:20:02,603 --> 00:20:04,438
消除网络中的缓存膨胀问题是多么重要


322
00:20:05,706 --> 00:20:09,209
我测试过一个10Mb下行速度


323
00:20:09,676 --> 00:20:14,481
模拟网络环境，


324
00:20:14,548 --> 00:20:18,519
这种网速对于观看视频来说已经足够了


325
00:20:18,585 --> 00:20:24,424
我将显示使用代表性
网络设置所获得的结果


326
00:20:25,192 --> 00:20:28,061
这是一种简单的先进先出队列


327
00:20:28,428 --> 00:20:30,597
数据包被缓存直到队列变满


328
00:20:30,664 --> 00:20:34,067
不能再容纳更多数据包
新到达的数据包将被丢弃


329
00:20:35,002 --> 00:20:38,405
这是现今的家用网关的典型配置


330
00:20:39,173 --> 00:20:42,876
我将介绍另外一种更智能的
队列处理方法和ECN机制并进行比较


331
00:20:44,545 --> 00:20:48,081
我将介绍一些
使用tcptrace的方案


332
00:20:49,016 --> 00:20:52,486
我期望你们
很多人都使用过tcptrace


333
00:20:52,819 --> 00:20:56,256
如果你们没有使用过
我强烈建议你们访问


334
00:20:56,323 --> 00:20:58,892
TCPtrace.org并下载它


335
00:20:59,793 --> 00:21:02,829
如果你要编写网络代码


336
00:21:03,363 --> 00:21:06,233
而且不使用tcptrace
来查看你的数据包


337
00:21:06,567 --> 00:21:10,604
你将没有办法弄清楚


338
00:21:10,904 --> 00:21:13,106
运行机制或理解APP 


339
00:21:13,340 --> 00:21:15,375
和协议的性能特征


340
00:21:16,143 --> 00:21:19,780
在我们编写APP时
应该注意内存使用情况


341
00:21:20,480 --> 00:21:24,184
应该分析代码
弄清楚哪些代码占用CPU


342
00:21:24,618 --> 00:21:26,587
然后优化代码


343
00:21:26,720 --> 00:21:29,756
以提高CPU效率
并且延长电池使用时间


344
00:21:31,191 --> 00:21:36,230
为此应该多关注CPU
和内存使用情况


345
00:21:36,763 --> 00:21:39,766
但是也不能忽略网络部分


346
00:21:39,900 --> 00:21:43,604
Tcptrace是一个工具
让你能够方便地


347
00:21:43,737 --> 00:21:46,106
进行网络分析分析网络流量


348
00:21:48,141 --> 00:21:51,845
这是一个流媒体视频的


349
00:21:52,112 --> 00:21:53,480
前10秒的TCPtrace


350
00:21:53,947 --> 00:21:56,183
如果你们一些人
以前没有见过tcptrace


351
00:21:56,250 --> 00:21:58,252
让我来简要介绍一下


352
00:21:58,952 --> 00:22:01,755
这些白色的短线条表示数据包


353
00:22:02,823 --> 00:22:08,929
白色线条所处的位置
表示数据包被捕获的时间


354
00:22:10,364 --> 00:22:15,002
白色线条的高度告诉我们


355
00:22:15,068 --> 00:22:18,305
数据包有多少字节线条的垂直位置


356
00:22:18,372 --> 00:22:21,808
告诉我们在整个逻辑TCP序列，
数字空间内的哪些位置


357
00:22:22,176 --> 00:22:25,946
收到这些数据包


358
00:22:26,980 --> 00:22:30,450
在这里我们可以看到
正在按顺序向外发送数据包流


359
00:22:30,951 --> 00:22:33,287
其间隔为数毫秒


360
00:22:34,655 --> 00:22:37,357
在返回数据时
我们看到接收端的应答消息


361
00:22:37,424 --> 00:22:39,159
声称它已经收到数据


362
00:22:40,360 --> 00:22:44,031
绿色线条表示累积应答线条


363
00:22:44,498 --> 00:22:48,802
所有数据包括绿色线条
都得到接收端的确认


364
00:22:49,636 --> 00:22:53,774
因此没有任何白色数据包
位于绿色线条之下


365
00:22:54,408 --> 00:22:55,542
那将表示存在bug


366
00:22:56,343 --> 00:22:59,680
我们看到没有白色数据包
位于绿色线条之下这说明一切正常


367
00:23:01,381 --> 00:23:04,585
黄色线条表示接收窗口


368
00:23:05,285 --> 00:23:10,390
当你打开TCP连接时
接收端将指示它分配多少内存


369
00:23:11,592 --> 00:23:17,898
来接收你的数据
不应该超过这个分配给你的内存量限值


370
00:23:18,532 --> 00:23:22,035
如果你看到白色数据包位于黄色线之上


371
00:23:22,336 --> 00:23:24,171
表示存在bug我们没有看到这种情况


372
00:23:24,371 --> 00:23:25,205
这说明一切正常


373
00:23:28,041 --> 00:23:30,911
数据传输看起来


374
00:23:30,978 --> 00:23:33,413
显示为一条直线


375
00:23:33,480 --> 00:23:37,084
这条曲线的斜率是10Mb/s


376
00:23:37,818 --> 00:23:41,989
这正是我们所期望的但是每隔几秒


377
00:23:42,089 --> 00:23:43,690
我们看到这种情况


378
00:23:44,358 --> 00:23:48,562
让我们来放大仔细观察


379
00:23:48,795 --> 00:23:50,330
发生了什么


380
00:23:52,933 --> 00:23:56,203
这些TCPtrace
图形提供丰富的信息


381
00:23:56,737 --> 00:23:59,640
我可以花上一个小时的时间
来讲解这些幻灯片


382
00:23:59,973 --> 00:24:01,675
但是我们并没有时间这样做


383
00:24:02,042 --> 00:24:07,781
我会讲解这个图形中的一些重要信息


384
00:24:09,283 --> 00:24:14,421
首先白色数据包线看起来正在


385
00:24:15,455 --> 00:24:16,990
偏离绿色应答线条


386
00:24:17,724 --> 00:24:20,861
这意味着我们将数据发送到


387
00:24:20,928 --> 00:24:25,699
网络的速度快于数据从另一侧被输出


388
00:24:25,799 --> 00:24:27,601
和被应答的数据


389
00:24:28,068 --> 00:24:29,970
如果数据被输入的速度


390
00:24:30,470 --> 00:24:31,872
快于被输出的速度


391
00:24:33,540 --> 00:24:34,875
情况就会变得不一样


392
00:24:35,409 --> 00:24:40,514
数据将会进入缓存网络缓存中的


393
00:24:40,681 --> 00:24:44,618
旧数据将会增大


394
00:24:45,252 --> 00:24:47,421
由于缓存数据量增大


395
00:24:47,855 --> 00:24:51,692
意味着数据包发送与


396
00:24:51,758 --> 00:24:54,461
接收端应答之间的往返延迟增大


397
00:24:56,597 --> 00:24:58,298
当缓存数据量达到一定程度时


398
00:24:58,599 --> 00:25:01,001
网关将无法缓存更多数据


399
00:25:01,301 --> 00:25:02,669
将开始出现丢包现象


400
00:25:04,404 --> 00:25:08,141
将会发生混乱而且是非常严重的混乱


401
00:25:08,442 --> 00:25:13,180
因此数据包进入队列末尾的速度


402
00:25:13,247 --> 00:25:18,218
将会快于数据包出列的速度
我们收到数据包但是会丢失它们


403
00:25:18,719 --> 00:25:20,120
其他数据包也会被丢失


404
00:25:20,387 --> 00:25:22,923
队列被清空一点
我们获得一个数据包接受它


405
00:25:23,490 --> 00:25:27,294
在队列的末尾是一片混乱


406
00:25:27,361 --> 00:25:30,664
它获得一个数据包就会丢失一个数据包


407
00:25:31,832 --> 00:25:33,233
但是在队列前部


408
00:25:33,700 --> 00:25:38,005
有200个数据包依次排列等待
它们需要有序地


409
00:25:38,071 --> 00:25:40,207
经过10Mb瓶颈链路


410
00:25:40,340 --> 00:25:42,776
不能有间隔不能发生问题


411
00:25:43,177 --> 00:25:45,946
只有在整个队列的数据


412
00:25:46,380 --> 00:25:48,282
发送完之后我们才会看到


413
00:25:48,348 --> 00:25:50,984
反映在发送端选择性应答消息中的


414
00:25:51,785 --> 00:25:54,988
接收端的数据包丢失情况


415
00:25:55,322 --> 00:25:56,623
然后开始进行补包


416
00:25:57,057 --> 00:25:58,992
因此这是严重的混乱现象


417
00:26:01,795 --> 00:26:04,231
由于网络传输API的工作方式


418
00:26:04,865 --> 00:26:06,266
数据必须依次传输


419
00:26:07,634 --> 00:26:10,771
如果一个数据包丢挡住


420
00:26:10,838 --> 00:26:12,806
其后抵达的所有数据包
在内核中将被延迟


421
00:26:13,040 --> 00:26:14,608
直到间隙被填满


422
00:26:15,075 --> 00:26:17,911
这是有道理的


423
00:26:18,145 --> 00:26:21,114
很多人曾经建议使用无序传输方法


424
00:26:21,515 --> 00:26:24,284
但是结果发现几乎所有APP都很难


425
00:26:24,351 --> 00:26:25,619
使用无序数据


426
00:26:25,919 --> 00:26:29,890
如果你要解码H.264视频


427
00:26:29,957 --> 00:26:33,193
只获得数据帧而无法获得它们
所依赖的I-Frame将不会有意义


428
00:26:33,560 --> 00:26:38,866
因此顺序数据传输确实是
APP所需的传输模式


429
00:26:40,767 --> 00:26:42,336
顺序数据传输导致


430
00:26:42,803 --> 00:26:45,405
我们看到这些长时间的空白期
在此期间没有数据传输


431
00:26:46,173 --> 00:26:49,543
对于Apple TV
视频回放流程来说


432
00:26:50,043 --> 00:26:52,846
这相当于一个无信号时间段


433
00:26:53,013 --> 00:26:54,181
在此期间将接收不到数据


434
00:26:54,815 --> 00:26:58,085
我们不想要视频卡住


435
00:26:58,819 --> 00:27:02,422
因此所有流媒体视频
都需要一个回放缓冲区


436
00:27:03,457 --> 00:27:06,627
较大的回放缓冲区意味着


437
00:27:06,727 --> 00:27:08,262
当你观看流媒体视频时


438
00:27:08,595 --> 00:27:11,532
你会看到不断旋转的图标提示正在缓冲


439
00:27:12,032 --> 00:27:14,134
因为缓冲区还有填满


440
00:27:14,401 --> 00:27:19,239
因此当长时间没有数据到达时
可能会始终显示这个图标


441
00:27:20,240 --> 00:27:23,277
当丢失的数据包到达时
我们开始填满间隙


442
00:27:23,477 --> 00:27:24,745
并且立即播放视频


443
00:27:26,580 --> 00:27:30,884
这将会给网络接收线程带来额外的负担


444
00:27:31,518 --> 00:27:36,089
它需要将CPU时间分配给
视频播放线程之外的其他线程


445
00:27:36,690 --> 00:27:40,327
从而造成视频播放卡顿


446
00:27:40,427 --> 00:27:41,261
这不是我们想要的


447
00:27:43,730 --> 00:27:48,735
这种不均衡的网络数据传输
给Apple TV等设备


448
00:27:48,836 --> 00:27:51,471
造成不佳的用户体验在我们努力降低


449
00:27:52,005 --> 00:27:54,741
设备的成本时


450
00:27:55,542 --> 00:27:59,112
这种长时间的数据空白期


451
00:27:59,346 --> 00:28:02,549
相当于我们需要增大设备内存
来缓存更多数据


452
00:28:03,217 --> 00:28:07,421
并且推迟视频开始时间和降低用户体验


453
00:28:08,789 --> 00:28:12,993
这种传输不均衡现象


454
00:28:13,060 --> 00:28:15,562
还会导致设备需要更快的CPU


455
00:28:15,829 --> 00:28:16,930
从而抬升设备价格


456
00:28:17,431 --> 00:28:24,304
因此对于流媒体视频来说
这种不均衡的传输是十分有害的


457
00:28:25,672 --> 00:28:27,741
一个有意思的事情是


458
00:28:28,175 --> 00:28:33,981
如果你跟踪观察
黄色应答线条的斜率...


459
00:28:34,381 --> 00:28:37,117
黄色窗口线和和绿色应答线条


460
00:28:37,651 --> 00:28:41,088
你会发现如果不发生丢包在轨迹末端


461
00:28:41,288 --> 00:28:44,258
线条会回到它们原本应该所在的位置


462
00:28:44,758 --> 00:28:47,494
因为TCP协议能够高效率地


463
00:28:47,561 --> 00:28:51,164
一次性填充需要重新传输的数据包


464
00:28:51,698 --> 00:28:54,735
而不会传输其他不需要重新传输的数据


465
00:28:55,202 --> 00:28:56,937
因此它将会返回原本应该所处的位置


466
00:28:57,905 --> 00:29:00,674
如果使用Iperf测量网络速度


467
00:29:00,741 --> 00:29:01,909
并且查看测量值


468
00:29:02,509 --> 00:29:04,211
你将会看到它显示为10Mb/s


469
00:29:04,545 --> 00:29:07,347
你会说很好我的网络一切正常


470
00:29:08,415 --> 00:29:10,984
但是如果你探究这些信息


471
00:29:11,051 --> 00:29:15,422
分析具体的数据


472
00:29:15,622 --> 00:29:17,224
你就会发现实际的网络情况


473
00:29:22,162 --> 00:29:25,799
现在我们知道是什么原因


474
00:29:25,966 --> 00:29:27,935
造成网络性能下降


475
00:29:28,669 --> 00:29:31,004
我决定使用智能网络进行实验


476
00:29:31,572 --> 00:29:35,142
对于这个实验我使用
一种名为CoDel的智能队列算法


477
00:29:35,209 --> 00:29:38,045
它是Controlled
Delay的简称


478
00:29:39,313 --> 00:29:42,015
其工作原理不是填充队列


479
00:29:42,082 --> 00:29:47,754
直到队列溢出并丢失数据
相反它监测队列的状态


480
00:29:48,388 --> 00:29:51,925
当队列快要变满时


481
00:29:51,992 --> 00:29:56,864
将会把它视为一个拥塞信号


482
00:29:57,764 --> 00:29:59,199
对于拥塞很多人认为


483
00:30:00,267 --> 00:30:03,370
我说的是高峰时间出现的情况


484
00:30:03,437 --> 00:30:05,506
实际上不是这样的


485
00:30:05,572 --> 00:30:09,109
必须理解的是在网络数据传输中


486
00:30:09,610 --> 00:30:12,312
拥塞始终存在


487
00:30:12,846 --> 00:30:14,515
它是一种稳定的网络状态


488
00:30:14,581 --> 00:30:17,584
TCP等传输协议的任务是


489
00:30:18,085 --> 00:30:20,821
最大限度地利用网络


490
00:30:21,321 --> 00:30:23,857
以确定网络的最大承载能力


491
00:30:24,324 --> 00:30:25,626
并且最高效地利用网络


492
00:30:26,560 --> 00:30:28,295
传输协议的工作原理是


493
00:30:28,362 --> 00:30:32,900
它越来越快地传输数据


494
00:30:32,966 --> 00:30:35,502
同时始终进行侦测
它尝试不断发送更多的数据


495
00:30:36,069 --> 00:30:39,573
直到发生丢包这时它将
知道负载过大并开始削减流量


496
00:30:40,040 --> 00:30:42,609
它始终进行这种尝试
以找到合适的传输速率


497
00:30:42,943 --> 00:30:44,478
这意味着它始终在尝试


498
00:30:44,778 --> 00:30:47,381
使网络进入拥塞状态


499
00:30:47,447 --> 00:30:51,618
然后降低传输负载从而减少拥塞


500
00:30:52,452 --> 00:30:56,723
CoDel的工作原理并不是
等待网络进入拥塞状态


501
00:30:57,391 --> 00:30:58,625
然后发出拥塞信息


502
00:30:59,326 --> 00:31:04,298
在发现第一个拥塞信号之后
它就会通知发送端


503
00:31:06,466 --> 00:31:09,403
在这个实验中我做的另一事情


504
00:31:09,469 --> 00:31:12,105
不是通过丢包来指示拥塞


505
00:31:12,172 --> 00:31:13,674
这需要重新传输


506
00:31:14,274 --> 00:31:17,411
相反我使用一种名为“显式拥塞通知”
即Explicit Congestion 


507
00:31:17,878 --> 00:31:22,482
Notification的新技术
智能队列算法不会丢弃数据包


508
00:31:22,850 --> 00:31:26,220
它设置IP标头中的一个位
声明遇到拥塞


509
00:31:26,854 --> 00:31:29,923
这个消息被传回给发送端
发送端作出响应


510
00:31:29,990 --> 00:31:33,894
降低传输速度
而不会造成破坏性的丢包后果


511
00:31:37,831 --> 00:31:41,869
这是使用CoDel和ECN的


512
00:31:42,069 --> 00:31:46,173
数据传输示意图如果我放大


513
00:31:46,240 --> 00:31:50,511
前面看过的相同部分
你可以看到非常明显的差别


514
00:31:51,111 --> 00:31:52,646
在我进行这些实验时


515
00:31:52,946 --> 00:31:56,216
我计划用一周的时间
来完成这些工作和收集数据


516
00:31:56,917 --> 00:31:59,419
结果只用了两个小时就全部完成了


517
00:31:59,753 --> 00:32:03,590
一个方案使用标准配置来执行
一个方案使用CoDel来执行


518
00:32:03,790 --> 00:32:06,693
这是我的第一个实验


519
00:32:06,760 --> 00:32:11,498
我预计需要调整参数重试并返回实验


520
00:32:12,165 --> 00:32:16,436
但是没有发生这种情况 差别很明显


521
00:32:16,570 --> 00:32:18,405
只需进行一次试验就够了


522
00:32:18,972 --> 00:32:20,274
好像有人在鼓掌 谢谢


523
00:32:26,380 --> 00:32:28,882
我们没有看到传输中断现象


524
00:32:28,949 --> 00:32:31,385
也没有出现高峰拥塞


525
00:32:32,052 --> 00:32:35,389
每次出现轻微的队列拥塞时


526
00:32:35,956 --> 00:32:37,991
CoDel算法就会发出信号


527
00:32:38,058 --> 00:32:40,327
要求降低传输速度


528
00:32:40,794 --> 00:32:44,531
这个方案的CWR标记
的含义是“减少拥塞窗口期”


529
00:32:44,598 --> 00:32:47,201
这是TCP的应答消息
意思是消息已经被接收和理解


530
00:32:47,267 --> 00:32:48,836
我已经降低传输速率


531
00:32:49,636 --> 00:32:50,704
这确实很不错


532
00:32:53,507 --> 00:32:56,076
总的来说CoDel


533
00:32:56,143 --> 00:32:58,512
和其他队列算法非常有效


534
00:32:58,846 --> 00:32:59,847
ECN十分有效


535
00:33:00,614 --> 00:33:02,449
将它们组合在一起将会功效倍增


536
00:33:05,519 --> 00:33:07,621
那么如果这么有效
应该在哪里使用它们？


537
00:33:08,222 --> 00:33:11,758
从历史来看对于传统的网络应用来说


538
00:33:11,825 --> 00:33:14,728
例如文件传输和发送电子邮件等


539
00:33:14,795 --> 00:33:19,166
丢包和重新传输并不会造成严重的问题


540
00:33:21,635 --> 00:33:24,905
当你传输文件时原则上传输层将会


541
00:33:24,972 --> 00:33:28,242
最后发送第一个数据包


542
00:33:28,308 --> 00:33:31,111
而且最先发送最后一个数据包
其间的所有数据包


543
00:33:31,178 --> 00:33:33,580
将会随机发送 在数据包全部到达之后


544
00:33:33,647 --> 00:33:37,317
将会按照文件的正确顺序重新进行组装
这就是你需要关注的所有事情


545
00:33:38,519 --> 00:33:40,721
但是当你观看流媒体视频时


546
00:33:41,255 --> 00:33:45,792
你并不想先看到结尾最后看到开头


547
00:33:46,293 --> 00:33:47,494
你希望按顺序观看


548
00:33:47,961 --> 00:33:51,565
这时按顺序发送数据
就成为一个更紧迫的问题


549
00:33:52,032 --> 00:33:54,301
现在我们通过
Internet传输流媒体视频


550
00:33:57,538 --> 00:33:59,773
这里的一个特点是在以前的应用中


551
00:33:59,840 --> 00:34:03,110
例如点击发送电子邮件等


552
00:34:03,710 --> 00:34:06,246
需要发送的数据量是预先确定的


553
00:34:07,114 --> 00:34:09,315
而发送所需要的时间是可变的


554
00:34:10,250 --> 00:34:13,387
基本上网络发送电子邮件


555
00:34:13,453 --> 00:34:16,389
所需要的时间是越少越好


556
00:34:17,024 --> 00:34:19,193
我们并没有邮件发送过快这样的说法


557
00:34:20,060 --> 00:34:23,130
发送时间是可变的你希望它越快越好


558
00:34:23,463 --> 00:34:25,532
现在的应用则有不同


559
00:34:26,833 --> 00:34:29,136
比如你通过Internet


560
00:34:29,402 --> 00:34:31,103
观看两个小时的电影


561
00:34:32,172 --> 00:34:35,542
我们不应该半个小时
或八个小时内看完成


562
00:34:35,742 --> 00:34:37,210
而必须是两个小时


563
00:34:38,045 --> 00:34:40,013
现在我们的应用必须具有适应能力


564
00:34:40,080 --> 00:34:42,549
时间是固定的但是必须调整


565
00:34:42,616 --> 00:34:45,118
这段时间内发送的数据量


566
00:34:45,219 --> 00:34:47,020
以适应网络状况


567
00:34:50,591 --> 00:34:51,592
现在的情况是怎样的？


568
00:34:52,125 --> 00:34:55,161
让人惊奇的是
Linux已经支持此功能


569
00:34:55,228 --> 00:34:59,433
而且在世界性能最强的
一百万台Web服务器中


570
00:34:59,499 --> 00:35:01,502
一半以上默认支持ECN


571
00:35:02,169 --> 00:35:04,505
对于一项无人使用的技术来说


572
00:35:04,571 --> 00:35:06,240
这种应用广泛性是惊人的


573
00:35:10,043 --> 00:35:14,748
客户端并不请求ECN连接


574
00:35:14,815 --> 00:35:16,984
它们不请求ECN在很大程度上


575
00:35:17,417 --> 00:35:20,721
是因为Internet
不支持ECN标记


576
00:35:21,021 --> 00:35:24,691
如果你启用这个选项


577
00:35:24,758 --> 00:35:27,661
可能会带来暴露bug的风险
而且没有直接好处


578
00:35:29,630 --> 00:35:30,697
那么路由器在做什么？ 


579
00:35:30,764 --> 00:35:33,600
没有路由器进行标记


580
00:35:33,667 --> 00:35:36,737
因为没有客户端请求它们
那么为什么要设计


581
00:35:36,803 --> 00:35:39,072
这样具有风险而且无人使用的功能呢？


582
00:35:39,339 --> 00:35:43,310
今天我高兴地宣布
Apple将首开先河


583
00:35:43,610 --> 00:35:44,745
打破这个僵局


584
00:35:45,212 --> 00:35:50,250
在所有的基本应用中默认情况下


585
00:35:50,617 --> 00:35:54,888
所有应用的所有
TCP连接将支持ECN


586
00:36:01,895 --> 00:36:05,432
我们将不会看到任何问题


587
00:36:05,933 --> 00:36:07,234
在我们的测试中一切运行正常


588
00:36:07,701 --> 00:36:10,537
我已经在我自己的
笔记本电脑上运行很长时间


589
00:36:11,672 --> 00:36:14,808
当然我们希望倾听你们的体会


590
00:36:14,975 --> 00:36:19,379
请接受这些基本应用在你的家庭网络


591
00:36:20,047 --> 00:36:22,816
工作单位酒店和机场使用它们


592
00:36:23,350 --> 00:36:26,620
和以前一样如果发现任何bug
请报告给Apple


593
00:36:27,421 --> 00:36:30,357
如果我们取得成功几个月之后


594
00:36:30,424 --> 00:36:32,659
将会有数百万设备运行ECN


595
00:36:33,527 --> 00:36:37,231
这样ISP将有足够的动力
来提供这项服务


596
00:36:39,466 --> 00:36:43,036
现在我们将主题从网络延迟


597
00:36:43,337 --> 00:36:45,339
转移到终端系统延迟


598
00:36:46,306 --> 00:36:50,410
许多技术进步的出发点是为了


599
00:36:50,477 --> 00:36:53,447
克服我们自己遇到的不便之处
这里也同样如此


600
00:36:54,681 --> 00:36:59,319
我使用屏幕共享功能
连接到我家里的Mac计算机


601
00:36:59,920 --> 00:37:01,221
这种功能真不错


602
00:37:01,855 --> 00:37:05,359
我能够远程控制计算机
能够访问计算机上的数据


603
00:37:06,026 --> 00:37:11,164
能够开始费时的视频转码


604
00:37:11,231 --> 00:37:13,100
在我到家时就已经完成转码


605
00:37:13,734 --> 00:37:14,935
这些确实不错


606
00:37:16,003 --> 00:37:18,405
在我进行这些实验时


607
00:37:19,907 --> 00:37:23,143
我使用的是很慢的DSL线路


608
00:37:24,011 --> 00:37:27,247
当然DSL是非对称的


609
00:37:27,648 --> 00:37:31,919
一般来说下行速度比上行速度快十倍


610
00:37:32,753 --> 00:37:34,755
当你进行屏幕共享时


611
00:37:35,189 --> 00:37:37,391
数据传输方向是上行方向


612
00:37:37,558 --> 00:37:41,662
因此速度会比较慢


613
00:37:42,563 --> 00:37:45,065
这有一点像那个众人皆知的
关于熊跳舞的笑话


614
00:37:45,399 --> 00:37:47,334
当你看到熊跳舞时


615
00:37:47,401 --> 00:37:49,203
你不应该惊讶于熊跳舞跳得很好


616
00:37:49,303 --> 00:37:51,405
而应该惊讶于熊会跳舞


617
00:37:52,172 --> 00:37:58,178
多年人与很多人一样
我被这个让人难受的


618
00:37:58,245 --> 00:38:04,618
勉强可用的功能所困扰
我发现当我点击一个菜单时


619
00:38:04,685 --> 00:38:08,288
要花费三到四秒的时间


620
00:38:08,355 --> 00:38:10,791
菜单才会显示出来
这样使用计算机几分钟之后


621
00:38:10,858 --> 00:38:14,394
让人感到非常不舒服


622
00:38:14,461 --> 00:38:16,430
有时候恨不得快点开车回家


623
00:38:16,496 --> 00:38:17,764
亲自在计算机上操作


624
00:38:19,800 --> 00:38:22,636
我曾经研究过
“bufferbloat”


625
00:38:23,270 --> 00:38:25,606
和网络中的过度队列


626
00:38:25,973 --> 00:38:30,644
很自然地我首先感到不满


627
00:38:30,911 --> 00:38:32,412
并且开始研究


628
00:38:32,713 --> 00:38:35,349
我最初认为罪魁祸首


629
00:38:35,415 --> 00:38:37,851
应该是这个愚蠢的DSL调制解调器


630
00:38:37,918 --> 00:38:39,520
产生过度的缓存膨胀


631
00:38:40,153 --> 00:38:41,455
于是我ping计算机


632
00:38:42,189 --> 00:38:44,391
ping时间为35ms


633
00:38:45,292 --> 00:38:48,729
当我点击鼠标时
却需要3秒才能显示鼠标


634
00:38:49,796 --> 00:38:52,866
我意识到情况可能
与我当初设想的不一样


635
00:38:53,700 --> 00:38:55,169
那么延迟来自于哪里呢？


636
00:38:56,003 --> 00:38:59,139
对此我进行了一些研究


637
00:39:00,641 --> 00:39:04,211
当时默认socket发送的
缓存数据是120KB


638
00:39:04,645 --> 00:39:08,248
我的网速率大约是50KB/s


639
00:39:08,415 --> 00:39:10,250
用时约为2.5秒


640
00:39:10,450 --> 00:39:12,119
这与我看到的延迟时间差不多


641
00:39:14,054 --> 00:39:17,257
发送缓冲数据的socket 
具有十分重要的意义


642
00:39:18,492 --> 00:39:21,762
当我们使用TCP等协议时


643
00:39:22,262 --> 00:39:25,666
它会发送一个数据包等待应答


644
00:39:25,732 --> 00:39:27,801
然后再发送一个数据包再等待应答


645
00:39:28,135 --> 00:39:29,503
这样的性能十分低下


646
00:39:29,903 --> 00:39:32,906
我们需要一次发送多个数据包
我们需要足够多的数据包


647
00:39:32,973 --> 00:39:37,110
以充分利目的地往返传输路径的带宽


648
00:39:37,778 --> 00:39:40,881
而且必须缓存这些数据包


649
00:39:40,948 --> 00:39:44,585
这样当它们丢失时可以重新进行传输。


650
00:39:45,085 --> 00:39:47,254
最大限度利用连接吐吞率


651
00:39:47,588 --> 00:39:50,290
是一个很好有用而且必要的方法


652
00:39:51,091 --> 00:39:53,460
但于超过需求的缓存


653
00:39:53,527 --> 00:39:57,865
仅仅会增加延迟而不会带来好处


654
00:39:58,065 --> 00:39:59,366
它不会帮助提高吞吐率


655
00:39:59,867 --> 00:40:00,767
而只会增大延迟


656
00:40:01,635 --> 00:40:04,371
最终我们只会得到这样的结果


657
00:40:05,205 --> 00:40:08,742
我们一次仅传输少量的数据
而且这些数据进入缓存


658
00:40:08,976 --> 00:40:10,544
以备在需要时重新传输


659
00:40:11,211 --> 00:40:15,816
而另一方面有大量的数据
在内核中等待被发送出去


660
00:40:20,287 --> 00:40:22,356
这让我明白


661
00:40:23,824 --> 00:40:27,761
不仅网络上存在延迟
而且主机之中存大量延迟


662
00:40:29,796 --> 00:40:33,066
屏幕共享程序会抓取
一个画面帧将它送入缓存


663
00:40:33,267 --> 00:40:36,370
再抓取一个画面帧将它送入缓存
内核将会让这些帧


664
00:40:36,770 --> 00:40:43,410
像葡萄酒那样长时间陈酿然后才会在
特定时间将它们通过网络发送出去


665
00:40:45,679 --> 00:40:51,185
为此我们引入了
TCP_NOTSENT-LOWAT


666
00:40:51,251 --> 00:40:52,286
套接字选项


667
00:40:53,120 --> 00:40:54,488
发送这个选项时


668
00:40:55,622 --> 00:40:58,625
Socket_Send_Buffer
保持不变


669
00:40:59,693 --> 00:41:02,763
区别在于kevent


670
00:41:03,330 --> 00:41:07,768
或你的run loop不会报告
Socket正在被写入


671
00:41:08,135 --> 00:41:10,637
直到未发送的数据量


672
00:41:10,804 --> 00:41:13,040
达到很低的阀值


673
00:41:13,106 --> 00:41:14,808
通常为8或16KB


674
00:41:15,809 --> 00:41:17,477
当socket转为可写入状态时


675
00:41:18,045 --> 00:41:23,217
你可以将单个有用的
基本数据块写入缓存


676
00:41:23,951 --> 00:41:27,621
不需要循环操作中
内核中也不会积累过多的数据


677
00:41:27,688 --> 00:41:30,490
因为现在内存已经很便宜
它可以容纳大量的数据


678
00:41:31,525 --> 00:41:33,360
你只需写入一个感应单元


679
00:41:33,627 --> 00:41:36,363
在屏幕共享程序中它是一个帧


680
00:41:37,231 --> 00:41:38,932
现在的情况是这样的


681
00:41:40,033 --> 00:41:42,102
有数据在等待发送它们位于缓存中


682
00:41:42,436 --> 00:41:44,671
需要等待较短的时间让它们发送出去


683
00:41:45,739 --> 00:41:48,208
在发送完毕之后中达到阀值


684
00:41:49,142 --> 00:41:50,444
Socket转为可写入状态


685
00:41:51,178 --> 00:41:52,479
我们写入一个数据块


686
00:41:52,846 --> 00:41:54,781
在它发送完毕之后再写入更多数据块


687
00:41:55,482 --> 00:41:58,285
现在我为你们演示这个过程


688
00:42:07,094 --> 00:42:08,495
在这里我将要在这台计算机上


689
00:42:08,862 --> 00:42:11,498
使用屏幕共享程序连接到这台计算机


690
00:42:12,432 --> 00:42:15,736
我将使用一个运行
sarawert[猜测写法]的网关


691
00:42:15,903 --> 00:42:18,372
来模拟DSL连接


692
00:42:20,307 --> 00:42:25,312
让我们调出终端窗口


693
00:42:32,252 --> 00:42:33,086
看到了


694
00:42:34,988 --> 00:42:36,657
我将移动这个窗口


695
00:42:37,791 --> 00:42:40,694
你可以看到鼠标指针在移动


696
00:42:40,961 --> 00:42:42,429
因为它是本地生成的


697
00:42:42,829 --> 00:42:45,766
实际的图形更新是由远程计算机生成的


698
00:42:46,200 --> 00:42:48,702
让我们窗口移动这里


699
00:42:48,936 --> 00:42:50,237
不 不是这里


700
00:42:50,304 --> 00:42:53,240
让我们移动它 不
我想让它回到原来的地方


701
00:42:53,307 --> 00:42:54,308
双手离开键盘


702
00:43:02,182 --> 00:43:04,451
让我们调出菜单：Shell


703
00:43:09,122 --> 00:43:11,191
它出现了
让我们打开“Edit”


704
00:43:11,425 --> 00:43:12,659
或者“View”


705
00:43:18,565 --> 00:43:21,568
这个演示让人感觉很着急


706
00:43:21,802 --> 00:43:24,905
看起来远程使用我的计算机
是非常费劲的事情


707
00:43:25,439 --> 00:43:28,842
这需要很好的耐心


708
00:43:31,078 --> 00:43:35,282
现在我一个新的方法


709
00:43:36,383 --> 00:43:41,188
我启用
TCP_NOTSENT-LOWAT选项


710
00:43:49,296 --> 00:43:52,432
然后重新进行连接
我可以随意拖动这个窗口


711
00:44:05,445 --> 00:44:06,280
谢谢


712
00:44:06,446 --> 00:44:13,387
多年来 在BSD网络应用中


713
00:44:13,453 --> 00:44:18,959
我们一直忍受着这种极其
糟糕的屏幕共享连接


714
00:44:20,093 --> 00:44:26,400
好消息是我们已经解决这个问题


715
00:44:27,234 --> 00:44:28,836
现在此技术已经在


716
00:44:33,707 --> 00:44:39,680
10.10.3最新版本中得到应用


717
00:44:39,746 --> 00:44:42,115
如果发现屏幕共享得到越来越多的运用


718
00:44:42,649 --> 00:44:44,451
背后的原因就在这里


719
00:44:44,985 --> 00:44:49,590
此技术已经被AirPlay使用
而且也可以在Linux中使用


720
00:44:50,157 --> 00:44:54,161
因为此选项应用于发送端数据源


721
00:44:54,628 --> 00:44:57,364
因此如果你运行Linux服务器


722
00:44:57,698 --> 00:44:59,800
此选项也可以用于你的服务器


723
00:45:03,170 --> 00:45:08,242
对于实时应用来说
这种降低延迟的好处很明显的


724
00:45:09,843 --> 00:45:13,881
在制作本讲座的幻灯片时


725
00:45:14,014 --> 00:45:15,048
我将APP分为两类


726
00:45:15,115 --> 00:45:18,352
一类APP应该使用
tcp_notsent-lowat选项


727
00:45:18,418 --> 00:45:19,586
另一类APP不应该使用


728
00:45:20,287 --> 00:45:23,590
但是我想不出任何APP
应归入不应该使用此选项的类别


729
00:45:24,391 --> 00:45:28,595
每次我们想到哪些传统应用
可能不需要使用此选项例如文件传输


730
00:45:29,129 --> 00:45:31,899
我们发现你们曾经有这样的经历


731
00:45:31,965 --> 00:45:33,767
你想要取消文件传输


732
00:45:33,834 --> 00:45:37,104
你按下Control-C
但是需要大约30秒的时间才能取消


733
00:45:37,971 --> 00:45:40,507
这是因为程序将所有数据


734
00:45:40,574 --> 00:45:42,609
过量载入内核而必须等待数据被清空


735
00:45:43,010 --> 00:45:44,511
因为并没有方法来改变此操作


736
00:45:45,012 --> 00:45:48,148
事实上文件传输


737
00:45:48,215 --> 00:45:51,885
并不会受益于过量载入数据


738
00:45:51,952 --> 00:45:53,820
我们想不出会任何APP


739
00:45:53,887 --> 00:45:55,622
会受益内核中的过量数据堆积


740
00:45:55,956 --> 00:45:59,993
在认识到这种情况之后


741
00:46:00,460 --> 00:46:04,698
我们决定在下一个版本中


742
00:46:05,566 --> 00:46:09,670
使用更高层次的SURLSession
和CFNetwork API


743
00:46:09,736 --> 00:46:11,538
自动为所有连接启用此选项


744
00:46:12,806 --> 00:46:15,242
为了最有效地利它需要做的事情是


745
00:46:15,642 --> 00:46:20,581
当socket变为可写入状态时
在看到EWOULDBLOCK错误码之前


746
00:46:20,647 --> 00:46:22,950
不要循环写入大量的数据


747
00:46:23,450 --> 00:46:25,552
只需要写入合适大小的数据块


748
00:46:26,253 --> 00:46:28,422
然后等待被告知可以写入更多数据块


749
00:46:28,822 --> 00:46:31,558
这样如果用户改变主意


750
00:46:31,625 --> 00:46:33,794
或者网络环境发生变化


751
00:46:33,994 --> 00:46:36,930
下次socket变为可写入状态时


752
00:46:37,264 --> 00:46:39,466
你可以做出明智的决定


753
00:46:40,467 --> 00:46:42,870
你可以即进生成数据


754
00:46:43,203 --> 00:46:48,642
根据当前的信息
而不是5或10秒前的信息


755
00:46:49,042 --> 00:46:51,912
生成最新的数据


756
00:46:53,814 --> 00:46:58,418
现在进入本讲座的最后一部分


757
00:46:59,319 --> 00:47:01,421
让我们来窥探


758
00:47:02,089 --> 00:47:05,759
一项名为TCP Fast Open的
全新技术


759
00:47:07,528 --> 00:47:14,501
传统TCP工作原理是这样的
我们通过发送消息和获得应答


760
00:47:15,068 --> 00:47:16,503
设置TCP连接


761
00:47:17,371 --> 00:47:18,972
然后我们第二次发送消息和获得应答


762
00:47:19,406 --> 00:47:21,675
以发送请求和获得响应


763
00:47:22,776 --> 00:47:26,947
TCP Fast Open
将连接设置


764
00:47:27,014 --> 00:47:30,050
与数据交换合并成为一个数据包交换


765
00:47:31,218 --> 00:47:34,454
所有APP并不会默认启用此选项


766
00:47:34,555 --> 00:47:35,756
而这是有原因的


767
00:47:37,624 --> 00:47:39,593
你需要注意这个警告信息


768
00:47:40,027 --> 00:47:43,497
提示说此功能仅对
幂等数据来说是安全的


769
00:47:43,797 --> 00:47:45,032
我将解释这其中的含义


770
00:47:47,901 --> 00:47:50,070
当你使用TFO操作时
握手与数据组合在一起


771
00:47:51,939 --> 00:47:57,945
服务器将收到消息服务器
作出反应发送响应信息


772
00:47:58,345 --> 00:47:59,580
然后你关闭连接


773
00:48:00,681 --> 00:48:05,552
Internet的工作模式并不保证


774
00:48:05,919 --> 00:48:08,522
不会重复发送数据包


775
00:48:09,356 --> 00:48:11,258
Internet的成功得益于


776
00:48:12,092 --> 00:48:14,461
其非常简单的工作模式


777
00:48:14,728 --> 00:48:18,365
即快速低成本地发送数据包


778
00:48:19,132 --> 00:48:21,502
你不需要考虑数据包的发送顺序


779
00:48:21,935 --> 00:48:24,304
不需要担心数据包是否损坏或丢失


780
00:48:24,371 --> 00:48:26,907
或者重复发送数据包
只需实现快速和低成本就可以了


781
00:48:27,774 --> 00:48:31,879
终端系统非常智能化
能够适应这种网络模型


782
00:48:33,447 --> 00:48:35,549
重复发送数据包的原因是多少方面的


783
00:48:35,616 --> 00:48:37,451
可能是因为路由器有bug


784
00:48:37,985 --> 00:48:40,721
也可能是因为Wi-Fi链路层


785
00:48:41,622 --> 00:48:43,891
意外地发送数据包两次


786
00:48:44,291 --> 00:48:46,693
终端系统可能重复发送：


787
00:48:46,760 --> 00:48:50,397
如果你发送数据包


788
00:48:50,964 --> 00:48:52,900
但是应答消息丢失


789
00:48:53,300 --> 00:48:54,801
你将需要重新发送数据包


790
00:48:55,302 --> 00:48:58,272
这样网络中就会出现两个相同的数据包


791
00:48:58,772 --> 00:49:02,943
如果其中一个数据包发生延迟
并且在很久以后出现


792
00:49:03,710 --> 00:49:06,380
对于服务器来说


793
00:49:06,446 --> 00:49:09,750
这是一个完全有效的TFO请求


794
00:49:10,150 --> 00:49:12,786
无论操作是什么都会再次执行此操作


795
00:49:13,654 --> 00:49:16,990
如果操作是向你发送一幅JPEG图片


796
00:49:17,324 --> 00:49:19,259
进行两次这样的操作
并不会带来严重的后果


797
00:49:20,060 --> 00:49:23,730
但是如果操作是
发送一双Zappos鞋子


798
00:49:24,164 --> 00:49:25,999
两次进行这样的操作可不是你想的


799
00:49:26,466 --> 00:49:31,205
对于这种情况你必须做出明智的决定


800
00:49:31,305 --> 00:49:32,739
哪些操作是合适和安全的


801
00:49:33,073 --> 00:49:35,409
哪些对你的APP来说不合适


802
00:49:37,377 --> 00:49:41,415
你可以通过connectx
系统调用来这样做


803
00:49:42,349 --> 00:49:48,088
这是早期适配器的简要技术预览


804
00:49:49,122 --> 00:49:52,759
让我们来看如何通过更高层API
来展示这个技术


805
00:49:52,826 --> 00:49:55,629
但是目前还不能
使用connectx来实现


806
00:49:56,463 --> 00:49:59,666
与你进行对话的服务器必须支持TFO


807
00:49:59,733 --> 00:50:01,335
APP必须选择加入对话


808
00:50:03,270 --> 00:50:06,507
如果你运行Linux服务器
你必须具有几个星期以前


809
00:50:06,573 --> 00:50:09,676
发布的最新Linux内核


810
00:50:10,110 --> 00:50:15,582
此内核支持标准ITF、TFO、


811
00:50:16,116 --> 00:50:18,685
TCP选项代码
OS X操作系统也同样如此


812
00:50:22,055 --> 00:50:25,125
最后作为总结我希望你们
记住今天讲座的要点


813
00:50:27,694 --> 00:50:28,595
即 你应该尽可能地


814
00:50:29,263 --> 00:50:32,366
使用最高层次的网络API


815
00:50:32,900 --> 00:50:38,005
这样你将能够获得
这些API所能提供的全部功能


816
00:50:39,573 --> 00:50:44,578
你绝对必须在NAT64网络上
测试你的APP


817
00:50:45,212 --> 00:50:48,348
幸运的是我们进行了大量的简化工作


818
00:50:48,482 --> 00:50:50,484
你只需要点击“选项”就可以了


819
00:50:52,586 --> 00:50:59,293
可靠的网络回退机制
能够让你的APP提供更好的用户体验


820
00:51:00,527 --> 00:51:04,231
你需要做的是注意
“Better Route”通知


821
00:51:04,498 --> 00:51:07,201
这样当Wi-Fi重新可用时
你可以返回到Wi-Fi连接


822
00:51:09,169 --> 00:51:13,106
“显式拥塞通知”
是一项新的基本功能


823
00:51:14,474 --> 00:51:19,746
它通过降低队列等待和减少丢包


824
00:51:20,314 --> 00:51:24,751
大幅提高网络数据传输的响应速度


825
00:51:25,419 --> 00:51:28,121
我希望你们测试这些功能
并且报告任何问题


826
00:51:29,489 --> 00:51:31,425
利用
CPNOTSENT-LOWAT选项


827
00:51:31,859 --> 00:51:34,528
你可以为自己设置一个
socket选项


828
00:51:35,229 --> 00:51:37,564
在下一个版本中你将可以免费使用它


829
00:51:38,398 --> 00:51:41,735
从而大幅减少发送机中
缓存的迟滞数据量


830
00:51:43,003 --> 00:51:46,707
最后对于喜欢
TCP Fast Open的开发者


831
00:51:46,773 --> 00:51:48,075
我们已经提供此功能


832
00:51:49,910 --> 00:51:53,013
有很多不错的文档资源可供你查看


833
00:51:53,614 --> 00:51:55,782
你们并不需要记下这些URL


834
00:51:55,849 --> 00:51:57,818
可以点击PDF文档中的链接


835
00:51:59,052 --> 00:52:04,191
还有一些不错的论坛
你可以提问并且讨论


836
00:52:04,658 --> 00:52:06,593
与网络应用相关的问题


837
00:52:09,596 --> 00:52:11,598
我鼓励你们观看


838
00:52:12,232 --> 00:52:14,968
NSURLSession讲座


839
00:52:15,335 --> 00:52:19,640
和Network 
Extensions讲座


840
00:52:20,340 --> 00:52:23,610
在网络实验室午餐休息之后
也可以与我们讨论


841
00:52:23,777 --> 00:52:25,279
我们将会回答你的所有问题


842
00:52:26,079 --> 00:52:26,914
谢谢

