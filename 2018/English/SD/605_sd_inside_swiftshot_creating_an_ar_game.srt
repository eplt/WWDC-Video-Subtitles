1
00:00:07,516 --> 00:00:16,500
[ Music ]


2
00:00:22,516 --> 00:00:29,036
[ Applause ]


3
00:00:29,536 --> 00:00:30,556
>> Hi, I'm Alex.


4
00:00:30,676 --> 00:00:31,886
I work for a group at Apple


5
00:00:31,886 --> 00:00:33,206
called Tools Foundation.


6
00:00:33,336 --> 00:00:34,576
Normally we get to do fun stuff


7
00:00:34,576 --> 00:00:35,726
like operating systems and


8
00:00:35,726 --> 00:00:36,286
compilers.


9
00:00:36,826 --> 00:00:37,776
But this year we got to do


10
00:00:37,776 --> 00:00:38,656
something a little different.


11
00:00:38,986 --> 00:00:40,036
We built a game called


12
00:00:40,036 --> 00:00:40,596
SwiftShot.


13
00:00:41,116 --> 00:00:42,246
Some of you may have seen it


14
00:00:42,246 --> 00:00:44,056
earlier today and you might have


15
00:00:44,056 --> 00:00:45,116
played it downstairs.


16
00:00:45,866 --> 00:00:48,036
But the important part is that


17
00:00:48,386 --> 00:00:50,176
SwiftShot is a showcase of some


18
00:00:50,176 --> 00:00:51,676
of the new functionality in


19
00:00:51,676 --> 00:00:52,136
ARKit.


20
00:00:52,906 --> 00:00:55,646
ARKit 2 is now available on


21
00:00:55,646 --> 00:00:57,006
hundreds of millions of devices,


22
00:00:57,376 --> 00:00:58,856
providing a platform for


23
00:00:59,176 --> 00:01:00,756
engaging AR experiences.


24
00:01:01,216 --> 00:01:02,576
And you are able to reach the


25
00:01:02,576 --> 00:01:03,786
widest possible audience with


26
00:01:03,786 --> 00:01:04,025
that.


27
00:01:04,916 --> 00:01:06,756
There is no special setup, just


28
00:01:06,756 --> 00:01:08,546
point the device's camera at a


29
00:01:08,666 --> 00:01:09,916
surface and start playing.


30
00:01:11,506 --> 00:01:13,896
It's integrated into iOS.


31
00:01:14,666 --> 00:01:16,206
First-party and third-party


32
00:01:16,206 --> 00:01:17,346
engines like SceneKit and


33
00:01:17,346 --> 00:01:19,826
SpriteKit as well as third-party


34
00:01:19,826 --> 00:01:22,396
ones like Unreal and Unity have


35
00:01:22,476 --> 00:01:23,486
a full integration at this


36
00:01:23,486 --> 00:01:24,000
point.


37
00:01:28,536 --> 00:01:29,686
A little agenda for you.


38
00:01:29,866 --> 00:01:30,976
First we're going to talk some


39
00:01:31,376 --> 00:01:32,896
game design principles for


40
00:01:32,896 --> 00:01:34,216
augmented reality, a few of the


41
00:01:34,216 --> 00:01:35,666
things we learned along the way.


42
00:01:36,886 --> 00:01:38,336
We are going to go deep into the


43
00:01:38,336 --> 00:01:40,186
internals of the game and in


44
00:01:40,186 --> 00:01:40,976
particular, we are going to


45
00:01:40,976 --> 00:01:42,426
cover WorldMap sharing which is


46
00:01:42,426 --> 00:01:43,676
a new feature in ARKit 2.


47
00:01:43,676 --> 00:01:45,556
And we will also talk about


48
00:01:45,556 --> 00:01:46,816
networking and physics and how


49
00:01:46,816 --> 00:01:47,726
we made that work.


50
00:01:48,726 --> 00:01:51,006
First, let's, you know, take a


51
00:01:51,576 --> 00:01:54,426
deep look at the game.


52
00:01:55,516 --> 00:02:29,500
[ Music ]


53
00:02:34,296 --> 00:02:35,496
So, let's talk a little bit


54
00:02:35,496 --> 00:02:37,246
about designing games for


55
00:02:37,246 --> 00:02:39,626
augmented reality.


56
00:02:40,486 --> 00:02:42,656
Above all else, gameplay comes


57
00:02:42,656 --> 00:02:42,976
first.


58
00:02:42,976 --> 00:02:46,086
You should ask yourself if you


59
00:02:46,086 --> 00:02:47,386
are designing a game, would this


60
00:02:47,386 --> 00:02:50,116
game be fun and enjoyable if it


61
00:02:50,116 --> 00:02:52,376
were just 1970s graphics or


62
00:02:52,636 --> 00:02:55,466
plain, flat-shaded grey cubes.


63
00:02:56,336 --> 00:02:58,166
It is worth prototyping with


64
00:02:58,166 --> 00:03:00,996
those kinds of artwork and get


65
00:03:00,996 --> 00:03:02,026
that gameplay down.


66
00:03:02,216 --> 00:03:03,416
Because if it's fun with those


67
00:03:03,416 --> 00:03:05,136
boring grey boxes, it's going to


68
00:03:05,136 --> 00:03:06,126
be fun when you add all the


69
00:03:06,126 --> 00:03:07,246
graphics and sound later.


70
00:03:08,446 --> 00:03:10,376
You should spend time refining


71
00:03:10,376 --> 00:03:12,306
that and don't convince yourself


72
00:03:12,306 --> 00:03:14,216
that if I just add another 5%


73
00:03:14,216 --> 00:03:15,546
better graphics, or that one


74
00:03:15,546 --> 00:03:16,776
feature, that the game is


75
00:03:16,776 --> 00:03:17,746
suddenly going to be fun.


76
00:03:18,496 --> 00:03:19,746
Because, you know, there's a


77
00:03:19,746 --> 00:03:20,796
wasteland of games out there


78
00:03:20,796 --> 00:03:22,316
that were never fun from the


79
00:03:22,316 --> 00:03:22,756
get-go.


80
00:03:22,926 --> 00:03:24,916
So, try not to fool yourself.


81
00:03:25,396 --> 00:03:28,186
Let's start with the gameplay.


82
00:03:31,476 --> 00:03:32,456
Keep games short.


83
00:03:34,046 --> 00:03:35,476
You are looking for a typical


84
00:03:35,476 --> 00:03:37,606
mobile experience still - easy


85
00:03:37,606 --> 00:03:38,526
in, easy out.


86
00:03:39,926 --> 00:03:43,196
You want to keep a variety of


87
00:03:43,246 --> 00:03:44,906
content so that it is fresh,


88
00:03:45,096 --> 00:03:46,836
avoid mental fatigue on the part


89
00:03:46,866 --> 00:03:47,816
of the player of repeating the


90
00:03:47,816 --> 00:03:51,776
same thing over and over again.


91
00:03:51,846 --> 00:03:53,276
One of the things we learned is


92
00:03:53,276 --> 00:03:54,726
that spectating the game turned


93
00:03:54,726 --> 00:03:55,986
out to be just as fun as playing


94
00:03:55,986 --> 00:03:56,076
it.


95
00:03:56,546 --> 00:03:57,596
Sitting there on the sidelines


96
00:03:57,596 --> 00:03:58,436
and watching like it is a


97
00:03:58,436 --> 00:03:59,736
sporting match going side to


98
00:03:59,736 --> 00:04:02,426
side, that is just a really


99
00:04:02,426 --> 00:04:03,446
enjoyable experience.


100
00:04:03,996 --> 00:04:04,866
It's something to think about.


101
00:04:07,666 --> 00:04:09,536
Games are a key form of social


102
00:04:09,536 --> 00:04:10,586
and personal interaction.


103
00:04:12,336 --> 00:04:14,136
Augmented reality can offer a


104
00:04:14,336 --> 00:04:16,716
kind of personal touch that you


105
00:04:16,716 --> 00:04:18,646
might have had before playing


106
00:04:18,646 --> 00:04:19,935
like a traditional card game


107
00:04:19,935 --> 00:04:20,875
around the table with older


108
00:04:20,875 --> 00:04:21,565
relatives.


109
00:04:22,065 --> 00:04:24,696
But now you have technology to


110
00:04:24,696 --> 00:04:25,516
help along the way.


111
00:04:27,226 --> 00:04:31,146
It isn't enough to just take a


112
00:04:31,146 --> 00:04:33,196
3D game and put it on a table in


113
00:04:33,196 --> 00:04:33,616
front of you.


114
00:04:34,406 --> 00:04:35,736
With augmented reality, you know


115
00:04:35,736 --> 00:04:36,966
how the device is positioned.


116
00:04:37,686 --> 00:04:39,416
You also know a little bit about


117
00:04:39,416 --> 00:04:41,566
the user's environment and you


118
00:04:41,566 --> 00:04:42,526
should try to take advantage of


119
00:04:42,526 --> 00:04:43,676
that in the game and make


120
00:04:43,676 --> 00:04:45,246
experiences that are really for


121
00:04:45,246 --> 00:04:46,536
augmented reality first.


122
00:04:51,036 --> 00:04:53,076
Your device can be used as a


123
00:04:53,076 --> 00:04:54,956
camera to look inward at an


124
00:04:54,956 --> 00:04:56,116
object of focus.


125
00:04:56,916 --> 00:04:59,116
In this case, this is a 3D


126
00:04:59,116 --> 00:05:00,686
puzzle game where we're looking


127
00:05:00,686 --> 00:05:01,986
to repair a broken vase.


128
00:05:02,206 --> 00:05:03,186
We can look all around it,


129
00:05:03,676 --> 00:05:04,706
figure out what piece goes


130
00:05:04,706 --> 00:05:06,066
where, and do our best on the


131
00:05:06,066 --> 00:05:06,566
repairs.


132
00:05:07,626 --> 00:05:08,996
In SwiftShot, we took a similar


133
00:05:08,996 --> 00:05:09,506
concept.


134
00:05:10,036 --> 00:05:11,246
The focus is the table you're


135
00:05:11,246 --> 00:05:12,876
playing on and you can walk


136
00:05:12,876 --> 00:05:13,366
around it.


137
00:05:14,006 --> 00:05:15,606
But the table isn't just a


138
00:05:15,606 --> 00:05:16,866
tracking surface for augmented


139
00:05:16,866 --> 00:05:17,226
reality.


140
00:05:17,526 --> 00:05:18,346
It's an integral part of the


141
00:05:18,346 --> 00:05:18,786
gameplay.


142
00:05:19,706 --> 00:05:21,176
The height of the table is


143
00:05:21,256 --> 00:05:23,666
actually significant and as a


144
00:05:23,666 --> 00:05:24,886
result, you'll see in the game


145
00:05:24,886 --> 00:05:26,396
that there are slingshots at


146
00:05:26,396 --> 00:05:27,646
different heights on tops of


147
00:05:27,646 --> 00:05:29,956
stacks of blocks in order to


148
00:05:30,536 --> 00:05:32,196
give you better shots or take


149
00:05:32,196 --> 00:05:33,686
advantage of the player dodging


150
00:05:33,686 --> 00:05:36,976
and weaving a little bit.


151
00:05:37,816 --> 00:05:39,006
Another possible principle is


152
00:05:39,006 --> 00:05:40,296
your device is a camera you use


153
00:05:40,296 --> 00:05:41,336
to look around you.


154
00:05:41,906 --> 00:05:47,026
In this case, we're looking for


155
00:05:47,256 --> 00:05:49,156
unicorns hiding out in the


156
00:05:49,156 --> 00:05:50,266
wilderness and we're taking


157
00:05:50,266 --> 00:05:50,896
pictures of them.


158
00:05:53,046 --> 00:05:54,576
It's just around you, not


159
00:05:55,136 --> 00:05:55,516
inward.


160
00:05:56,736 --> 00:06:01,576
The device can also be a portal


161
00:06:01,576 --> 00:06:02,726
into an alternate universe.


162
00:06:02,976 --> 00:06:04,056
You don't need to see what the


163
00:06:04,056 --> 00:06:05,186
camera sees directly.


164
00:06:06,376 --> 00:06:07,376
The environment can be entirely


165
00:06:07,376 --> 00:06:07,976
replaced.


166
00:06:08,556 --> 00:06:10,286
Laws of physics can be bent or


167
00:06:10,456 --> 00:06:11,446
completely changed.


168
00:06:12,326 --> 00:06:13,226
Whatever you need to do to make


169
00:06:13,226 --> 00:06:13,636
it fun.


170
00:06:14,226 --> 00:06:15,196
In this case, we're able to see


171
00:06:15,196 --> 00:06:16,156
the stars, even though it's


172
00:06:16,186 --> 00:06:16,796
bright daylight.


173
00:06:17,946 --> 00:06:22,316
Also, your device can be the


174
00:06:22,316 --> 00:06:23,966
controller itself.


175
00:06:25,716 --> 00:06:27,296
You're able to fuse yourself


176
00:06:27,296 --> 00:06:29,386
with the virtual world using the


177
00:06:29,386 --> 00:06:30,376
device as the controller.


178
00:06:30,956 --> 00:06:32,736
In this example, we're sort of


179
00:06:32,736 --> 00:06:34,376
magnetically levitating blocks


180
00:06:34,376 --> 00:06:35,556
and placing them in the sorting


181
00:06:35,556 --> 00:06:35,886
cube.


182
00:06:36,706 --> 00:06:37,526
That's the focus of the


183
00:06:37,526 --> 00:06:38,586
interaction in SwiftShot.


184
00:06:39,796 --> 00:06:40,996
You want to encourage slow


185
00:06:40,996 --> 00:06:41,996
movement of the device.


186
00:06:42,966 --> 00:06:44,106
That gives the best images to


187
00:06:44,106 --> 00:06:45,426
the camera without motion blur


188
00:06:45,696 --> 00:06:46,686
and it can do the best job at


189
00:06:46,686 --> 00:06:47,136
tracking.


190
00:06:48,186 --> 00:06:50,256
And despite how thin and light


191
00:06:50,256 --> 00:06:52,386
these devices are, waving them


192
00:06:52,386 --> 00:06:53,676
all around at arm's length turns


193
00:06:53,676 --> 00:06:54,616
out to be a little bit tiring.


194
00:06:54,786 --> 00:06:55,886
So, you're looking for slow and


195
00:06:55,886 --> 00:06:56,876
deliberate movements.


196
00:06:57,146 --> 00:07:00,696
You want to encourage the player


197
00:07:00,696 --> 00:07:02,516
to move around the play field In


198
00:07:02,636 --> 00:07:05,006
this case, our shot of the enemy


199
00:07:05,136 --> 00:07:06,856
slingshot is blocked by those


200
00:07:06,856 --> 00:07:07,366
blocks.


201
00:07:08,026 --> 00:07:09,276
So, we have to move over to


202
00:07:09,276 --> 00:07:11,156
another slingshot to clear the


203
00:07:11,156 --> 00:07:12,000
obstruction.


204
00:07:19,326 --> 00:07:20,646
Control feedback is important


205
00:07:20,646 --> 00:07:21,136
for immersion.


206
00:07:22,146 --> 00:07:24,826
In SwiftShot, we give feedback


207
00:07:24,826 --> 00:07:26,506
using both audio and haptics.


208
00:07:27,576 --> 00:07:29,716
There's a variety of dynamic


209
00:07:29,756 --> 00:07:31,396
behavior in the stretching band


210
00:07:31,396 --> 00:07:35,056
sound and haptics on the phones


211
00:07:35,056 --> 00:07:36,316
to give you that feel that


212
00:07:36,316 --> 00:07:36,826
you're doing it.


213
00:07:37,406 --> 00:07:38,876
We'll talk a lot more later


214
00:07:38,876 --> 00:07:40,036
about the dynamic audio.


215
00:07:42,956 --> 00:07:44,196
So, next I'd like to bring up


216
00:07:44,196 --> 00:07:46,096
David Paschich, who will go deep


217
00:07:46,096 --> 00:07:47,376
into the details of SwiftShot.


218
00:07:47,786 --> 00:07:48,666
Thank you.


219
00:07:50,286 --> 00:07:50,486
David?


220
00:07:53,756 --> 00:07:55,086
>> Thank you Alex, and hello,


221
00:07:55,086 --> 00:07:55,536
everybody.


222
00:07:55,536 --> 00:07:58,256
I just want to echo what Alex


223
00:07:58,256 --> 00:07:58,546
said.


224
00:07:58,546 --> 00:08:00,056
The response that we've seen


225
00:08:00,056 --> 00:08:01,136
from people here at the show to


226
00:08:01,136 --> 00:08:02,596
SwiftShot has been really


227
00:08:02,596 --> 00:08:04,196
amazing and it's been gratifying


228
00:08:04,196 --> 00:08:05,496
to see some people already


229
00:08:05,846 --> 00:08:07,106
downloading it, building it and


230
00:08:07,106 --> 00:08:08,266
altering it from the sample


231
00:08:08,266 --> 00:08:08,606
code.


232
00:08:08,606 --> 00:08:09,746
So, I thank you for that.


233
00:08:09,746 --> 00:08:10,966
We're really excited about that.


234
00:08:10,966 --> 00:08:13,476
I want to talk by talking first


235
00:08:13,476 --> 00:08:15,246
about the technologies we used


236
00:08:15,246 --> 00:08:16,126
in building SwiftShot.


237
00:08:16,516 --> 00:08:18,736
The first and foremost is ARKit,


238
00:08:19,166 --> 00:08:20,766
which lets us render the content


239
00:08:20,916 --> 00:08:22,416
into the physical world around


240
00:08:22,416 --> 00:08:23,656
the players, immersing them in


241
00:08:23,656 --> 00:08:24,396
the experience.


242
00:08:26,336 --> 00:08:28,636
We use SceneKit to manage and


243
00:08:28,636 --> 00:08:30,096
draw that content, using


244
00:08:30,096 --> 00:08:31,896
advanced 3D rendering and


245
00:08:31,896 --> 00:08:33,106
realistic physics for fun


246
00:08:33,106 --> 00:08:33,466
gameplay.


247
00:08:35,186 --> 00:08:36,686
Metal lets us harness the power


248
00:08:36,686 --> 00:08:39,686
of the GPU devices.


249
00:08:39,686 --> 00:08:41,655
It came into play both within


250
00:08:41,655 --> 00:08:43,256
SceneKit for the shading and


251
00:08:43,256 --> 00:08:45,346
rendering and also for the flag


252
00:08:45,346 --> 00:08:46,346
simulation, which I'll talk


253
00:08:46,346 --> 00:08:48,166
about a little later on.


254
00:08:48,856 --> 00:08:50,406
GameplayKit provides an entity


255
00:08:50,406 --> 00:08:52,046
component architecture for our


256
00:08:52,046 --> 00:08:52,666
game object.


257
00:08:52,786 --> 00:08:54,526
It let us easily share behaviors


258
00:08:54,526 --> 00:08:57,506
between objects in the game.


259
00:08:57,716 --> 00:08:59,566
Multi-peer connectivity provides


260
00:08:59,566 --> 00:09:01,676
the networking layer, including


261
00:09:01,676 --> 00:09:03,426
discovery of nearby devices and


262
00:09:03,426 --> 00:09:05,716
synchronization, and encryption


263
00:09:05,716 --> 00:09:05,976
as well.


264
00:09:07,396 --> 00:09:09,206
AV Foundation controls both the


265
00:09:09,206 --> 00:09:11,056
music for atmosphere and the


266
00:09:11,056 --> 00:09:13,186
sound effects for the devices,


267
00:09:13,186 --> 00:09:14,236
really giving you that immersive


268
00:09:14,236 --> 00:09:14,846
experience.


269
00:09:16,026 --> 00:09:17,706
And lastly, we built the entire


270
00:09:17,706 --> 00:09:18,806
application in Swift.


271
00:09:19,426 --> 00:09:22,216
Swift's type safety, performance


272
00:09:22,696 --> 00:09:25,196
and advanced features like


273
00:09:25,196 --> 00:09:27,366
protocol extensions let us focus


274
00:09:27,366 --> 00:09:28,756
more on the gameplay and worry


275
00:09:28,756 --> 00:09:30,196
less about crashes and


276
00:09:30,196 --> 00:09:31,536
mismatched interfaces between


277
00:09:31,536 --> 00:09:32,136
code layers.


278
00:09:32,626 --> 00:09:36,716
Those are the iOS technologies


279
00:09:36,716 --> 00:09:37,176
we use.


280
00:09:37,576 --> 00:09:39,026
I'll talk about how we use those


281
00:09:39,026 --> 00:09:40,406
as we implemented several of the


282
00:09:40,406 --> 00:09:41,266
features of the game.


283
00:09:41,836 --> 00:09:43,206
Establishing the shared


284
00:09:43,206 --> 00:09:43,996
coordinate space.


285
00:09:44,796 --> 00:09:45,366
Networking.


286
00:09:46,096 --> 00:09:48,546
Physics. Asset important and


287
00:09:48,546 --> 00:09:48,896
management.


288
00:09:49,696 --> 00:09:50,656
Flag simulation.


289
00:09:51,086 --> 00:09:52,006
And the dynamic audio.


290
00:09:52,006 --> 00:09:56,226
We'll start by talking about


291
00:09:56,226 --> 00:09:57,556
setting up a shared coordinate


292
00:09:57,556 --> 00:09:58,036
space.


293
00:09:58,376 --> 00:10:00,926
The key in the experience is


294
00:10:00,926 --> 00:10:02,196
having the player see the same


295
00:10:02,196 --> 00:10:03,636
object in the same places on


296
00:10:03,636 --> 00:10:04,406
both devices.


297
00:10:04,876 --> 00:10:06,186
To do that, we have to have a


298
00:10:06,186 --> 00:10:07,216
shared coordinate space,


299
00:10:07,796 --> 00:10:09,386
allowing them to talk about


300
00:10:09,386 --> 00:10:10,896
locations in the world in the


301
00:10:10,896 --> 00:10:12,000
same way.


302
00:10:14,046 --> 00:10:15,076
ARKit provides a number of


303
00:10:15,076 --> 00:10:16,406
features you can use to set this


304
00:10:16,406 --> 00:10:16,606
up.


305
00:10:17,126 --> 00:10:20,056
In iOS 11.3, we introduced image


306
00:10:20,056 --> 00:10:21,596
recognition, allowing your apps


307
00:10:21,596 --> 00:10:22,926
to recognize images in the world


308
00:10:22,926 --> 00:10:23,366
around you.


309
00:10:24,796 --> 00:10:27,036
Now in iOS 12, we're adding two


310
00:10:27,036 --> 00:10:28,926
additional technologies - object


311
00:10:28,926 --> 00:10:30,966
detection and world map sharing.


312
00:10:32,356 --> 00:10:34,046
Both image detection and object


313
00:10:34,046 --> 00:10:35,896
detection let you add content to


314
00:10:35,896 --> 00:10:37,116
things the user sees in the real


315
00:10:37,116 --> 00:10:38,836
world but they require you to


316
00:10:38,836 --> 00:10:40,106
have pre-recorded those objects


317
00:10:40,106 --> 00:10:41,086
for later recognition.


318
00:10:41,696 --> 00:10:42,656
You saw that in the keynote


319
00:10:42,656 --> 00:10:43,616
during the Lego demo,


320
00:10:43,866 --> 00:10:45,196
recognizing built models and


321
00:10:45,196 --> 00:10:45,936
adding content.


322
00:10:46,446 --> 00:10:48,966
For this game, we wanted to


323
00:10:48,966 --> 00:10:50,316
enable users to play anywhere


324
00:10:50,316 --> 00:10:51,556
with a table such as a cafÃ©,


325
00:10:51,556 --> 00:10:52,816
their kitchen and so forth.


326
00:10:53,166 --> 00:10:54,286
WorldMap sharing is how we did


327
00:10:55,186 --> 00:10:55,306
that.


328
00:10:55,716 --> 00:10:56,556
You can also apply this


329
00:10:56,556 --> 00:10:57,566
technique to applications


330
00:10:57,566 --> 00:10:59,086
besides games, like a fixed


331
00:10:59,086 --> 00:11:00,236
installation in a retail


332
00:11:00,236 --> 00:11:01,636
environment or a museum.


333
00:11:02,486 --> 00:11:04,856
In the game room downstairs, we


334
00:11:04,856 --> 00:11:06,326
use iBeacons so devices know


335
00:11:06,326 --> 00:11:09,436
which table they're next to and


336
00:11:09,436 --> 00:11:10,666
can load the correct WorldMap


337
00:11:10,986 --> 00:11:11,636
for that area.


338
00:11:12,236 --> 00:11:13,436
That really makes the experience


339
00:11:13,436 --> 00:11:13,786
magical.


340
00:11:14,326 --> 00:11:17,946
One of the features of SwiftShot


341
00:11:17,996 --> 00:11:18,866
you may have used if you built


342
00:11:18,866 --> 00:11:20,476
your app yourself is the ability


343
00:11:20,476 --> 00:11:23,036
to, ability for players to place


344
00:11:23,036 --> 00:11:23,956
the game board in the virtual


345
00:11:23,956 --> 00:11:24,326
world.


346
00:11:24,706 --> 00:11:26,136
At the tables downstairs, we're


347
00:11:26,136 --> 00:11:27,326
using preloaded maps.


348
00:11:27,456 --> 00:11:28,766
But here's an example of


349
00:11:28,766 --> 00:11:30,046
building your own board and


350
00:11:30,046 --> 00:11:31,866
placing it in the virtual world.


351
00:11:32,716 --> 00:11:34,986
This is how that works.


352
00:11:36,046 --> 00:11:37,316
As you saw in the video, you


353
00:11:37,316 --> 00:11:38,836
start by scanning the surface,


354
00:11:38,916 --> 00:11:40,366
letting ARKit build up a map of


355
00:11:40,366 --> 00:11:40,766
the area.


356
00:11:41,376 --> 00:11:43,916
You can then serialize that map


357
00:11:43,916 --> 00:11:45,726
out as data and transfer it to


358
00:11:45,726 --> 00:11:46,436
another device.


359
00:11:47,716 --> 00:11:49,236
The target device then loads the


360
00:11:49,236 --> 00:11:51,386
map into ARKit and uses it to


361
00:11:51,386 --> 00:11:52,816
recognize the same surface.


362
00:11:53,346 --> 00:11:54,396
At that point, we now have a


363
00:11:54,396 --> 00:11:55,626
shared reference point in the


364
00:11:55,626 --> 00:11:57,926
real world, and both devices can


365
00:11:57,926 --> 00:11:58,986
render the game board into the


366
00:11:58,986 --> 00:12:00,446
same place in that world.


367
00:12:02,576 --> 00:12:03,566
The first step in the


368
00:12:03,566 --> 00:12:05,036
implementation is getting the


369
00:12:05,036 --> 00:12:06,386
World Map from the ARSession on


370
00:12:06,386 --> 00:12:07,236
the first device.


371
00:12:08,186 --> 00:12:09,786
That's the call to a new API in


372
00:12:09,876 --> 00:12:11,776
iOS 12 in ARSession,


373
00:12:11,956 --> 00:12:12,836
getCurrentWorldMap.


374
00:12:13,376 --> 00:12:15,006
It builds an ARWorldMap object


375
00:12:15,196 --> 00:12:16,236
from the session's current


376
00:12:16,236 --> 00:12:17,196
understanding of the world


377
00:12:17,196 --> 00:12:19,036
around you and then returns it


378
00:12:19,036 --> 00:12:20,226
in an asynchronous callback.


379
00:12:20,976 --> 00:12:23,876
We then use NSKeyedArchiver to


380
00:12:23,876 --> 00:12:25,116
serialize that out to a data


381
00:12:25,116 --> 00:12:25,666
object.


382
00:12:26,396 --> 00:12:27,846
You can then save the data or


383
00:12:27,846 --> 00:12:28,746
send it over the network.


384
00:12:31,316 --> 00:12:32,906
Once you have that data object,


385
00:12:33,546 --> 00:12:34,616
you next have to decide how to


386
00:12:34,616 --> 00:12:35,636
get it from one device to


387
00:12:35,636 --> 00:12:35,956
another.


388
00:12:36,456 --> 00:12:38,286
For ad hoc gaming like you saw


389
00:12:38,376 --> 00:12:40,286
in the videoing, SwiftShot uses


390
00:12:40,286 --> 00:12:41,086
a peer-to-peer network


391
00:12:41,086 --> 00:12:42,466
connection which we'll get into


392
00:12:42,466 --> 00:12:43,436
more detail on shortly.


393
00:12:43,976 --> 00:12:45,716
When the second device joins the


394
00:12:45,716 --> 00:12:47,376
network session, the first


395
00:12:47,376 --> 00:12:48,776
device serialized the WorldMap


396
00:12:48,776 --> 00:12:50,076
and sent it over the network.


397
00:12:50,826 --> 00:12:52,126
This is great for casual gaming


398
00:12:52,126 --> 00:12:53,696
situations, allowing users to


399
00:12:53,696 --> 00:12:55,346
set up anywhere they can find a


400
00:12:55,346 --> 00:12:56,756
surface to play on.


401
00:12:58,536 --> 00:12:59,596
For the gaming tables


402
00:12:59,596 --> 00:13:00,886
downstairs, we used a different


403
00:13:00,886 --> 00:13:01,306
approach.


404
00:13:01,676 --> 00:13:03,316
We spent some time during setup


405
00:13:03,316 --> 00:13:04,966
for the conference recording


406
00:13:04,966 --> 00:13:05,966
WorldMaps for each of the


407
00:13:05,966 --> 00:13:07,776
tables, ensuring that we could


408
00:13:07,776 --> 00:13:09,186
localize that shared coordinate


409
00:13:09,186 --> 00:13:10,486
space from multiple angles.


410
00:13:11,236 --> 00:13:12,456
Each table has its own unique


411
00:13:12,456 --> 00:13:13,856
characteristics as well as


412
00:13:13,856 --> 00:13:15,386
slightly different lighting and


413
00:13:15,386 --> 00:13:15,826
positioning.


414
00:13:16,286 --> 00:13:18,586
We then saved the files to local


415
00:13:18,586 --> 00:13:19,726
sstorage on each device.


416
00:13:20,666 --> 00:13:21,946
Since the devices in use are


417
00:13:21,946 --> 00:13:23,116
managed by our conference team,


418
00:13:23,346 --> 00:13:24,616
we're able to use mobile device


419
00:13:24,616 --> 00:13:26,116
management to make sure that the


420
00:13:26,116 --> 00:13:27,626
same files are present on every


421
00:13:27,626 --> 00:13:29,026
device in the game.


422
00:13:29,846 --> 00:13:33,676
To make the solution even more


423
00:13:33,676 --> 00:13:35,506
seamless, you can use iBeacons


424
00:13:35,646 --> 00:13:36,256
on each table.


425
00:13:36,746 --> 00:13:38,826
By correlating the identifier of


426
00:13:38,826 --> 00:13:39,866
the iBeacon with particular


427
00:13:39,866 --> 00:13:41,796
WorldMaps, each instance of the


428
00:13:41,796 --> 00:13:43,316
SwiftShot application can load


429
00:13:43,316 --> 00:13:44,076
the correct WorldMap


430
00:13:44,076 --> 00:13:44,676
automatically.


431
00:13:45,266 --> 00:13:46,386
Now, if you're building a


432
00:13:46,386 --> 00:13:48,626
consumer application, you can


433
00:13:48,626 --> 00:13:50,736
also use things like iOS's


434
00:13:50,736 --> 00:13:53,516
on-demand resources or your own


435
00:13:53,516 --> 00:13:55,236
cloud-sharing solution to share


436
00:13:55,236 --> 00:13:56,606
WorldMaps between devices.


437
00:13:57,196 --> 00:13:58,276
This would allow you to for


438
00:13:58,276 --> 00:13:59,806
instance select the correct


439
00:13:59,806 --> 00:14:01,566
WorldMap for a particular retail


440
00:14:01,566 --> 00:14:02,996
location somewhere out in the


441
00:14:02,996 --> 00:14:03,246
world.


442
00:14:04,326 --> 00:14:05,086
There's really a lot


443
00:14:05,086 --> 00:14:06,866
possibilities here to tailor


444
00:14:06,866 --> 00:14:08,146
users' experience and really


445
00:14:08,146 --> 00:14:08,836
build something great.


446
00:14:09,336 --> 00:14:12,746
So, those are a couple of the


447
00:14:12,746 --> 00:14:14,426
ways to get that WorldMap data


448
00:14:14,576 --> 00:14:15,726
from one device to another.


449
00:14:16,386 --> 00:14:17,746
Let's talk about how you then


450
00:14:17,746 --> 00:14:19,106
load it on the second device.


451
00:14:19,386 --> 00:14:20,796
In this case, we use


452
00:14:20,846 --> 00:14:24,336
NSKeyUnarchiveder to blow up


453
00:14:24,336 --> 00:14:25,746
that WorldMap again from the


454
00:14:25,746 --> 00:14:26,956
data that we received.


455
00:14:27,836 --> 00:14:29,926
We then build an ARWorldTracking


456
00:14:29,926 --> 00:14:31,696
configuration and add the


457
00:14:31,696 --> 00:14:33,456
WorldMap to that configuration


458
00:14:33,456 --> 00:14:35,236
object, setting up the way we


459
00:14:35,236 --> 00:14:35,386
want.


460
00:14:36,246 --> 00:14:38,606
And then lastly, we ask the


461
00:14:38,606 --> 00:14:39,646
ARSession to run that


462
00:14:39,646 --> 00:14:41,736
configuration, resetting any


463
00:14:41,736 --> 00:14:45,116
existing anchors and tracking.


464
00:14:45,116 --> 00:14:47,016
ARKit on the target device then


465
00:14:47,016 --> 00:14:48,366
starts scanning the world around


466
00:14:48,366 --> 00:14:50,366
you, correlating those feature


467
00:14:50,366 --> 00:14:52,706
points from the original map


468
00:14:52,706 --> 00:14:53,776
with those that it sees there.


469
00:14:54,166 --> 00:14:55,396
Once it's able to do that,


470
00:14:55,656 --> 00:14:56,456
you've got that shared


471
00:14:56,456 --> 00:14:57,276
coordinate space.


472
00:14:57,696 --> 00:14:59,966
Both devices have 000 in the


473
00:14:59,966 --> 00:15:01,096
same place in the real world.


474
00:15:01,396 --> 00:15:05,446
So, a quick word about privacy


475
00:15:05,446 --> 00:15:06,196
with WorldMaps.


476
00:15:06,826 --> 00:15:07,916
In the process of recording the


477
00:15:07,916 --> 00:15:09,926
WorldMap, we take into account


478
00:15:10,076 --> 00:15:11,226
features of the world around


479
00:15:11,226 --> 00:15:12,386
you, physical arrangements of


480
00:15:12,386 --> 00:15:13,616
objects and so forth.


481
00:15:15,016 --> 00:15:16,746
While it does include geographic


482
00:15:16,746 --> 00:15:18,036
information like latitude and


483
00:15:18,036 --> 00:15:19,366
longitude and thus your


484
00:15:19,366 --> 00:15:20,756
application doesn't need to ask


485
00:15:20,756 --> 00:15:22,296
for location permission to use


486
00:15:22,296 --> 00:15:25,046
ARKit, it may include personally


487
00:15:25,046 --> 00:15:26,726
identifiable information about


488
00:15:26,726 --> 00:15:27,736
the user's environment.


489
00:15:28,686 --> 00:15:29,976
So, we recommend that you treat


490
00:15:30,046 --> 00:15:32,086
a serialized WorldMap the same


491
00:15:32,156 --> 00:15:33,266
way that you would any other


492
00:15:33,266 --> 00:15:35,866
user-created private data.


493
00:15:36,156 --> 00:15:38,686
This means that you want to make


494
00:15:38,686 --> 00:15:39,846
sure that you're encrypting it


495
00:15:40,616 --> 00:15:41,976
both at rest and when moving


496
00:15:41,976 --> 00:15:42,746
across the network.


497
00:15:43,666 --> 00:15:44,676
You may also want to let your


498
00:15:44,676 --> 00:15:46,406
users know if you're planning to


499
00:15:46,636 --> 00:15:48,156
save that WorldMap information


500
00:15:48,156 --> 00:15:49,586
for an extended period of time,


501
00:15:49,896 --> 00:15:51,316
past a single session of your


502
00:15:51,316 --> 00:15:51,856
application.


503
00:15:53,296 --> 00:15:54,766
In SwiftShot, we're able to take


504
00:15:54,766 --> 00:15:56,806
advantage of iOS's built-in


505
00:15:56,986 --> 00:15:59,596
encryption for encrypting the


506
00:15:59,596 --> 00:16:00,606
data while at rest.


507
00:16:01,376 --> 00:16:03,496
I'll talk next about how we did


508
00:16:03,496 --> 00:16:05,246
the networking for encryption,


509
00:16:05,546 --> 00:16:06,526
on the networking.


510
00:16:07,066 --> 00:16:10,496
Now, in addition to setting up


511
00:16:10,496 --> 00:16:12,616
shared coordinate space for


512
00:16:12,616 --> 00:16:14,006
SwiftShot, we needed to tell the


513
00:16:14,006 --> 00:16:15,416
other device where the user has


514
00:16:15,416 --> 00:16:16,716
chosen to locate the board.


515
00:16:17,236 --> 00:16:19,266
We use an ARAnchor to do this.


516
00:16:19,676 --> 00:16:21,666
When you create an ARAnchor, you


517
00:16:21,666 --> 00:16:23,536
provide a name as well as


518
00:16:23,536 --> 00:16:24,736
position and rotation


519
00:16:24,736 --> 00:16:26,386
information as a 4 x 4


520
00:16:26,386 --> 00:16:26,836
transform.


521
00:16:27,306 --> 00:16:30,236
ARKit can then include the


522
00:16:30,236 --> 00:16:32,176
Anchor in the ARWorldMap we


523
00:16:32,176 --> 00:16:34,386
generate and serialize out, and


524
00:16:34,386 --> 00:16:35,476
then, so we can transfer that


525
00:16:35,476 --> 00:16:36,936
board information to the other


526
00:16:36,936 --> 00:16:37,496
device.


527
00:16:38,106 --> 00:16:40,906
Now, the system ARAnchor class


528
00:16:40,906 --> 00:16:42,576
just has the name and the


529
00:16:42,576 --> 00:16:43,836
orientation we created.


530
00:16:44,196 --> 00:16:45,656
We can look up the anchor that


531
00:16:45,656 --> 00:16:46,846
we're interested in by name on


532
00:16:46,846 --> 00:16:47,406
the other side.


533
00:16:48,036 --> 00:16:49,286
For our application though, we


534
00:16:49,286 --> 00:16:50,596
need to include some additional


535
00:16:50,596 --> 00:16:51,946
information for the other


536
00:16:51,946 --> 00:16:53,946
device, and that's the size that


537
00:16:53,996 --> 00:16:55,976
the user chose for that board,


538
00:16:56,306 --> 00:16:57,456
deciding whether they're playing


539
00:16:57,456 --> 00:16:59,356
on a, you know, a small table


540
00:16:59,356 --> 00:17:00,936
top and surface, or they want to


541
00:17:00,936 --> 00:17:02,576
blow the board up to be the size


542
00:17:02,576 --> 00:17:03,646
of a basketball court.


543
00:17:04,106 --> 00:17:07,656
We thought about, you know,


544
00:17:07,656 --> 00:17:08,646
adding that to our network


545
00:17:08,646 --> 00:17:10,435
protocol alongside the WorldMap,


546
00:17:10,826 --> 00:17:11,536
but then we came up with a


547
00:17:11,536 --> 00:17:12,126
better solution.


548
00:17:13,415 --> 00:17:15,455
We created a custom subclass of


549
00:17:15,455 --> 00:17:16,836
ARAnchor that we called board


550
00:17:16,836 --> 00:17:18,546
anchor and added that


551
00:17:18,546 --> 00:17:20,165
information to that class, the


552
00:17:20,165 --> 00:17:20,935
size of the board.


553
00:17:22,236 --> 00:17:24,796
We then made sure that we


554
00:17:24,796 --> 00:17:27,026
implemented the NSCoding


555
00:17:27,026 --> 00:17:28,546
required classes or override


556
00:17:28,546 --> 00:17:30,546
them to include that information


557
00:17:30,866 --> 00:17:32,486
when the object is serialized


558
00:17:32,486 --> 00:17:32,696
out.


559
00:17:33,376 --> 00:17:35,076
Now, the information is included


560
00:17:35,076 --> 00:17:36,476
directly within the WorldMap


561
00:17:36,836 --> 00:17:38,066
when we transfer it over to the


562
00:17:38,066 --> 00:17:38,776
other device.


563
00:17:39,146 --> 00:17:40,166
It makes it very easy and


564
00:17:40,166 --> 00:17:40,766
straightforward.


565
00:17:42,116 --> 00:17:43,236
One thing to keep in mind, and


566
00:17:43,236 --> 00:17:44,986
this bit us for a little bit.


567
00:17:45,476 --> 00:17:47,996
When you use Swift to make a


568
00:17:47,996 --> 00:17:50,036
subclass like this, when you


569
00:17:50,036 --> 00:17:52,136
serialize it out, the name of


570
00:17:52,136 --> 00:17:53,416
the module or the name of your


571
00:17:53,416 --> 00:17:54,856
application is included in the


572
00:17:54,856 --> 00:17:55,356
class name.


573
00:17:56,016 --> 00:17:57,296
This is something to be aware of


574
00:17:57,336 --> 00:17:58,406
if you're planning to move


575
00:17:58,406 --> 00:17:59,786
WorldMaps between different


576
00:17:59,786 --> 00:18:00,556
applications.


577
00:18:01,016 --> 00:18:02,556
NSKeyedArchiver can help you


578
00:18:02,666 --> 00:18:03,906
accommodate that.


579
00:18:04,676 --> 00:18:06,306
So, that's WorldMap sharing.


580
00:18:06,756 --> 00:18:08,976
It's a new feature in iOS 12.


581
00:18:09,136 --> 00:18:10,156
We're really looking forward to


582
00:18:10,156 --> 00:18:11,716
seeing what everyone can build


583
00:18:12,376 --> 00:18:14,336
with that.


584
00:18:14,536 --> 00:18:15,376
Next, let's talk about the


585
00:18:15,376 --> 00:18:17,466
networking we built into the


586
00:18:17,826 --> 00:18:17,936
game.


587
00:18:17,936 --> 00:18:19,566
We used iOS's multi-peer


588
00:18:19,566 --> 00:18:21,236
connectivity API which has been


589
00:18:21,236 --> 00:18:22,906
in the system since iOS 7 in


590
00:18:22,906 --> 00:18:23,746
order to do this.


591
00:18:24,636 --> 00:18:25,856
Multi-peer connectivity.


592
00:18:26,106 --> 00:18:27,146
Allows us to set up a


593
00:18:27,146 --> 00:18:28,626
peer-to-peer session on a local


594
00:18:28,626 --> 00:18:30,776
network, allowing devices in the


595
00:18:30,776 --> 00:18:32,246
session to communicate without


596
00:18:32,246 --> 00:18:33,206
going through a dedicated


597
00:18:33,206 --> 00:18:33,516
server.


598
00:18:34,506 --> 00:18:35,616
Now, in our application, we


599
00:18:35,616 --> 00:18:37,126
designate one of the devices as


600
00:18:37,126 --> 00:18:39,026
the server but that's something


601
00:18:39,026 --> 00:18:40,286
that we did for our application.


602
00:18:40,286 --> 00:18:41,146
It's not inherent in the


603
00:18:41,146 --> 00:18:41,516
protocol.


604
00:18:43,046 --> 00:18:44,346
Encryption and authentication


605
00:18:44,346 --> 00:18:45,536
are built into multi-peer


606
00:18:45,536 --> 00:18:46,146
connectivity.


607
00:18:46,866 --> 00:18:48,006
In our case, we didn't use


608
00:18:48,006 --> 00:18:49,436
authentication because we wanted


609
00:18:49,436 --> 00:18:50,506
a very quick in-and-out


610
00:18:50,506 --> 00:18:52,336
experience but we did use


611
00:18:52,396 --> 00:18:52,966
encryption.


612
00:18:53,516 --> 00:18:54,596
We found that turning on


613
00:18:54,596 --> 00:18:56,276
encryption really provided no


614
00:18:56,276 --> 00:18:58,016
performance penalty, so there's


615
00:18:58,376 --> 00:19:00,936
either in network data size or


616
00:19:00,936 --> 00:19:01,536
computation.


617
00:19:01,646 --> 00:19:02,666
So there's really no reason not


618
00:19:02,666 --> 00:19:04,306
to use it.


619
00:19:05,126 --> 00:19:06,616
Multi-peer connectivity also


620
00:19:06,616 --> 00:19:08,596
provides APIs for advertisements


621
00:19:08,696 --> 00:19:09,316
and discovery.


622
00:19:09,846 --> 00:19:11,256
We use this to broadcast


623
00:19:11,256 --> 00:19:12,476
available games and allow


624
00:19:12,536 --> 00:19:13,596
players to select a game to


625
00:19:14,226 --> 00:19:14,316
join.


626
00:19:14,956 --> 00:19:16,056
So, here's how we get that


627
00:19:16,056 --> 00:19:16,616
session set up.


628
00:19:17,486 --> 00:19:19,116
First, on one device, the user


629
00:19:19,116 --> 00:19:20,906
decides to set themselves up as


630
00:19:20,906 --> 00:19:21,936
hosts for the application.


631
00:19:23,356 --> 00:19:24,746
They scan the world, place the


632
00:19:24,746 --> 00:19:27,456
gameboard within that world, and


633
00:19:27,456 --> 00:19:29,026
then the device starts a new


634
00:19:29,026 --> 00:19:30,516
session, a multi-peer


635
00:19:30,516 --> 00:19:31,966
connectivity session, and starts


636
00:19:31,966 --> 00:19:33,486
advertising it to other devices


637
00:19:33,486 --> 00:19:34,806
on the local network.


638
00:19:35,476 --> 00:19:37,866
A user on the other device sees


639
00:19:37,866 --> 00:19:39,036
a list of available games.


640
00:19:39,546 --> 00:19:41,856
When he selects one, his device


641
00:19:41,856 --> 00:19:42,916
sends a request to join the


642
00:19:42,916 --> 00:19:43,716
existing session.


643
00:19:45,276 --> 00:19:47,186
Once the first device accepts


644
00:19:47,186 --> 00:19:48,346
the request, multi-peer


645
00:19:48,346 --> 00:19:49,686
connectivity sets up a true


646
00:19:49,686 --> 00:19:50,526
peer-to-peer network.


647
00:19:51,086 --> 00:19:53,226
Any device in the network can


648
00:19:53,226 --> 00:19:54,266
send a message to any other


649
00:19:54,266 --> 00:19:55,126
device in the network.


650
00:19:55,976 --> 00:19:58,246
In SwiftShot, we designate the


651
00:19:58,246 --> 00:19:59,576
device that started the session


652
00:19:59,576 --> 00:20:00,796
as the source of truth for the


653
00:20:00,796 --> 00:20:01,336
game state.


654
00:20:01,736 --> 00:20:03,226
But again, that's the decision


655
00:20:03,226 --> 00:20:04,166
we layered on top of the


656
00:20:04,166 --> 00:20:05,636
networking protocol; it's not


657
00:20:05,636 --> 00:20:06,566
inherent in multi-peer


658
00:20:06,566 --> 00:20:07,116
connectivity.


659
00:20:07,536 --> 00:20:11,696
Once the session is set up,


660
00:20:11,696 --> 00:20:13,366
multi-peer connectivity lets us


661
00:20:13,366 --> 00:20:15,006
send data between peers in three


662
00:20:15,006 --> 00:20:15,416
ways.


663
00:20:15,946 --> 00:20:17,096
As data packets.


664
00:20:17,716 --> 00:20:19,906
As resources, file URLs on the


665
00:20:19,906 --> 00:20:20,636
local storage.


666
00:20:21,096 --> 00:20:21,946
And as streams.


667
00:20:22,716 --> 00:20:23,986
Data objects can be sent,


668
00:20:23,986 --> 00:20:25,216
broadcast to all peers in the


669
00:20:25,216 --> 00:20:27,366
network whereas resources and


670
00:20:27,366 --> 00:20:28,766
streams are device to device.


671
00:20:29,026 --> 00:20:32,196
In SwiftShot, we use the data


672
00:20:32,196 --> 00:20:33,816
packets primarily as a way to


673
00:20:33,816 --> 00:20:35,676
share game events and also the


674
00:20:35,676 --> 00:20:36,256
physics state.


675
00:20:36,566 --> 00:20:38,886
We'll talk about that later on.


676
00:20:38,886 --> 00:20:40,206
And then we used the resources


677
00:20:40,206 --> 00:20:41,186
to transfer the WorldMap.


678
00:20:41,186 --> 00:20:43,146
It ended up we didn't need


679
00:20:43,146 --> 00:20:44,176
streams for our application.


680
00:20:44,656 --> 00:20:47,456
Under the covers, multi-peer


681
00:20:47,456 --> 00:20:49,326
connectivity relies on UDP for


682
00:20:49,326 --> 00:20:50,736
the transfer between devices.


683
00:20:51,366 --> 00:20:53,726
This gives a low latency for,


684
00:20:53,896 --> 00:20:55,156
great for applications like


685
00:20:55,156 --> 00:20:55,506
games.


686
00:20:56,536 --> 00:20:57,926
Now, UDP inherently doesn't


687
00:20:57,926 --> 00:20:59,436
guarantee delivery, so


688
00:20:59,436 --> 00:21:00,886
multi-peer connectivity lets you


689
00:21:00,886 --> 00:21:02,786
make that decision and specify


690
00:21:02,786 --> 00:21:04,206
whether a particular data packet


691
00:21:04,206 --> 00:21:06,016
is to be sent reliably or


692
00:21:06,016 --> 00:21:06,626
unreliably.


693
00:21:07,556 --> 00:21:08,716
If you choose reliably,


694
00:21:09,246 --> 00:21:10,606
multi-peer connectivity takes


695
00:21:10,606 --> 00:21:12,046
care of the retries for you, so


696
00:21:12,176 --> 00:21:13,316
you don't have to worry about


697
00:21:13,346 --> 00:21:15,876
that in your code.


698
00:21:15,876 --> 00:21:17,426
Even when you're broadcasting to


699
00:21:17,426 --> 00:21:18,676
all members of the session.


700
00:21:18,676 --> 00:21:22,686
Now that we have a networking


701
00:21:22,686 --> 00:21:24,106
layer, we need to build our


702
00:21:24,106 --> 00:21:25,446
application protocol on top of


703
00:21:26,166 --> 00:21:26,236
it.


704
00:21:26,456 --> 00:21:28,456
SwiftEnums with associated types


705
00:21:28,736 --> 00:21:29,756
make this very easy.


706
00:21:30,736 --> 00:21:32,416
Each case has a data structure


707
00:21:32,416 --> 00:21:34,356
around it, ensuring type safety


708
00:21:34,606 --> 00:21:35,896
as information moves around the


709
00:21:35,896 --> 00:21:36,266
system.


710
00:21:37,496 --> 00:21:39,056
Some of those can be further


711
00:21:39,056 --> 00:21:39,496
enums.


712
00:21:39,866 --> 00:21:40,766
So, for instance, in this


713
00:21:40,766 --> 00:21:42,446
example, gameAction includes


714
00:21:42,446 --> 00:21:43,806
things like a player grabbed a


715
00:21:43,806 --> 00:21:44,386
catapult.


716
00:21:44,386 --> 00:21:46,076
A projectile launched, and so


717
00:21:46,076 --> 00:21:46,386
forth.


718
00:21:47,166 --> 00:21:48,966
The PhysicsSyncData is a strut


719
00:21:49,096 --> 00:21:50,476
and we'll talk more about how we


720
00:21:50,476 --> 00:21:52,336
encoded that later on.


721
00:21:53,316 --> 00:21:55,046
Again, Swift makes this very


722
00:21:55,046 --> 00:21:55,276
easy.


723
00:21:55,576 --> 00:21:57,206
For struts, if all the members


724
00:21:57,206 --> 00:21:59,136
of the struct are codable, then


725
00:21:59,136 --> 00:22:00,756
all you need to do is mark that


726
00:22:00,756 --> 00:22:02,406
struct as codable and the Swift


727
00:22:02,406 --> 00:22:03,646
compiler takes care of the rest,


728
00:22:04,096 --> 00:22:05,286
building all the infrastructure


729
00:22:05,286 --> 00:22:06,596
needed for the serialization.


730
00:22:07,006 --> 00:22:09,706
Swift doesn't do that for enums


731
00:22:09,936 --> 00:22:11,456
and so we ended up implementing


732
00:22:11,456 --> 00:22:14,226
that ourselves, implementing the


733
00:22:14,226 --> 00:22:16,806
init and then coding method from


734
00:22:16,806 --> 00:22:18,766
the codable protocol to make


735
00:22:19,196 --> 00:22:20,716
that work.


736
00:22:20,906 --> 00:22:22,596
Serialization then is very easy.


737
00:22:22,806 --> 00:22:23,926
Just build a property listing


738
00:22:23,926 --> 00:22:25,426
coder and have it encode the


739
00:22:25,426 --> 00:22:26,146
object out for you.


740
00:22:26,786 --> 00:22:28,986
We can then send a data packet


741
00:22:29,246 --> 00:22:30,056
within the multi-peer


742
00:22:30,056 --> 00:22:30,986
connectivity session.


743
00:22:32,026 --> 00:22:33,466
Now, a reasonable question here


744
00:22:33,466 --> 00:22:35,206
might be how's this going to do


745
00:22:35,206 --> 00:22:37,166
in size and performance?


746
00:22:38,626 --> 00:22:39,956
Property-- binary property lists


747
00:22:39,956 --> 00:22:41,116
are pretty compact and the


748
00:22:41,116 --> 00:22:42,506
encoder's pretty fast.


749
00:22:43,496 --> 00:22:45,466
But sometimes, you know, the


750
00:22:45,466 --> 00:22:47,216
soft implementation in many ways


751
00:22:47,216 --> 00:22:49,256
is optimized for developer time,


752
00:22:49,356 --> 00:22:50,406
which is sometimes your most


753
00:22:50,406 --> 00:22:51,756
precious resource on a project.


754
00:22:52,646 --> 00:22:55,146
Now, we ran up against some of


755
00:22:55,146 --> 00:22:56,426
those limitations as we started


756
00:22:56,426 --> 00:22:57,836
to build the next feature, and


757
00:22:57,836 --> 00:22:59,026
we'll talk about how we overcame


758
00:22:59,746 --> 00:22:59,866
this.


759
00:23:01,576 --> 00:23:03,046
So, let's talk next about the


760
00:23:03,046 --> 00:23:04,326
physics simulation in the game.


761
00:23:04,616 --> 00:23:06,106
For a game like SwiftShot,


762
00:23:06,726 --> 00:23:08,156
physics is really key to create


763
00:23:08,156 --> 00:23:10,206
a fun interaction that comes


764
00:23:10,206 --> 00:23:11,296
from the realistic interaction


765
00:23:11,296 --> 00:23:12,316
between objects and the game.


766
00:23:12,816 --> 00:23:14,146
It's a really great experience


767
00:23:14,146 --> 00:23:16,106
to take that shot and bounce it


768
00:23:16,106 --> 00:23:17,556
off an object in a game and take


769
00:23:17,556 --> 00:23:18,526
out the opponent's slingshot.


770
00:23:19,346 --> 00:23:20,676
And that really comes from the


771
00:23:20,676 --> 00:23:21,466
physics simulation.


772
00:23:23,716 --> 00:23:25,066
We use SceneKit's built-in


773
00:23:25,066 --> 00:23:25,656
physics engine.


774
00:23:25,986 --> 00:23:26,886
It's integrated with the


775
00:23:26,886 --> 00:23:28,336
rendering engine, updating


776
00:23:28,386 --> 00:23:29,476
positions of the object and


777
00:23:29,526 --> 00:23:30,996
scene automatically, and


778
00:23:30,996 --> 00:23:32,676
informing us of collisions using


779
00:23:32,676 --> 00:23:33,196
delegation.


780
00:23:34,616 --> 00:23:35,966
In our implementation, we


781
00:23:35,966 --> 00:23:37,286
decided that the best approach


782
00:23:37,356 --> 00:23:39,426
was for one device in the


783
00:23:39,426 --> 00:23:40,516
session to act as a source of


784
00:23:40,546 --> 00:23:41,576
truth or server.


785
00:23:42,296 --> 00:23:44,306
It sends periodic updates about


786
00:23:44,306 --> 00:23:45,846
the physics state to the other


787
00:23:45,846 --> 00:23:47,596
devices in the network using


788
00:23:47,596 --> 00:23:49,026
that multi-peer connectivity


789
00:23:49,296 --> 00:23:50,876
broadcast method.


790
00:23:52,706 --> 00:23:55,716
Now, the other devices also have


791
00:23:55,756 --> 00:23:56,986
the physics simulation on.


792
00:23:57,736 --> 00:23:58,856
That's because we don't send


793
00:23:58,856 --> 00:24:00,436
information about every object


794
00:24:00,436 --> 00:24:02,246
in the game, only those objects


795
00:24:02,246 --> 00:24:03,156
that are relevant to the


796
00:24:03,156 --> 00:24:04,606
gameplay such as the box,


797
00:24:04,606 --> 00:24:06,066
projectile and catapult.


798
00:24:06,666 --> 00:24:09,216
Things like simulating the


799
00:24:09,216 --> 00:24:10,286
swinging of the rope and the


800
00:24:10,286 --> 00:24:13,136
sling, particles and so forth,


801
00:24:13,656 --> 00:24:15,446
those are just done locally on


802
00:24:15,446 --> 00:24:16,726
each device since it's not


803
00:24:16,726 --> 00:24:18,166
critical to the game that they


804
00:24:18,166 --> 00:24:19,166
be in the same place on every


805
00:24:19,166 --> 00:24:19,646
device.


806
00:24:20,526 --> 00:24:24,886
Now, one of the things that we


807
00:24:24,886 --> 00:24:26,016
discovered was when we were


808
00:24:26,016 --> 00:24:28,366
doing this was that the physics


809
00:24:28,366 --> 00:24:29,336
engine responded very


810
00:24:29,336 --> 00:24:30,466
differently depending on the


811
00:24:30,466 --> 00:24:31,616
scale of the objects.


812
00:24:32,246 --> 00:24:33,966
And so the physics simulation


813
00:24:33,966 --> 00:24:35,466
thinks the objects are about 10


814
00:24:35,466 --> 00:24:36,876
times the size as you would see


815
00:24:36,876 --> 00:24:37,676
them in the real world.


816
00:24:38,316 --> 00:24:39,386
We found that gave the best


817
00:24:39,466 --> 00:24:41,756
gameplay experience and the best


818
00:24:41,756 --> 00:24:42,336
performance.


819
00:24:42,936 --> 00:24:44,516
We had to tweak some of the laws


820
00:24:44,516 --> 00:24:45,766
of physics to make that look


821
00:24:45,766 --> 00:24:47,216
right but, you know, when you're


822
00:24:47,216 --> 00:24:48,616
building a game, if it looks


823
00:24:48,616 --> 00:24:49,966
right and feels right and it's


824
00:24:49,966 --> 00:24:53,616
fun, then it is right.


825
00:24:53,856 --> 00:24:55,426
Now, to share that physics state


826
00:24:55,586 --> 00:24:56,546
and make sure everything looked


827
00:24:56,546 --> 00:24:57,996
right, we need to share four


828
00:24:57,996 --> 00:24:59,056
pieces of information.


829
00:24:59,646 --> 00:25:00,336
The position.


830
00:25:01,956 --> 00:25:03,026
The velocity.


831
00:25:04,356 --> 00:25:05,856
The angular velocity.


832
00:25:05,856 --> 00:25:07,486
And the orientation.


833
00:25:07,936 --> 00:25:09,566
That's a lot of information


834
00:25:09,566 --> 00:25:10,666
about every object in the game,


835
00:25:11,056 --> 00:25:12,846
so it was vital that we minimize


836
00:25:12,846 --> 00:25:13,886
the number of bits actually


837
00:25:13,886 --> 00:25:14,256
used.


838
00:25:15,006 --> 00:25:16,266
I'll walk you through that using


839
00:25:16,266 --> 00:25:18,946
position as an example.


840
00:25:18,946 --> 00:25:20,556
SceneKit represents position as


841
00:25:20,556 --> 00:25:21,926
a vector of three floating point


842
00:25:21,926 --> 00:25:22,406
values.


843
00:25:22,766 --> 00:25:24,996
This is the native format and


844
00:25:24,996 --> 00:25:26,646
gives the best performance for


845
00:25:26,646 --> 00:25:27,896
calculations at run time.


846
00:25:28,346 --> 00:25:31,416
However, there are really more


847
00:25:31,416 --> 00:25:33,416
bits than necessary to specify


848
00:25:33,416 --> 00:25:34,366
the object's location.


849
00:25:35,226 --> 00:25:37,256
A 30-bit float has 8-bits of


850
00:25:37,256 --> 00:25:38,686
exponent and 23 bits of


851
00:25:38,686 --> 00:25:39,256
mantissa.


852
00:25:39,366 --> 00:25:41,386
For a range of plus or minus 10


853
00:25:41,386 --> 00:25:42,656
to the 38th meters.


854
00:25:42,976 --> 00:25:44,566
It's way more than we need for


855
00:25:44,566 --> 00:25:47,166
this game.


856
00:25:47,366 --> 00:25:48,506
So, because the physics


857
00:25:48,506 --> 00:25:50,026
simulation thinks our table is


858
00:25:50,126 --> 00:25:52,486
28 meters long, we said you


859
00:25:52,486 --> 00:25:54,006
know, 80 meters is going to give


860
00:25:54,006 --> 00:25:55,506
us plenty of buffer space around


861
00:25:55,506 --> 00:25:56,506
that on either side.


862
00:25:57,816 --> 00:25:59,876
When we're coding that then,


863
00:26:00,876 --> 00:26:02,856
we're able to eliminate the sign


864
00:26:02,856 --> 00:26:05,666
bit by normalizing that between


865
00:26:05,666 --> 00:26:07,206
0 and 80 meters, even though our


866
00:26:07,206 --> 00:26:08,356
origin is at the center of the


867
00:26:08,356 --> 00:26:08,646
table.


868
00:26:09,446 --> 00:26:10,556
Now all values are positive.


869
00:26:11,196 --> 00:26:13,966
We then scale that value to be


870
00:26:13,966 --> 00:26:15,096
in a range of 0 to 1.


871
00:26:15,696 --> 00:26:16,636
That way we don't need the


872
00:26:16,636 --> 00:26:17,866
exponent information that's


873
00:26:17,866 --> 00:26:20,626
inherent in the protocol.


874
00:26:21,176 --> 00:26:24,366
And then lastly, we take that


875
00:26:24,366 --> 00:26:25,786
and we scale it to the number of


876
00:26:25,786 --> 00:26:29,136
bits available so that all 1s is


877
00:26:29,266 --> 00:26:31,876
a floating point 1 and all 0s is


878
00:26:31,876 --> 00:26:32,806
the floating point 0.


879
00:26:34,126 --> 00:26:35,356
This gave us millimeter scale


880
00:26:35,356 --> 00:26:37,376
precision which, as we


881
00:26:37,376 --> 00:26:39,296
discovered, was really enough to


882
00:26:39,296 --> 00:26:40,716
achieve that smooth synchronous


883
00:26:40,906 --> 00:26:43,296
appearance in the game.


884
00:26:43,436 --> 00:26:44,816
Now, we did a similar technique


885
00:26:44,816 --> 00:26:46,026
for all the other values that


886
00:26:46,026 --> 00:26:46,546
you saw.


887
00:26:46,716 --> 00:26:48,526
The velocity, angular velocity


888
00:26:48,666 --> 00:26:49,466
and orientation.


889
00:26:50,336 --> 00:26:52,326
Tailing the ranges and the


890
00:26:52,326 --> 00:26:53,906
number of bits for each to


891
00:26:53,906 --> 00:26:54,806
really make sure that we


892
00:26:55,226 --> 00:26:56,526
transmit the information using


893
00:26:56,526 --> 00:26:57,436
the minimal amount of data.


894
00:26:58,096 --> 00:27:00,356
Overall, we reduce the number of


895
00:27:00,356 --> 00:27:02,126
bits for each object by more


896
00:27:02,916 --> 00:27:04,706
than half.


897
00:27:04,706 --> 00:27:05,656
Now, even though we've


898
00:27:05,706 --> 00:27:08,106
compressed the numbers, property


899
00:27:08,106 --> 00:27:09,616
lists still have a fair amount


900
00:27:09,616 --> 00:27:11,526
of overhead for the metadata


901
00:27:11,526 --> 00:27:13,466
around it, sending each field by


902
00:27:13,466 --> 00:27:13,686
name.


903
00:27:14,796 --> 00:27:16,226
We said there's no reason for


904
00:27:16,226 --> 00:27:16,436
that.


905
00:27:16,866 --> 00:27:17,886
We all know what these objects


906
00:27:17,886 --> 00:27:18,106
are.


907
00:27:18,106 --> 00:27:19,786
That's not information we need.


908
00:27:20,446 --> 00:27:24,456
So, to do this, we implemented a


909
00:27:24,456 --> 00:27:26,386
new serialization strategy which


910
00:27:26,386 --> 00:27:27,136
we call a BitStream.


911
00:27:28,416 --> 00:27:29,826
BitStreams are designed to pack


912
00:27:29,876 --> 00:27:31,066
the information into as few


913
00:27:31,066 --> 00:27:32,926
bytes as possible by providing


914
00:27:32,926 --> 00:27:34,216
fast serialization and


915
00:27:34,216 --> 00:27:34,986
deserialization.


916
00:27:34,986 --> 00:27:36,966
Now, our implementation is


917
00:27:36,996 --> 00:27:38,716
purpose-built for communicating


918
00:27:38,716 --> 00:27:40,956
binary data with low latency in


919
00:27:40,956 --> 00:27:42,056
an application like this.


920
00:27:42,916 --> 00:27:44,706
Strategies like this wouldn't


921
00:27:44,706 --> 00:27:47,036
work well for data that needs to


922
00:27:47,036 --> 00:27:48,946
persist or data that, where you


923
00:27:48,946 --> 00:27:50,256
need to keep track of the schema


924
00:27:50,476 --> 00:27:51,626
and watch it changing over time.


925
00:27:52,526 --> 00:27:54,376
But for an ephemeral application


926
00:27:54,376 --> 00:27:55,576
like this, it was just the


927
00:27:55,986 --> 00:27:56,096
thing.


928
00:27:57,896 --> 00:27:59,316
To help implement this, we


929
00:27:59,316 --> 00:28:01,606
created two protocols, BitStream


930
00:28:01,606 --> 00:28:03,216
Encodable and BitStream


931
00:28:03,216 --> 00:28:03,796
Decodable.


932
00:28:04,576 --> 00:28:05,616
Combine those and you get


933
00:28:05,616 --> 00:28:06,376
BitStream Codable.


934
00:28:07,266 --> 00:28:09,186
Then we took that and marked all


935
00:28:09,186 --> 00:28:10,416
the objects that we needed to


936
00:28:10,416 --> 00:28:12,176
serialize, using that protocol,


937
00:28:12,176 --> 00:28:12,926
helping us to get the


938
00:28:12,926 --> 00:28:13,576
implementation.


939
00:28:14,106 --> 00:28:16,006
That includes both our own data


940
00:28:16,006 --> 00:28:17,266
objects and the object we use


941
00:28:17,266 --> 00:28:19,916
from the system such as the simD


942
00:28:20,226 --> 00:28:22,886
floating point vector type.


943
00:28:24,936 --> 00:28:26,556
So, here's the implementation of


944
00:28:26,556 --> 00:28:27,856
compressing floats.


945
00:28:28,526 --> 00:28:30,006
The compressors, configured with


946
00:28:30,006 --> 00:28:31,436
the minimum and maximum range,


947
00:28:31,656 --> 00:28:32,866
and the number of bits we wanted


948
00:28:32,866 --> 00:28:33,326
to use.


949
00:28:34,646 --> 00:28:36,786
It clamps the value to the range


950
00:28:37,036 --> 00:28:37,996
and then converts it to an


951
00:28:37,996 --> 00:28:40,396
integer value for encoding using


952
00:28:40,396 --> 00:28:42,326
the specified number of bits.


953
00:28:42,836 --> 00:28:44,326
Each component for each object


954
00:28:44,326 --> 00:28:45,406
in the scene is compressed in


955
00:28:45,406 --> 00:28:45,716
this way.


956
00:28:46,616 --> 00:28:48,316
We also use an additional bit at


957
00:28:48,316 --> 00:28:49,766
the front to tell if an object


958
00:28:49,766 --> 00:28:51,306
has moved since the last update.


959
00:28:52,026 --> 00:28:53,716
If it hasn't moved, we don't


960
00:28:53,716 --> 00:28:54,716
resend that information.


961
00:28:56,696 --> 00:28:58,746
So, let's go back to our action


962
00:28:58,746 --> 00:28:59,716
enum, with the three different


963
00:28:59,716 --> 00:29:00,816
actions to talk about how we


964
00:29:00,816 --> 00:29:03,726
apply BitStream to do this.


965
00:29:03,866 --> 00:29:05,886
For regular codable, if you're


966
00:29:05,886 --> 00:29:07,636
doing your own serialization,


967
00:29:07,636 --> 00:29:09,606
you specify encoding keys for


968
00:29:09,606 --> 00:29:10,896
enums for the different cases in


969
00:29:10,896 --> 00:29:11,246
the enum.


970
00:29:12,106 --> 00:29:13,766
For BitStream, we used integer


971
00:29:13,766 --> 00:29:15,496
values for this rather than


972
00:29:15,706 --> 00:29:16,746
string values.


973
00:29:17,296 --> 00:29:19,926
And then in our encoding method,


974
00:29:20,426 --> 00:29:22,486
we're able to then append that


975
00:29:22,486 --> 00:29:24,326
value first followed by the data


976
00:29:24,326 --> 00:29:26,346
structure associated with that


977
00:29:26,536 --> 00:29:27,426
case of the enum.


978
00:29:27,916 --> 00:29:29,416
Now, if you look at this code


979
00:29:29,416 --> 00:29:30,706
though, there's kind of a pit


980
00:29:30,706 --> 00:29:31,096
fall here.


981
00:29:31,836 --> 00:29:33,646
We know that this one has, this


982
00:29:33,766 --> 00:29:36,466
case has three different cases.


983
00:29:37,256 --> 00:29:38,746
And so we only need two bits to


984
00:29:38,746 --> 00:29:39,766
encode it.


985
00:29:40,376 --> 00:29:42,326
But what happens when we add


986
00:29:42,506 --> 00:29:44,236
another case, 4 bits with 4


987
00:29:44,236 --> 00:29:45,366
cases, we'll still find.


988
00:29:45,806 --> 00:29:47,506
We add that fifth case and now


989
00:29:47,506 --> 00:29:49,676
we need to go through and change


990
00:29:49,676 --> 00:29:51,416
that so that every time we do


991
00:29:51,416 --> 00:29:52,716
this, we're using three bits


992
00:29:52,716 --> 00:29:53,336
instead of two.


993
00:29:54,086 --> 00:29:55,486
Now, that's kind of tedious.


994
00:29:55,486 --> 00:29:56,266
This code's a little bit


995
00:29:56,266 --> 00:29:58,286
repetitive and, you know,


996
00:29:58,416 --> 00:29:59,366
there's stuff that could go


997
00:29:59,366 --> 00:29:59,726
wrong there.


998
00:29:59,726 --> 00:30:00,996
We really, if we don't remember


999
00:30:00,996 --> 00:30:01,866
this, we're just going to end up


1000
00:30:01,866 --> 00:30:02,576
in a bad place.


1001
00:30:03,836 --> 00:30:05,706
So, we took a look at this and


1002
00:30:05,706 --> 00:30:07,116
figured out that there was a way


1003
00:30:07,116 --> 00:30:10,896
that Swift can help us do this.


1004
00:30:11,096 --> 00:30:12,406
So, we used a new feature in


1005
00:30:12,406 --> 00:30:14,956
Swift 4.2, which is case


1006
00:30:14,956 --> 00:30:15,386
iterable.


1007
00:30:16,336 --> 00:30:19,386
We added that protocol


1008
00:30:19,816 --> 00:30:21,606
compliance to our enum type.


1009
00:30:22,536 --> 00:30:24,696
When you do that, Swift adds a


1010
00:30:24,696 --> 00:30:26,596
new static member of the type


1011
00:30:26,886 --> 00:30:28,336
called all cases, containing


1012
00:30:28,336 --> 00:30:29,856
each of the cases in the enum.


1013
00:30:30,676 --> 00:30:32,216
That lets us automatically get a


1014
00:30:32,216 --> 00:30:33,826
count of the number of cases.


1015
00:30:34,976 --> 00:30:36,436
We then added another extension,


1016
00:30:36,816 --> 00:30:37,706
this time on the raw


1017
00:30:37,706 --> 00:30:39,426
representable type which all


1018
00:30:39,426 --> 00:30:41,146
enums with number types like


1019
00:30:41,146 --> 00:30:42,466
that conform to.


1020
00:30:43,106 --> 00:30:44,726
Where it's case iterable and


1021
00:30:44,726 --> 00:30:45,736
where that number is affixed


1022
00:30:45,736 --> 00:30:46,256
with integer.


1023
00:30:47,036 --> 00:30:47,876
And to this, we get to


1024
00:30:47,876 --> 00:30:49,616
automatically take those number


1025
00:30:49,616 --> 00:30:51,176
of cases and figure out how many


1026
00:30:51,176 --> 00:30:53,246
bits it takes to represent all


1027
00:30:53,246 --> 00:30:56,176
those cases on the wire.


1028
00:30:56,376 --> 00:30:58,386
Lastly, we added a generic


1029
00:30:58,386 --> 00:31:00,606
method on the writable BitStream


1030
00:31:00,606 --> 00:31:02,526
type allowing us to encode that


1031
00:31:02,526 --> 00:31:02,756
enum.


1032
00:31:03,436 --> 00:31:04,696
It appends things of that type


1033
00:31:04,696 --> 00:31:06,306
and it uses that new static


1034
00:31:06,306 --> 00:31:07,656
property to figure out the


1035
00:31:07,656 --> 00:31:09,306
number of bits that are needed


1036
00:31:09,966 --> 00:31:11,536
to use.


1037
00:31:11,736 --> 00:31:13,336
Now, our encode method is much


1038
00:31:13,336 --> 00:31:13,716
simpler.


1039
00:31:14,246 --> 00:31:16,566
We just used append enum on the


1040
00:31:16,566 --> 00:31:18,086
proper coding key for each and


1041
00:31:18,086 --> 00:31:19,256
Swift takes care of the rest.


1042
00:31:19,576 --> 00:31:21,186
When we add more cases to the


1043
00:31:21,186 --> 00:31:22,996
enum, the BitField expands


1044
00:31:22,996 --> 00:31:23,576
automatically.


1045
00:31:24,016 --> 00:31:25,656
If we remove cases, it contracts


1046
00:31:25,656 --> 00:31:26,266
automatically.


1047
00:31:26,546 --> 00:31:28,246
We don't have to worry about it.


1048
00:31:31,356 --> 00:31:32,676
So, how much faster and more


1049
00:31:32,676 --> 00:31:34,466
compact is BitStreamCodable?


1050
00:31:35,066 --> 00:31:36,976
We ran some tests using XE test


1051
00:31:36,976 --> 00:31:38,286
support for performance testing


1052
00:31:38,706 --> 00:31:40,106
using a representative message


1053
00:31:40,106 --> 00:31:41,356
in which we send information


1054
00:31:41,356 --> 00:31:42,366
about object movement.


1055
00:31:43,716 --> 00:31:44,826
The results were pretty


1056
00:31:44,826 --> 00:31:46,666
impressive - 1/10 the size,


1057
00:31:46,666 --> 00:31:48,436
twice as fast to code, 10 times


1058
00:31:48,436 --> 00:31:49,276
as fast to decode.


1059
00:31:50,196 --> 00:31:51,536
Now when we talk about going


1060
00:31:51,536 --> 00:31:53,906
from 75 microseconds down to 6


1061
00:31:53,906 --> 00:31:55,246
microseconds, that seems like


1062
00:31:55,246 --> 00:31:56,056
small potatoes.


1063
00:31:56,186 --> 00:31:58,206
But there's around 200 objects


1064
00:31:58,206 --> 00:31:59,436
in the game and we want to do


1065
00:31:59,436 --> 00:32:00,626
this very frequently to make


1066
00:32:00,626 --> 00:32:02,046
sure the game remains smooth for


1067
00:32:02,046 --> 00:32:02,946
all participants.


1068
00:32:03,546 --> 00:32:04,926
By using this encoding format,


1069
00:32:05,066 --> 00:32:06,466
we were able to do those physics


1070
00:32:06,466 --> 00:32:09,266
updates at 60 fps, ensuring that


1071
00:32:09,266 --> 00:32:10,416
you get a smooth experience for


1072
00:32:10,416 --> 00:32:12,746
everyone in the game.


1073
00:32:13,456 --> 00:32:15,326
Now, I've talked about this.


1074
00:32:15,326 --> 00:32:16,826
We did some things with codable


1075
00:32:16,826 --> 00:32:17,896
and some things with BitStream


1076
00:32:17,896 --> 00:32:19,606
Codable that, you could have a


1077
00:32:19,606 --> 00:32:20,556
problem there because we're


1078
00:32:20,556 --> 00:32:21,586
encoding things two different


1079
00:32:21,586 --> 00:32:21,886
ways.


1080
00:32:22,306 --> 00:32:23,246
And that means now we need to


1081
00:32:23,246 --> 00:32:24,176
have two different code paths


1082
00:32:24,176 --> 00:32:24,956
through our application.


1083
00:32:26,146 --> 00:32:27,736
Swift helps us out again and


1084
00:32:27,736 --> 00:32:28,476
lets us figure out how to


1085
00:32:28,476 --> 00:32:29,626
combine them.


1086
00:32:30,166 --> 00:32:32,156
We then added constrained


1087
00:32:32,156 --> 00:32:34,416
extensions so that anything that


1088
00:32:34,416 --> 00:32:36,346
is codable in BitStream Codable,


1089
00:32:36,666 --> 00:32:37,646
we provide default


1090
00:32:37,646 --> 00:32:39,346
implementation of the BitStream


1091
00:32:39,346 --> 00:32:39,766
encoding.


1092
00:32:39,766 --> 00:32:42,816
And then we just go ahead and


1093
00:32:42,816 --> 00:32:45,166
use a binary [inaudible] encoder


1094
00:32:45,876 --> 00:32:47,506
to encode the data and stuff it


1095
00:32:47,506 --> 00:32:48,056
into BitStream.


1096
00:32:48,866 --> 00:32:51,576
And then anything, any struct


1097
00:32:51,576 --> 00:32:52,766
that is codable, we just add


1098
00:32:52,766 --> 00:32:53,896
that by marking it BitStream


1099
00:32:53,896 --> 00:32:54,226
Codable.


1100
00:32:54,956 --> 00:32:56,796
Now, this implementation then is


1101
00:32:56,796 --> 00:32:58,596
not as fast and compact as if we


1102
00:32:58,596 --> 00:32:59,936
went forward and made everything


1103
00:32:59,936 --> 00:33:01,156
BitStream Codable directly.


1104
00:33:01,876 --> 00:33:02,976
But we discovered we didn't need


1105
00:33:02,976 --> 00:33:04,206
to do that for every object in


1106
00:33:04,206 --> 00:33:05,746
the game, only the most frequent


1107
00:33:05,746 --> 00:33:06,306
messages.


1108
00:33:06,906 --> 00:33:08,396
This let us really move quickly


1109
00:33:08,396 --> 00:33:10,586
and keep better rna on the game.


1110
00:33:11,716 --> 00:33:13,216
So, that's how we did the


1111
00:33:13,216 --> 00:33:13,936
physics.


1112
00:33:14,266 --> 00:33:15,606
Next I want to talk about how we


1113
00:33:15,696 --> 00:33:16,686
dealt with the assets on the


1114
00:33:16,686 --> 00:33:17,576
game levels and this is the


1115
00:33:17,576 --> 00:33:18,586
question that a lot of people


1116
00:33:18,586 --> 00:33:19,916
asked us downstairs.


1117
00:33:20,646 --> 00:33:23,016
You know, the assets include the


1118
00:33:23,016 --> 00:33:24,576
3D modules, the textures, the


1119
00:33:24,576 --> 00:33:25,696
animations and so forth.


1120
00:33:26,136 --> 00:33:27,356
So, we have some text angle


1121
00:33:27,356 --> 00:33:28,876
artists here in Apple and they


1122
00:33:28,876 --> 00:33:30,246
used some commercial tools to


1123
00:33:30,246 --> 00:33:31,546
build the visuals for the games.


1124
00:33:31,546 --> 00:33:32,886
The blocks, the catapults and so


1125
00:33:32,886 --> 00:33:33,236
forth.


1126
00:33:34,086 --> 00:33:36,416
They then exported those assets


1127
00:33:36,416 --> 00:33:37,926
in the common DAE file format.


1128
00:33:38,286 --> 00:33:39,156
We're looking forward to the


1129
00:33:39,156 --> 00:33:40,876
commercial tools supporting USDZ


1130
00:33:41,276 --> 00:33:42,096
but for this game they weren't


1131
00:33:42,096 --> 00:33:42,626
quite there yet.


1132
00:33:43,126 --> 00:33:45,616
We then built a command line


1133
00:33:45,616 --> 00:33:47,576
tool in Swift that converts the


1134
00:33:47,576 --> 00:33:49,986
object from DAE into SceneKit


1135
00:33:49,986 --> 00:33:52,196
files using the SceneKit API.


1136
00:33:53,166 --> 00:33:54,346
Because SceneKit provides the


1137
00:33:54,346 --> 00:33:56,856
same APIs on both iOS and macOS,


1138
00:33:57,336 --> 00:33:58,976
we're able to run this tool as


1139
00:33:58,976 --> 00:34:00,306
part of our build process on


1140
00:34:00,306 --> 00:34:02,336
macOS and include the SceneKit


1141
00:34:02,336 --> 00:34:04,016
files directly in our iOS build


1142
00:34:04,016 --> 00:34:04,776
in the application.


1143
00:34:06,496 --> 00:34:08,315
We structured the data so that


1144
00:34:08,315 --> 00:34:10,346
each individual type of block is


1145
00:34:10,346 --> 00:34:12,646
its own file and then for each


1146
00:34:12,646 --> 00:34:14,106
levels, we combine those blocks


1147
00:34:14,106 --> 00:34:14,466
together.


1148
00:34:15,476 --> 00:34:17,186
This let us iterate on the


1149
00:34:17,186 --> 00:34:18,636
appearance and physics behavior


1150
00:34:18,636 --> 00:34:20,396
of each individual block and


1151
00:34:20,396 --> 00:34:21,896
then pull them all together for


1152
00:34:21,896 --> 00:34:23,295
those levels and iterate on


1153
00:34:23,295 --> 00:34:24,036
gameplay design.


1154
00:34:24,346 --> 00:34:25,335
Try out some of the different


1155
00:34:25,335 --> 00:34:26,306
levels that you'll see if you


1156
00:34:26,306 --> 00:34:27,466
look in the source code to the


1157
00:34:27,466 --> 00:34:28,025
application.


1158
00:34:30,116 --> 00:34:32,275
To optimize, further optimize


1159
00:34:32,275 --> 00:34:33,576
for different distances,


1160
00:34:33,926 --> 00:34:35,206
SceneKit supports varying the


1161
00:34:35,206 --> 00:34:37,116
assets used based on the level


1162
00:34:37,116 --> 00:34:37,946
of detail required.


1163
00:34:39,116 --> 00:34:40,806
Nearby objects use more polygons


1164
00:34:40,806 --> 00:34:42,446
and more detailed textures while


1165
00:34:42,446 --> 00:34:43,735
far away objects use fewer


1166
00:34:43,735 --> 00:34:45,005
polygons and less detailed


1167
00:34:45,005 --> 00:34:45,466
textures.


1168
00:34:46,005 --> 00:34:47,216
This really optimizes the


1169
00:34:47,216 --> 00:34:50,996
rendering of the scene.


1170
00:34:51,156 --> 00:34:52,806
However, we still want the


1171
00:34:52,806 --> 00:34:54,096
gameplay to stay consistent.


1172
00:34:54,466 --> 00:34:55,876
And so we specified the physics


1173
00:34:55,876 --> 00:34:56,775
body separately.


1174
00:34:57,886 --> 00:34:58,966
SceneKit provides a number of


1175
00:34:58,966 --> 00:35:00,556
built-in physics body types such


1176
00:35:00,556 --> 00:35:02,556
as cube, sphere, cylinder.


1177
00:35:03,356 --> 00:35:04,796
And if you use those, you really


1178
00:35:04,796 --> 00:35:05,946
get the best performance.


1179
00:35:06,676 --> 00:35:08,136
If you don't specify one,


1180
00:35:08,576 --> 00:35:09,966
SceneKit will build a convex


1181
00:35:09,966 --> 00:35:11,826
hull automatically for you and


1182
00:35:11,826 --> 00:35:12,516
that works.


1183
00:35:12,946 --> 00:35:14,366
But it is a lower, can be a


1184
00:35:14,366 --> 00:35:16,796
lower performance implementation


1185
00:35:17,276 --> 00:35:19,376
by adding these objects where


1186
00:35:19,376 --> 00:35:20,306
they were available and where


1187
00:35:20,306 --> 00:35:21,996
they made sense, we really sped


1188
00:35:21,996 --> 00:35:25,786
up the performance of the game.


1189
00:35:25,826 --> 00:35:26,996
So, here's some examples of the


1190
00:35:26,996 --> 00:35:29,356
physics finished product.


1191
00:35:29,356 --> 00:35:30,466
First one is one of the blocks


1192
00:35:30,466 --> 00:35:30,996
from the game.


1193
00:35:30,996 --> 00:35:32,356
In this case, a cylinder with


1194
00:35:32,356 --> 00:35:33,686
textures for a great wood grain


1195
00:35:33,686 --> 00:35:33,876
look.


1196
00:35:35,116 --> 00:35:36,456
Next is the slingshot with the


1197
00:35:36,456 --> 00:35:37,136
sling head idle.


1198
00:35:37,946 --> 00:35:39,016
We add the [inaudible] colors at


1199
00:35:39,016 --> 00:35:40,856
RunTime using shaders and built


1200
00:35:40,856 --> 00:35:42,086
some custom animation for the


1201
00:35:42,086 --> 00:35:43,326
sling's motion during gameplay.


1202
00:35:44,946 --> 00:35:46,416
Lastly, we included some extra


1203
00:35:46,416 --> 00:35:47,736
assets that didn't get included


1204
00:35:47,736 --> 00:35:48,286
in the gameplay.


1205
00:35:48,776 --> 00:35:50,036
Even though we had to sacrifice


1206
00:35:50,036 --> 00:35:51,416
them, we want you to have them


1207
00:35:51,416 --> 00:35:53,006
and use them in your own sample


1208
00:35:53,546 --> 00:35:53,646
code.


1209
00:35:55,876 --> 00:35:57,606
So, one of the other fun things


1210
00:35:57,606 --> 00:35:58,916
we included is this flag


1211
00:35:58,916 --> 00:35:59,406
animation.


1212
00:35:59,696 --> 00:36:00,956
It really improves the immersion


1213
00:36:00,956 --> 00:36:01,866
in the game environment.


1214
00:36:02,626 --> 00:36:04,076
We wanted a realistic wind


1215
00:36:04,076 --> 00:36:04,896
effect on this.


1216
00:36:05,156 --> 00:36:06,296
Now, we could've used a cloth


1217
00:36:06,386 --> 00:36:07,656
simulation out of the physics


1218
00:36:07,656 --> 00:36:07,976
engine.


1219
00:36:09,506 --> 00:36:11,026
But instead, we decided to use


1220
00:36:11,026 --> 00:36:12,846
the GPU and do it with Metal.


1221
00:36:14,736 --> 00:36:16,626
We started with a SceneKit asset


1222
00:36:16,626 --> 00:36:17,976
built by our technical artist.


1223
00:36:18,516 --> 00:36:19,566
To get the Apple logo on the


1224
00:36:19,566 --> 00:36:21,946
flag, we applied a texture at


1225
00:36:21,946 --> 00:36:22,336
RunTime.


1226
00:36:23,716 --> 00:36:25,026
Then we built a Swift class


1227
00:36:25,026 --> 00:36:26,136
around the Metal device.


1228
00:36:26,806 --> 00:36:28,506
Swift code builds a metal


1229
00:36:28,506 --> 00:36:29,746
command queue and inserts


1230
00:36:29,746 --> 00:36:31,126
information from the state of


1231
00:36:31,126 --> 00:36:32,736
the game, such as the direction


1232
00:36:32,736 --> 00:36:34,466
the wind is blowing.


1233
00:36:34,586 --> 00:36:35,706
That command queue is running a


1234
00:36:35,706 --> 00:36:37,016
custom Metal compute shader.


1235
00:36:37,826 --> 00:36:39,046
That comes from a legacy code


1236
00:36:39,046 --> 00:36:39,816
built in C.


1237
00:36:40,176 --> 00:36:41,536
But because Metal is based on


1238
00:36:41,536 --> 00:36:43,916
modern C++, it was a very easy


1239
00:36:43,916 --> 00:36:44,726
conversion to make.


1240
00:36:45,826 --> 00:36:47,486
We then also run another compute


1241
00:36:47,486 --> 00:36:49,226
shader to compute normal for the


1242
00:36:49,226 --> 00:36:50,966
surface, so we can get a great,


1243
00:36:50,966 --> 00:36:53,426
smooth flag look without a huge


1244
00:36:53,426 --> 00:36:54,716
number of polygons in the scene.


1245
00:36:55,196 --> 00:36:56,646
And it really makes the flag


1246
00:36:56,646 --> 00:36:57,156
look amazing.


1247
00:36:58,296 --> 00:37:00,586
Each frame, the shader updates


1248
00:37:00,586 --> 00:37:02,056
the geometry of the match to its


1249
00:37:02,056 --> 00:37:02,586
new position.


1250
00:37:03,296 --> 00:37:04,776
By taking advantage of the GPU


1251
00:37:04,776 --> 00:37:06,316
in this way, we get a great


1252
00:37:06,316 --> 00:37:08,936
effect without it impacting the


1253
00:37:08,936 --> 00:37:09,646
main CPU.


1254
00:37:12,056 --> 00:37:13,936
So, lastly I'd like to talk


1255
00:37:13,936 --> 00:37:15,186
about the audio implementation


1256
00:37:15,186 --> 00:37:15,746
in SwiftShot.


1257
00:37:16,586 --> 00:37:18,156
Audio can make any game even


1258
00:37:18,156 --> 00:37:19,726
more immersive and engaging.


1259
00:37:20,756 --> 00:37:22,096
We knew we wanted to provide


1260
00:37:22,096 --> 00:37:23,346
realistic sound effects


1261
00:37:23,536 --> 00:37:25,006
positioned properly in the world


1262
00:37:25,286 --> 00:37:26,366
for that really immersive


1263
00:37:26,366 --> 00:37:26,896
experience.


1264
00:37:26,896 --> 00:37:28,046
And giving the user great


1265
00:37:28,046 --> 00:37:28,866
feedback on how they're


1266
00:37:28,866 --> 00:37:29,816
interacting with that world.


1267
00:37:30,926 --> 00:37:31,946
We also wanted to make sure it


1268
00:37:31,946 --> 00:37:33,626
was fast and pay attention to


1269
00:37:33,626 --> 00:37:35,096
how much adding the audio would


1270
00:37:35,176 --> 00:37:37,046
add to the size of our app.


1271
00:37:37,046 --> 00:37:38,356
So, we came up with what we


1272
00:37:38,356 --> 00:37:39,256
think is a great solution.


1273
00:37:40,336 --> 00:37:42,156
We created a few representative


1274
00:37:42,156 --> 00:37:44,036
sound samples using some toys we


1275
00:37:44,036 --> 00:37:45,626
borrowed from children of people


1276
00:37:45,626 --> 00:37:47,406
on the team.


1277
00:37:47,406 --> 00:37:49,246
We then recorded those and used


1278
00:37:49,246 --> 00:37:51,656
those to combine them into an AU


1279
00:37:51,656 --> 00:37:53,516
preset file and use those to


1280
00:37:53,516 --> 00:37:55,256
build a custom Midi instrument


1281
00:37:55,496 --> 00:37:57,506
in AV Foundation using AV Audio


1282
00:37:57,506 --> 00:37:58,636
Unit Midi Instrument.


1283
00:37:59,486 --> 00:38:00,746
That made it easy to quickly


1284
00:38:00,746 --> 00:38:01,796
play the right sound at the


1285
00:38:01,796 --> 00:38:03,146
right time in response to user


1286
00:38:03,146 --> 00:38:04,266
inputs and collisions in the


1287
00:38:04,266 --> 00:38:04,486
game.


1288
00:38:05,016 --> 00:38:08,046
We didn't just play the sounds


1289
00:38:08,046 --> 00:38:08,536
as is.


1290
00:38:09,186 --> 00:38:10,316
To give good feedback to the


1291
00:38:10,316 --> 00:38:11,316
user, we pull back on the


1292
00:38:11,316 --> 00:38:11,806
slingshot.


1293
00:38:12,146 --> 00:38:13,776
We vary the sound in a couple of


1294
00:38:13,776 --> 00:38:14,146
ways.


1295
00:38:14,856 --> 00:38:16,536
We change the pitch based on how


1296
00:38:16,536 --> 00:38:17,866
far back they've pulled the


1297
00:38:17,866 --> 00:38:18,396
slingshot.


1298
00:38:19,456 --> 00:38:23,546
And we vary the volume based on


1299
00:38:23,546 --> 00:38:24,796
the speed as you pull back.


1300
00:38:24,796 --> 00:38:26,406
And we do that at RunTime by


1301
00:38:26,406 --> 00:38:27,546
selecting the right Midi note


1302
00:38:27,546 --> 00:38:29,656
and then using some additional


1303
00:38:29,656 --> 00:38:30,946
Midi commands to alter that


1304
00:38:30,946 --> 00:38:31,876
sound before we play it.


1305
00:38:32,386 --> 00:38:33,746
So, let's take a listen and this


1306
00:38:33,746 --> 00:38:35,000
is, we'll play it.


1307
00:38:38,516 --> 00:38:53,246
[ Sound effects ]


1308
00:38:53,746 --> 00:38:55,896
Now, we also wanted to make sure


1309
00:38:55,896 --> 00:38:56,816
that when you're using the


1310
00:38:56,816 --> 00:38:59,086
slingshot, we also give users


1311
00:38:59,496 --> 00:39:01,496
some audio feedback as to


1312
00:39:01,496 --> 00:39:02,486
whether or not they're within


1313
00:39:02,486 --> 00:39:03,646
range of the slingshot and


1314
00:39:03,646 --> 00:39:04,616
whether or not they've grabbed


1315
00:39:04,616 --> 00:39:04,846
that.


1316
00:39:04,846 --> 00:39:05,976
And those are the little beeps


1317
00:39:05,976 --> 00:39:06,716
you heard at the start.


1318
00:39:07,456 --> 00:39:08,906
Because those are UI feedback


1319
00:39:08,906 --> 00:39:11,056
for the users, those sounds only


1320
00:39:11,056 --> 00:39:12,466
come out of the device that the


1321
00:39:12,466 --> 00:39:13,896
user is using to interact with


1322
00:39:13,896 --> 00:39:14,466
the slingshot.


1323
00:39:14,936 --> 00:39:16,406
However, we also want everybody


1324
00:39:16,406 --> 00:39:18,466
else in the game to know what's


1325
00:39:18,466 --> 00:39:19,576
going on with the slingshot,


1326
00:39:19,576 --> 00:39:20,586
whether someone else is pulling


1327
00:39:20,586 --> 00:39:21,646
something or something like


1328
00:39:21,646 --> 00:39:21,886
that.


1329
00:39:22,076 --> 00:39:22,946
But we want one of those to be


1330
00:39:22,946 --> 00:39:23,416
quieter.


1331
00:39:23,856 --> 00:39:25,896
So, we use positional audio so


1332
00:39:25,896 --> 00:39:27,176
that if my opponent across the


1333
00:39:27,176 --> 00:39:27,916
table is pulling their


1334
00:39:27,916 --> 00:39:29,556
slingshot, I still hear that


1335
00:39:29,556 --> 00:39:30,766
sound from my device but it's


1336
00:39:30,766 --> 00:39:32,296
quieter and positioned correctly


1337
00:39:32,296 --> 00:39:32,666
in the world.


1338
00:39:34,926 --> 00:39:36,526
For colliding blocks, we took a


1339
00:39:37,046 --> 00:39:38,176
similar approach but slightly


1340
00:39:38,176 --> 00:39:38,526
different.


1341
00:39:39,146 --> 00:39:40,886
We really wanted a cacophonous


1342
00:39:41,076 --> 00:39:41,496
effect.


1343
00:39:41,996 --> 00:39:45,066
And the blocks are generally not


1344
00:39:45,066 --> 00:39:46,936
near any one player so again,


1345
00:39:47,006 --> 00:39:48,416
using the positional support


1346
00:39:48,596 --> 00:39:50,356
from SceneKit really made this


1347
00:39:50,396 --> 00:39:50,946
sound great.


1348
00:39:52,106 --> 00:39:53,156
Each device makes sounds


1349
00:39:53,156 --> 00:39:55,256
separately without worrying


1350
00:39:55,256 --> 00:39:56,386
about synchronizing across


1351
00:39:56,386 --> 00:39:57,926
devices because we want it to be


1352
00:39:58,036 --> 00:39:59,386
cacophonous, blocks smashing


1353
00:39:59,386 --> 00:39:59,656
about.


1354
00:40:00,486 --> 00:40:02,206
Again, we use a custom Midi


1355
00:40:02,206 --> 00:40:03,676
instrument to take a small


1356
00:40:03,676 --> 00:40:04,996
number of sounds and vary them.


1357
00:40:05,376 --> 00:40:06,636
In this case, varying the attack


1358
00:40:06,636 --> 00:40:08,226
rate based on the strength of


1359
00:40:08,226 --> 00:40:09,636
the collision impulse coming


1360
00:40:09,636 --> 00:40:10,656
from the SceneKit physics


1361
00:40:10,656 --> 00:40:10,886
engine.


1362
00:40:13,316 --> 00:40:15,086
These sounds again are localized


1363
00:40:15,086 --> 00:40:16,386
in 3D coordinates based on the


1364
00:40:16,386 --> 00:40:17,806
device's position in the scene.


1365
00:40:17,976 --> 00:40:19,176
So, collisions in the far end of


1366
00:40:19,176 --> 00:40:20,586
the table are quieter than those


1367
00:40:20,586 --> 00:40:20,996
at your end.


1368
00:40:21,616 --> 00:40:24,000
Let's take a listen to this.


1369
00:40:25,516 --> 00:40:37,886
[ Sound effects ]


1370
00:40:38,386 --> 00:40:39,136
One more shot.


1371
00:40:39,676 --> 00:40:41,116
There we go.


1372
00:40:42,496 --> 00:40:42,676
Right.


1373
00:40:43,266 --> 00:40:47,366
So we wanted to share one more


1374
00:40:47,366 --> 00:40:48,426
little trick that we discovered


1375
00:40:48,426 --> 00:40:50,836
as we were working on this.


1376
00:40:50,836 --> 00:40:51,956
In the process of setting up the


1377
00:40:51,956 --> 00:40:53,206
sounds, we discovered that we


1378
00:40:53,206 --> 00:40:54,686
needed to have a script run at


1379
00:40:54,686 --> 00:40:56,376
RunTime to do some file name


1380
00:40:56,376 --> 00:40:57,746
path conversions on the property


1381
00:40:57,746 --> 00:40:59,246
list for the DAU preset.


1382
00:40:59,926 --> 00:41:01,076
We found that we're able to


1383
00:41:01,076 --> 00:41:03,056
build that tool using Swift but


1384
00:41:03,056 --> 00:41:04,336
set it up as a command line


1385
00:41:04,336 --> 00:41:04,596
tool.


1386
00:41:05,196 --> 00:41:06,706
Do you notice at the top of


1387
00:41:06,706 --> 00:41:07,996
this, the traditional Unix


1388
00:41:07,996 --> 00:41:09,566
shebang-style statement at the


1389
00:41:09,566 --> 00:41:10,266
top of the script.


1390
00:41:10,706 --> 00:41:13,156
That tells your shell to fire up


1391
00:41:13,156 --> 00:41:15,436
Swift to run this.


1392
00:41:15,536 --> 00:41:17,076
By doing this, we can then treat


1393
00:41:17,076 --> 00:41:18,526
Swift as a scripting language.


1394
00:41:19,976 --> 00:41:21,226
You can develop one of these by


1395
00:41:21,226 --> 00:41:23,316
using a Swift playground to work


1396
00:41:23,316 --> 00:41:24,726
with your code interactively and


1397
00:41:24,726 --> 00:41:25,696
make sure that you've gotten it


1398
00:41:25,696 --> 00:41:25,866
right.


1399
00:41:26,966 --> 00:41:28,556
Once it's ready, just save it


1400
00:41:28,556 --> 00:41:30,286
out to a file, add the shebang


1401
00:41:30,286 --> 00:41:31,906
line to the top and make the


1402
00:41:31,906 --> 00:41:33,886
file executable in the file


1403
00:41:33,886 --> 00:41:34,236
system.


1404
00:41:35,246 --> 00:41:36,546
Now you've got a command line


1405
00:41:36,546 --> 00:41:38,736
tool that you can use either,


1406
00:41:38,736 --> 00:41:39,496
you know, outside the


1407
00:41:39,496 --> 00:41:41,876
application or in Xcode using a


1408
00:41:41,876 --> 00:41:42,666
RunScript phase.


1409
00:41:43,486 --> 00:41:45,866
It's very easy and it really


1410
00:41:45,866 --> 00:41:47,216
gives you access to all the


1411
00:41:47,216 --> 00:41:48,056
system frameworks.


1412
00:41:48,316 --> 00:41:49,456
In this case, we're able to edit


1413
00:41:49,456 --> 00:41:50,386
the P list directly.


1414
00:41:51,036 --> 00:41:52,076
It's a really great technique


1415
00:41:52,076 --> 00:41:53,586
and we hope that you'll be able


1416
00:41:53,586 --> 00:41:54,986
to take advantage of it.


1417
00:41:57,116 --> 00:41:59,016
So, today I hope you've seen how


1418
00:41:59,096 --> 00:42:00,226
AR provides really new


1419
00:42:00,226 --> 00:42:01,626
opportunities for engaging games


1420
00:42:01,626 --> 00:42:02,706
and other experiences.


1421
00:42:03,746 --> 00:42:04,986
We encourage you to design with


1422
00:42:04,986 --> 00:42:06,006
AR in mind from the start.


1423
00:42:06,346 --> 00:42:07,866
And remember that for games, the


1424
00:42:07,866 --> 00:42:08,606
play is the thing.


1425
00:42:08,776 --> 00:42:10,856
You can't sprinkle fun on top at


1426
00:42:10,976 --> 00:42:12,000
the end.


1427
00:42:13,146 --> 00:42:14,056
We really hope that you'll


1428
00:42:14,056 --> 00:42:15,966
download the SwiftShot available


1429
00:42:15,966 --> 00:42:17,456
as sample code and use it to


1430
00:42:17,456 --> 00:42:18,696
guide you as you build your own


1431
00:42:18,696 --> 00:42:20,316
apps and we're planning to


1432
00:42:20,316 --> 00:42:21,826
update that with each subsequent


1433
00:42:21,826 --> 00:42:23,976
seed of iOS 12 as we go to the


1434
00:42:23,976 --> 00:42:24,306
release.


1435
00:42:24,906 --> 00:42:27,316
And finally, if you haven't had


1436
00:42:27,316 --> 00:42:28,636
a chance yet, we hope you'll


1437
00:42:28,636 --> 00:42:29,596
play SwiftShot with us


1438
00:42:29,786 --> 00:42:32,326
downstairs in the game room.


1439
00:42:32,456 --> 00:42:34,136
For more information, there's an


1440
00:42:34,136 --> 00:42:35,536
ARKit lab immediately after this


1441
00:42:35,536 --> 00:42:36,656
session and the get together


1442
00:42:36,656 --> 00:42:37,176
this evening.


1443
00:42:37,836 --> 00:42:39,406
I'm also happy to announce that


1444
00:42:39,406 --> 00:42:40,196
for those of you here at the


1445
00:42:40,196 --> 00:42:41,536
conference, we're going to have


1446
00:42:41,536 --> 00:42:42,696
a SwiftShot tournament this


1447
00:42:42,696 --> 00:42:44,566
Friday from noon to 2, so we


1448
00:42:44,566 --> 00:42:45,586
hope you'll join us for that.


1449
00:42:46,496 --> 00:42:47,186
Thank you very much.


1450
00:42:48,338 --> 00:42:50,338
[ Applause ]

