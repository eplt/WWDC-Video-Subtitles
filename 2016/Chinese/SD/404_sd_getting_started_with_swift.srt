1
00:00:19,353 --> 00:00:23,190
Swift入门


2
00:00:23,257 --> 00:00:25,926
大家好欢迎参加Swift入门


3
00:00:26,426 --> 00:00:29,563
我是Dave Addey
和同事Brian和Alex一起


4
00:00:29,630 --> 00:00:33,033
我想要给你们一个Swift编程语言
的快速概览


5
00:00:33,800 --> 00:00:36,970
在之后60分钟里
你们会获得足够的Swift 3知识


6
00:00:37,037 --> 00:00:40,774
来能够阅读Swift代码
最好还能开始写代码


7
00:00:42,309 --> 00:00:46,180
让我们看看这个语言的一些基础


8
00:00:46,680 --> 00:00:48,916
这是一些我两年前写的代码


9
00:00:49,383 --> 00:00:51,418
我写了一个常量
用let来表明


10
00:00:51,718 --> 00:00:54,188
这被叫做language
是一个字符串类型


11
00:00:54,721 --> 00:00:57,491
这中间的冒号我们会经常
在Swift中看见


12
00:00:57,558 --> 00:00:58,992
它表明是类型


13
00:00:59,059 --> 00:01:00,994
language是一个字符串类型


14
00:01:01,562 --> 00:01:04,730
我在swift代码里用字符串给它赋值


15
00:01:05,966 --> 00:01:06,934
让我们做更多


16
00:01:07,301 --> 00:01:09,403
假设有个整数称为
introduced


17
00:01:09,469 --> 00:01:10,904
我们将它赋值为2014


18
00:01:11,305 --> 00:01:13,307
及一个布尔型被称为
isAwesome


19
00:01:13,473 --> 00:01:14,675
把它设为真


20
00:01:16,043 --> 00:01:19,413
你注意到这些值都无需改变


21
00:01:19,713 --> 00:01:21,515
名字language不会改变


22
00:01:21,582 --> 00:01:23,183
或者它出现的年份


23
00:01:23,684 --> 00:01:26,486
两年了Swift还是很好


24
00:01:26,553 --> 00:01:28,355
所以这也可以是一个常量


25
00:01:28,989 --> 00:01:30,924
这是Swift中的一般原则


26
00:01:31,258 --> 00:01:34,027
如果一些量不需要被改变
我们申明它为常量


27
00:01:35,329 --> 00:01:38,131
现在你可能还注意到了命名习惯


28
00:01:38,565 --> 00:01:41,902
常量和变量是小写开始的驼峰式
命名法


29
00:01:41,969 --> 00:01:45,372
像字符串、取整和布尔
类型是大写驼峰式命名法


30
00:01:47,174 --> 00:01:49,209
现在如果我们看右边的这些


31
00:01:49,276 --> 00:01:50,644
很明显


32
00:01:50,711 --> 00:01:54,314
我想要的是字符串 整数 布尔型


33
00:01:55,215 --> 00:01:58,385
在这种情况下
Swift会推断这些类型


34
00:01:58,452 --> 00:02:00,754
我们不需要写出来


35
00:02:00,821 --> 00:02:03,323
你仍然得到明确申明了类型的变量


36
00:02:03,390 --> 00:02:04,992
但是你不用写那么多代码


37
00:02:06,426 --> 00:02:07,861
这是一些常量


38
00:02:07,928 --> 00:02:10,797
那么对于变量呢？
它们有时候会改变


39
00:02:10,864 --> 00:02:12,799
这是一个变量
被用var表明


40
00:02:12,866 --> 00:02:14,401
这是为了语言的版本


41
00:02:14,468 --> 00:02:17,838
它被改变了
让我们更新它到2016年的情况


42
00:02:19,239 --> 00:02:21,608
现在如果我试着对常量这样做


43
00:02:21,675 --> 00:02:23,977
如果我试着给
isAwesome赋值为假


44
00:02:24,645 --> 00:02:25,979
Swift告诉我有个错误


45
00:02:26,046 --> 00:02:27,047
这是对的


46
00:02:28,982 --> 00:02:31,285
编程时常做的一件事


47
00:02:31,351 --> 00:02:33,320
是通过其它值生成字符串


48
00:02:33,387 --> 00:02:36,089
我们可以把字符串连接在一起


49
00:02:36,156 --> 00:02:39,393
像这里展示的这样
但是Swift有一个更整洁的方法


50
00:02:39,459 --> 00:02:42,162
被称为字符串插入
它看起来是这样的


51
00:02:42,930 --> 00:02:46,233
我们可以把字符串和值放进
一个更大的字符串


52
00:02:46,300 --> 00:02:49,403
通过用括号包裹并在前面加一个
反斜杠


53
00:02:49,469 --> 00:02:52,005
我们在这想生成消息
“Hello WWDC”


54
00:02:53,207 --> 00:02:54,908
我们并不只用字符串


55
00:02:54,975 --> 00:02:56,443
我们还可以添加其他值


56
00:02:56,510 --> 00:02:58,478
像是这里的整数
加入年


57
00:02:59,079 --> 00:03:01,582
我们还可以加入表达式


58
00:03:01,648 --> 00:03:04,751
我们可以让年加1
为了可能是明年的代码


59
00:03:06,520 --> 00:03:09,756
现在Swift中的字符串
对于Unicode编码是完全兼容的


60
00:03:09,823 --> 00:03:14,127
它可以是ASCII
也可以是猫 狗 国旗


61
00:03:14,828 --> 00:03:16,530
这都是相同的


62
00:03:16,597 --> 00:03:19,066
不论是常量还是变量


63
00:03:19,132 --> 00:03:20,868
你几乎可以使用任何字符


64
00:03:20,934 --> 00:03:23,036
在常量和变量名中


65
00:03:24,338 --> 00:03:26,373
说到标准字符


66
00:03:26,440 --> 00:03:29,409
Swift做了很多工作来解决这意味
什么


67
00:03:29,476 --> 00:03:30,844
做为一个单独字符


68
00:03:31,311 --> 00:03:33,780
无论你的字符串是怎样在幕后编码的


69
00:03:33,847 --> 00:03:35,349
或者怎么显示在屏幕上


70
00:03:36,683 --> 00:03:38,785
我有一个字符串
叫做dogString


71
00:03:39,353 --> 00:03:42,689
你可能认为它有6个字符


72
00:03:42,756 --> 00:03:46,627
D O G ？！狗脸


73
00:03:47,194 --> 00:03:48,495
但你错了


74
00:03:48,562 --> 00:03:51,098
这里只有5个字符而不是6个


75
00:03:51,765 --> 00:03:55,302
这里有一个特殊符号
被称为问号惊叹号


76
00:03:55,369 --> 00:03:59,106
很好的用来形容狗


77
00:04:00,374 --> 00:04:02,910
如果你不相信我
让Swift来证明这点


78
00:04:03,744 --> 00:04:06,146
每个字符串都有一属性
叫characters


79
00:04:06,213 --> 00:04:08,382
它给我们字符串中的字符的集合


80
00:04:08,448 --> 00:04:11,051
我们可以访问这个集合的计数属性


81
00:04:11,118 --> 00:04:12,653
来看有多少字符


82
00:04:13,253 --> 00:04:14,922
如果把那传递给Print函数


83
00:04:14,988 --> 00:04:17,558
我们发现我们实际上有5个字符


84
00:04:18,725 --> 00:04:20,793
如果你仍然不相信我


85
00:04:20,861 --> 00:04:23,197
让我们一个个遍历那些字符


86
00:04:23,263 --> 00:04:24,865
用for-in循环


87
00:04:24,932 --> 00:04:26,767
把每一个打印在它们自己的一行中


88
00:04:26,834 --> 00:04:29,403
你可以看到我们实际上有5个字符


89
00:04:29,736 --> 00:04:33,240
D O G ？！和狗脸


90
00:04:35,943 --> 00:04:39,012
除了基本类型外


91
00:04:39,079 --> 00:04:41,181
我们还有一些内置的集合


92
00:04:41,248 --> 00:04:43,217
我们有数组和字典


93
00:04:43,584 --> 00:04:47,221
你可能知道字典在别的语言里
是哈希或者映射表


94
00:04:47,955 --> 00:04:51,191
最简单的创造数组或字典的方法
是使用字面值


95
00:04:51,258 --> 00:04:54,361
这是一个数组字面值
用方括号包围


96
00:04:54,428 --> 00:04:55,762
并用逗号分隔每个值


97
00:04:56,663 --> 00:04:59,933
这里我们有一个数组包含4个名字
4个字符串


98
00:05:00,968 --> 00:05:02,436
字典看起来类似


99
00:05:02,503 --> 00:05:05,172
它们的键和值被冒号分开


100
00:05:05,239 --> 00:05:08,542
我们有一个字典
它的键是名字是字符串类型


101
00:05:08,609 --> 00:05:10,143
它的值是整数


102
00:05:11,912 --> 00:05:15,782
现在你可能注意到在数组中


103
00:05:15,849 --> 00:05:17,718
它们都是相同的类型
都是字符串


104
00:05:18,318 --> 00:05:21,188
在名字数组中插入其它类型是
没有意义的


105
00:05:21,255 --> 00:05:24,224
有一个整数 布尔型或自行车


106
00:05:24,725 --> 00:05:26,126
这会很奇怪


107
00:05:26,760 --> 00:05:29,029
对于名字
我们总是希望它们是字符串


108
00:05:29,530 --> 00:05:30,664
我们可在Swift中表达它


109
00:05:30,731 --> 00:05:33,166
我们可以说我们想要一个字符串
数组


110
00:05:33,233 --> 00:05:35,369
当我们从中取出值时


111
00:05:35,435 --> 00:05:37,271
我们可以把它当成字符串处理


112
00:05:38,038 --> 00:05:39,273
这就是我们为何这样写


113
00:05:39,339 --> 00:05:42,442
这是我们怎么写一个字符串数组
用方括号包围一个字符串


114
00:05:43,443 --> 00:05:44,611
但是我们早前看到


115
00:05:45,479 --> 00:05:49,183
如果右手边明显的表明了我们
想要的类型


116
00:05:49,583 --> 00:05:52,319
Swift会为我们做推断
在这也会发生


117
00:05:52,386 --> 00:05:54,021
我们不需要写下类型


118
00:05:54,321 --> 00:05:57,057
很清楚我们想要字符串数组


119
00:05:57,791 --> 00:05:59,126
对字典也是同样的


120
00:05:59,193 --> 00:06:02,329
这里很明显我们想要键是字符串
值是整数


121
00:06:02,396 --> 00:06:06,099
Swift可以为我们推断这些
所有东西都有清楚的类型


122
00:06:08,335 --> 00:06:11,638
Swift有所以你在别的语言里知道
循环种类


123
00:06:11,705 --> 00:06:15,509
我们有在执行循环体之前
检查条件用的While循环


124
00:06:16,043 --> 00:06:18,545
一repeat-while循环
执行循环体一次


125
00:06:18,612 --> 00:06:21,081
在检查条件前
来决定是否继续


126
00:06:22,015 --> 00:06:24,384
我们先前看过我们有for-in循环


127
00:06:24,451 --> 00:06:26,653
用来在字符串中遍历所有字符


128
00:06:27,421 --> 00:06:30,424
这不是for-in唯一能做的事


129
00:06:31,258 --> 00:06:34,061 line:1
我们能用它遍历一个范围


130
00:06:34,127 --> 00:06:36,864 line:1
这里我们有一个从1到5的范围


131
00:06:36,930 --> 00:06:38,565 line:1
包括这些数字


132
00:06:38,632 --> 00:06:41,602 line:1
我们用来打印5个入口
在乘以4表中


133
00:06:42,302 --> 00:06:46,473 line:1
我们把它写成1... 5
这被称为闭合范围


134
00:06:46,540 --> 00:06:47,908 line:1
因为它包括2边的数字


135
00:06:48,675 --> 00:06:50,511 line:1
有时我们需要


136
00:06:50,577 --> 00:06:54,014 line:1
一个范围
运行到比最后的数字少1


137
00:06:54,548 --> 00:06:55,949 line:1
这是一个它很有用的例子


138
00:06:56,717 --> 00:06:59,987 line:1
我有一个整数数组
但我只想打印前5个


139
00:07:00,621 --> 00:07:05,058 line:1
因为数组的索引从0开始
我希望索引从0到4


140
00:07:05,792 --> 00:07:08,362 line:1
所以我们想要用半闭合范围运算符


141
00:07:08,428 --> 00:07:09,429 line:1
点 点 小于


142
00:07:09,496 --> 00:07:12,566 line:1
因为它运行到比最终的数字
在这是5小1


143
00:07:14,835 --> 00:07:17,037 line:1
我们可以对数组使用for-in循环


144
00:07:17,104 --> 00:07:19,773 line:1
这里我们为数组里的每个名字
打印一条信息


145
00:07:20,541 --> 00:07:22,376 line:1
我们也可以对字典使用它


146
00:07:22,943 --> 00:07:26,613 line:1
现在注意我们要遍历键和值


147
00:07:26,680 --> 00:07:28,682 line:1
名字和年龄
在同一时间


148
00:07:29,383 --> 00:07:32,486 line:1
这在Swift里被称为元组


149
00:07:32,553 --> 00:07:34,454 line:1
让你把多个值组合在一起


150
00:07:34,521 --> 00:07:35,789 line:1
同时使用它们


151
00:07:35,856 --> 00:07:38,225 line:1
我们晚点会看到另一个例子


152
00:07:38,425 --> 00:07:41,595 line:1
这使代码遍历一个字典时清楚很多


153
00:07:43,497 --> 00:07:45,699 line:1
我们要怎么修改这些集合？


154
00:07:46,366 --> 00:07:49,303 line:1
这是我今年 WWDC 的装箱单


155
00:07:49,369 --> 00:07:51,905 line:1
我把它申明我一个变量
所以我可以改变它


156
00:07:51,972 --> 00:07:55,042 line:1
我包括了基本的袜子和鞋子


157
00:07:56,677 --> 00:08:00,147 line:1
在 WWDC 2014


158
00:08:00,214 --> 00:08:03,984 line:1
我忘记了我的袜子
这是一个恶梦


159
00:08:04,051 --> 00:08:05,853
我不会再犯同样的错误


160
00:08:06,186 --> 00:08:10,057
所以我们检查数组的第一项是袜子


161
00:08:10,123 --> 00:08:12,960
2014后如果我把它放在列表里它
会是第一个


162
00:08:13,527 --> 00:08:15,295
我们通过下标来这样做


163
00:08:15,362 --> 00:08:18,565
在数组名后写一个在方括号里的
索引


164
00:08:18,632 --> 00:08:21,802
如果我们打印这个值
我实际上记得添加袜子


165
00:08:23,070 --> 00:08:26,039
袜子和鞋子还不够
但是为了一星期的会议


166
00:08:26,106 --> 00:08:28,809
我还需要其他东西
让我们添加一个新物品


167
00:08:28,876 --> 00:08:31,245 line:1
让我们把裤子加入数组


168
00:08:31,311 --> 00:08:33,145 line:1
我们使用append方法


169
00:08:34,448 --> 00:08:35,782 line:1
但是这有一个问题


170
00:08:36,683 --> 00:08:39,852 line:1
这个会议是在美国
他们不叫裤子“trousers”


171
00:08:40,787 --> 00:08:42,121 line:1
他们叫裤子“pants”


172
00:08:42,188 --> 00:08:44,591 line:1
这会引起很多误解


173
00:08:44,791 --> 00:08:46,727
所以让我们修改数组中的一个值


174
00:08:47,094 --> 00:08:49,062
让我们把它改成牛仔裤


175
00:08:49,129 --> 00:08:52,432 line:1
我们又用下标来这样做
改变在索引2的项目


176
00:08:52,799 --> 00:08:55,536 line:1
牛仔裤在哪都一样
因此不会招致误解


177
00:08:57,371 --> 00:09:00,641 line:1
这个会议在加利福尼亚州
这里总是晴天很热


178
00:09:01,208 --> 00:09:02,476 line:1
让我们再加一些东西


179
00:09:02,543 --> 00:09:06,446 line:1
让我们加一些短裤 拖鞋 防晒霜


180
00:09:07,147 --> 00:09:09,716 line:1
我们可用append
contentsOf方法


181
00:09:09,783 --> 00:09:12,452 line:1
并传递一个兼容的数组
另一个字符串数组


182
00:09:13,120 --> 00:09:15,022 line:1
它们在同一时间都被添加


183
00:09:16,523 --> 00:09:21,094 line:1
这个会议是在加利福尼亚州的
旧金山


184
00:09:21,628 --> 00:09:23,163 line:1
这里并不总是天晴并且炎热


185
00:09:23,764 --> 00:09:25,566 line:1
所以让我们修改一下这三项


186
00:09:25,632 --> 00:09:28,302
用连帽衫和围巾来代替


187
00:09:29,069 --> 00:09:31,738
我们可以通过传递一个下标范围
来这么做


188
00:09:32,005 --> 00:09:33,974
注意我们要修改三项中的两项


189
00:09:34,041 --> 00:09:35,943 line:1
这在Swift中是合法的


190
00:09:37,811 --> 00:09:40,214 line:1
那对于字典呢？
让我们修改一个字典


191
00:09:40,547 --> 00:09:44,117 line:1
这里是我的年龄字典


192
00:09:44,184 --> 00:09:46,520 line:1
我想加入其他人


193
00:09:46,587 --> 00:09:51,191 line:1
我们通过用下标的办法
来为一个还没有值的键加一个值


194
00:09:51,258 --> 00:09:52,659 line:1
我加入了Justyn


195
00:09:53,660 --> 00:09:56,129 line:1
但是仔细想想
上周是Justyn的生日


196
00:09:56,196 --> 00:09:57,397 line:1
所以这个值现在不对


197
00:09:57,464 --> 00:10:00,901 line:1
我需要更新它
我还是用一样的方法


198
00:10:00,968 --> 00:10:02,936 line:1
我给同一个键赋不同的值


199
00:10:03,003 --> 00:10:04,404 line:1
现在我的字典是对的了


200
00:10:06,607 --> 00:10:09,576
如果我想要从字典里取出一个值


201
00:10:10,077 --> 00:10:12,246
如果我想知道是否有Devon的年龄


202
00:10:12,312 --> 00:10:15,382
或者Daryl
或者Daniel


203
00:10:16,650 --> 00:10:19,319
可能在字典对这些人有一个值


204
00:10:19,386 --> 00:10:22,189
也可能没有
我们需要一个方式来应对这种情况


205
00:10:22,956 --> 00:10:26,226
这是Swift的被称为可选的一个
功能的好的使用案例


206
00:10:27,294 --> 00:10:31,532 line:1
如果我们试着对Amy这样做
我们可能期望有个值是40


207
00:10:32,299 --> 00:10:34,768 line:1
如果我们对Daryl这么做
我们应该得到什么？


208
00:10:34,835 --> 00:10:36,236 line:1
这里对Daryl没有值


209
00:10:37,938 --> 00:10:39,239
这样考虑这个问题


210
00:10:39,907 --> 00:10:43,677
或者在字典里Amy有一个整数值


211
00:10:44,244 --> 00:10:47,915
或者没有一个整数值
像例子里的Daryl


212
00:10:49,216 --> 00:10:54,087
所以这里我们有一个可选的整数
我们写成Int问号


213
00:10:54,788 --> 00:10:56,823
问号表示这里可能有值


214
00:10:56,890 --> 00:10:57,991
也可能没有


215
00:10:59,860 --> 00:11:02,196
我们看看我们是否找到一个值


216
00:11:02,262 --> 00:11:03,897
通过把它和nil比较


217
00:11:03,964 --> 00:11:06,834
nil是一种特殊情况
是没有值的简写


218
00:11:07,401 --> 00:11:09,870
如果对Daryl这么做
没有值


219
00:11:09,937 --> 00:11:11,071
我们会打印这个信息


220
00:11:12,406 --> 00:11:13,240
年龄没有找到


221
00:11:14,041 --> 00:11:16,743
如果我们试着对Amy这样做
我们找到一个值


222
00:11:16,810 --> 00:11:19,479
所以它不等于nil
我们不打印这个消息


223
00:11:21,014 --> 00:11:23,183
一般我们不仅仅查看一个值是否
存在


224
00:11:23,250 --> 00:11:25,319
当它存在时我们想使用它


225
00:11:25,385 --> 00:11:27,955
Swift有一种简单的写法


226
00:11:28,288 --> 00:11:29,456
写下“if let”


227
00:11:30,858 --> 00:11:35,195
它是说如果字典含有Amy的值


228
00:11:36,129 --> 00:11:38,832
让一个新的常量age等于那个值


229
00:11:39,533 --> 00:11:42,135 line:1
我们就可以在if语句里使用那个值


230
00:11:42,970 --> 00:11:45,072 line:1
请注意在此我们把它当成
真正的整数使用


231
00:11:45,138 --> 00:11:46,373 line:1
它不再是可选的


232
00:11:47,307 --> 00:11:50,110 line:1
if语句查看它的值并解包


233
00:11:50,177 --> 00:11:53,447 line:1
给我们一个普通的整数
我们可以对它做整数的操作


234
00:11:55,649 --> 00:11:57,818
我们看了一些if语句


235
00:11:57,885 --> 00:11:59,987
这是另一个
用来打印生日消信


236
00:12:00,721 --> 00:12:03,056
有两件事需要注意


237
00:12:04,057 --> 00:12:07,895
首先我们不需要在条件附近有括号
只需要写下条件


238
00:12:09,029 --> 00:12:13,133
第二我们给每一部分的语句加
大括号


239
00:12:13,200 --> 00:12:15,936
加表明哪部分代码会被执行


240
00:12:18,071 --> 00:12:21,508
此外我们还有switch语句


241
00:12:21,575 --> 00:12:24,378
可以用来写更复杂更强大的匹配


242
00:12:25,345 --> 00:12:28,949
它转换一个常量或者变量的当前值


243
00:12:29,016 --> 00:12:30,817
和一系列可能的情况匹配


244
00:12:31,552 --> 00:12:33,554
比如我们有这种情况


245
00:12:33,620 --> 00:12:36,623
如果年龄值是1


246
00:12:36,690 --> 00:12:39,426
我们想要打印第一个生日快乐的
消息


247
00:12:40,127 --> 00:12:42,062
我们也可以匹配范围


248
00:12:42,262 --> 00:12:44,831
匹配任意值使一些人是青少年


249
00:12:45,666 --> 00:12:48,936
我们可以匹配更复杂的模式
比如这一个


250
00:12:49,002 --> 00:12:52,139
一个叫decade的临时常量


251
00:12:52,606 --> 00:12:54,641
等于我们当前要匹配的值


252
00:12:55,309 --> 00:12:57,377
检查是否能被10整除


253
00:12:58,245 --> 00:13:01,815
如果可以
用它打印一条特殊的生日消息


254
00:13:01,882 --> 00:13:06,220
为任何人刚满30或40岁或其他
重要的年龄


255
00:13:07,788 --> 00:13:10,424
但这有一个问题


256
00:13:11,525 --> 00:13:15,062
如果我们想要为以下年龄的人打印
消息 比如41


257
00:13:15,462 --> 00:13:17,664
97或56


258
00:13:18,632 --> 00:13:20,200
它们不会得到一个消息


259
00:13:20,267 --> 00:13:23,070
听起来很不幸
特别是在它们的生日上


260
00:13:25,038 --> 00:13:26,640
坦白说Swift在这帮助我们


261
00:13:27,040 --> 00:13:30,277
Swift确保switch语句
是完整的


262
00:13:30,344 --> 00:13:33,780
你不会偶然的忘记你需要的情况


263
00:13:34,448 --> 00:13:37,084
在这个例子里
我们可以加一个default语句


264
00:13:37,317 --> 00:13:40,888 line:1
捕获每一个我们之前没有捕获的
情况


265
00:13:40,954 --> 00:13:43,357 line:1
说无聊的生日快乐


266
00:13:45,559 --> 00:13:47,261 line:1
这里有另一个switch语句


267
00:13:48,095 --> 00:13:51,932
它获得一个字符串值用户名
和一个布尔型值


268
00:13:51,999 --> 00:13:54,735
指示用户密码是否合法


269
00:13:55,469 --> 00:13:57,771
我们会一起用这两个值


270
00:13:57,838 --> 00:14:00,073
来产生一个合适的消息用来显示


271
00:14:00,140 --> 00:14:02,509
当用户要登录一个受限的区域


272
00:14:03,777 --> 00:14:07,481
要这样做 我们可以同时switch
两个值


273
00:14:08,015 --> 00:14:09,783
用一个元组
像之前做过的那样


274
00:14:10,918 --> 00:14:13,620
这表明我们可以写一些非常非常
有趣的case


275
00:14:13,687 --> 00:14:15,455
有趣的switch case


276
00:14:15,522 --> 00:14:17,524
可有一个case
是用户名为admin


277
00:14:17,591 --> 00:14:19,126
密码为真


278
00:14:19,193 --> 00:14:21,328
然后打印消息来欢迎管理员回来


279
00:14:22,863 --> 00:14:24,598
现在如果是一个客人


280
00:14:24,665 --> 00:14:27,234
我们永远都不希望客人进入受限
区域


281
00:14:27,301 --> 00:14:28,936
即使密码是合法的


282
00:14:29,436 --> 00:14:32,706
我们可以用下划线来忽略密码


283
00:14:33,273 --> 00:14:35,742
它的意思是匹配任意可能的值


284
00:14:36,977 --> 00:14:38,478
对所有其他用户


285
00:14:38,545 --> 00:14:41,782
我们不关心用户名是什么
我们只关心密码


286
00:14:41,849 --> 00:14:43,617
我们可以忽略用户名


287
00:14:44,184 --> 00:14:47,054
我们切换到我们想要做的


288
00:14:47,120 --> 00:14:48,655
检查密码合法性


289
00:14:48,922 --> 00:14:51,892
要这么做我们创建一个叫做
IsValid的临时常量


290
00:14:52,459 --> 00:14:55,562
然后我们用三元条件运算符


291
00:14:55,629 --> 00:14:57,998
就是这个问号和冒号


292
00:14:59,166 --> 00:15:01,602
来说如果是合法的
用这个消息


293
00:15:01,668 --> 00:15:03,871
否则用这个消息


294
00:15:05,005 --> 00:15:06,707
如果我们浏览一些例子


295
00:15:07,774 --> 00:15:10,010
如果使用管理员并且密码有效


296
00:15:10,077 --> 00:15:12,679
他们将得到一个管理员消息
就像我预期的那样


297
00:15:13,614 --> 00:15:16,817
如果我们试着用客人
即使密码有效


298
00:15:16,884 --> 00:15:19,720
他们得到对不起你不能进入的消息


299
00:15:20,320 --> 00:15:22,823
如果我们用Bob并且密码有效


300
00:15:22,890 --> 00:15:25,058
他获得预期的欢迎消息


301
00:15:25,592 --> 00:15:28,428
但如果他的密码无效
他得到访问被拒绝的消息


302
00:15:30,664 --> 00:15:34,268
现在关于这个switch语句
有最后一个需要注意的点


303
00:15:35,068 --> 00:15:37,437
它没有默认这个情况


304
00:15:38,305 --> 00:15:40,374
它没有的原因是它不需要


305
00:15:40,440 --> 00:15:42,042
它已经是完整的


306
00:15:42,109 --> 00:15:46,346
如果我们看一下后这个case


307
00:15:46,713 --> 00:15:49,850
实际上它包括了所有可能的情况


308
00:15:49,917 --> 00:15:51,451
我们没有在上面匹配到的


309
00:15:51,518 --> 00:15:53,921
所以switch语句不需要default
就已经完整了


310
00:15:56,023 --> 00:15:58,926
这就是Swift语言的一些基本知识


311
00:15:58,992 --> 00:16:00,994
现在我想把演讲交给
我的同事Brian


312
00:16:01,061 --> 00:16:03,463
来介绍Swift中的函数和闭包


313
00:16:08,802 --> 00:16:11,038
好的 谢谢Dave
就像我已经说过的


314
00:16:11,104 --> 00:16:13,974
让我从怎样在Swift中
定义函数开始


315
00:16:14,675 --> 00:16:17,110
你用func关键字定义函数


316
00:16:17,177 --> 00:16:19,513
然后你在大括号里实现它


317
00:16:19,580 --> 00:16:22,416
我们定义了一个简单的函数
叫做sendMessage


318
00:16:22,482 --> 00:16:24,251
打印消息到控制台


319
00:16:25,419 --> 00:16:27,821
然后你可以用一个直观的方式
调用这个函数


320
00:16:27,888 --> 00:16:32,392 line:1
通过写下其名sendMessage
接着是一对空括号


321
00:16:33,293 --> 00:16:34,962 line:1
让我们给这个函数加上参数


322
00:16:35,028 --> 00:16:38,198 line:1
来表明消息是否应该吼叫


323
00:16:39,366 --> 00:16:41,802
你写下参数的名称
接着是冒号


324
00:16:41,869 --> 00:16:43,070
然后是参数的类型


325
00:16:43,136 --> 00:16:46,406
就像你申明一个常量或变量
所做的那样


326
00:16:46,940 --> 00:16:50,110
我们添加了一个叫做shouting
的参数 它是布尔类型


327
00:16:50,844 --> 00:16:52,079
当你调用这个函数时


328
00:16:52,145 --> 00:16:55,716
参数的名称为你传入的参数提供
一个标签


329
00:16:57,618 --> 00:17:00,287 line:1
给参数加标签使代码更易读


330
00:17:00,354 --> 00:17:03,056 line:1
使参数的目的清楚


331
00:17:03,757 --> 00:17:06,193 line:1
在这个情况下
如果没有shouting标签


332
00:17:06,260 --> 00:17:09,229 line:1
一些阅读你的代码的人可能以为
那个真是表明


333
00:17:09,296 --> 00:17:11,565 line:1
是否发送这条消息


334
00:17:12,965 --> 00:17:14,233 line:1
所以你可以喊出一个消息


335
00:17:14,300 --> 00:17:15,836 line:1
但是你要把消息发给谁？


336
00:17:16,403 --> 00:17:17,738 line:1
让我们加入另一个参数


337
00:17:17,804 --> 00:17:19,873 line:1
使我们把消息发给特定的人


338
00:17:21,308 --> 00:17:23,343
在这我们添加一个参数叫做接收人


339
00:17:23,410 --> 00:17:24,877
是一个字符串类型


340
00:17:24,944 --> 00:17:28,982
我们还通过字符串插入将接收人
姓名加入我们的消息中


341
00:17:30,417 --> 00:17:33,654 line:1
当你调用函数时你可以传入接收人
姓名


342
00:17:34,555 --> 00:17:37,291 line:1
现在虽然这个消息按你期待的
那样打印


343
00:17:37,357 --> 00:17:39,526 line:1
它读起来不是很好


344
00:17:40,127 --> 00:17:43,497
发送消息接收人
Morgan读起来很怪


345
00:17:43,964 --> 00:17:46,233
当你调用函数时你希望它读起来
自然


346
00:17:46,300 --> 00:17:48,335
在这个例子中你希望读起来像


347
00:17:48,402 --> 00:17:52,206
发送消息给Morgan
这形成一个有好的语法的短语


348
00:17:52,806 --> 00:17:55,475
你可以通过改变参数名称来这样做


349
00:17:55,542 --> 00:17:58,212
这也会改变参数的标签名


350
00:17:58,278 --> 00:18:00,981
这使得函数被调用时读起来好一些


351
00:18:01,048 --> 00:18:02,883
发送消息给Morgan


352
00:18:02,950 --> 00:18:06,153
但是这在函数内部工作的不好


353
00:18:07,187 --> 00:18:11,091
在函数体里你希望参数是一个名词
而不是一个介词


354
00:18:11,158 --> 00:18:13,560
嘿给听起来不好


355
00:18:14,461 --> 00:18:17,197
但是有时没有一个单词能工作良好


356
00:18:17,264 --> 00:18:21,368
既在函数体内
又在调用函数的标签


357
00:18:21,969 --> 00:18:24,104
在Swift中你不用放弃其中的一个


358
00:18:24,605 --> 00:18:26,406
当一个参数的名称不合适时


359
00:18:26,473 --> 00:18:29,710
参数的标签


360
00:18:29,776 --> 00:18:31,778
你可以明确地提供一个更合适的
名称


361
00:18:33,080 --> 00:18:36,817
你把这个明确的参数标签写在
参数名前


362
00:18:36,884 --> 00:18:39,520
在这我们添加to作为明确的参数标签


363
00:18:39,586 --> 00:18:41,622
在接收者参数的之上


364
00:18:41,688 --> 00:18:43,524
这表示你可以用“to”


365
00:18:43,590 --> 00:18:46,093
当你调用函数发送消息给Morgan


366
00:18:46,159 --> 00:18:49,630
然后你仍然可以在函数体内
使用接收者


367
00:18:51,098 --> 00:18:53,634
让我们添加另一个参数到函数中


368
00:18:53,700 --> 00:18:55,802
使你调用它时能提供一个定制消息


369
00:18:57,504 --> 00:19:00,174
这里我们添加了一个消息参数
是字符串类型


370
00:19:00,240 --> 00:19:03,010
现在我们调用函数
你可以传递你自己的消息


371
00:19:04,745 --> 00:19:07,481 line:1
再一次的
代码如预期一样运行


372
00:19:07,548 --> 00:19:09,516 line:1
但是读起来还是不好


373
00:19:10,050 --> 00:19:12,686 line:1
发送消息消息是重复的


374
00:19:13,587 --> 00:19:17,824
消息标签无助于澄清第一个
参数的作用


375
00:19:17,891 --> 00:19:20,394
因为函数名中已经说清楚了


376
00:19:20,460 --> 00:19:21,461
发送消息


377
00:19:22,329 --> 00:19:24,998
在这里参数标签使代码更难读


378
00:19:25,732 --> 00:19:26,834
在这种情况


379
00:19:26,900 --> 00:19:29,469
你可以在参数名前写一个下划线


380
00:19:30,304 --> 00:19:32,840
这表明你不给参数提供标签


381
00:19:32,906 --> 00:19:34,174
当你调用函数时


382
00:19:37,277 --> 00:19:39,513
这时我们的函数读起来自然


383
00:19:39,580 --> 00:19:41,548
发送消息 在Bash见
给Morgan


384
00:19:43,784 --> 00:19:46,420
我们不常需要喊出我们的消息


385
00:19:46,486 --> 00:19:49,523
我们通常传递假给这个参数


386
00:19:50,157 --> 00:19:51,825
在Swift你可以捕获这个行为


387
00:19:51,892 --> 00:19:54,027
在函数申明中


388
00:19:54,695 --> 00:19:57,631
当参数有一个常用到的值时


389
00:19:57,698 --> 00:19:59,900
你可以把它作为default值


390
00:20:01,001 --> 00:20:04,438
你能过赋一个default值
在这个情况下是假


391
00:20:04,505 --> 00:20:06,340
在参数的类型的后面


392
00:20:07,074 --> 00:20:08,442
当你调用函数时


393
00:20:08,509 --> 00:20:10,677
你可以忽略相应的参数


394
00:20:10,744 --> 00:20:12,346
default值被使用


395
00:20:15,015 --> 00:20:18,752 line:1
当你决定是否使用 怎样使用
明确的参数标签


396
00:20:18,819 --> 00:20:22,990 line:1
什么时候忽略一个参数或者提供
一个default值


397
00:20:23,056 --> 00:20:25,826 line:1
记得函数只被申明一次


398
00:20:25,893 --> 00:20:27,361 line:1
但是被重复使用


399
00:20:27,427 --> 00:20:29,296 line:1
最重要的事是


400
00:20:29,363 --> 00:20:32,232 line:1
函数被调用时读起来清楚准确


401
00:20:33,467 --> 00:20:34,701 line:1
现在让我们学习更多


402
00:20:34,768 --> 00:20:36,436 line:1
你需要考虑的事


403
00:20:36,503 --> 00:20:38,238 line:1
当编写优秀Swift API时


404
00:20:38,939 --> 00:20:41,141 line:1
请去看Swift API指导演讲


405
00:20:42,309 --> 00:20:44,811
我们已经看了很多种函数获得
值的方式


406
00:20:45,312 --> 00:20:48,015
让我们看看让它们返回值的方法


407
00:20:48,815 --> 00:20:50,250
假设你想写一个函数


408
00:20:50,317 --> 00:20:53,453
返回数组里第一个有给定前缀的
字符串


409
00:20:54,588 --> 00:20:56,423
函数获得一个字符串前缀


410
00:20:57,391 --> 00:20:58,692
一个字符串数组


411
00:20:59,660 --> 00:21:02,196
返回一个有给定前缀的字符串


412
00:21:02,262 --> 00:21:03,797
如你所见 你用一个箭头


413
00:21:03,864 --> 00:21:06,433
来表明函数值的类型


414
00:21:06,500 --> 00:21:07,668
在这里是字符串


415
00:21:08,735 --> 00:21:10,137
让我们看看这是怎么工作的


416
00:21:11,438 --> 00:21:14,575
首先用一个for-in循环来遍历
数组中的每一个字符串


417
00:21:15,375 --> 00:21:17,711
然后检测字符串是否有给定的前缀


418
00:21:19,413 --> 00:21:21,515
你需要检测字符串
是否有给定的前缀


419
00:21:21,582 --> 00:21:23,550
使用string.hasprefix方法


420
00:21:23,917 --> 00:21:27,020
如果它有 那么完成了
你只需要返回这个字符串


421
00:21:27,087 --> 00:21:28,889
通过将它写进返回语句


422
00:21:30,724 --> 00:21:31,859
但是你要返回什么


423
00:21:31,925 --> 00:21:34,261
如果数组不含有你在找的字符串？


424
00:21:35,128 --> 00:21:37,564
因为这个函数申明了会返回字符串


425
00:21:37,631 --> 00:21:40,734
唯一的选项是一些合法的字符串


426
00:21:40,801 --> 00:21:42,236
在这个情况下是空字符串


427
00:21:43,003 --> 00:21:44,304
但这不是好的Swift代码


428
00:21:45,405 --> 00:21:48,041
但是像Dave演示过的
可选是完美的


429
00:21:48,108 --> 00:21:50,410
用来表明值有可能不存在


430
00:21:51,712 --> 00:21:54,181
所以你只需要改变函数返回类型


431
00:21:54,248 --> 00:21:57,184
为可选字符串
通过在字符串后写一个问号


432
00:21:57,584 --> 00:22:00,487
现在你可以返回nil
当字符串没有找到时


433
00:22:01,388 --> 00:22:04,124 line:1
因为函数返回可选的字符串


434
00:22:04,191 --> 00:22:06,560 line:1
你可以在一个if-let语句里安全
地使用它


435
00:22:07,528 --> 00:22:10,497 line:1
请注意Swift推断函数的返回类型


436
00:22:10,564 --> 00:22:12,666
所以不需要明确的写出来


437
00:22:14,434 --> 00:22:16,003
我们看了一些方法


438
00:22:16,069 --> 00:22:19,072
函数能获得和返回不同类型


439
00:22:19,139 --> 00:22:22,943
比如字符串 整数 数组
和可选类型


440
00:22:23,243 --> 00:22:25,913
让我们看看怎么写另一种函数


441
00:22:28,015 --> 00:22:30,651
假设你要写一个函数过滤一个
数字数组


442
00:22:30,717 --> 00:22:32,085
基于一些条件


443
00:22:33,120 --> 00:22:34,988
让我们想想这个函数需要做什么


444
00:22:36,223 --> 00:22:37,925 line:1
它要获得一个数字数组


445
00:22:38,358 --> 00:22:39,927 line:1
对数组中的每一个数字


446
00:22:39,993 --> 00:22:43,330 line:1
函数判断是否将它包含在被过滤
的结果中


447
00:22:44,364 --> 00:22:48,635 line:1
比如你想要一个数组
被过滤成只含有偶数


448
00:22:49,469 --> 00:22:51,772 line:1
你可以测试每个数是否能被2整除


449
00:22:52,339 --> 00:22:56,210 line:1
4当然是偶数
所以它被包括在结果数组里


450
00:22:57,978 --> 00:23:00,180 line:1
如果一个数不是偶数
比如17


451
00:23:01,114 --> 00:23:03,884 line:1
过滤函数转而检测下一个数


452
00:23:03,951 --> 00:23:05,886 line:1
然后继续 遍历剩下的数组


453
00:23:06,920 --> 00:23:08,822 line:1
让我们看看写这个函数的代码


454
00:23:10,858 --> 00:23:13,227
函数申明是你想要的


455
00:23:13,493 --> 00:23:16,230
但是你要把什么类型放在
这个包括数字参数这里？


456
00:23:16,964 --> 00:23:21,101
你刚刚看到
决定是否把数字包括进结果里


457
00:23:21,668 --> 00:23:23,570
是一个函数


458
00:23:23,637 --> 00:23:26,139
不是一个简单的值比如字符串
或者一个数字


459
00:23:27,241 --> 00:23:31,245
在Swift里函数可以接收其他函数
做为参数


460
00:23:31,912 --> 00:23:34,014
那么函数类型看起来是怎样的？


461
00:23:35,182 --> 00:23:37,684
所有的函数类型在Swift中
都有基本的形式


462
00:23:38,085 --> 00:23:40,521
函数参数类型
如果有的话


463
00:23:40,587 --> 00:23:43,757
在括号里
跟随的是一个箭头


464
00:23:43,824 --> 00:23:44,858
然后是函数返回类型


465
00:23:46,326 --> 00:23:49,663
比如说我们早前的发送消息函数


466
00:23:50,163 --> 00:23:52,266
它有空的括号


467
00:23:52,332 --> 00:23:55,169
因为它不需要任何参数
箭头空


468
00:23:55,836 --> 00:23:58,405
这里空表示它不返回任何值


469
00:23:59,406 --> 00:24:01,575
在Swift中如果你的函数不返回
任何值


470
00:24:01,642 --> 00:24:04,478
你不需要明确的写箭头空


471
00:24:08,715 --> 00:24:11,218
这是第一个字符串函数


472
00:24:11,385 --> 00:24:13,353
它的签名复杂一些


473
00:24:13,420 --> 00:24:15,489
但是它的类型还是遵循基本的形式


474
00:24:16,256 --> 00:24:19,793
它获得一个字符串一个数组
一个字符串参数并返回一个可选字符串


475
00:24:20,327 --> 00:24:23,096
你们已经知道了函数类型的语法


476
00:24:23,163 --> 00:24:26,767
所以很清楚你要怎么完成过滤
整数这个函数的申明


477
00:24:27,768 --> 00:24:29,169
这个包括数字参数


478
00:24:29,236 --> 00:24:33,207
可以是任何函数获得一个整数
返回一个布尔型


479
00:24:33,273 --> 00:24:37,511
你把类型Int写在括号里
箭头布尔


480
00:24:38,212 --> 00:24:40,380
让我们来完成函数的剩余部分


481
00:24:41,915 --> 00:24:44,151
你需要生成一个过滤过的数字
的数组


482
00:24:44,218 --> 00:24:46,019
这有一个变量叫做结果


483
00:24:46,086 --> 00:24:48,755
它被初始化为一个整数数组


484
00:24:49,423 --> 00:24:52,392
随着你遍历传给这个函数的数组


485
00:24:52,559 --> 00:24:55,796
检查每个数字是否应该包括在
结果数组里


486
00:24:56,830 --> 00:25:00,501
要这么做 你把每个数字传递给
包括数字函数


487
00:25:00,567 --> 00:25:02,636
注意在过滤整数函数体内


488
00:25:02,703 --> 00:25:07,441
包括数字参数被当成被传入的函数
的名字


489
00:25:07,908 --> 00:25:09,009
那说明你可以调用它


490
00:25:09,076 --> 00:25:11,311
和调用其实函数相同的方式


491
00:25:12,412 --> 00:25:13,780
这就是你怎么写一个函数


492
00:25:13,847 --> 00:25:15,949
获得另一个函数做为一个参数


493
00:25:16,450 --> 00:25:18,452
但是你怎么调用这类函数？


494
00:25:19,720 --> 00:25:22,689
首先你需要把一些值传递给过滤
整数函数


495
00:25:22,756 --> 00:25:24,458
这是一个数字数组


496
00:25:24,525 --> 00:25:26,927
和一个简单的函数叫做可被2整除


497
00:25:26,994 --> 00:25:28,896
表明一个整数是否是偶数


498
00:25:31,465 --> 00:25:34,334
你可以看到能被2整除的类型


499
00:25:34,401 --> 00:25:37,104
和包括数字参数的类型匹配


500
00:25:37,671 --> 00:25:42,676
这表明我们可以传递能被2整除
函数


501
00:25:43,143 --> 00:25:45,145
给过滤整数函数做为一个参数


502
00:25:46,346 --> 00:25:50,284
你通过简单地传递能被2整除
函数的名字


503
00:25:51,218 --> 00:25:53,854 line:1
现在你得到一个数组只含有偶数


504
00:25:54,788 --> 00:25:57,057 line:1
注意你没有包括括号


505
00:25:57,124 --> 00:25:59,793 line:1
当传递能被2整除函数时


506
00:25:59,860 --> 00:26:02,362 line:1
这是因为你现在并没有调用它


507
00:26:02,429 --> 00:26:05,299 line:1
它在晚些时候在过滤整数函数体
内被调用


508
00:26:07,201 --> 00:26:10,037 line:1
还要注意我们传递了数组的名字


509
00:26:11,238 --> 00:26:14,007 line:1
我们也可以传递数组字面值


510
00:26:14,474 --> 00:26:16,910 line:1
比如如果你只需要传递少量值


511
00:26:16,977 --> 00:26:19,746 line:1
不需要创建一个常量
为了等会的重用


512
00:26:21,081 --> 00:26:24,184 line:1
传递函数参数也可以这样


513
00:26:26,653 --> 00:26:29,323 line:1
很可能能被2整除函数


514
00:26:29,389 --> 00:26:30,757 line:1
不会被重用


515
00:26:31,291 --> 00:26:33,794 line:1
新建一个函数很麻烦


516
00:26:33,861 --> 00:26:37,231 line:1
每次你想要传递不同的过滤函数
条件


517
00:26:38,565 --> 00:26:41,368 line:1
如果你看看能被2整除的重要部分


518
00:26:41,668 --> 00:26:43,637 line:1
你可以看到给它一个名字


519
00:26:43,704 --> 00:26:46,573 line:1
仅仅是为了方便重用


520
00:26:47,941 --> 00:26:50,210
能被2整除仅仅是一个名字


521
00:26:50,277 --> 00:26:52,679
针对你所看重的功能


522
00:26:54,715 --> 00:26:58,552
在Swift中像你可以写
一个字面值字符串或字面值数组


523
00:26:58,619 --> 00:27:01,522
你也可以写一个
没有名字的字面值函数


524
00:27:01,588 --> 00:27:04,224
被称为闭包表达式
并在你的代码中被传递


525
00:27:05,325 --> 00:27:06,860
写一个闭包表达示的语法


526
00:27:06,927 --> 00:27:09,363
和函数申明很像


527
00:27:09,429 --> 00:27:10,898
除了它没有名字


528
00:27:11,832 --> 00:27:15,903
把整个闭包的函数写在大括号中


529
00:27:15,969 --> 00:27:20,741
用in关键字把闭包函数体和
签名区分开


530
00:27:20,807 --> 00:27:23,777
用数字参数类型是整数


531
00:27:23,844 --> 00:27:26,280
在闭包的函数体内返回一个布尔型


532
00:27:28,649 --> 00:27:31,752
这是最明确和最完整的定义闭包
的方式


533
00:27:32,452 --> 00:27:33,720
但是你之前见过了


534
00:27:33,787 --> 00:27:37,157
Swift可以推断很多信息
从代码的上下文中


535
00:27:39,393 --> 00:27:42,829
比如闭包的函数类型已知


536
00:27:42,896 --> 00:27:45,566
从包括数字这个参数的类型中


537
00:27:46,099 --> 00:27:48,202
所以你不需要明确的写出来


538
00:27:49,670 --> 00:27:53,207
如果整个闭包的体只是一个
返回语句


539
00:27:53,273 --> 00:27:56,777
像这里一样你不需要明确的写
出return关键字


540
00:27:58,345 --> 00:28:02,382
这是更干净的语法
但是因为闭包很短


541
00:28:02,649 --> 00:28:05,652
看起来这个参数数字都显得有点
多余


542
00:28:06,186 --> 00:28:09,790
像这种情况
Swift提供暗示的变量名


543
00:28:09,857 --> 00:28:13,460
所以不需要写出参数名或者in
关键字


544
00:28:14,928 --> 00:28:16,230
这个暗示的文件名


545
00:28:16,296 --> 00:28:18,732
用一个美元符号开始
以及一个从0开始的数字


546
00:28:18,799 --> 00:28:23,136
$0表示第一个闭包参数
$1是第二个 等等


547
00:28:24,238 --> 00:28:27,574
虽然这可以在任何闭包表达式中
使用


548
00:28:28,275 --> 00:28:31,979
使用它们不会使你的代码变得
难以阅读


549
00:28:33,714 --> 00:28:37,818 line:1
现在你看到Swift提供很多方便的
编写闭包的方式


550
00:28:37,985 --> 00:28:41,255 line:1
但是直接在一个函数的括号中
传递它们


551
00:28:41,688 --> 00:28:43,457 line:1
看起来有很多符号


552
00:28:44,258 --> 00:28:47,060 line:1
一个关闭大括号紧邻一个关闭括号


553
00:28:47,327 --> 00:28:48,428 line:1
看起来很怪


554
00:28:50,030 --> 00:28:53,100 line:1
但是当闭包是最后一个参数时


555
00:28:53,166 --> 00:28:54,401 line:1
这种情况就是


556
00:28:55,002 --> 00:28:57,371 line:1
你可以写一个尾随闭包


557
00:28:57,437 --> 00:28:59,139 line:1
就在括号外面


558
00:29:00,307 --> 00:29:04,278 line:1
你接下来会看到如果一个闭包是
一个函数的唯一参数


559
00:29:04,678 --> 00:29:06,713 line:1
你可以移除这个括号


560
00:29:07,814 --> 00:29:09,983 line:1
这时尾随闭包看起来很好


561
00:29:10,317 --> 00:29:12,886 line:1
当闭包含有多于一行代码时


562
00:29:13,820 --> 00:29:16,323
比如这个更复杂的闭包


563
00:29:16,390 --> 00:29:19,860
它判断一个数每一位相加的和
是否是偶数


564
00:29:21,328 --> 00:29:22,563
尾随闭包语法


565
00:29:22,629 --> 00:29:27,034
确保即使是复杂的有多行的闭包


566
00:29:27,100 --> 00:29:28,836
看起来也很自然很好


567
00:29:30,671 --> 00:29:33,273
现在过滤整数函数很有用


568
00:29:33,340 --> 00:29:35,642
如果你想要过滤整数


569
00:29:36,376 --> 00:29:39,313
但是要怎么过滤其他类型的数组
比如类型数组？


570
00:29:40,514 --> 00:29:42,816
例如假设你有一个名字数组


571
00:29:42,883 --> 00:29:45,352
你想要一个过滤了的数组
只含有名字


572
00:29:45,419 --> 00:29:47,354
含有少于给定的字符数


573
00:29:48,755 --> 00:29:50,757 line:1
你可以写一个过滤字符串函数


574
00:29:50,824 --> 00:29:52,259 line:1
像你看到的这个


575
00:29:52,726 --> 00:29:55,262 line:1
因为你已经写好了一个过滤整数
函数


576
00:29:55,329 --> 00:29:57,764 line:1
让我们来看看你能否重用一些逻辑


577
00:29:59,499 --> 00:30:01,568
首先你当然想要做一些簿记


578
00:30:01,635 --> 00:30:05,372
把所有涉及数字的地方改成字符串


579
00:30:06,507 --> 00:30:11,278
下一步把所有整型改成字符串类型


580
00:30:13,447 --> 00:30:15,382
因为实际上这2个函数的行为


581
00:30:15,449 --> 00:30:18,318
是一样的
对整数和字符串


582
00:30:18,385 --> 00:30:19,786
没有什么别的要做


583
00:30:19,853 --> 00:30:21,421
它们实际上是同样的函数


584
00:30:22,422 --> 00:30:25,025
你现在有函数过滤字符串数组


585
00:30:26,393 --> 00:30:30,197
现在如果你想要一个函数过滤
其他类型


586
00:30:30,464 --> 00:30:33,534
你可以重复这个步骤


587
00:30:33,600 --> 00:30:34,601
为每种类型


588
00:30:34,935 --> 00:30:37,638
但是这显然很无聊


589
00:30:38,505 --> 00:30:41,141
实际上你可以写一个函数


590
00:30:41,208 --> 00:30:43,977
可以处理任意类型的数组


591
00:30:44,044 --> 00:30:45,546
这被称为泛型函数


592
00:30:46,346 --> 00:30:47,948
我们来看看怎么写一个


593
00:30:48,682 --> 00:30:52,152
写一个这种函数和你已经看到的
没有很大不同


594
00:30:52,753 --> 00:30:54,988
首先你把名字改得更通用


595
00:30:55,055 --> 00:30:57,925
比如函数叫过滤


596
00:30:57,991 --> 00:31:00,594
而不是过滤整数或过滤字符串


597
00:31:01,495 --> 00:31:04,164
接下来更重要的是你需要填写
占位符


598
00:31:04,231 --> 00:31:07,234
你在这里看到的
元素的类型


599
00:31:07,835 --> 00:31:10,137
但是你现在还不知道元素的类型


600
00:31:10,971 --> 00:31:13,640
所以你希望是一个类型参数


601
00:31:14,007 --> 00:31:16,844
实际的类型会在函数被调用时确定


602
00:31:18,378 --> 00:31:20,247
这里我们填写了占位符


603
00:31:20,314 --> 00:31:22,649
用一个通用类型参数叫做元素


604
00:31:23,650 --> 00:31:26,720
所以你能看到区别
在类型参数


605
00:31:26,787 --> 00:31:30,190
和实际存在的类型比如字符串
或者整数


606
00:31:30,624 --> 00:31:34,528
你把类型参数写在尖括号中


607
00:31:34,595 --> 00:31:36,163
紧跟函数名后面


608
00:31:36,730 --> 00:31:38,632
现在你有一个泛型函数


609
00:31:38,699 --> 00:31:42,035
作用于一个数组包含任意类型的值


610
00:31:44,571 --> 00:31:47,374
你和以前一样调用这种函数


611
00:31:47,441 --> 00:31:50,611
你不需要指定你想要这个函数
处理的类型


612
00:31:50,677 --> 00:31:53,247
因为可以通过你传入的值推断


613
00:31:54,681 --> 00:31:58,352 line:1
过滤是如此有用的操作
所以Swift标准库


614
00:31:58,418 --> 00:32:02,256 line:1
有一个过滤方法可用用于任何
种类的序列或集合


615
00:32:03,257 --> 00:32:07,160
你和你看到的过滤函数以同样的
方式工作


616
00:32:07,227 --> 00:32:10,531
除了这是一个方法
你需要用点号来调用它


617
00:32:10,597 --> 00:32:12,900
names.filter像你看到的


618
00:32:14,668 --> 00:32:17,037 line:1
Swift标准库实际上有很多其他
方法


619
00:32:17,104 --> 00:32:19,339 line:1
接受闭包作为一个参数


620
00:32:19,907 --> 00:32:22,643 line:1
另一个很有用的是映射方法


621
00:32:22,709 --> 00:32:25,212 line:1
它也作用于任何序列或集合


622
00:32:26,013 --> 00:32:27,981 line:1
映射返回一个新的数组


623
00:32:28,048 --> 00:32:30,884 line:1
包含对每个元素进行闭包的结果


624
00:32:31,251 --> 00:32:34,888 line:1
这是一个例子在对上面得到的
包含短名字的数组调用映射方法


625
00:32:35,088 --> 00:32:38,625 line:1
它传递一个闭包把每个字符串
转成大写


626
00:32:40,527 --> 00:32:44,598 line:1
你可以把它们链起来强行多个操作


627
00:32:44,665 --> 00:32:45,666
比如


628
00:32:45,732 --> 00:32:49,102
你可以在同一个表达式里过滤
并大写


629
00:32:49,169 --> 00:32:51,672
通过把两个方法形成一个链


630
00:32:51,738 --> 00:32:53,073
使用点号


631
00:32:53,140 --> 00:32:54,875
过滤先进行


632
00:32:54,942 --> 00:32:56,977
然后映射在被过滤过的数组上
被调用


633
00:32:57,044 --> 00:32:59,613
最终返回大写的字符串


634
00:33:01,381 --> 00:33:02,516 line:1
这读起来很棒


635
00:33:02,583 --> 00:33:04,918 line:1
即使你用尾随闭包语法


636
00:33:06,587 --> 00:33:10,324 line:1
所以使用闭包和函数接收闭包
作为参数的这个组合


637
00:33:10,390 --> 00:33:15,362 line:1
使它有可能写一些复杂强大的代码


638
00:33:15,929 --> 00:33:18,498 line:1
用一个简明但是很有表现力的方式


639
00:33:19,099 --> 00:33:22,936
我们已经看了函数和闭包
以及一点泛型函数


640
00:33:23,003 --> 00:33:27,274
我想邀请Alex上台告诉你们
所有关于Swift数据类型的事


641
00:33:34,314 --> 00:33:35,148
谢谢Brian


642
00:33:36,083 --> 00:33:38,886
你们看到了Swift中的数据类型


643
00:33:39,286 --> 00:33:43,123
现在让我们看看怎样创建
你自己的数据类型


644
00:33:44,525 --> 00:33:46,126
让我们从结构开始


645
00:33:46,627 --> 00:33:48,595
你创建一个像这样


646
00:33:48,662 --> 00:33:52,799
你写下struct关键字
跟随的是结构的名字


647
00:33:52,866 --> 00:33:54,568
矩形


648
00:33:56,170 --> 00:33:58,172
然后在大括号里


649
00:34:00,374 --> 00:34:02,543
你写下结构的属性


650
00:34:04,478 --> 00:34:06,213
属性使用相同的语法


651
00:34:06,280 --> 00:34:09,382
和你在前面见过的变量和常量一样


652
00:34:11,083 --> 00:34:12,652
这里有两个属性


653
00:34:12,719 --> 00:34:15,656
做为申明的一部分被赋值


654
00:34:15,989 --> 00:34:20,293
所以你可以新建一个矩形
通过只写下矩形这个名字


655
00:34:21,027 --> 00:34:23,197
跟随一对括号


656
00:34:24,197 --> 00:34:27,601
要访问属性
你使用点号


657
00:34:30,137 --> 00:34:33,139
你不需要为属性提供值


658
00:34:33,206 --> 00:34:35,442
在类型申明中


659
00:34:35,509 --> 00:34:37,844
实际上大部分时候你不这么做


660
00:34:38,277 --> 00:34:40,581
更常见的 你只写类型


661
00:34:41,648 --> 00:34:44,818
然后你在建立实例时赋值


662
00:34:46,520 --> 00:34:51,458
矩形除了尺寸的另一个属性是面积


663
00:34:52,525 --> 00:34:54,895
虽然你不想储存面积


664
00:34:55,062 --> 00:34:58,665
你需要在每次尺寸变化时更新它


665
00:34:59,533 --> 00:35:01,602
你想要的是一个属性


666
00:35:01,668 --> 00:35:05,172
它的值当你需要的时候被计算出


667
00:35:05,639 --> 00:35:08,675
你可以用一个被计算属性


668
00:35:10,077 --> 00:35:11,778
要创建一个被计算属性


669
00:35:12,513 --> 00:35:17,885
在属性的名称和类型后面
你写一个函数体


670
00:35:18,118 --> 00:35:21,321
用来计算并返回


671
00:35:21,588 --> 00:35:23,590
函数的当前值


672
00:35:24,658 --> 00:35:27,628
虽然它是被计算的而不是被储存的


673
00:35:27,694 --> 00:35:30,197
你还是可以用点号访问它


674
00:35:31,665 --> 00:35:33,967
你还可以用属性做更多


675
00:35:34,334 --> 00:35:36,870
你可以有设置者和监视者


676
00:35:38,038 --> 00:35:40,507 line:1
你可以获得更多信息


677
00:35:40,574 --> 00:35:45,445 line:1
在Swift编程语言的属性章节


678
00:35:48,215 --> 00:35:51,051
就像你在结构中定义属性


679
00:35:51,218 --> 00:35:53,120
你还可以定义方法


680
00:35:54,154 --> 00:35:57,691
和你已经看过的函数一样的语法


681
00:35:59,159 --> 00:36:03,597 line:1
和属性一样
你用点号访问方法


682
00:36:03,664 --> 00:36:05,132 line:1
当你需要调用它们时


683
00:36:08,435 --> 00:36:12,339 line:1
你看到几次新建矩形的语法了


684
00:36:12,906 --> 00:36:15,943 line:1
我们看看它做了什么的更多细节


685
00:36:17,377 --> 00:36:21,815
这看起来像调用函数因为这个括号


686
00:36:22,049 --> 00:36:24,351
实际上它是在调用初始化者


687
00:36:25,319 --> 00:36:28,889
我们一直在用一个特殊的初始化者


688
00:36:28,956 --> 00:36:31,291
称为成员初始化者


689
00:36:31,358 --> 00:36:34,995
Swift为你的结构实现


690
00:36:35,662 --> 00:36:37,130
这是它看起来的样子


691
00:36:37,197 --> 00:36:40,033 line:1
如果你明确的写这个初始化者


692
00:36:41,134 --> 00:36:43,370 line:1
你写init关键字


693
00:36:43,437 --> 00:36:47,641 line:1
然后在里面你为矩形的属性设值


694
00:36:48,942 --> 00:36:52,012 line:1
注意有两个宽度


695
00:36:52,513 --> 00:36:54,815 line:1
一个是属性另一个是参数


696
00:36:55,516 --> 00:37:00,654 line:1
你写下self点来明确的参考属性


697
00:37:01,855 --> 00:37:04,424 line:1
这就是你怎么写初始化者


698
00:37:06,894 --> 00:37:10,097 line:1
矩形结构有足够多的代码


699
00:37:10,163 --> 00:37:13,100 line:1
值得进行一些组织


700
00:37:13,166 --> 00:37:16,970 line:1
Swift中这样做的一个方法是
使用扩展


701
00:37:18,372 --> 00:37:22,676
一个扩展让你向一个已有的类型
添加功能


702
00:37:23,911 --> 00:37:28,682
在Swift里你可以用扩展来分离
你的代码


703
00:37:29,816 --> 00:37:33,487
核心功能可以在结构的申明中


704
00:37:34,588 --> 00:37:39,193
辅助的功能可以在一个或多个
扩展中


705
00:37:40,427 --> 00:37:43,263
你可以不受限地扩展你自己的类型


706
00:37:43,830 --> 00:37:47,768
如果你需要你可以扩展从其他
地方来的类型


707
00:37:47,835 --> 00:37:51,538
比如foundation 或者标准库


708
00:37:53,140 --> 00:37:56,643
你早前看到怎么创建范型函数


709
00:37:56,710 --> 00:38:01,215
在不同的类型上进行相同的操作


710
00:38:01,982 --> 00:38:07,554
你还可以创建泛型结构
它包含不同类型的数据


711
00:38:08,255 --> 00:38:10,424
语法看起来很相似


712
00:38:10,490 --> 00:38:15,863
你仍然有泛型类型参数在名字
后面的尖括号里


713
00:38:16,730 --> 00:38:21,935
这个例子把名字附加给一些种类
的元素的数组


714
00:38:22,970 --> 00:38:26,440
这会是个有用的数据结构
比如


715
00:38:26,507 --> 00:38:31,178
来填充一个表视图
有不同的部分有标题名


716
00:38:31,678 --> 00:38:35,215
你创建一个泛型结构实例


717
00:38:35,282 --> 00:38:37,684
就像另一个类型的实例


718
00:38:39,586 --> 00:38:43,123
你在这看到如果你写下类型标注


719
00:38:44,424 --> 00:38:48,028
棋盘游戏和质数有不同的类型


720
00:38:49,029 --> 00:38:53,433
一个是字符串数组
另一个是整数数组


721
00:38:54,301 --> 00:38:58,739
它们有不同的元素类型
所以它们是不同的类型


722
00:39:00,174 --> 00:39:02,209
你不需要写数组


723
00:39:02,709 --> 00:39:06,146
Swift自动推测是什么元素


724
00:39:08,182 --> 00:39:09,650
这就是结构


725
00:39:11,518 --> 00:39:14,621
在Swift中另一个数据类型是类


726
00:39:15,689 --> 00:39:18,392
你在名称前写下类别关键字


727
00:39:18,458 --> 00:39:21,161
但是关于结构的一切都仍然有效


728
00:39:21,695 --> 00:39:24,998
属性 方法 初始化者等等


729
00:39:26,099 --> 00:39:29,169
那么为什么你想要创建一个类？


730
00:39:30,804 --> 00:39:36,176
一个原因是你的代码可以引用
一个类的同一个实例


731
00:39:36,243 --> 00:39:38,045
从不同的地方


732
00:39:38,679 --> 00:39:41,982
这和结构的行为不同


733
00:39:43,083 --> 00:39:46,019
一个结构的行为像一个大的值


734
00:39:46,787 --> 00:39:51,058
比如 在游戏中 你让玩家1有
一个分数


735
00:39:52,359 --> 00:39:58,031
你给玩家2一个一样的分数
你有两个独立的分数


736
00:39:58,899 --> 00:40:03,837
改变玩家2的分数不会改变
玩家1的分数


737
00:40:05,072 --> 00:40:10,477
但是两个玩家需要引用硬盘上
的同一个文件


738
00:40:10,544 --> 00:40:12,446
当他们记录他们的高分的时候


739
00:40:13,914 --> 00:40:17,150
因为这是一个类
这就是你想要的行为


740
00:40:18,652 --> 00:40:23,991
当玩家2得到一个新的高分
并把它记录到文件中


741
00:40:24,658 --> 00:40:26,960
两个玩家都看到改变


742
00:40:29,062 --> 00:40:31,999
如果你是从另一个面向对象语言
中过来


743
00:40:32,065 --> 00:40:35,402
你可能习惯于写很多类


744
00:40:35,469 --> 00:40:40,040
在Swift中你不需要经常写它们


745
00:40:41,208 --> 00:40:45,746
任何时候你想要检查是否相等
或进行复制


746
00:40:46,780 --> 00:40:49,917
你通常只需要一个值类型像是结构


747
00:40:51,518 --> 00:40:55,822 line:1
要知道更多为什么以及怎么
用值类型的信息


748
00:40:55,889 --> 00:40:58,492 line:1
你可以看一个很有用的演讲


749
00:40:59,726 --> 00:41:02,095 line:1
另一个用类的原因是


750
00:41:02,162 --> 00:41:05,065 line:1
你想从已有的类中派生一个子类


751
00:41:06,934 --> 00:41:09,670
比如假设你有一个框架


752
00:41:09,736 --> 00:41:14,741
给你鱼类包含一些核心的鱼的功能


753
00:41:15,976 --> 00:41:22,049 line:1
你可以创建子类来添加功能
像是飞鱼可以添加飞方法


754
00:41:23,050 --> 00:41:27,654 line:1
你标明这是一个子类通过写冒号鱼


755
00:41:28,789 --> 00:41:34,394 line:1
子类还可以覆盖方法来提供它们
自己的实现


756
00:41:35,462 --> 00:41:37,664 line:1
像抱怨鱼


757
00:41:37,731 --> 00:41:41,835 line:1
它像普通鱼一样游泳
只是会先报怨


758
00:41:44,838 --> 00:41:49,610 line:1
你写super.swim
来调用父类的实现


759
00:41:50,611 --> 00:41:53,046 line:1
这个代码还不能被编译


760
00:41:54,014 --> 00:41:56,617 line:1
当你在Swift中覆盖方法


761
00:41:56,683 --> 00:42:00,854 line:1
你需能写覆写关键字来明确标明


762
00:42:01,455 --> 00:42:03,257 line:1
现在代码工作


763
00:42:04,725 --> 00:42:08,862 line:1
像是一个错误
偶然覆盖了一些东西


764
00:42:08,929 --> 00:42:14,568 line:1
这也是一个错误
写了覆写却不覆盖任何东西


765
00:42:15,736 --> 00:42:20,474 line:1
这就是说如果你拼错了一个
想要覆盖的方法的名字


766
00:42:20,974 --> 00:42:24,545 line:1
Swift会在编译时告诉你这个错误


767
00:42:26,346 --> 00:42:29,249 line:1
一个赛格威也可以提供初始化者


768
00:42:30,684 --> 00:42:35,189 line:1
比如鱼有初始化者接收一个名字


769
00:42:35,889 --> 00:42:41,361 line:1
抱怨鱼的初始化者需要名字和报怨


770
00:42:42,663 --> 00:42:46,900 line:1
在初始化者中你设置初始值


771
00:42:46,967 --> 00:42:50,370 line:1
为子类申明的属性


772
00:42:51,471 --> 00:42:53,907 line:1
然后你调用super.init


773
00:42:54,808 --> 00:42:58,011 line:1
让父类完成初始化


774
00:42:59,613 --> 00:43:04,017 line:1
你可以用初始化者做更多
特别是围绕类


775
00:43:05,752 --> 00:43:09,389 line:1
你可以在初始化者这一章知道更多


776
00:43:09,456 --> 00:43:11,425 line:1
在Swift编程语言中


777
00:43:13,193 --> 00:43:15,562
你看过了怎么用子类


778
00:43:15,629 --> 00:43:18,632
让我们谈谈子类编程


779
00:43:20,868 --> 00:43:25,772
继续游戏的例子
假设你有玩家基类


780
00:43:26,473 --> 00:43:30,511
因为每个玩家轮流行动
你有一种方法这样做


781
00:43:31,411 --> 00:43:33,680
你有两类玩家


782
00:43:34,348 --> 00:43:36,383
你有人类玩家类


783
00:43:36,450 --> 00:43:39,887
通过显示UI给用户来完成一轮


784
00:43:40,554 --> 00:43:43,190 line:1
你有电脑玩家类


785
00:43:43,257 --> 00:43:46,960 line:1
通过进行最好的合法的移动来
完成一轮


786
00:43:48,161 --> 00:43:53,400 line:1
问题就是什么进入基类的实现中？


787
00:43:54,768 --> 00:44:00,307 line:1
人类和电脑玩家没有共享的行为


788
00:44:01,008 --> 00:44:04,211
没有共享的代码可以移出


789
00:44:05,145 --> 00:44:07,681
在附近的代码


790
00:44:07,748 --> 00:44:12,019
你永远都不会想要一个
玩家基类实例


791
00:44:12,553 --> 00:44:15,122
所以这个方法永远都不应该被调用


792
00:44:16,757 --> 00:44:19,626
这里能写的唯一合理的东西


793
00:44:19,693 --> 00:44:23,931 line:1
是一些严重错误来帮助你捕获失误


794
00:44:23,997 --> 00:44:26,466 line:1
在开发的早期阶段


795
00:44:27,534 --> 00:44:33,240 line:1
所有玩家类在做的是描述
做为一个玩家意味着什么


796
00:44:33,640 --> 00:44:36,243 line:1
每个玩家进行一轮


797
00:44:36,844 --> 00:44:39,847 line:1
它是玩家的蓝图


798
00:44:41,181 --> 00:44:46,286 line:1
在Swift中你用协议表达这种关系


799
00:44:47,321 --> 00:44:51,725 line:1
协议规定要求像是方法和属性


800
00:44:52,960 --> 00:44:56,296
他们就像接口或者抽象类


801
00:44:56,363 --> 00:44:58,332
你可能在别的语言里知道


802
00:44:59,700 --> 00:45:03,003
你使用protocol关键字
来创建一个


803
00:45:03,637 --> 00:45:08,308 line:1
因为它描述其他类型要实现的要求


804
00:45:09,042 --> 00:45:11,044 line:1
你不提供一个实现


805
00:45:12,779 --> 00:45:17,417 line:1
类型通过提供那些实际来遵守协议


806
00:45:18,418 --> 00:45:22,456 line:1
你通过写：Player来申明符合性


807
00:45:22,956 --> 00:45:25,325 line:1
就像你对父类做的那样


808
00:45:26,960 --> 00:45:30,297 line:1
这样你不再使用子类


809
00:45:30,364 --> 00:45:33,467 line:1
这些方法不覆盖任何东西


810
00:45:34,868 --> 00:45:36,970 line:1
你不写覆写关键字


811
00:45:39,406 --> 00:45:43,243 line:1
没有理由它再是一个类


812
00:45:43,343 --> 00:45:44,978 line:1
让我们把它变为结构


813
00:45:46,847 --> 00:45:50,384 line:1
让我们仔细看看人类玩家


814
00:45:52,286 --> 00:45:56,023
它还有一些其它的属性比如
名字和分数


815
00:45:56,757 --> 00:46:00,194
如果你创建一个玩家实例
你可以打印它


816
00:46:02,329 --> 00:46:07,000 line:1
你得到一个default的描述
因为标准库


817
00:46:07,267 --> 00:46:10,404 line:1
可以把任何类型转化成字符串


818
00:46:12,306 --> 00:46:15,042 line:1
但是如果你想要定制这个转化


819
00:46:15,108 --> 00:46:17,511 line:1
来打印一个更好的描述


820
00:46:18,445 --> 00:46:23,450 line:1
该标准库还有一个协议
叫CustomStringConvertible


821
00:46:23,984 --> 00:46:26,453 line:1
使你提供自己的描述


822
00:46:27,154 --> 00:46:29,456
这是这个协议的样子


823
00:46:30,090 --> 00:46:33,594
它有一个要求
一个描述属性


824
00:46:34,962 --> 00:46:39,700
任何遵守这个协议的类型
使用定制描述


825
00:46:40,467 --> 00:46:45,239
你要在哪实现这个描述属性？


826
00:46:46,340 --> 00:46:49,710
记住你可以整理你的代码


827
00:46:49,776 --> 00:46:54,982
使用扩展
核心功能在函数申明中


828
00:46:55,048 --> 00:46:58,185
附加功能在扩展中


829
00:46:59,186 --> 00:47:04,291
有一个字符串转换功能是第二类


830
00:47:04,358 --> 00:47:08,896
它不是核心功能
所以把它放在扩展里


831
00:47:09,396 --> 00:47:13,500
这是你如何扩展一个类型
来遵守协议


832
00:47:14,468 --> 00:47:18,872
你在第一行写下
“: CustomStringConvertible”


833
00:47:20,007 --> 00:47:24,144
然后你在扩展体内实现要求


834
00:47:26,113 --> 00:47:30,417 line:1
现在你可以调用打印
你获得定制的字符串转换


835
00:47:31,818 --> 00:47:36,657 line:1
你可以在Swift里用协议和扩展
做很多


836
00:47:36,757 --> 00:47:39,693 line:1
来组织你的代码并建立抽象


837
00:47:40,827 --> 00:47:43,864 line:1
要知道更多信息请看


838
00:47:43,931 --> 00:47:47,901 line:1
2015年的面向协议编程


839
00:47:49,436 --> 00:47:54,575 line:1
那带来Swift最后的一个数据类型
枚举


840
00:47:55,576 --> 00:47:58,912
你在有一个值列表时使用枚举


841
00:47:58,979 --> 00:48:00,881
当你提前知道


842
00:48:01,582 --> 00:48:06,587
这是一个枚举支持左或右对齐
的文本


843
00:48:07,588 --> 00:48:12,893
当你用一个枚举时
你用点号来访问它的案例


844
00:48:14,027 --> 00:48:16,463
这里只有两个案例


845
00:48:16,530 --> 00:48:19,600
所以你把它们写在一行还是可读的


846
00:48:21,101 --> 00:48:25,138
因为枚举是一个可能值的列表


847
00:48:25,205 --> 00:48:27,808
经常把它和switch一起用


848
00:48:28,709 --> 00:48:32,212 line:1
一个switch case
对应一个枚举案例


849
00:48:33,714 --> 00:48:37,751 line:1
一遍遍写对齐有点重复


850
00:48:37,818 --> 00:48:39,853 line:1
在这并不需要


851
00:48:40,921 --> 00:48:47,261 line:1
switch考虑文本对齐
所以需要检查的仅有的可能值


852
00:48:47,461 --> 00:48:50,397 line:1
是枚举的案例


853
00:48:51,164 --> 00:48:54,535 line:1
所以你可以省略枚举名称


854
00:48:54,601 --> 00:48:56,803 line:1
只用写“.left”


855
00:48:58,438 --> 00:49:01,742 line:1
还要注意这里没有default


856
00:49:02,843 --> 00:49:05,379 line:1
和你已经看到的原因一样


857
00:49:05,979 --> 00:49:10,417 line:1
switch已经覆盖了所有可能的
对齐值


858
00:49:10,584 --> 00:49:14,087 line:1
没有东西留下给default来处理


859
00:49:15,489 --> 00:49:18,892 line:1
省略default有一个好处


860
00:49:19,493 --> 00:49:23,597 line:1
如果你晚些回来增加一个枚举案例


861
00:49:23,664 --> 00:49:26,200 line:1
但是忘记更新switch


862
00:49:26,266 --> 00:49:30,504 line:1
Swift会高亮这个错误直到你添加
遗失的代码


863
00:49:32,673 --> 00:49:38,011 line:1
让我们快速看一看
你能对枚举做的其他两件事


864
00:49:40,681 --> 00:49:44,718
你可以给每个枚举案例关联一个值


865
00:49:45,652 --> 00:49:51,124
比如对齐可以指定要用多少填充


866
00:49:52,793 --> 00:49:58,332 line:1
你可以获得那个填充值
在switch case中


867
00:50:00,601 --> 00:50:07,441
你也可以给每个枚举案例
一个原始值从其他类型中


868
00:50:07,508 --> 00:50:09,877
比如字符串或者整数


869
00:50:11,578 --> 00:50:14,882 line:1
来让你提升代码的类型安全


870
00:50:14,948 --> 00:50:18,752 line:1
通过用枚举取代字符串常量


871
00:50:21,154 --> 00:50:24,258 line:1
你今天下午看了很多Swift


872
00:50:24,758 --> 00:50:27,127 line:1
但是没有时间展示所有的


873
00:50:28,028 --> 00:50:31,532 line:1
最后一个我想展示的是错误处理


874
00:50:34,134 --> 00:50:39,173
在Swift中你可以用枚举来描述
错误


875
00:50:40,741 --> 00:50:44,912
你用throws关键字标记一个函数
可以抛出错误


876
00:50:47,047 --> 00:50:51,752
你在必须要运行的代码块前
写defer关键字


877
00:50:51,818 --> 00:50:53,720
无论是否发生错误


878
00:50:54,087 --> 00:50:58,258
它都会在退出作用域前被运行


879
00:50:58,325 --> 00:51:00,294
比如从一个函数返回


880
00:51:03,630 --> 00:51:06,633
在调用可能抛出错误的代码前


881
00:51:06,700 --> 00:51:08,402
你用try关键字标记它


882
00:51:09,970 --> 00:51:14,675 line:1
你可以捕获和抛出错误
用catch和throw关键字


883
00:51:16,243 --> 00:51:21,582 line:1
关于所有细节请看错误处理章节


884
00:51:21,648 --> 00:51:23,717 line:1
在Swift编程语言中


885
00:51:25,452 --> 00:51:29,389
你可以在这找到这本书和其他资源
的链接


886
00:51:31,592 --> 00:51:36,964 line:1
有很多很好的Swift演讲
可以在这周晚些时间参加或者看视频


887
00:51:37,698 --> 00:51:38,532
谢谢

