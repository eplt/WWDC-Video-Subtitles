1
00:00:19,753 --> 00:00:24,224
构建基于文档的app


2
00:00:25,893 --> 00:00:26,727
谢谢


3
00:00:29,963 --> 00:00:30,797
下午好


4
00:00:31,131 --> 00:00:34,635
我是迈克·赫斯一名来自iOS
Apps和框架团队的软件工程师


5
00:00:35,002 --> 00:00:36,737
今天我和约翰尼斯·福特曼一起


6
00:00:36,837 --> 00:00:40,407
在这里给大家讲讲怎样让
你的基于文档的app脱颖而出


7
00:00:41,708 --> 00:00:43,977
今天我们给你们写了一些
示例代码会展示给你们


8
00:00:44,211 --> 00:00:48,682
如何构建一个基于文档的
app的两个主要元件


9
00:00:50,384 --> 00:00:54,288
首先我们要向你演示如何构建
一个很棒的“文档浏览器”


10
00:00:54,621 --> 00:00:57,491
这样你的用户就可以很快
找到他们感兴趣的文档


11
00:00:57,558 --> 00:00:58,926
需要处理的文档


12
00:01:00,360 --> 00:01:03,931
其次我们要向你们演示如何
构建一个能够和文档正确进行交互


13
00:01:04,397 --> 00:01:09,670
协调处理并发阅读程序和写入程序
比如iCloud驱动守护进程


14
00:01:09,736 --> 00:01:11,505
这样一个很棒的文档编辑器


15
00:01:12,439 --> 00:01:14,374
我们稍后会深入讲一下
iCloud驱动守护进程


16
00:01:14,741 --> 00:01:17,010
首先我们来看看“文档浏览器”


17
00:01:18,912 --> 00:01:21,048
那么什么是基于文档的app？


18
00:01:22,916 --> 00:01:26,620
我们认为一个文档就是一个
单一的独立的实体


19
00:01:26,687 --> 00:01:30,657
用户也把它理解为一个单一的实体


20
00:01:31,325 --> 00:01:34,394
那么基于文档的app就是一个
能够管理这些文档列表、


21
00:01:34,461 --> 00:01:37,331
把文档展示给用户以便用户对它们进行


22
00:01:37,397 --> 00:01:41,702
查看 编辑 重命名的这样一个app


23
00:01:43,003 --> 00:01:45,472
比如说Keynote
就可以对Keynote文档列表


24
00:01:45,539 --> 00:01:46,540
进行管理


25
00:01:46,607 --> 00:01:51,378
而Numbers这个应用程序就可以
管理Numbers电子表格文档列表


26
00:01:51,678 --> 00:01:55,415
就连Garage Band也可以对
Garage Band歌曲文档进行管理


27
00:01:55,782 --> 00:01:59,520
我们把这些都看作基于文档的app


28
00:02:01,255 --> 00:02:04,958
现在我们就来深入讲一讲
我们如何构建我们的“文档浏览器”


29
00:02:06,493 --> 00:02:09,496
一个很棒的“文档浏览器”
有四个主要元件


30
00:02:11,832 --> 00:02:14,101
首先我们希望能够以对我们的用户


31
00:02:14,168 --> 00:02:16,737
有意义的方式列出我们的
文档就像我们在这个


32
00:02:16,803 --> 00:02:20,240
示例代码中这样根据文档名
对文档进行了分类


33
00:02:20,407 --> 00:02:23,644
我们的用户就可以理解
我们的app的流程


34
00:02:25,546 --> 00:02:27,581
其次我们认为你应该使用
缩略图这样文档可见性


35
00:02:27,648 --> 00:02:30,317
可以很棒你的用户只需要一瞥


36
00:02:30,384 --> 00:02:34,354
就可以快速找出他们感兴趣的文档


37
00:02:34,421 --> 00:02:36,023
需要处理的文档


38
00:02:38,158 --> 00:02:41,161
第三我们想要展示我们的
app中所有可用的文档


39
00:02:41,228 --> 00:02:44,565
包括位于其它app的容器内的文档


40
00:02:44,631 --> 00:02:47,835
比如示例中的这个文档它是位于


41
00:02:48,402 --> 00:02:51,605
共享iCloud Drive容器上


42
00:02:53,207 --> 00:02:55,275
第四，我们认为保存一个
最近访问的文档列表


43
00:02:55,342 --> 00:02:58,912
是个不错的主意
这样用户就可以快速返回


44
00:02:59,513 --> 00:03:03,317
他们当前正在处理的文档


45
00:03:05,953 --> 00:03:08,589
现在我们看看怎样找出我们的


46
00:03:08,655 --> 00:03:10,324
“文档浏览器”上的文档


47
00:03:12,826 --> 00:03:17,798
一个笨办法可能是使用
NSFileManager尝试列出


48
00:03:17,865 --> 00:03:19,633
你在云端的文档


49
00:03:19,933 --> 00:03:21,635
但是这些结果是不完整的


50
00:03:23,537 --> 00:03:27,541
比如说在iCloud有一个
文档的概念


51
00:03:27,975 --> 00:03:29,977
文档位于那里 但是内容还没有实现


52
00:03:30,043 --> 00:03:32,679
本地可见的文档就是说


53
00:03:32,746 --> 00:03:34,248
还没有下载到磁盘上的文档


54
00:03:34,414 --> 00:03:37,551
NSFileManager并不能
正确获得这些文档


55
00:03:38,819 --> 00:03:42,155
此外如果你试图通过
NSFileManager来列出你的文档


56
00:03:42,589 --> 00:03:44,424
那么外部文档就不会包括进来


57
00:03:44,658 --> 00:03:47,594
那么你列出的也就不是你的app
可用的所有的文档


58
00:03:48,829 --> 00:03:49,997
我们来快速看一下


59
00:03:51,098 --> 00:03:53,567
假如说你用的是
NSFileManager API


60
00:03:55,936 --> 00:03:57,971
如果你用的是NSFileManager
你可能会获得文档一


61
00:03:58,038 --> 00:04:00,174
以及这里的文档二
它们都已经完整下载到了


62
00:04:00,541 --> 00:04:03,477
我们的app的容器的硬盘上


63
00:04:04,211 --> 00:04:06,613
但是你遗漏了位于iCloud的


64
00:04:06,847 --> 00:04:08,982
文档三这个文档


65
00:04:09,449 --> 00:04:13,620
并且你也遗漏了位于另一个
app容器上的文档四


66
00:04:13,720 --> 00:04:17,824
而我们的用户已经授予了你的
app访问那个文档的权限


67
00:04:18,291 --> 00:04:22,129
因此当你列出你的文档时你肯定不会
想用NSFileManager API


68
00:04:23,697 --> 00:04:26,099
你想用的肯定是
NSMetadataQuery


69
00:04:27,134 --> 00:04:30,070
我们来看看
NSMetadataQuery的工作原理


70
00:04:31,638 --> 00:04:35,008
NSMetadataQuery会
获得所有你的app可用的文档


71
00:04:35,609 --> 00:04:38,679
包括位于iCloud的文档三


72
00:04:38,745 --> 00:04:42,149
以及位于另一个app的容器
但是用户已经授权了我们的


73
00:04:42,216 --> 00:04:45,719
app查看那个文档权限的文档四


74
00:04:46,520 --> 00:04:50,257
重点要注意的是这里还有个文档五
同样位于另一个app的容器


75
00:04:50,457 --> 00:04:53,827
但是用户并未授予我们的app
查看那个文档的权限


76
00:04:54,328 --> 00:04:57,664
文档五并没有包括在
NSMetadataQuery结果中


77
00:04:57,731 --> 00:05:00,300
因为如果我们把那个文档展示给用户


78
00:05:00,367 --> 00:05:02,202
那就构成了隐私泄漏


79
00:05:04,905 --> 00:05:06,840
让我们用
NSMetadataQuery


80
00:05:06,907 --> 00:05:08,175
找出我们位于云端的文档


81
00:05:10,210 --> 00:05:11,745
那么流程是怎样的呢？


82
00:05:13,013 --> 00:05:15,883
首先你要创建你的
NSMetadataQuery


83
00:05:17,384 --> 00:05:21,054
然后NSMetadataQuery
就会经过一个初始收集阶段


84
00:05:21,188 --> 00:05:24,291
列出所有当前对你的app可用的文档


85
00:05:26,360 --> 00:05:28,729
初始收集阶段完成后


86
00:05:28,996 --> 00:05:31,965
你会得到一条通知
然后你只需要在你的app的UI


87
00:05:32,032 --> 00:05:35,836
主线程上把这些初始文档
显示出来就可以了


88
00:05:38,272 --> 00:05:40,874
但是NSMetadataQuery
并不是到此就完事了


89
00:05:41,241 --> 00:05:45,112
此外当云端状态发生变更时
你会收到更新通知


90
00:05:45,179 --> 00:05:48,315
比如在这里
iCloud Drive守护程序


91
00:05:49,016 --> 00:05:52,119
向我们的app的容器内下载了
一个新文档


92
00:05:52,186 --> 00:05:54,388
我们就在我们的
NSMetadataQuery


93
00:05:54,454 --> 00:05:55,923
上收到了关于这个文档的通知


94
00:05:58,125 --> 00:06:02,696
然后你只需要计算变更动画


95
00:06:02,763 --> 00:06:06,733
比如在这里我们可能想要向
我们的CollectionView


96
00:06:07,100 --> 00:06:08,869
插入一个
CollectionView单元


97
00:06:08,936 --> 00:06:12,773
然后只需要把这个更新过的UI
显示在我们的主线程上


98
00:06:16,510 --> 00:06:18,412
既然我们已经知道了
怎样找出我们的文档


99
00:06:18,478 --> 00:06:21,915
我们再来看看怎样用文档缩略图


100
00:06:21,982 --> 00:06:23,584
让我们的UI更棒


101
00:06:30,457 --> 00:06:35,796
我们认为在你的UI显示缩略图
是一个不错的主意


102
00:06:36,430 --> 00:06:38,866
因为它可以给你的用户提供视觉语境


103
00:06:39,766 --> 00:06:43,403
这样你的用户只需要一瞥
就可以找到他们感兴趣的文档


104
00:06:43,470 --> 00:06:45,839
需要处理的文档
因为他们有了不错的缩略图


105
00:06:45,939 --> 00:06:47,474
他们就可以很快找到文档


106
00:06:48,775 --> 00:06:51,578
iOS 9上有项新特性
会自动为你创建某些特定的


107
00:06:51,645 --> 00:06:54,581
通用文档类型的缩略图


108
00:06:54,648 --> 00:06:57,551
比如说大的图像文件举个例子


109
00:07:00,087 --> 00:07:02,923
现在我们再来看看你加载你的缩略图


110
00:07:02,990 --> 00:07:06,627
显示在你的app的UI的工作流程


111
00:07:07,861 --> 00:07:09,663
这里要重点注意的是


112
00:07:09,730 --> 00:07:14,334
加载缩略图涉及向内存中
加载数量可能很大的数据


113
00:07:14,968 --> 00:07:20,641
可能会很慢因此加载你的缩略图数据时
你肯定不想阻塞你的主线程


114
00:07:21,708 --> 00:07:23,744
首先让我们看一个工作
流程实例应该可以


115
00:07:24,311 --> 00:07:26,480
这就是我们的示例代码app的
工作流程


116
00:07:27,948 --> 00:07:30,083
首先在我们的示例代码中我们
有一个CollectionView


117
00:07:30,150 --> 00:07:33,687
CollectionView让我们加载一个
CollectionView单元


118
00:07:34,755 --> 00:07:40,494
我们要通过一个后台进程
安排读取缩略图


119
00:07:40,561 --> 00:07:42,763
因为我们尚未缓存完毕缩略图


120
00:07:44,431 --> 00:07:47,668
现在我们并不会等待完成读取缩略图


121
00:07:48,268 --> 00:07:51,205
我们要立即返回一个带有占位图像的


122
00:07:51,271 --> 00:07:55,142
CollectionView单元
这样用户就知道那里有图像


123
00:07:56,476 --> 00:08:00,080
之后某个时间完成读取缩略图后


124
00:08:01,081 --> 00:08:03,383
我们会通知我们的
CollectionView


125
00:08:03,450 --> 00:08:05,118
需要重新加载那个单元


126
00:08:06,153 --> 00:08:10,224
然后我们只要在我们的UI的
那个单元上显示我们的缩略图就可以了


127
00:08:12,793 --> 00:08:17,631
好的 然我们已经知道了怎样找出
文档怎样用漂亮的缩略图


128
00:08:17,698 --> 00:08:20,934
把它们显示出来
我们再来看看怎样管理最近列表


129
00:08:23,470 --> 00:08:25,772
我们认为你可能想用最近列表


130
00:08:25,839 --> 00:08:29,610
因为最近访问的文档通常就是用户


131
00:08:29,676 --> 00:08:32,578
正在处理的文档


132
00:08:33,614 --> 00:08:37,384
因此存储这些文档的这样
一个列表是个不错的主意


133
00:08:37,451 --> 00:08:39,486
这样你的用户就可以快速返回文档中


134
00:08:41,989 --> 00:08:45,425
同样地一个笨办法可能是
使用NSURLs来存储一个


135
00:08:45,492 --> 00:08:48,395
最近访问的文档的最近列表


136
00:08:48,795 --> 00:08:51,431
但是像之前NSFileManager
已经出现的那样


137
00:08:51,565 --> 00:08:53,534
这样有很多缺陷


138
00:08:54,835 --> 00:08:56,203
我们来快速看一下


139
00:08:57,471 --> 00:09:02,342
假如说我们向最近访问的文档
存储一个NSURLs列表


140
00:09:02,910 --> 00:09:06,413
但是在我们的app不运行时
iCloud Drive守护程序移动了文档


141
00:09:06,580 --> 00:09:09,616
比如像这样移动到了一个新文件夹


142
00:09:11,185 --> 00:09:14,755
现在NSURL就成了一个受损引用
没法解算我们的文档


143
00:09:14,988 --> 00:09:17,391
在磁盘上更改后的位置


144
00:09:18,091 --> 00:09:22,162
因此我们不能靠它来存储
我们的最近列表


145
00:09:24,231 --> 00:09:28,669
存储最近列表的正确方法
是使用安全范围书签


146
00:09:30,170 --> 00:09:34,007
这里如果我们向这个文档
存储了一个安全范围书签


147
00:09:34,575 --> 00:09:37,778
而iCloud Drive
守护程序再次把这个文档


148
00:09:37,845 --> 00:09:42,783
移动到了一个文件夹
那么书签就会自动更新


149
00:09:42,916 --> 00:09:46,954
解算文档在磁盘上的新位置
因此当我们管理我们的最近列表时


150
00:09:47,020 --> 00:09:48,689
我们应该使用安全范围书签


151
00:09:51,058 --> 00:09:53,594
我想快速做个演示


152
00:09:54,161 --> 00:09:56,396
看看我们如何管理我们的最近列表


153
00:09:56,496 --> 00:09:58,198
如何加载缩略图


154
00:10:07,541 --> 00:10:09,610
好的让我们在这里启动我们的示例代码


155
00:10:10,110 --> 00:10:12,379
我们尚未向我们的app中加载缩略图


156
00:10:15,382 --> 00:10:19,219
但是举例来说如果
我使用新的多任务处理


157
00:10:19,286 --> 00:10:22,322
功能打开iCloud Drive
app 我们就可以看到


158
00:10:22,389 --> 00:10:24,258
这些文档的缩略图已经在那里了


159
00:10:25,392 --> 00:10:29,029
我们只需要加载它们
显示到我们的app的UI上即可


160
00:10:31,532 --> 00:10:33,734
我们来看看它在代码中是什么样的


161
00:10:38,071 --> 00:10:42,276
好的 首先我们来讲讲如何在代码中
管理我们的最近列表


162
00:10:46,313 --> 00:10:47,681
这里有件重要的事情


163
00:10:49,650 --> 00:10:54,821
当我们在这里保存对象时我们使用了


164
00:10:55,455 --> 00:10:59,793
“标记带有选项数据”
的方法来进行标记


165
00:11:00,160 --> 00:11:04,398
这里重要的是要传递
“适合标记文档”选项


166
00:11:04,665 --> 00:11:06,533
这样我们就可以稍后进行解算


167
00:11:08,602 --> 00:11:10,470
我们的app启动后我们使用书签


168
00:11:10,771 --> 00:11:15,742
调用了“经由解算标记数据”
NSURL构造符方法


169
00:11:15,809 --> 00:11:19,313
这是我们之前保存的
然后我们得到了一个URL


170
00:11:19,379 --> 00:11:22,416
就是我们的文档在磁盘上的
更新后的位置


171
00:11:24,384 --> 00:11:27,721
这里重要的是有了这个返回的URL


172
00:11:27,788 --> 00:11:30,791
我们需要调用
“开始访问资源的安全范围”


173
00:11:31,191 --> 00:11:33,460
防止这个文档是
另一个app的容器内的文档


174
00:11:33,527 --> 00:11:39,433
否则我们就无法读取这个文档
因为...这个文档的读属性


175
00:11:39,666 --> 00:11:42,603
因为这样就会让我们的沙盒


176
00:11:42,936 --> 00:11:44,705
访问到这个文档


177
00:11:47,441 --> 00:11:51,311
那么对于缩略图来说
我们已经为你在示例代码中


178
00:11:51,378 --> 00:11:55,949
写好了这个很棒的缩略图缓存类


179
00:11:56,016 --> 00:11:59,720
可以为我们的app缓存我们的缩略图


180
00:12:01,021 --> 00:12:03,423
这会让我们如释重负


181
00:12:03,490 --> 00:12:06,727
比如调度在后台进程中加载缩略图等等


182
00:12:06,793 --> 00:12:10,731
然后通知我们的
CollectionView


183
00:12:10,797 --> 00:12:12,432
我们需要重新加载单元


184
00:12:13,166 --> 00:12:14,902
我们最后一个没有实现的


185
00:12:15,502 --> 00:12:17,171
是这里的这个代码块


186
00:12:17,437 --> 00:12:20,641
它会从磁盘上加载我们的缩略图


187
00:12:22,109 --> 00:12:24,711
我们只需要在带有一个
缩略图字典键的URL上


188
00:12:24,778 --> 00:12:29,583
调用“获取键的承诺项目资源值”
这个NSURL方法


189
00:12:30,350 --> 00:12:33,587
然后我们就会得到一本缩略图字典


190
00:12:33,687 --> 00:12:37,357
然后我们只需要从字典上抽出
UIImage然后把它返回到


191
00:12:37,958 --> 00:12:41,995
我们的缩略图类这样我们就可以显示它


192
00:12:42,930 --> 00:12:46,900
这里重要的是使用
“获取键的承诺项目资源值”


193
00:12:46,967 --> 00:12:49,336
来代替“获取键的资源值”


194
00:12:49,837 --> 00:12:52,639
因为文档可能还没有实现内容本地可用


195
00:12:53,040 --> 00:12:59,613
这样即使尚未下载我们
也可以展示我们的缩略图


196
00:13:02,482 --> 00:13:05,485
我们需要做的就是重新部署下


197
00:13:08,555 --> 00:13:10,591
这样我们的app里就有了
一些很棒的缩略图


198
00:13:11,258 --> 00:13:14,761
是在后台加载的这样当我们示例代码中


199
00:13:14,828 --> 00:13:17,865
滚动时它们就不会阻塞我们的滚动


200
00:13:19,233 --> 00:13:20,400
好的让我们回到幻灯片


201
00:13:27,541 --> 00:13:30,544
关于构建一个“文档浏览器”
我们学到了什么？


202
00:13:32,179 --> 00:13:33,714
首先我们学到了我们应该使用


203
00:13:33,780 --> 00:13:37,150
NSMetadataQuery而
不是其它方法来找出我们的文档


204
00:13:37,217 --> 00:13:43,023
这样我们就可以
找到所有我们的app可用的文档


205
00:13:44,458 --> 00:13:47,928
其次我们学到了我们应该在
我们的app的UI展示缩略图


206
00:13:48,428 --> 00:13:50,631
这样我们就可以构建一些很棒的UI


207
00:13:50,697 --> 00:13:53,600
我们的用户也可以很快找到
他们正在处理的文档


208
00:13:54,535 --> 00:13:56,436
最后我们学到了我们应该使用书签


209
00:13:56,503 --> 00:13:58,639
而不是其它方法来存储我们的最近列表


210
00:13:58,705 --> 00:14:01,608
这样用户就可以快速回到


211
00:14:01,675 --> 00:14:03,744
他们正在处理的文档


212
00:14:04,378 --> 00:14:07,548
那么我想请约翰尼斯·福特曼上台来


213
00:14:07,614 --> 00:14:09,716
给你们讲讲如何构建文档编辑器


214
00:14:15,822 --> 00:14:16,657
谢谢 迈克


215
00:14:17,991 --> 00:14:18,992
迈克刚才向你们展示了


216
00:14:19,193 --> 00:14:22,563
如何在你的应用程序内构建
一个漂亮的“文档浏览器”


217
00:14:23,130 --> 00:14:26,500
当然这会让我们的app非常漂亮


218
00:14:26,633 --> 00:14:28,302
但是同等重要的


219
00:14:28,368 --> 00:14:32,339
甚至可能更重要的是你的应用程序中


220
00:14:32,406 --> 00:14:36,443
你的用户可以加载编辑文档的那一部分


221
00:14:36,877 --> 00:14:40,113
毕竟用户就是为了这个目的
而试图使用你的应用程序


222
00:14:41,281 --> 00:14:45,018
在我们开始讲整个
加载写入变更文档之前


223
00:14:45,085 --> 00:14:48,889
我们先来快速看看一个叫做


224
00:14:49,223 --> 00:14:51,658
文件的协调性的概念


225
00:14:52,793 --> 00:14:54,761
我在这里讲的是什么？


226
00:14:55,963 --> 00:15:01,635
在我们新的现代
基于多任务处理的世界中


227
00:15:01,969 --> 00:15:06,540
这个概念指的是多个
app访问显示同一文件


228
00:15:07,841 --> 00:15:11,211
举个例子我们可以在iCloud
Drive app显示


229
00:15:11,578 --> 00:15:15,415
你的文档容器内的全部
文件的概述的同时


230
00:15:16,083 --> 00:15:21,588
让你的app运行并且
让用户编辑这个文档


231
00:15:22,856 --> 00:15:26,093
或者还有一种更保守的方法


232
00:15:26,493 --> 00:15:30,464
即使你的用户没有使用这个
两个在前多任务处理视图


233
00:15:30,531 --> 00:15:34,101
也可能经常出现iCloud
Drive同步守护程序


234
00:15:34,601 --> 00:15:37,070
可能想要访问这个文档进行云端同步


235
00:15:37,838 --> 00:15:44,044
而同时你的用户正在编辑这个文档


236
00:15:44,111 --> 00:15:46,446
实际上这是一种非常常见的情况


237
00:15:46,914 --> 00:15:49,650
因为用户正在编辑这个文档


238
00:15:50,284 --> 00:15:52,586
他们把这个文档保存到了磁盘


239
00:15:53,287 --> 00:15:56,190
这个文档当然就发生了变化
因此iCloud Drive守护程序


240
00:15:56,523 --> 00:15:59,426
就想确保它在云端也进行更新了


241
00:16:00,861 --> 00:16:05,866
因此这是一种常见的情况


242
00:16:06,633 --> 00:16:10,137
我们来看看你的用户正在磁盘上


243
00:16:10,204 --> 00:16:13,507
编辑这个文档这一具体案例


244
00:16:14,341 --> 00:16:16,977
当然你的app看起来正在运行中


245
00:16:17,578 --> 00:16:19,346
用户正在进行编辑


246
00:16:19,913 --> 00:16:22,816
同时你的应用程序正在


247
00:16:23,016 --> 00:16:29,056
自动保存定期把这个文档写入磁盘


248
00:16:29,590 --> 00:16:31,859
这样我们在某一时刻有一个写入操作


249
00:16:32,559 --> 00:16:35,762
然后之后某个时刻我们又有用户编辑


250
00:16:36,196 --> 00:16:39,032
变更文档的这样一个操作
然后我们又有一个写入操作


251
00:16:40,033 --> 00:16:43,136
很好 我们假设在某个时刻
我们的用户充分利用了


252
00:16:43,637 --> 00:16:45,606
这个多任务处理功能也就是说


253
00:16:45,672 --> 00:16:51,311
当他们编辑这个文档时他们还同时


254
00:16:51,712 --> 00:16:53,413
运行着另外一个应用程序


255
00:16:54,248 --> 00:16:57,684
这个其它应用程序可能
之前对这个文档有一个引用


256
00:16:57,751 --> 00:17:01,555
并不会立即进行状态恢复


257
00:17:01,622 --> 00:17:05,559
举例来说即试图从磁盘上读取这个文档


258
00:17:06,727 --> 00:17:11,031
现在你可以看到这种情况很糟糕


259
00:17:11,598 --> 00:17:14,800
因为当我们读取这个文档时同时还有


260
00:17:14,902 --> 00:17:16,737
另外一个应用程序对它进行写入操作


261
00:17:17,738 --> 00:17:19,406
这实际上就是我们的应用程序


262
00:17:19,873 --> 00:17:22,142
我们得到的就是这个不一致的读取


263
00:17:22,542 --> 00:17:24,178
当然这很不幸


264
00:17:24,778 --> 00:17:26,445
我们正在写入这个文档但是同时


265
00:17:26,512 --> 00:17:28,382
另一个应用程序又正在读取这个文档


266
00:17:29,049 --> 00:17:32,019
数据仅仅写了一半到磁盘
另一半还没有写入


267
00:17:32,619 --> 00:17:35,189
出现这种怪异的不一致的数据时


268
00:17:35,255 --> 00:17:37,090
其它app可能就不知道应该怎么做


269
00:17:37,591 --> 00:17:38,759
这种情况很糟糕


270
00:17:39,927 --> 00:17:43,830
同样地即使我们设法挺了过去


271
00:17:44,264 --> 00:17:46,600
我们第二次写入后别忘了


272
00:17:46,667 --> 00:17:49,436
我们现在仍然正在第一个
应用程序中编辑这个文档


273
00:17:50,270 --> 00:17:54,842
其它应用程序现在仍然
正在显示你的文档


274
00:17:55,809 --> 00:18:00,914
其它应用程序现在正在
显示你的文档的旧版本


275
00:18:00,981 --> 00:18:04,551
我们就遇到了过时显示这样一个问题


276
00:18:05,953 --> 00:18:08,021
当然出现这种情况很不幸


277
00:18:08,689 --> 00:18:11,758
这里我们给你们准备了
两个方便的解决方法


278
00:18:12,693 --> 00:18:16,530
首先我们有了这个文件的协调性的概念


279
00:18:17,631 --> 00:18:22,202
文件的协调性是一种
分布式阅读程序/写入程序加锁机制


280
00:18:23,003 --> 00:18:26,740
这就意味着
虽然任何时候多个阅读程序


281
00:18:26,807 --> 00:18:29,810
都可以读取同一个文档
但是每次却只能有一个写入程序


282
00:18:30,344 --> 00:18:35,782
这个写入程序会禁止
其它任何阅读程序进行读取


283
00:18:37,284 --> 00:18:39,620
这就意味着如果我们的应用程序


284
00:18:39,686 --> 00:18:42,956
就像使用UIDocument那样
使用正确的文件的协调性


285
00:18:43,423 --> 00:18:45,692
这些机制就会生效


286
00:18:46,326 --> 00:18:51,532
我们的读取操作就会被推迟到
我们的写入操作完成后


287
00:18:51,965 --> 00:18:54,601
这样我们就能始终保持


288
00:18:55,202 --> 00:18:59,606
这个文档一致的形象


289
00:19:00,307 --> 00:19:01,141
非常棒


290
00:19:02,309 --> 00:19:05,245
我向你们保证这里还有一个机制


291
00:19:05,546 --> 00:19:08,282
这里的这个机制是
NSFilePresentation


292
00:19:09,249 --> 00:19:12,119
NSFilePresentation
是一种分布式修改机制


293
00:19:12,920 --> 00:19:16,790
这就意味着我们的文件的协调性会


294
00:19:17,157 --> 00:19:20,227
自动告诉所有其它的文件提出器


295
00:19:20,294 --> 00:19:24,298
你的文档已经登记过了已经写入了磁盘


296
00:19:24,865 --> 00:19:27,768
文件提出器需要对自身进行更新


297
00:19:29,069 --> 00:19:32,005
这样在我们的第二次写入后
我们就可以立即得到一个通知


298
00:19:32,072 --> 00:19:35,909
我们就可以放心地更新我们的UI了


299
00:19:36,877 --> 00:19:43,884
很好我们就是这样来确认我们的文档
总是保存一致的形象


300
00:19:44,418 --> 00:19:45,719
但是文档是什么？


301
00:19:46,753 --> 00:19:49,456
当然我们首先需要创建一些文档


302
00:19:49,523 --> 00:19:52,226
这样才可以显示文档让用户编辑文档


303
00:19:52,726 --> 00:19:53,894
我们来看看这个


304
00:19:54,795 --> 00:19:57,564
我们创建这些文档的目的是什么？


305
00:19:57,865 --> 00:20:01,268
让我们想象下
当我们实现我们的示例app时


306
00:20:01,335 --> 00:20:03,670
我们在右上角有这样一个
小的“加号”按钮


307
00:20:04,071 --> 00:20:07,040
这是个加号按钮用户点击下


308
00:20:07,107 --> 00:20:10,811
我们可能会弹出一个
示例对话或是类似的东西


309
00:20:11,078 --> 00:20:14,014
不过我们总会在某个时刻创建一个文档


310
00:20:14,581 --> 00:20:16,783
在这里我们的主要目的是


311
00:20:17,084 --> 00:20:21,188
给用户一个一致的显示


312
00:20:21,822 --> 00:20:23,857
并且这个显示总是最新的


313
00:20:24,291 --> 00:20:28,228
如果用户点击这个小加号按钮
那就没什么大用


314
00:20:28,629 --> 00:20:31,431
我们现在并不会在我们的
“文档浏览器”内得到更新


315
00:20:31,498 --> 00:20:35,035
用户就会困惑不解不知道发生了什么


316
00:20:35,102 --> 00:20:37,738
用户可能会再点击几次这个加号按钮


317
00:20:37,804 --> 00:20:40,707
现在我们有了五个不同的新文档
这可不太妙


318
00:20:40,941 --> 00:20:46,813
如果不使用文件的协调性
我们最后就可能出现


319
00:20:47,447 --> 00:20:51,752
现在这种情况当然了这是因为...


320
00:20:51,818 --> 00:20:54,254
这就意味着我们在
磁盘上创建了一个文档


321
00:20:55,088 --> 00:20:57,724
之后某个时刻iCloud
Drive守护程序注意到了


322
00:20:57,991 --> 00:21:01,895
这个新文档然后通知我们的app


323
00:21:01,962 --> 00:21:06,233
这个延迟可能在半秒左右


324
00:21:06,300 --> 00:21:08,669
如果守护程序现在正忙
延迟时间可能会更长


325
00:21:09,503 --> 00:21:12,339
我们正是想要避免这种延迟


326
00:21:13,006 --> 00:21:17,144
如果你使用文件的协调性
那现在就很方便了


327
00:21:17,611 --> 00:21:19,613
会直接替你完成


328
00:21:20,814 --> 00:21:25,853
协同运行会与你用来
在你的浏览器中显示文档的


329
00:21:26,119 --> 00:21:28,522
NSMetadataQuery一起


330
00:21:28,589 --> 00:21:34,628
协力也就是在协调完成后


331
00:21:34,695 --> 00:21:37,598
进行回路循环立即告诉


332
00:21:38,031 --> 00:21:40,300
你正在运行的查询出现了


333
00:21:40,868 --> 00:21:43,036
一个新的更新后的文档


334
00:21:44,338 --> 00:21:46,874
这样我们就干掉了这个令人厌恶的延迟


335
00:21:48,308 --> 00:21:50,711
当然这里还是要提醒你们一件事


336
00:21:51,311 --> 00:21:53,714
因为我们是在磁盘上进行写入


337
00:21:54,214 --> 00:21:57,551
无论我们往磁盘上写入什么都需要时间


338
00:21:58,619 --> 00:22:03,090
当然了在主线程上执行任何需要


339
00:22:03,156 --> 00:22:06,093
时间的操作都很不幸


340
00:22:06,159 --> 00:22:09,363
因为它会阻塞主线程
让你的应用程序在用户看来


341
00:22:09,429 --> 00:22:11,632
就像成了一个结巴


342
00:22:15,936 --> 00:22:18,605
当然了解决这个也很容易


343
00:22:19,173 --> 00:22:20,607
我们要使用一个后台进程


344
00:22:20,674 --> 00:22:25,712
来发送这一协同运行来确保


345
00:22:25,979 --> 00:22:31,518
我们的操作不会阻塞主线程


346
00:22:32,352 --> 00:22:34,154
幸运的是我们仍然...


347
00:22:34,221 --> 00:22:36,056
因为我们仍然在用这个协同运行


348
00:22:36,623 --> 00:22:40,928
我们就仍然可以在我们的UI
上得到立即更新的显示


349
00:22:40,994 --> 00:22:44,331
这是因为我们的
NSMetadataQuery


350
00:22:44,798 --> 00:22:46,333
仍然是直接更新的


351
00:22:47,234 --> 00:22:49,436
你甚至都不需要把这个信息
弹回给主线程


352
00:22:49,503 --> 00:22:51,405
这是因为我们是在直接更新


353
00:22:51,471 --> 00:22:53,040
NSMetadataQuery


354
00:22:54,374 --> 00:22:59,046
很好 另一个常用的
操作是删除某个文档


355
00:23:00,180 --> 00:23:03,317
对于你的用户来说
这是再正常不过的事


356
00:23:03,383 --> 00:23:05,752
这个文档他们不用了
他们想把这个文档删掉


357
00:23:06,119 --> 00:23:07,688
这样就不会弄乱他们的工作区


358
00:23:08,255 --> 00:23:12,226
删除文档背后的基本理念
仍然是一模一样的


359
00:23:12,926 --> 00:23:17,664
我们会通过我们的后台线程
协调某个写入操作


360
00:23:17,998 --> 00:23:21,902
在本次写入时执行删除操作然后通过
NSMetadataQuery


361
00:23:21,969 --> 00:23:27,040
回送给主线程及时进行更新


362
00:23:29,042 --> 00:23:35,983
很好 你就是这样通过你们的
后台进程对创建删除文档进行管理的


363
00:23:36,984 --> 00:23:42,256
我们来看看你到底想用这些文档干什么


364
00:23:42,956 --> 00:23:45,726
当然你想显示这些文档


365
00:23:46,493 --> 00:23:48,562
也就是说你想读写这些文档


366
00:23:49,396 --> 00:23:52,666
现在我们强烈推荐你使用


367
00:23:52,733 --> 00:23:55,502
UIDocument来读写文档


368
00:23:56,036 --> 00:24:00,841
UIDocument会实现
NSFileCoordination调用


369
00:24:01,008 --> 00:24:03,977
这样可以确保你在任何时候
进行读写文档时


370
00:24:04,044 --> 00:24:06,046
都是以一种协调的方式进行


371
00:24:07,314 --> 00:24:12,119
此外它还会实现
NSFilePresentation


372
00:24:12,319 --> 00:24:13,987
确保会立即通知这个文档发生了变更


373
00:24:14,054 --> 00:24:17,591
可以在你的显示中立即更新了


374
00:24:19,026 --> 00:24:20,928
我们来看看怎样读取一个文档


375
00:24:21,662 --> 00:24:25,332
你创建一个UIDocument对象
然后在这个UIDocument实例中


376
00:24:25,399 --> 00:24:28,302
简单调用这个“完成后打开”方法


377
00:24:29,203 --> 00:24:32,973
这种方法会通过一个后台工作队列


378
00:24:33,674 --> 00:24:35,375
取出一个协调读取


379
00:24:36,510 --> 00:24:40,147
这样你的应用程序就可以保持
完美的性能和响应性


380
00:24:40,981 --> 00:24:44,818
同时你的文档可以对自身进行读入


381
00:24:45,652 --> 00:24:49,523
那么现在你需要做的


382
00:24:49,823 --> 00:24:52,292
就是实现“通过内容载入”这个方法


383
00:24:53,293 --> 00:24:55,662
这种方法会在协调读入中简单调用


384
00:24:55,829 --> 00:24:58,298
因此就被这个协调读入给封装了


385
00:24:58,398 --> 00:25:01,602
这就意味着在那里
读入任何你想要的东西


386
00:25:01,668 --> 00:25:05,305
都是绝对安全的 
请听清楚是来自那个文档


387
00:25:06,139 --> 00:25:09,843
那么你需要做的就是取出内容


388
00:25:09,910 --> 00:25:13,814
然后把它们填入你的文档数据


389
00:25:14,448 --> 00:25:17,885
现在这里还有一种方法


390
00:25:18,118 --> 00:25:20,521
你也可以选择实现这种方法


391
00:25:21,522 --> 00:25:25,893
它会取出一个
NSURL而不是一大堆数据


392
00:25:26,727 --> 00:25:30,430
你也可以把这个方法用于
举例来说流文档


393
00:25:30,497 --> 00:25:34,935
有时候你可能更有理由这么做


394
00:25:35,502 --> 00:25:40,240
这是因为举例来说磁盘上的文档格式
与你在内存中想要的格式完全不同


395
00:25:41,208 --> 00:25:44,778
完成后我们只需要回送给主队列


396
00:25:44,845 --> 00:25:48,815
然后调用你提供给我们的完成块


397
00:25:49,249 --> 00:25:53,620
在那个完成块中你可以举例来说


398
00:25:53,687 --> 00:25:57,491
为你的文档推送更新你的新界面


399
00:26:00,227 --> 00:26:03,397
很好读入一个文档的原理就是这样的


400
00:26:03,897 --> 00:26:06,967
不过别忘了麦克告诉过你们


401
00:26:07,034 --> 00:26:09,036
这个概念叫做“约定”


402
00:26:09,770 --> 00:26:16,109
一项“约定”指的是iCloud 
Drive守护程序允诺给你的app


403
00:26:16,410 --> 00:26:20,681
某个文档就在那里
但是还没有进行下载


404
00:26:21,949 --> 00:26:24,084
这就意味着对这个文档进行读入


405
00:26:24,151 --> 00:26:26,320
就可能会触发一次下载


406
00:26:27,688 --> 00:26:32,025
当然了如果你像我们一样


407
00:26:32,092 --> 00:26:38,165
生活在真实的世界中
很明显下载有时候会很慢


408
00:26:38,465 --> 00:26:41,768
依据你的文档大小下载可能


409
00:26:42,269 --> 00:26:43,370
需要一段时间


410
00:26:43,971 --> 00:26:49,409
你的用户可能把这次下载
归咎于你的app出了问题


411
00:26:49,710 --> 00:26:51,879
这很不公平这不是你的错


412
00:26:52,479 --> 00:26:56,917
本次下载所处的网络连接很慢
需要一点时间


413
00:26:57,684 --> 00:27:02,723
我们在iOS 9中为你准备了一项
新特性我们公开了一种通过


414
00:27:02,789 --> 00:27:05,759
新的
NSProgressReporting协议


415
00:27:06,126 --> 00:27:09,663
在UIDocuments上显示
进度的方法


416
00:27:10,697 --> 00:27:12,633
实现这个非常简单


417
00:27:13,133 --> 00:27:18,639
NSProgressReporting协议在你的
UIDocument实例上公开了一项


418
00:27:19,173 --> 00:27:24,878
进度属性这项进度属性是我们填写的
显示给你我们的进度如何了


419
00:27:25,546 --> 00:27:29,116
基本上这就是下载状态的
一项简单的百分比


420
00:27:30,350 --> 00:27:35,989
我们现在通过一个状态变换
公开了这项NSProgress属性


421
00:27:36,390 --> 00:27:39,993
这样你就可以把它显示为
你在你的文档状态上


422
00:27:40,894 --> 00:27:44,831
监听到的状态变换通知


423
00:27:46,133 --> 00:27:50,304
当状态发生变换时你就可以
看到带有下列内容的新标志


424
00:27:50,571 --> 00:27:53,040
“你好我在这里公开了一条进度”


425
00:27:54,007 --> 00:27:55,809
然后你只要显示这个进度就可以了


426
00:27:56,510 --> 00:28:00,314
举例来说在一个
UIProgress视图上显示一个进度


427
00:28:00,614 --> 00:28:02,449
过去往往比较复杂


428
00:28:02,883 --> 00:28:05,018
这是因为它公开了一项
你需要把值观测键入


429
00:28:05,085 --> 00:28:08,722
这个进度视图的属性


430
00:28:09,389 --> 00:28:13,627
当然我们也意识到了这一点
还是在iOS 9上


431
00:28:13,861 --> 00:28:17,097
我们在UIProgress视图新公
开了一项观测进度属性


432
00:28:17,698 --> 00:28:23,237
你就可以直接把NSProgress
弄到进度视图


433
00:28:23,770 --> 00:28:25,606
你只需要把
NSProgress分配给


434
00:28:25,873 --> 00:28:28,375
进度视图的“观测进度”属性


435
00:28:29,076 --> 00:28:31,879
它就会自动更新它的计数


436
00:28:33,514 --> 00:28:35,048
对你来说这非常方便


437
00:28:38,252 --> 00:28:43,123
谢谢 那么你只需要监听
下次状态变换


438
00:28:43,223 --> 00:28:47,861
监听这样的信号：
“你好我们把这个进度搞完了”


439
00:28:48,729 --> 00:28:53,433
此时你可能想取消显示你的
UIProgress视图


440
00:28:53,834 --> 00:28:57,237
准备显示新的文档控制器


441
00:28:58,872 --> 00:29:01,675
很好 这就是读入文档


442
00:29:01,875 --> 00:29:03,710
当然我们还想写入文档


443
00:29:04,344 --> 00:29:08,048
写入文档和读入文档是对称的


444
00:29:08,715 --> 00:29:12,085
我们写入文档的方式
就是在一条后台进程上


445
00:29:12,152 --> 00:29:15,122
取出一个协调文件的协调性


446
00:29:15,923 --> 00:29:19,526
这个略微有点不同不是由你来启动它


447
00:29:19,993 --> 00:29:23,597
而是由UIDocument
自动通知说现在非常适合


448
00:29:24,164 --> 00:29:27,835
保存文档


449
00:29:28,135 --> 00:29:31,905
比如说因为有一阵没有编辑进来


450
00:29:31,972 --> 00:29:36,543
或者因为文档上次保存后
已经过去了一段时间


451
00:29:37,611 --> 00:29:40,647
或者因为用户把你的
应用程序放到了后台


452
00:29:40,714 --> 00:29:43,450
那么这个时候保存文档就非常合适


453
00:29:44,117 --> 00:29:47,688
不过这种实现方式
和读入一个文档是非常


454
00:29:47,754 --> 00:29:51,091
对称的我们只需要在
你的UIDocument实例上


455
00:29:51,158 --> 00:29:52,759
调用“类型内容”


456
00:29:53,160 --> 00:29:56,830
然后你把你从那里返回的
NSData实例填进去


457
00:29:57,865 --> 00:30:00,534
非常好 这里还有一件事


458
00:30:00,834 --> 00:30:04,004
此时写入一幅缩略图也非常方便


459
00:30:04,771 --> 00:30:08,375
正如麦克告诉你们的
我们会为某些非常特定的文档


460
00:30:08,642 --> 00:30:12,980
格式自动生成缩略图
不过有很大几率你正在构建的东西


461
00:30:13,046 --> 00:30:16,149
和我们正在构建的东西并不完全一致


462
00:30:16,683 --> 00:30:21,421
因此如果你没有使用我们的
非常通用的格式来


463
00:30:21,488 --> 00:30:25,526
进行构建像图像或者简单文本


464
00:30:25,959 --> 00:30:28,896
那么你就想自己写入缩略图


465
00:30:29,930 --> 00:30:32,466
现在你这样实现的方式


466
00:30:32,533 --> 00:30:35,068
我们称之为在
你的UIDocument上


467
00:30:35,135 --> 00:30:37,871
“自行写入文件属性”方法


468
00:30:39,039 --> 00:30:42,676
使用这种方法
你只需要当成你的属性字典的一部分


469
00:30:42,943 --> 00:30:45,078
返回一个UIImage实例


470
00:30:46,280 --> 00:30:48,215
在这个实例中我们会在写入你的文档


471
00:30:49,116 --> 00:30:53,520
包含于同一协调写入上进行写入


472
00:30:54,188 --> 00:30:56,390
这就意味着如果此时用户


473
00:30:56,456 --> 00:31:01,762
在一个单独的窗格中打开了
“文档浏览器”


474
00:31:02,196 --> 00:31:04,331
他们就不会看到不一致的状态


475
00:31:05,098 --> 00:31:10,270
很好 这里重点需要记住的是
这是在一条后台进程上调用的


476
00:31:10,971 --> 00:31:14,007
这就意味着在任何情况下


477
00:31:14,074 --> 00:31:17,678
你都不能用UIViews
来写入...来渲染你的缩略图


478
00:31:18,212 --> 00:31:21,148
UIViews不属于线程安全
因此你需要确保你的缩略图


479
00:31:21,481 --> 00:31:23,717
渲染是通过举例来说


480
00:31:24,218 --> 00:31:28,088
Core Graphics
或者textKit


481
00:31:28,455 --> 00:31:33,060
或者任何其它我们在我们的
平台上提供的线程安全渲染机制来进行


482
00:31:33,293 --> 00:31:38,532
在iOS 8上访问一个文档的
唯一机制是通过一个副本来访问


483
00:31:39,299 --> 00:31:42,169
原因在于一般来说应用程序


484
00:31:42,236 --> 00:31:45,005
不能访问彼此的沙盒


485
00:31:45,372 --> 00:31:48,976
因此如果我们有两个应用程序
沙盒那么从一个沙盒


486
00:31:49,343 --> 00:31:53,380
移动到另一个沙盒的
唯一方式就是第一个应用程序


487
00:31:53,647 --> 00:31:58,151
在另一个应用程序的
沙盒内生成一个副本


488
00:31:58,752 --> 00:32:04,525
现在通过使用UIDocument
菜单视图控制器我们就可以松口气了


489
00:32:04,992 --> 00:32:10,297
它允许你的应用程序
在另一个应用程序的容器内进行拉取


490
00:32:11,131 --> 00:32:15,536
不过一般来说你不会
仅仅打开一个文档就算了


491
00:32:16,203 --> 00:32:19,306
每次打开这个文档都会生成一个副本


492
00:32:20,340 --> 00:32:24,578
当然 处理这些副本就非常方便了


493
00:32:24,711 --> 00:32:27,748
因为你现在其它应用程序的
容器内有一个你的


494
00:32:28,081 --> 00:32:30,584
文档的副本用户会对它进行修改


495
00:32:30,651 --> 00:32:33,220
这样你就会得到这个文档的第二个版本


496
00:32:33,854 --> 00:32:36,590
现在举例来说回到你的应用程序中


497
00:32:36,657 --> 00:32:39,459
用户想打开这个文档


498
00:32:40,160 --> 00:32:42,763
这样就会生成第三个副本


499
00:32:43,197 --> 00:32:46,700
现在漂浮着的
你有文档的三个不同的版本


500
00:32:47,401 --> 00:32:50,504
这很不幸因为用户会感到困惑不解


501
00:32:50,938 --> 00:32:52,873
不知道哪个版本是最近的版本


502
00:32:54,308 --> 00:32:56,710
这种情况可不太妙


503
00:32:57,945 --> 00:33:00,681
现在在iOS 9中
我们有了这个漂亮的新机制


504
00:33:00,747 --> 00:33:01,949
叫做“就地打开”


505
00:33:03,150 --> 00:33:05,853
这意味着通过使用文档交互控制器


506
00:33:05,986 --> 00:33:08,255
你的应用程序可以授予另一个应用程序


507
00:33:08,856 --> 00:33:14,561
访问一个文档的权限


508
00:33:15,896 --> 00:33:18,599
文档还是一模一样的


509
00:33:18,665 --> 00:33:22,436
这不是一个副本
而是对这个文档的一个副本


510
00:33:23,670 --> 00:33:27,975
当然了这就意味着
另一个应用程序就可以进行编辑


511
00:33:28,308 --> 00:33:30,611
然后通过展示文件这一魔法


512
00:33:30,677 --> 00:33:34,414
直接反射到你的应用程序中


513
00:33:36,116 --> 00:33:38,552
当然了这对用户来说就非常方便


514
00:33:39,119 --> 00:33:42,389
这包括通过iCloud Drive
app以及通过Spotlight


515
00:33:42,689 --> 00:33:43,557
打开的文件


516
00:33:44,491 --> 00:33:48,729
这就意味着你的用户任何时候在
iCloud Drive app中


517
00:33:48,996 --> 00:33:55,068
浏览他们的文档时我们就可以直接
就地打开那个文档


518
00:33:56,703 --> 00:33:59,139
这个背后的机制
和“文档菜单视图控制器”


519
00:33:59,206 --> 00:34:01,909
中使用的机制非常相似


520
00:34:02,476 --> 00:34:05,012
这就意味着如果你的应用程序
已经对此提供支持了


521
00:34:05,679 --> 00:34:08,315
那么对你来说支持这种机制
就不费吹灰之力


522
00:34:09,315 --> 00:34:12,619
即使你现在不支持
UIMenuViewController


523
00:34:12,686 --> 00:34:15,255
采用这种机制也不费吹灰之力


524
00:34:15,322 --> 00:34:18,659
因为这并不是多么神奇的东西


525
00:34:18,725 --> 00:34:20,226
你获得一个URL后


526
00:34:20,494 --> 00:34:23,597
就把它放入你稍后将要展示的
一个UIDocument实例中 


527
00:34:24,697 --> 00:34:28,135
我们现在来快速看看
你怎样可以对此提供支持


528
00:34:29,969 --> 00:34:31,271
就像我之前说的非常简单


529
00:34:31,871 --> 00:34:33,907
首先你要告诉我们你对此提供支持了


530
00:34:34,574 --> 00:34:36,143
记住当我们试图找出我们是否要


531
00:34:36,210 --> 00:34:41,614
就地打开这个文件时
你的app可能在那时并不会启动


532
00:34:42,149 --> 00:34:43,617
因此你要事先告诉我们


533
00:34:44,284 --> 00:34:48,621
你需要在你的Info.plist中
采用“LS支持就地打开文档”


534
00:34:48,688 --> 00:34:50,791
这个键来告知我们


535
00:34:51,190 --> 00:34:53,159
根据你用的是Objective-C
还是Swift不同


536
00:34:53,226 --> 00:34:55,295
你只需要把它设置成
为“是”或者“真”即可


537
00:34:55,996 --> 00:35:02,336
这样就可以告诉我们
你的应用程序可以处理这个了


538
00:35:03,136 --> 00:35:05,873
你还需要再写一点代码


539
00:35:06,540 --> 00:35:09,109
是一种新的委托方法


540
00:35:10,177 --> 00:35:11,078
那个看起来怎么样？


541
00:35:11,678 --> 00:35:15,015
假如说你已经在这里打开了文档


542
00:35:15,649 --> 00:35:18,919
这样假设很合理这是因为
你的app是基于文档的


543
00:35:19,353 --> 00:35:23,757
因此你实现的方法
肯定就和我们在这里看到的非常类似


544
00:35:24,591 --> 00:35:28,262
现在你的方法肯定
得到了一个NSURL


545
00:35:29,129 --> 00:35:32,332
因为这个NSURL是
系统为你的app创建的


546
00:35:32,399 --> 00:35:35,602
临时副本你就需要把这个副本复制到


547
00:35:36,670 --> 00:35:40,674
你自己的容器然后打开这个复制文件


548
00:35:41,642 --> 00:35:46,313
这一小块代码的作用就是这个


549
00:35:46,880 --> 00:35:49,449
现在首先要做的
是在这里采用我们的新方法


550
00:35:50,250 --> 00:35:53,320
这种新方法和旧方法非常相似


551
00:35:53,854 --> 00:35:56,423
它只是取得了一本选项字典


552
00:35:57,157 --> 00:36:01,295
对之前的方法的参数进行封装


553
00:36:01,929 --> 00:36:05,832
重要的是其中的一个参数是
“就地打开”键


554
00:36:07,067 --> 00:36:11,672
现在你要做的，
就是看看这个“就地打开”键


555
00:36:12,039 --> 00:36:13,607
是否为真如果这个键为真


556
00:36:14,741 --> 00:36:18,445
那么你的应用程序应该就可以
就地打开这个文件了


557
00:36:18,812 --> 00:36:20,848
这就意味着它不应该生成副本


558
00:36:21,648 --> 00:36:24,585
很简单你不应该再做
你之前不得不做的事了


559
00:36:26,119 --> 00:36:29,089
现在你有了这个URL


560
00:36:29,523 --> 00:36:34,194
你只需要照着之前的打开方式
打开它就可以了


561
00:36:36,196 --> 00:36:38,665
支持就地打开就是这么简单


562
00:36:40,467 --> 00:36:43,003
很好 我们来总结下今天学到的东西


563
00:36:43,904 --> 00:36:47,341
我们已经看过了怎样让你的app
性能响应性很高


564
00:36:47,407 --> 00:36:53,247
看过了使用NSMetadataQuery
来展示一组文档并且当云端


565
00:36:53,313 --> 00:36:58,118
有变更发生时及时更新这些文档


566
00:36:58,218 --> 00:36:59,753
这种方法有多么漂亮


567
00:37:00,587 --> 00:37:04,258
我们还看到了怎样使用
书签来实现最近访问机制


568
00:37:04,892 --> 00:37:07,294
这样你的用户就可以很快返回


569
00:37:07,427 --> 00:37:09,897
他们之前的状态...
他们之前所处的文档


570
00:37:10,631 --> 00:37:12,733
当然有些事情我们没有说


571
00:37:12,799 --> 00:37:14,468
但是也非常合理


572
00:37:14,668 --> 00:37:17,204
即你也可以使用书签来实现状态恢复


573
00:37:17,704 --> 00:37:21,742
这样你的用户就可以直接返回
他们之前所处的状态


574
00:37:22,809 --> 00:37:26,180
我们还看到了怎样使用缩略图
让你的应用程序非常美观


575
00:37:26,547 --> 00:37:30,350
看到了怎样实现进度显示
确保你的用户


576
00:37:30,417 --> 00:37:33,253
始终清楚在他们的
应用程序内发生了什么


577
00:37:34,121 --> 00:37:37,491
最后我们也看到了实现
就地打开有多么容易


578
00:37:38,125 --> 00:37:41,461
就地打开是个很棒的新机制
你的用户就可以直接在


579
00:37:41,762 --> 00:37:45,632
你的应用程序内打开文档


580
00:37:46,166 --> 00:37:49,036
而不用复制多份副本


581
00:37:50,470 --> 00:37:54,942
我们今天发布的一个示例代码
对所有的这些概念


582
00:37:55,008 --> 00:37:57,144
都做了一个漂亮的展示


583
00:37:57,744 --> 00:37:59,813
这个示例代码实际上
就是麦克之前在演示中


584
00:37:59,880 --> 00:38:01,415
向你们演示的那个


585
00:38:01,915 --> 00:38:03,684
它实现了所有的这些特征特性


586
00:38:04,151 --> 00:38:07,120
即在一个“文档浏览器”中创建文档


587
00:38:08,155 --> 00:38:13,360
展示文档生成这些文档的变更动画


588
00:38:13,827 --> 00:38:18,098
当然还有写入缩略图当然还有就地打开


589
00:38:19,066 --> 00:38:22,703
如果你需要获得技术支持
我们建议你去我们的论坛


590
00:38:23,737 --> 00:38:27,341
你可以看到在这个链接下面
我们也有很棒的资料


591
00:38:28,242 --> 00:38:32,145
如果你想了解关于使用
“UIDocument菜单视图控制器”


592
00:38:32,212 --> 00:38:33,447
的更多信息


593
00:38:33,981 --> 00:38:39,386
来实现拉取机制，
而不是就地打开工具的拉取机制


594
00:38:39,887 --> 00:38:45,359
这样你的应用程序就可以
从另一个应用程序的容器内拉取文档


595
00:38:45,893 --> 00:38:50,197
或者你对如何实现基于UIDocument
的应用程序略感兴趣


596
00:38:50,664 --> 00:38:53,267
我们建议你观看我们去年的会议


597
00:38:54,101 --> 00:38:57,004
即去年的会议234


598
00:38:57,604 --> 00:38:59,273
当然你在网上也找得到


599
00:39:00,040 --> 00:39:01,608
那么谢谢你抽出时间参会


600
00:39:01,875 --> 00:39:03,210
祝你下午过得愉快

