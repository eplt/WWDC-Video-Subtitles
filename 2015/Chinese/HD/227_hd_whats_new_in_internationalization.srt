1
00:00:19,987 --> 00:00:21,221
奈特·希拉德：早上好 各位 


2
00:00:24,625 --> 00:00:26,660
早上好 或者我该说 “早安”


3
00:00:27,027 --> 00:00:28,929
“美好的一天”“早上好”


4
00:00:29,162 --> 00:00:30,230
我叫奈特·希拉德


5
00:00:30,664 --> 00:00:33,500
今天我会再次介绍国际化应用的新特性


6
00:00:34,101 --> 00:00:36,170
我会再次介绍我们之前
介绍过的新的API


7
00:00:36,270 --> 00:00:39,139
以及对当前API所做的改进 


8
00:00:39,206 --> 00:00:41,808
让你的APP可以在全世界范围使用


9
00:00:42,910 --> 00:00:45,279
首先 这是地球


10
00:00:46,146 --> 00:00:48,515
有超过70亿人在地球上


11
00:00:49,116 --> 00:00:51,451
对于这70亿人 苹果已经卖出了


12
00:00:51,518 --> 00:00:54,555
超过10亿台iOS设备


13
00:00:54,988 --> 00:00:56,790
而且 Mac OS X
的安装数量


14
00:00:56,857 --> 00:00:58,525
达到800万台


15
00:00:59,126 --> 00:01:02,963
我们在全世界有超过450家实体店


16
00:01:03,530 --> 00:01:06,767
还有140万个以上的APP


17
00:01:07,234 --> 00:01:09,102
不断被全球范围内的开发者


18
00:01:09,503 --> 00:01:11,104
和用户所使用着


19
00:01:12,105 --> 00:01:16,043
这是一个惊人的数字但如果今天在现场


20
00:01:16,109 --> 00:01:18,045
只需要一个数字 那么是这个


21
00:01:19,313 --> 00:01:24,518
69% 现在苹果69%的
收益来自于国际市场


22
00:01:24,852 --> 00:01:26,286
现在这份收益是很大的


23
00:01:26,353 --> 00:01:28,121
展望一下 我们来看个图表


24
00:01:28,822 --> 00:01:31,825
苹果现在的收益超过二分之三来自于


25
00:01:31,892 --> 00:01:33,193
美国之外的地方


26
00:01:33,660 --> 00:01:35,295
这些用户对于


27
00:01:35,362 --> 00:01:37,397
APP的使用有着不同的期待


28
00:01:37,764 --> 00:01:39,600
包括语言的不同


29
00:01:39,666 --> 00:01:42,703
地区的不同 和文化的不同
这些你要记在脑子里


30
00:01:43,203 --> 00:01:44,938
现在 我们一起细说


31
00:01:46,373 --> 00:01:49,409
有趣的是 这里 我们41%


32
00:01:49,476 --> 00:01:51,478
的用户来自中国和日本


33
00:01:52,346 --> 00:01:53,780
现在 我想这里有个常见误会


34
00:01:53,847 --> 00:01:56,350
国际化你的APP
意味着要打入欧洲市场


35
00:01:56,984 --> 00:02:00,087
事实上 这点很重要


36
00:02:00,153 --> 00:02:01,955
但你还要谨记中国和日本


37
00:02:02,322 --> 00:02:04,124
用户方面的挑战


38
00:02:04,958 --> 00:02:07,494
也就是 他们不使用字母文字


39
00:02:07,961 --> 00:02:09,630
没有字之间没有空格


40
00:02:10,030 --> 00:02:14,701
而且 除此之外 
UI上日文和中文会变的很短


41
00:02:15,435 --> 00:02:18,705
因此 好消息是
如果你使用我们的API


42
00:02:19,606 --> 00:02:21,808
我们能够快速地
对你的APP进行国际化


43
00:02:22,809 --> 00:02:25,145
所以 今天我们会在谈起四个 


44
00:02:25,212 --> 00:02:28,715
你必须考虑的四大块领域：
本地化 格式化


45
00:02:29,049 --> 00:02:30,384
信息处理和布局设计


46
00:02:31,318 --> 00:02:35,622
那首先 说说本土化


47
00:02:36,757 --> 00:02:38,425
现在 通过本土化 我是指


48
00:02:38,492 --> 00:02:40,761
让你的APP使用用户的语言


49
00:02:41,361 --> 00:02:44,631
字面上而言就是翻译UI文字  


50
00:02:44,932 --> 00:02:46,099
进一步而言


51
00:02:46,533 --> 00:02:49,503
就是翻译出文字背后你所要表达的观念


52
00:02:50,537 --> 00:02:52,906
所以 从这点开始比较如容易入手 


53
00:02:52,973 --> 00:02:56,844
观察用户如何操作系统


54
00:02:58,312 --> 00:03:01,148
左边我们有OS X系统
右边是iOS系统


55
00:03:01,415 --> 00:03:03,050
这里有语言和地区面板


56
00:03:03,617 --> 00:03:06,253
在左手边这里 在OS X截图上


57
00:03:06,320 --> 00:03:07,788
你会看到首选语言列表


58
00:03:08,388 --> 00:03:11,124
事实上 这里很重要的是
这是个有序的语言列表


59
00:03:11,592 --> 00:03:13,560
用户可以添加多种语言 并且  


60
00:03:13,627 --> 00:03:16,430
如果设定语言无法用于UI的话


61
00:03:17,097 --> 00:03:18,866
系统会自动选择下一种语言


62
00:03:19,766 --> 00:03:23,237
例如 用户已经选了
瑞士德语作为主要语言


63
00:03:23,670 --> 00:03:26,139
但实际上我们没有添加瑞士德语


64
00:03:26,573 --> 00:03:28,675
因此对于这个UI它会变回英文界面


65
00:03:29,276 --> 00:03:30,978
这个恢复设置事实上很普遍


66
00:03:31,044 --> 00:03:33,247
所以你要从开发者的视角对此进行思考


67
00:03:33,981 --> 00:03:35,549
此外    


68
00:03:35,616 --> 00:03:37,251
对于APP所显示的语言


69
00:03:37,851 --> 00:03:39,553
我们有额外的地域优先


70
00:03:40,787 --> 00:03:42,389
右边的OS X系统是默认关闭的


71
00:03:42,689 --> 00:03:44,591
而iOS系统中要进入下一级才能设置


72
00:03:45,526 --> 00:03:48,195
现在事实上这些会应用于相关单元  


73
00:03:48,762 --> 00:03:52,533
用于显示特定地区时间 日程数据


74
00:03:55,335 --> 00:03:59,406
所以说 对于目标语言


75
00:03:59,673 --> 00:04:02,576
把你想翻出来的
背后含义翻译出来并不容易


76
00:04:03,577 --> 00:04:05,546
对于更多关于


77
00:04:05,612 --> 00:04:07,915
优先语言和区域设置的差别


78
00:04:08,549 --> 00:04:11,418
请看去年的讲演 "国际化高级议题"


79
00:04:11,852 --> 00:04:13,120
那有更多相关细节


80
00:04:14,188 --> 00:04:16,822
所以 我们提供了
更多原来没有的设置  


81
00:04:16,890 --> 00:04:19,226
如果用户有个人喜好


82
00:04:19,358 --> 00:04:21,028
但我们也允许用户进行自定义设置


83
00:04:21,695 --> 00:04:23,997
iOS9系统和El Capitan
系统新的地方 


84
00:04:24,331 --> 00:04:26,266
是我们可以自定义数字系统


85
00:04:27,734 --> 00:04:28,569
正如你在这看到的


86
00:04:29,236 --> 00:04:31,805
假设我们有个用户是讲乌尔都语的


87
00:04:32,406 --> 00:04:34,474
他们选择了乌尔都语
作为他们的首要语言


88
00:04:34,541 --> 00:04:36,410
那么系统会恢复到


89
00:04:37,578 --> 00:04:40,480
我们操作系统所显示的语言 英语


90
00:04:41,849 --> 00:04:45,953
默认情况下 
用户会看到标准的阿拉伯数字


91
00:04:48,088 --> 00:04:52,960
虽然我们允许在iOS 9、OS X
和 El Capitan系统中


92
00:04:53,026 --> 00:04:56,096
自定义这些设置
来取代已有的数字系统


93
00:04:56,730 --> 00:04:59,833
很多人没有意识到的是
全球有很多种类的数字系统


94
00:05:00,434 --> 00:05:02,035 position:10%
最上面有阿拉伯语数字


95
00:05:02,102 --> 00:05:04,738
还有波斯-阿拉伯数字


96
00:05:04,805 --> 00:05:06,039
常在中东地区使用


97
00:05:06,640 --> 00:05:08,075
所以用户可以选择这种设置  


98
00:05:08,475 --> 00:05:10,811
在整个操作系统中会有很有趣的变化


99
00:05:11,778 --> 00:05:13,514
例如 我们有天气APP


100
00:05:13,780 --> 00:05:16,783
现在由于开发者还未此进行任何修改 


101
00:05:17,251 --> 00:05:19,720
但是我们称之为“本地化格式字符”


102
00:05:20,187 --> 00:05:21,922
或者是NS数字格式器的API


103
00:05:22,489 --> 00:05:24,992
已经可以免费改变数字系统了


104
00:05:25,626 --> 00:05:27,895
在左边 我们有使用阿拉伯数字的用户


105
00:05:28,195 --> 00:05:30,097
在右边 我们有
波斯-阿拉伯数字的用户


106
00:05:30,797 --> 00:05:34,601
我们发现他们每一位的数符
在UI上都改变了


107
00:05:35,702 --> 00:05:38,105
包括屏幕上方的时间标记


108
00:05:39,406 --> 00:05:41,909
对于一个研发人而言 这很有趣 


109
00:05:42,176 --> 00:05:44,878
我们称之为
“本地化格式字符”这是免费的


110
00:05:45,879 --> 00:05:49,583
现在 除了用户在屏幕上看的语言外


111
00:05:49,983 --> 00:05:52,553
用户还会在你的应用上输入文本


112
00:05:54,054 --> 00:05:57,991
在新iOS9系统里我们为
印度语系语言添加五种新键盘


113
00:05:59,026 --> 00:06:01,094
在右边 这里 
你看到泰卢固语输入键盘 


114
00:06:02,029 --> 00:06:04,598
而且 现在我们可以为四种语言


115
00:06:04,665 --> 00:06:06,700
进行输入预测 包括韩语


116
00:06:06,834 --> 00:06:08,602
墨西哥西班牙语 俄语和土耳其语


117
00:06:09,603 --> 00:06:11,939
现在 从开发者的视角而言


118
00:06:12,206 --> 00:06:16,176
我们发现通常这些字符并不是
我们通常意义上的字符


119
00:06:16,710 --> 00:06:19,179
在泰卢固语输入键盘
这里我们加入了标记字符 


120
00:06:19,446 --> 00:06:22,683
实际上 还有别的字符
才能输入一个可识别单元


121
00:06:23,584 --> 00:06:24,751
再往深一点说


122
00:06:26,220 --> 00:06:30,591
所以现在我们已经看过了
用户如何在你的操作系统改变设置


123
00:06:31,091 --> 00:06:34,795
但本地化工具如何
把字符翻译成用户看到的字符呢？


124
00:06:35,829 --> 00:06:39,533
本地化工具主页面是字符串文件


125
00:06:40,234 --> 00:06:42,002
字符串文有自己的格式


126
00:06:42,436 --> 00:06:45,405
首先有注释 是c语言的注释语法  


127
00:06:45,772 --> 00:06:49,009
其次是左侧的开发语言


128
00:06:49,276 --> 00:06:50,477
目标语言在右侧


129
00:06:51,044 --> 00:06:53,046
我们这里有德文字符文件  


130
00:06:54,681 --> 00:06:57,651
字符文件储存在lproj目录文件包


131
00:06:58,352 --> 00:06:59,553
在资源目录下


132
00:07:00,187 --> 00:07:03,590
英语有自己的字符文件包 
同样的德语也有 


133
00:07:04,424 --> 00:07:08,495
我们自从
XCode 6系统就允许你们


134
00:07:08,762 --> 00:07:12,132
输出本地化设置
一般是XLIFF文件格式


135
00:07:12,766 --> 00:07:15,536
然后可以以字符文件
重新输入到你的项目中


136
00:07:16,036 --> 00:07:17,604
关于这其中更多的信息


137
00:07:17,905 --> 00:07:19,439
我建议你们去看上一年的讲演


138
00:07:19,506 --> 00:07:21,108
"XCode 6本地化"


139
00:07:22,476 --> 00:07:24,945
所以 我们已经看过了
用户是如何改变设定的


140
00:07:25,512 --> 00:07:27,915
我们已经看过了本地化工具


141
00:07:28,182 --> 00:07:30,184
如何把你屏幕上的字符翻译成你想要的


142
00:07:30,350 --> 00:07:32,352
但是  作为一名开发者
你如何利用这些设置呢？


143
00:07:34,054 --> 00:07:34,888
这正是...


144
00:07:34,955 --> 00:07:36,924
NSLocalizedString
的功能


145
00:07:36,990 --> 00:07:39,026
在Objective-C
这是项庞大的工作


146
00:07:39,493 --> 00:07:42,262 position:10%
在Swift上 
我们将其开发成高级功能


147
00:07:42,329 --> 00:07:45,232
它需要五个参数
其中三个是有默认值的  


148
00:07:45,766 --> 00:07:47,301
有趣的是 在Swift中


149
00:07:47,367 --> 00:07:49,837
我们做到了 
其实设置评注这是无奈之举


150
00:07:50,604 --> 00:07:53,040
我们这是要强调这是重要因素


151
00:07:53,106 --> 00:07:54,975
它能够为你的翻译器提供上下文


152
00:07:55,676 --> 00:07:58,412
在某些情况下给定单词
可能是模棱两可的


153
00:07:58,478 --> 00:08:01,748
这个注释参数会帮助你进行自定义


154
00:08:02,983 --> 00:08:04,852
所以 重点是你想要翻译的字符 


155
00:08:05,252 --> 00:08:07,254
注释是来注释解释它的


156
00:08:07,888 --> 00:08:09,890
现在 对本土化字符是起了 


157
00:08:09,957 --> 00:08:12,960
除此在外 我们也允许你
可以获得本地化格式字符串


158
00:08:13,427 --> 00:08:16,129
也就是说可以
填入带有变量参数的字符串


159
00:08:16,964 --> 00:08:19,132
所以 你可以称之为本地化格式字符串


160
00:08:19,700 --> 00:08:23,637
带有特定格式的格式字符串


161
00:08:23,971 --> 00:08:26,573
可以填入到有
参数变量的格式字符串之中


162
00:08:27,808 --> 00:08:29,943
而且事实上结合使用更为常见


163
00:08:30,177 --> 00:08:32,513
根据NSLocalized-
String的叫法


164
00:08:32,578 --> 00:08:34,448
我们称之为“本地化格式字符串”


165
00:08:36,049 --> 00:08:37,518
现在 看看它的应用如何


166
00:08:37,951 --> 00:08:39,720
做一个简短的演示可能助理解


167
00:08:42,990 --> 00:08:46,460
假设我们希望翻译的字符的位置是：X


168
00:08:47,060 --> 00:08:49,329 position:10%
现在 也假设我们有一个变量位置


169
00:08:49,396 --> 00:08:50,964
且已经被翻译器植入到


170
00:08:51,198 --> 00:08:52,766
用户的实际位置


171
00:08:54,101 --> 00:08:55,502
这就是字符串文件的样子


172
00:08:56,069 --> 00:08:58,372
左手边是等待被翻译的字符串


173
00:08:58,438 --> 00:09:00,040
右手边是翻译好的变量


174
00:09:01,141 --> 00:09:04,011
事实上我们会发现
翻译好的变量仍然存在变量字符串


175
00:09:04,511 --> 00:09:06,547
百分比添加意味着填充字符串变量


176
00:09:07,781 --> 00:09:11,285
因此 这是在英语工环境下的
我们定位在旧金山


177
00:09:11,752 --> 00:09:12,886
也同样在日语环境下生效


178
00:09:13,187 --> 00:09:14,188
这就是等效字符串


179
00:09:15,522 --> 00:09:17,424
因此 你知道了这些之后


180
00:09:18,225 --> 00:09:20,327
你脑中可能会出现一些假设


181
00:09:21,195 --> 00:09:24,631
其中一个是 本地化格式字符串的顺序


182
00:09:25,032 --> 00:09:27,067
应该会与英文版的相同


183
00:09:27,901 --> 00:09:29,369
现在我们会看看为什么不是这样


184
00:09:30,070 --> 00:09:32,573
我们根据NSLocalized-
String结果


185
00:09:32,639 --> 00:09:33,907
调动本地化格式字符串


186
00:09:34,441 --> 00:09:36,810
我们想要翻译
字符串 “copy X is Y”


187
00:09:37,211 --> 00:09:39,646
这里的X是用户名
Y是我们想要复制的东西


188
00:09:40,447 --> 00:09:42,182
这里 我们通过
hairForce1


189
00:09:42,316 --> 00:09:45,152
这是克雷格·费德里吉选择
InstaMessage进行处理


190
00:09:45,285 --> 00:09:46,119
以及“照片”


191
00:09:46,620 --> 00:09:49,156
在我们的Iproj中
在不同的Iproj中的


192
00:09:49,223 --> 00:09:52,125
字符串文件中开发者可以假设


193
00:09:52,192 --> 00:09:53,927
参数将以同样的顺序出现


194
00:09:54,761 --> 00:09:55,896
这可能对英语环境奏效


195
00:09:56,597 --> 00:09:57,931
而事实上对德语无效


196
00:09:59,166 --> 00:10:02,169
这些参数需要转化成
德语中有意义的顺序


197
00:10:02,903 --> 00:10:05,005
因此 这里就是定位器生效位置


198
00:10:05,405 --> 00:10:07,474
以及可以添加位置格式参数的位置


199
00:10:07,741 --> 00:10:09,643
这就使得原先的第二个参数


200
00:10:09,710 --> 00:10:11,245
变为第一个反之亦然


201
00:10:12,145 --> 00:10:16,984
因此 接着 开发者
并不需要做任何事情


202
00:10:17,117 --> 00:10:20,254
他们调用 本地化格式字符串 以及
NSLocalizedString


203
00:10:20,320 --> 00:10:23,690
但是 重要的是要牢记
从开发者角度而言


204
00:10:24,157 --> 00:10:26,660
你认为的第一个字符也许并不是第一个


205
00:10:27,194 --> 00:10:31,365
因此 假如你设定
操作会以相同的顺序执行


206
00:10:31,665 --> 00:10:33,267
那么你可能需要重新考虑这个假设


207
00:10:34,902 --> 00:10:38,372
因此 现在我们知道
字符串文件是如何存储


208
00:10:38,639 --> 00:10:39,907
以及存储在哪个目录下


209
00:10:40,607 --> 00:10:44,378
但至此你可能会尝试做如下的事情


210
00:10:45,279 --> 00:10:49,016
你将语言变量设置为
你所选择的语言队列的第一对象


211
00:10:49,516 --> 00:10:52,753
这与我们之前看到的UI元素
即首选语言列表相一致


212
00:10:53,453 --> 00:10:56,990
再者 你将后缀Iproj添加于此 


213
00:10:57,324 --> 00:10:58,725
并调用资源通道


214
00:10:58,959 --> 00:11:02,863
假设我们想要
本地化一个停止符号图形


215
00:11:04,798 --> 00:11:08,235
因此 我们在这里假设
我们的单独文件包只有唯一一个


216
00:11:08,302 --> 00:11:10,370
对应西班牙语的es.lproj


217
00:11:11,004 --> 00:11:13,640
但是我们假设我们
用户的首选语言是墨西哥西班牙语


218
00:11:14,308 --> 00:11:17,845
运用这种特定的方法
用户将不会得到任何反馈


219
00:11:18,579 --> 00:11:19,646
为什么会这样


220
00:11:20,113 --> 00:11:23,350 position:10%
那是因为我们没有运用标准的
NSBundle API


221
00:11:23,851 --> 00:11:26,386
如果NSBundle不可用
系统将自动


222
00:11:26,753 --> 00:11:29,957
退回到可执行位置


223
00:11:30,257 --> 00:11:32,492
因此es-MX将会退回到es


224
00:11:33,193 --> 00:11:35,662
另外 我们还有其它智能的回退逻辑


225
00:11:35,729 --> 00:11:39,733
例如从印度英语 回退到英式英语 


226
00:11:40,801 --> 00:11:42,202
即在英国使用英语


227
00:11:42,970 --> 00:11:46,773
因此 假如你使用这些API


228
00:11:47,407 --> 00:11:49,776
你会得到合适的资源


229
00:11:50,177 --> 00:11:51,345
以及回退


230
00:11:51,645 --> 00:11:53,180
“资源图像”会给你图像提示


231
00:11:53,680 --> 00:11:55,749
“完整资源路径”会给你完整的资源


232
00:11:55,816 --> 00:11:57,417
‘URL资源’会给你


233
00:11:57,851 --> 00:12:00,187
任何其他既定的文件格式


234
00:12:01,522 --> 00:12:03,657
因此 我们可以看到 运用


235
00:12:03,724 --> 00:12:06,560
NSBundle API可以使你
更容易地找到你感兴趣的资源


236
00:12:07,427 --> 00:12:12,499
另外 然而你可能会认为
有些东西只能通过代码实现


237
00:12:13,567 --> 00:12:15,269
现在 你们当中有多少人
会写这样的代码


238
00:12:15,702 --> 00:12:19,173
比 你想要翻译字符串“还剩下X天”


239
00:12:19,806 --> 00:12:22,142
我们知道在英语中如果只有一天


240
00:12:22,442 --> 00:12:24,611
我们会用还剩下X天  如果是两天


241
00:12:24,678 --> 00:12:26,580
或以上 我们用“还有多天”


242
00:12:27,347 --> 00:12:28,749
这适用于英语


243
00:12:28,882 --> 00:12:30,551
适用于一天和五天


244
00:12:31,051 --> 00:12:33,720
但对于其它语言而言复数形式方面


245
00:12:34,121 --> 00:12:37,057
不具有同样的逻辑
假设一个给定的数字


246
00:12:37,758 --> 00:12:40,994
例如在俄语中对于单独一个 


247
00:12:41,061 --> 00:12:43,997
我们有一种形式同样对于少数 许多


248
00:12:44,298 --> 00:12:45,332
以及更多 也有一种形式


249
00:12:46,233 --> 00:12:48,702
因此 这并不适用于


250
00:12:48,769 --> 00:12:50,571
不同复数规则的语言


251
00:12:50,637 --> 00:12:51,939
为了帮助你更好地了解此问题


252
00:12:52,439 --> 00:12:53,941
我们提供了复数规则


253
00:12:54,374 --> 00:12:55,742
出现已经有好几个版本


254
00:12:56,109 --> 00:12:57,477
但需要强调的是...


255
00:12:58,579 --> 00:13:00,480
字符串stick文件本质上是


256
00:13:00,948 --> 00:13:03,050
你存储在项目中的一个plist文件


257
00:13:03,483 --> 00:13:04,618
它是一个本地化资源


258
00:13:04,685 --> 00:13:06,553
因此 它位于特定定位


259
00:13:07,054 --> 00:13:08,322
Iproj目录之下


260
00:13:09,022 --> 00:13:10,691
同样 你也有一个给定的密匙


261
00:13:10,924 --> 00:13:12,926
该密匙链接了数字参数


262
00:13:13,293 --> 00:13:16,797
取决于与不同的数字参数
就会产生不同的成果


263
00:13:17,497 --> 00:13:21,535
我发现这里有很多文本
尤其是当你在这里添加俄语组件的时候


264
00:13:23,537 --> 00:13:27,207
这就是说 你知道
英语中对一个有一种形式


265
00:13:27,341 --> 00:13:29,910
对其它则有另一种形式然而 俄语中


266
00:13:29,977 --> 00:13:31,912
一个 少数 许多
以及其它分别有它的各自形式


267
00:13:32,246 --> 00:13:34,748 position:10%
现在 当你要格式化
stick文件的时候


268
00:13:34,815 --> 00:13:37,184
我奉劝你查看一下
“国际化和本地化指南”


269
00:13:37,584 --> 00:13:39,520
这涉及到许多我们没有在这里


270
00:13:40,220 --> 00:13:42,322
提出来的细节 
例如如何格式化 如何创建文件夹


271
00:13:43,423 --> 00:13:47,060
因此 从开发者的
角度来说非常容易上手


272
00:13:47,961 --> 00:13:50,030
再次说明 我们调用的是
“本地化格式字符串”


273
00:13:50,097 --> 00:13:52,266
是基于NSLocalized-
String的结果


274
00:13:52,332 --> 00:13:55,135
你传输的字符串就是
字符串string词典的密匙


275
00:13:56,103 --> 00:13:59,339 position:10%
然后你传输一个数字参数


276
00:13:59,406 --> 00:14:03,877
填充到返回的格式化字符串变量中


277
00:14:05,112 --> 00:14:07,748
因此无论是对于英语
还是俄语中的一天 两天


278
00:14:07,814 --> 00:14:09,816
五天 都是正确的


279
00:14:10,184 --> 00:14:12,986
在这里我们会发现俄语中的两天
和五天是不一样的


280
00:14:14,721 --> 00:14:16,857
让我们再多谈谈字符串stick


281
00:14:17,691 --> 00:14:19,259
我们在iOS 9中有新的机制


282
00:14:20,794 --> 00:14:24,097
可以让你在屏幕上
利用字符串stick来格式化字符串


283
00:14:25,766 --> 00:14:28,335
应当说这同样
存在于EI Capitan系统中


284
00:14:28,402 --> 00:14:31,171
首先 让我们一个普遍的问题


285
00:14:31,772 --> 00:14:34,174
在你的Interface-
Builder应用里


286
00:14:34,241 --> 00:14:36,643
你设置了出现在你屏幕中央的字符
串 “欢迎来到商店”


287
00:14:37,377 --> 00:14:38,912
这可能会在iPad Air中奏效


288
00:14:40,681 --> 00:14:43,183
但它不一定也会在
IPhone 6 里奏效


289
00:14:43,350 --> 00:14:45,552
甚至在IPodTouch效果更糟


290
00:14:45,886 --> 00:14:49,323
解决这个问题的一个办法是
运用自动布局以及特定限制


291
00:14:49,389 --> 00:14:51,892
这常常是解决这类问题的办法
我们晚一点会深究这个问题


292
00:14:52,326 --> 00:14:54,928
但事实上 另一个
解决这个问题的办法是


293
00:14:54,995 --> 00:14:58,465
运用新的“可变宽度规则类型”机制


294
00:14:59,132 --> 00:15:01,001 position:10%
这指的是在字符串
stick内添加条目


295
00:15:01,268 --> 00:15:03,103
这样可以根据可用空间的大小


296
00:15:03,170 --> 00:15:05,305
而产生不同的效果


297
00:15:06,139 --> 00:15:09,743
在iOS上 这是指可用屏幕宽度M 


298
00:15:10,143 --> 00:15:12,779
这指的是标准系统字体中


299
00:15:12,846 --> 00:15:13,914
大写字母M的可见宽度


300
00:15:14,715 --> 00:15:16,583
在这里我们要公布三种不同的尺寸


301
00:15:17,084 --> 00:15:19,119
我们定义如果有20M可用


302
00:15:19,553 --> 00:15:21,622
我们就将字符串显示为“你好”


303
00:15:22,155 --> 00:15:23,557
如果是25 为“欢迎”


304
00:15:23,757 --> 00:15:25,392
如果是50 则为“欢迎来到商店”


305
00:15:26,760 --> 00:15:28,829
对于开发者来说这么使用相当容易


306
00:15:29,196 --> 00:15:30,697
你可以在字符串stick文件中


307
00:15:31,231 --> 00:15:34,101
调用NSLocalized-
String秘钥 


308
00:15:34,568 --> 00:15:36,370
然后将它设置为UI界面标签对象


309
00:15:37,938 --> 00:15:40,841
适用于iPad Air
iPhone 6


310
00:15:41,074 --> 00:15:42,075
和iPod Touch


311
00:15:42,676 --> 00:15:43,744
但效果是不同的


312
00:15:44,244 --> 00:15:46,647
有趣的是 我们以英语为例子


313
00:15:47,047 --> 00:15:50,684
但事实上它对各国的用户都有重要影响


314
00:15:51,251 --> 00:15:53,921
通常将英语翻译为其他语言


315
00:15:54,021 --> 00:15:54,855
都会比原文长


316
00:15:55,255 --> 00:15:58,825
因此 这可以使你
从不同的翻译版本中


317
00:15:59,126 --> 00:16:01,862
选择出不同语言的给定字符串
因此这是一个非常有用的工具


318
00:16:03,530 --> 00:16:08,569
在OS X上情况是不一样的


319
00:16:08,635 --> 00:16:12,673
同样的 在OS X上 你调用


320
00:16:13,073 --> 00:16:15,108
然后传输你的
字符串stick字典密匙


321
00:16:15,676 --> 00:16:18,111
然后你调用变量拟合布局宽度


322
00:16:18,712 --> 00:16:22,182
在OS X系统中 该整数变量


323
00:16:22,516 --> 00:16:24,618
其实是一个任意数量


324
00:16:25,052 --> 00:16:27,054
这可以是任意值因为它被界定为


325
00:16:27,120 --> 00:16:28,655
字符串stick内的其他相对值


326
00:16:31,458 --> 00:16:35,062
因此使用整数值20的效果是“您好”


327
00:16:35,662 --> 00:16:38,298
25是“欢迎” 
50是“欢迎来到商店”


328
00:16:39,099 --> 00:16:42,169
总体上我们
使之更加容易现在翻译字符串


329
00:16:42,236 --> 00:16:44,338 position:10%
更容易 更灵活了


330
00:16:44,705 --> 00:16:46,974
世界上各种语言在屏幕上
显示的字符串效果更好了


331
00:16:48,509 --> 00:16:50,744
接下来 来说说格式化


332
00:16:51,512 --> 00:16:54,681
简单的转化屏幕上的
字符串一般是不够的


333
00:16:55,115 --> 00:16:57,317
此外 你还得考虑
格式化日期 数字 时间


334
00:16:57,551 --> 00:17:01,722
在iOS 9和ElCapitan
新品上还需要格式化名字


335
00:17:02,756 --> 00:17:05,224
所以 首先从格式化数字开始


336
00:17:05,291 --> 00:17:06,993
这里有一个正确的方法一个错误的方法


337
00:17:07,261 --> 00:17:09,429
假设  我们希望
向用户显示常数圆周率


338
00:17:10,497 --> 00:17:13,400
一个天真的做法是
使用格式参数百分比3F 


339
00:17:13,534 --> 00:17:17,570
也就是说用3位精确浮点数参数


340
00:17:17,637 --> 00:17:19,006
来表示字符串变量


341
00:17:20,741 --> 00:17:22,910
在英文中 这个是适用的 
圆周率显示为3.142


342
00:17:24,278 --> 00:17:27,915
若你进行转换而你的用户
是在德国进行操作的


343
00:17:28,448 --> 00:17:30,484
他们会得到这个字符串


344
00:17:30,551 --> 00:17:32,352
乍一看 好像是正确的


345
00:17:32,819 --> 00:17:36,290
但事实上 德国用户
得到的圆周率是3,142


346
00:17:36,723 --> 00:17:39,693
因为在德国 十进制数字


347
00:17:40,227 --> 00:17:42,329
不好意思 千位数和
十进制数字事实上会被互换


348
00:17:42,396 --> 00:17:44,731
也就是说
我们在美国英语中用句号


349
00:17:45,032 --> 00:17:47,267
他们则逗号 反之亦然


350
00:17:48,202 --> 00:17:49,603
所以 利用这个事实


351
00:17:50,037 --> 00:17:52,105
你可以调用本地化格式字符串


352
00:17:52,372 --> 00:17:54,708
进入你先前用过的同一格式参数中


353
00:17:54,775 --> 00:17:57,911
因为用户所在场所不同
实现方式也会有所不同


354
00:17:58,512 --> 00:18:02,049
意思就是 现在英语用户
和德语用户的东西是一样的


355
00:18:02,916 --> 00:18:06,520
高级选项下本地化格式字符串
用的是NS数字格式器


356
00:18:07,621 --> 00:18:11,558
Ns数字格式器也有不少
改进这些我们都会讲到


357
00:18:12,593 --> 00:18:18,065
在iOS9和El Capitan中
NS数字格式器的数字格式不同


358
00:18:18,532 --> 00:18:20,467
除了现有的货币格式外


359
00:18:20,834 --> 00:18:22,603
现在 我们有货币ISO码格式


360
00:18:23,103 --> 00:18:26,540
以及货币复数格式和外币账格式


361
00:18:27,307 --> 00:18:31,111
很有趣 这里有外币账格式
如果它是负数


362
00:18:31,612 --> 00:18:33,714
那么它则会在括号里


363
00:18:34,081 --> 00:18:35,415
在会计领域里 这很正常


364
00:18:36,750 --> 00:18:39,720
同样地 我们增加顺序格式


365
00:18:39,786 --> 00:18:41,688
意思就是 排序列表里数字的显示方式


366
00:18:42,122 --> 00:18:44,224
输入42 你得到42nd


367
00:18:45,492 --> 00:18:48,161
所以 除了格式化数字外


368
00:18:48,929 --> 00:18:51,865
格式化日期也很容易出错


369
00:18:52,266 --> 00:18:54,201
这里有一个用来格式
化日期的很简单的方法


370
00:18:54,768 --> 00:18:57,237
我们用这个格式参数
初始化一个NS字符串


371
00:18:57,738 --> 00:19:01,542
也就是说对于美国英语用户来说


372
00:19:01,608 --> 00:19:03,710
它显示的是今天的日期 早上9点


373
00:19:04,978 --> 00:19:07,247
所以在美国英语环境下
我们会得到这个字符串


374
00:19:07,314 --> 00:19:08,849
看起来是恰当且正确的


375
00:19:09,283 --> 00:19:12,286
但对于意大利语用户来说
我们得到了相同的字符串


376
00:19:12,686 --> 00:19:14,321
而这个在意大利语种的意思截然相反


377
00:19:14,488 --> 00:19:17,191
在意大利语中 意思是12月6日


378
00:19:18,492 --> 00:19:20,894
此外可以对时间在稍微多些阐明


379
00:19:20,961 --> 00:19:21,895
我们马上会讲到这点


380
00:19:22,496 --> 00:19:25,766
所以试图解决这个问题的一个方法是


381
00:19:25,832 --> 00:19:27,167
创建一个NS日期格式器


382
00:19:27,501 --> 00:19:29,403
事实上 NS日期格式器
是正确的解决方式


383
00:19:29,469 --> 00:19:30,938
但这种使用方法是错误的


384
00:19:31,572 --> 00:19:33,307
这里 我们创建一个日期格式参数


385
00:19:33,774 --> 00:19:37,311
现在 日期格式
蕴含字符串一个明确的顺序


386
00:19:37,744 --> 00:19:40,514
你在这里提供的准确变量


387
00:19:40,581 --> 00:19:45,953
将在你所在的场所扩展成
你所看到的恰当的字符顺序


388
00:19:46,553 --> 00:19:49,323
再一次 在意大利这个地方
收到的字符串是错误的


389
00:19:50,224 --> 00:19:51,892
事实上 通过在你的NS日期格式器上


390
00:19:51,959 --> 00:19:53,994
创建日期格式和时间格式


391
00:19:54,061 --> 00:19:55,395
就可以很容易的解决这个问题


392
00:19:55,896 --> 00:19:58,465
我们为NS日期格式器
提供若干即用型的格式


393
00:19:58,532 --> 00:20:02,336
这允许你指定空格数量


394
00:20:02,402 --> 00:20:04,438
使其适用于对应的字符串宽度


395
00:20:05,172 --> 00:20:09,076
在这里 我们调用在这里我们为日期
和时间创建ShortStyle


396
00:20:09,776 --> 00:20:12,913
因此 在意大利收到的反馈是...


397
00:20:14,615 --> 00:20:15,749
字符串相同但是变量不同


398
00:20:16,216 --> 00:20:21,455
对于意大利用户来说
现在意思是6月12日


399
00:20:21,922 --> 00:20:24,157
这和美国英语用户看到的是一样的


400
00:20:25,125 --> 00:20:29,463
现在有时候 这些日期格式和时间格式
并未如你所需的那样明确


401
00:20:30,097 --> 00:20:33,233
为了解决这个问题iOS 9
和El Capitan的新特性


402
00:20:33,300 --> 00:20:35,702
允许你在模板里创建本地日期格式


403
00:20:36,703 --> 00:20:40,274
这里你提供一个模板


404
00:20:40,407 --> 00:20:41,975
变量视你所给的位置情况重新排列


405
00:20:43,043 --> 00:20:46,747
现在这是 当个人风格
无法立即提供足够信息


406
00:20:47,114 --> 00:20:50,684
比如说 用户希望第二个字符串也出现


407
00:20:51,084 --> 00:20:53,253
但第二个字符串通常不是简洁的格式


408
00:20:54,421 --> 00:20:57,824
使用模板 我们允许你有
24个小时的时间


409
00:20:59,660 --> 00:21:03,630
允许你重新安排月份和日期参数


410
00:21:04,798 --> 00:21:08,101
我们已经看过如何格式化数字
如何格式化日期


411
00:21:08,502 --> 00:21:10,437
但是 同样重要的是如何格式化单位


412
00:21:12,172 --> 00:21:15,442
事实上 这是个非常简单的事例


413
00:21:15,509 --> 00:21:17,578
但是却很真实很真实的发生过


414
00:21:18,212 --> 00:21:21,882
假设你想把数量6磅转换成其它语言


415
00:21:22,583 --> 00:21:26,153
一个很简单的做法是转化字符串


416
00:21:26,653 --> 00:21:28,622
你的左手边有X pounds


417
00:21:28,989 --> 00:21:31,792
对于意大利语用户我们将
它转换成X chilogrammi


418
00:21:31,859 --> 00:21:34,928
即kilogram的意大利语
是chilogrammi


419
00:21:35,629 --> 00:21:39,566
这显然是错误的在英语里我们说6磅


420
00:21:40,267 --> 00:21:43,670
在意大利语里 变成说6千克
这个数量无法对等6磅不等于6千克


421
00:21:43,737 --> 00:21:47,074
事实上 数量是不相等的
6磅作为一个单位并不等于6千克


422
00:21:47,574 --> 00:21:48,909
这样做是错误的


423
00:21:49,676 --> 00:21:52,246
NSMassFormatter
的方法会更简单些


424
00:21:52,679 --> 00:21:54,348
NSMassFormatter


425
00:21:54,414 --> 00:21:55,782
与
NSEnergyFormatter


426
00:21:55,849 --> 00:21:57,484
和
LengthFormatter一样


427
00:21:57,551 --> 00:22:00,120
假设在高级选项下你用的是公制单位


428
00:22:00,554 --> 00:22:03,590
所以当你为可变重量分配一个浮点数时


429
00:22:03,891 --> 00:22:05,559
它假设你用的是千克


430
00:22:06,026 --> 00:22:08,395
所以你格式化一个
NSMassFormatter


431
00:22:08,562 --> 00:22:10,163
创建它的单位格式 


432
00:22:10,430 --> 00:22:14,835
然后你调用string from
kilograms 重量单位是千克


433
00:22:15,502 --> 00:22:18,405
在英语环境下它返回44.092


434
00:22:19,306 --> 00:22:22,776
事实上这些单位
转换成了美国常用的单位


435
00:22:23,544 --> 00:22:26,180
此外 在意大利语种你得到的
是20 chilogrammi


436
00:22:26,380 --> 00:22:31,585
这是正确的你所提供的
重量数量转换的条件也是正确的


437
00:22:32,352 --> 00:22:34,354
所以 使用
NSMassFormatter


438
00:22:34,421 --> 00:22:36,290
可以非常容易的地显示目标单位


439
00:22:37,224 --> 00:22:38,992
iOS 9系统的新特性


440
00:22:39,893 --> 00:22:43,697
允许你格式化名字
iOS 9和El Capitan


441
00:22:44,398 --> 00:22:47,935
为了理解的实用性
我们来看看并排在一起的两个名字


442
00:22:48,335 --> 00:22:50,637
第一个是Grace
Murray Hopper


443
00:22:51,271 --> 00:22:53,273
这是一位著名的计算机科学家来自美国


444
00:22:53,674 --> 00:22:56,710
她定义了“bug”这个术语
并开发了第一个编译器


445
00:22:57,511 --> 00:23:00,414
此外 我们来看一个中文名字
“Wang Dongling”


446
00:23:01,081 --> 00:23:02,616
这是为著名的书法家


447
00:23:02,716 --> 00:23:04,818
他在杭州
Apple Store外写书法


448
00:23:05,519 --> 00:23:07,421
这两个名字都由三个部分组成


449
00:23:08,021 --> 00:23:10,490
对它们进行说明的方法
很重要同时也是不同的


450
00:23:11,892 --> 00:23:16,330
在英语里
我们一般只称呼名中间名和姓


451
00:23:16,897 --> 00:23:21,001
在我们试图将这个概念套用到
中国用户上时我们来看看会发生什么


452
00:23:22,169 --> 00:23:25,806
顺序从左到右先前排在最后的名字


453
00:23:25,873 --> 00:23:26,840
现在是第一个


454
00:23:27,541 --> 00:23:29,710
中文名完全不存在了


455
00:23:30,210 --> 00:23:34,781
从左到右 原先是第一个的


456
00:23:36,517 --> 00:23:38,118
现在变成最后一个了


457
00:23:38,719 --> 00:23:44,024
从这里可以看到应用
在这些概念中的术语和标签同样重要


458
00:23:44,825 --> 00:23:48,395
所以 我们引入了NS 人名组件


459
00:23:48,595 --> 00:23:50,330
和NS人名组件格式器


460
00:23:50,898 --> 00:23:53,233
曾经有个笑话说推特不适合这套方法


461
00:23:53,333 --> 00:23:55,903
使用方面需要花些时间也有点困难


462
00:23:56,203 --> 00:23:58,038
但是 换而言之它所做的是非常精确的


463
00:23:58,105 --> 00:23:59,373
它将人名格式化了


464
00:24:00,841 --> 00:24:01,942
这是使用方法


465
00:24:02,643 --> 00:24:05,479
你初始化一个NS人名组件对象


466
00:24:06,013 --> 00:24:08,849
你填入教名中名和姓氏


467
00:24:08,949 --> 00:24:10,617
这是针对美国英语用户如何使用它


468
00:24:11,418 --> 00:24:13,320
对于俄国用户来说


469
00:24:13,387 --> 00:24:14,621
你可能需要将Fyodor


470
00:24:14,688 --> 00:24:16,990
Mikhailovich
Dostoyevsky


471
00:24:17,057 --> 00:24:18,892
同样的 填写在相同的域里


472
00:24:20,761 --> 00:24:22,229
接下来是如何将它格式化


473
00:24:22,930 --> 00:24:25,766
你初始化NS人名组件格式器对象


474
00:24:26,300 --> 00:24:29,002
正如我们用其他
NS格式器所看到的它有一个格式组件


475
00:24:29,369 --> 00:24:30,704
这里 我们指定简洁格式


476
00:24:31,405 --> 00:24:34,942
然后 你在人名组件对象中
调用人名组件字符串


477
00:24:35,876 --> 00:24:37,744
这次调用的结果如下


478
00:24:38,512 --> 00:24:41,014
有五种适用的格式


479
00:24:41,215 --> 00:24:43,617
默认 简洁 中等格式  长格式
和缩写  对每种语言来说


480
00:24:43,684 --> 00:24:44,651
我们的方法是正确的


481
00:24:45,252 --> 00:24:46,253
需要注意一些事情


482
00:24:46,386 --> 00:24:49,389
事实上简洁格式的变化
和下面这些有关系


483
00:24:49,690 --> 00:24:53,694
即用户的位置
以及个人用户在邮箱 联系方式


484
00:24:53,760 --> 00:24:55,662
日历设置和加载设置


485
00:24:56,697 --> 00:24:59,199
同样地 对于俄语的名字来说


486
00:24:59,266 --> 00:25:01,435
取名字 中名 和姓氏


487
00:25:01,502 --> 00:25:05,205
第一个字符组成的缩写名字是不存在的


488
00:25:05,272 --> 00:25:07,040
所以 我们退回到简洁格式


489
00:25:07,941 --> 00:25:12,179
这真的很简单可以立即
对用户的名字进行格式化


490
00:25:14,014 --> 00:25:17,451
这就是数字 日期 
时间 单位 和名字


491
00:25:18,785 --> 00:25:20,354
我们已经知道如何转化


492
00:25:20,854 --> 00:25:22,222
如何在你的UI上转化字符串


493
00:25:22,456 --> 00:25:24,791
如何将用户看到的单位格式化


494
00:25:25,359 --> 00:25:28,462
此外 重要的是
如何处理从用户那收到的文本


495
00:25:31,031 --> 00:25:33,500
这涉及到考虑字符是什么


496
00:25:33,967 --> 00:25:36,703
在不同情况下的不同变化


497
00:25:36,770 --> 00:25:39,573
你是如何搜索那个字符的


498
00:25:39,640 --> 00:25:42,142
同样地你是如何将它转换成其他脚本的


499
00:25:43,177 --> 00:25:45,646
开始这部分之前
我们来问一个哲学问题


500
00:25:45,913 --> 00:25:46,914
什么是字符


501
00:25:47,748 --> 00:25:51,218
开始之前 我们来问问
这个表情符号里有多少个字符


502
00:25:51,952 --> 00:25:56,256
最近 我们在iOS中引入了这个
用键盘也可将其敲打出来


503
00:25:57,891 --> 00:25:59,626
尽管表面上看它只包含单一的单位


504
00:25:59,693 --> 00:26:01,628
但答案并不是立即就可以看出来


505
00:26:02,129 --> 00:26:05,265
高级选项下 它由一 二 三 四 五


506
00:26:05,666 --> 00:26:09,937
六 七 八个单独字符表示


507
00:26:10,737 --> 00:26:13,874
事实上 这些是万国码代码点


508
00:26:14,074 --> 00:26:16,443
并取决于你所使用的编码
事实上它可能多于8个


509
00:26:16,510 --> 00:26:17,678
比如说 可能是十一 


510
00:26:18,245 --> 00:26:21,582
但是这也就是说 你不需要考虑它


511
00:26:23,250 --> 00:26:29,323
现在 很明显的一个地方是列举字符串


512
00:26:29,890 --> 00:26:33,961
假设有个字符串测试
后面紧跟着我们刚讨论过的表情字符


513
00:26:34,661 --> 00:26:37,898
现在你想在字符串内列举每个字符


514
00:26:37,965 --> 00:26:39,900
并调用character
at index


515
00:26:40,834 --> 00:26:43,737
这将返回到包含
单独字符串的unichar


516
00:26:44,338 --> 00:26:45,372
但这并不是你想要的


517
00:26:45,772 --> 00:26:48,942
事实上 这显示的是问号字符


518
00:26:49,009 --> 00:26:51,512
有时是三个不可打印字符


519
00:26:51,578 --> 00:26:53,714
由于某种原因这其中有个中心


520
00:26:54,515 --> 00:26:56,350
所以它不是 显然
这个方法绝对是错误的


521
00:26:57,017 --> 00:27:00,554
列举字符串的正确做法是
调用“列举子字符串队列”


522
00:27:01,121 --> 00:27:03,991
此外 并表达“组成成字符序列”


523
00:27:04,391 --> 00:27:06,093
这就使得这个字符


524
00:27:06,159 --> 00:27:09,863
在高级选项下的再现与视觉再现相匹配


525
00:27:10,464 --> 00:27:13,667
因此 当我们在字符串上调用时
我们恰好得到六个字符


526
00:27:15,102 --> 00:27:17,804
这就是列举一个字符串的应用


527
00:27:18,505 --> 00:27:21,441
但是有时你想把那个
字符串转化成不同格式


528
00:27:22,776 --> 00:27:26,246
iOS 9新特性具备这个功能


529
00:27:26,313 --> 00:27:28,015
iOS 9和
El Capitan具备能


530
00:27:28,148 --> 00:27:29,950
转化字符串的功能


531
00:27:30,884 --> 00:27:32,753
假设字符串是“istanbul”


532
00:27:33,554 --> 00:27:35,055
首字大写字符串的一个简单方法是


533
00:27:35,122 --> 00:27:39,159
只需调用“首字大写字符串”属性


534
00:27:39,960 --> 00:27:41,795
对于美国英语用户而言
这看起来是正确的


535
00:27:41,962 --> 00:27:44,865
事实上 对于英语用户来说
这是正确的大写方式


536
00:27:45,232 --> 00:27:47,801
但对于使用土耳其语的人来说


537
00:27:47,868 --> 00:27:49,703
小写字母i变成了大写字母I


538
00:27:51,371 --> 00:27:53,140
为了能立即实现该功能


539
00:27:53,473 --> 00:27:57,511
你可以简单的在那个字符串上
调用“本地化首字大写字符串”


540
00:27:57,744 --> 00:28:01,381
因此你可以得到正确的
首字大写的字符串


541
00:28:01,481 --> 00:28:03,917
也就是说字符串的第一个字符是大写的


542
00:28:04,785 --> 00:28:08,088
除了“本地化首字大写字符串”


543
00:28:08,155 --> 00:28:10,457
我们还提供了“本地化大写字符串”


544
00:28:10,524 --> 00:28:11,692
和本地化小写字符串


545
00:28:12,626 --> 00:28:13,794
这就是它们看起来的样子


546
00:28:14,695 --> 00:28:17,064
所以 你立即就可以通过


547
00:28:17,130 --> 00:28:18,832
简单使用已经存在的
API的本地变量


548
00:28:19,099 --> 00:28:20,400
善用这些字符


549
00:28:21,435 --> 00:28:24,605
这就是如何转化字符串的例子


550
00:28:24,805 --> 00:28:26,974
假设你想寻找一个字符串


551
00:28:27,841 --> 00:28:30,410
回到一开始的问题字符是什么


552
00:28:31,678 --> 00:28:34,982
在用户需要搜索
一个指定的字符串时


553
00:28:35,048 --> 00:28:36,116
他们期待的是什么


554
00:28:36,850 --> 00:28:40,521
假设这里有一个变量
代表德语的 uber


555
00:28:41,221 --> 00:28:42,322
其中有个字母U


556
00:28:42,723 --> 00:28:44,358
刚好又是元音U


557
00:28:45,292 --> 00:28:48,529
用户可能会想
按照通常英语书写格式


558
00:28:48,595 --> 00:28:51,899
写出小写的uber就可以找到字符串


559
00:28:52,766 --> 00:28:56,570
作为开发者你可能调用
“字符串范围”进行寻找


560
00:28:57,104 --> 00:28:58,505
但结果是0


561
00:28:59,640 --> 00:29:02,609
在iOS 9和
El Capitan新特性中


562
00:29:02,676 --> 00:29:05,145
正确的搜索方法是
“本地化标准字符串范围”


563
00:29:05,913 --> 00:29:10,584
这可使你在其他对发音不敏感的
字符串和对大写不敏感的字符串里


564
00:29:11,051 --> 00:29:13,620
搜索这个字符串


565
00:29:14,488 --> 00:29:17,591
此外 它还为指定用户位置提供修正值


566
00:29:18,358 --> 00:29:20,861
所以 在这里
通过简单调用这些新API


567
00:29:20,961 --> 00:29:25,899
我们通过“大写U-变音-ber”里
找到了 uber小写字符串


568
00:29:27,267 --> 00:29:30,037
除在字符串里进行搜索之外


569
00:29:30,103 --> 00:29:32,673
有时你可能想转化整个字符串


570
00:29:33,841 --> 00:29:35,475
这就是转换的由来


571
00:29:36,243 --> 00:29:40,247
转换允许你在整个字符串的大写字母和
小写字母变量之间进行转化


572
00:29:40,747 --> 00:29:43,650
此外他们允许你进行万国码标准化


573
00:29:43,784 --> 00:29:47,154
也就是说 他们可以
元音字符拿出并将它们分开


574
00:29:47,221 --> 00:29:50,190
比如带有一个元音变音的A
变成了A加元音变音字符


575
00:29:51,091 --> 00:29:54,528
此外 还允许你进行
脚本对脚本的转化或直译


576
00:29:54,595 --> 00:29:58,632
也就是说中文汉字
字符可转化成拉丁文字符


577
00:29:59,366 --> 00:30:02,102
先前 这种转化只能在
Core Foundation进行


578
00:30:03,237 --> 00:30:05,138
因为iOS 9 和
El Capitan新特性


579
00:30:05,939 --> 00:30:07,741
你可在
Foundation里进行转化


580
00:30:09,209 --> 00:30:11,178
你只需简单调用“字符串应用转化”


581
00:30:12,212 --> 00:30:14,414
然后提供一个字符串或常量


582
00:30:15,382 --> 00:30:18,852
表达你想要如何转化字符串转化成


583
00:30:19,453 --> 00:30:21,121
这里 我们想把这个表情字符翘起拇指


584
00:30:21,688 --> 00:30:27,060
或 直译成 XML 表达方式


585
00:30:28,595 --> 00:30:32,332
做到这点只需调用“字符串应用转化”


586
00:30:32,699 --> 00:30:35,169
并提供“NS字符串转
化之XML十六进制”


587
00:30:35,903 --> 00:30:39,373
此外 我们也为汉字字符与拉丁文


588
00:30:39,439 --> 00:30:43,810
以及欧洲不同脚本提供了这种转换功能


589
00:30:44,545 --> 00:30:46,413
所以 很容易


590
00:30:46,480 --> 00:30:50,217
就可以转化 转换不同脚本间的字符串


591
00:30:50,284 --> 00:30:54,354
并将单个字符转换成不同的表现方式


592
00:30:55,355 --> 00:30:58,926
这就是在我们的系统内


593
00:30:59,293 --> 00:31:00,661
如何处理从用户那收到的文本


594
00:31:01,562 --> 00:31:04,731
此外 重要的一点是
在屏幕布局视觉元素的方法


595
00:31:06,433 --> 00:31:10,237
这就是自动布局的由来


596
00:31:11,238 --> 00:31:12,973
自动布局很早就发布了


597
00:31:13,407 --> 00:31:18,011
最初的意图是
在适合你的屏幕数量的基础上


598
00:31:18,078 --> 00:31:20,214
用不同的方式格式化指定UI


599
00:31:20,914 --> 00:31:23,817
在我们为iOS 和 OS X
发布了不同的形状因子后


600
00:31:23,884 --> 00:31:27,254
自动布局就变得越来越重要了


601
00:31:28,222 --> 00:31:31,592
自动布局有一个附加的好处


602
00:31:31,959 --> 00:31:34,561
就是将应用的UI本地化


603
00:31:36,597 --> 00:31:38,665
这是UI外观的样子


604
00:31:38,866 --> 00:31:42,069
所以 假设 比如说
我们想在iCloud中增加新日历


605
00:31:42,636 --> 00:31:44,338
这是一个英文版本的UI外观


606
00:31:44,872 --> 00:31:46,773
这个UI功能或许已经相当完善


607
00:31:47,074 --> 00:31:50,511
当你在不同情况下测试时
它可能会起作用


608
00:31:50,811 --> 00:31:53,814
可能会与在运行时间内增加的
内容不断地相互作用


609
00:31:54,915 --> 00:31:58,452
但是对于它如何运作


610
00:31:58,519 --> 00:32:00,454
你并未在其他UI或语言中设置修正值


611
00:32:00,821 --> 00:32:04,424
那么它就可能打破
你到刚才为止所做的这些假设


612
00:32:05,592 --> 00:32:11,164
这个UI和前面的一样 语言是希腊语
乍一看 它似乎可以用


613
00:32:11,765 --> 00:32:16,270
当你再仔细看时 你会发现事实上
这个字符的长度等于3.5个字符


614
00:32:16,870 --> 00:32:19,039
UI的附加部分也出现这个问题


615
00:32:19,806 --> 00:32:22,009
现在 我要说的是
在不同位置进行测试时


616
00:32:22,075 --> 00:32:23,710
没有必要本地化app 


617
00:32:24,211 --> 00:32:26,013
多亏了XCode皮肤菜单


618
00:32:26,346 --> 00:32:29,049
现在你可以使用双宽度伪距语言
和右至左伪距语言


619
00:32:29,116 --> 00:32:30,851
测试你的app


620
00:32:31,418 --> 00:32:33,820
使用这种方法可以不需要转换


621
00:32:34,188 --> 00:32:36,456
就可以在在不同的
环境中查看UI是如何操作的


622
00:32:37,558 --> 00:32:39,927
假设你将使用自动布局


623
00:32:40,360 --> 00:32:42,696
并已经正确设置压缩优先权


624
00:32:43,130 --> 00:32:45,098
和抗压缩优先权


625
00:32:45,566 --> 00:32:46,934
这就是出来的UI外观


626
00:32:49,203 --> 00:32:52,573
可以看到 先前是3.5个字符
现在变成了12个


627
00:32:53,173 --> 00:32:55,175
差别非常大


628
00:32:55,542 --> 00:32:58,278
我们不通过指定静态限制


629
00:32:59,179 --> 00:33:02,983
而是根据它可增长限制
允许标签扩大可用的空格


630
00:33:03,350 --> 00:33:06,987
也就是说
限制少于或等于到屏幕边的宽度


631
00:33:07,721 --> 00:33:11,625
更多信息请重新看看昨天的演讲


632
00:33:12,192 --> 00:33:14,228
自动布局的神秘之处 第1和第2部分


633
00:33:14,962 --> 00:33:16,096
里面有很多信息


634
00:33:16,430 --> 00:33:19,166
关于如何在世界范围内
以及不同的设备方向上


635
00:33:20,434 --> 00:33:22,402
在你的app上使用自动布局


636
00:33:23,570 --> 00:33:28,108
在UI中布局 还需要注意一点


637
00:33:28,442 --> 00:33:30,978
即表格单元格会自己变动大小


638
00:33:31,912 --> 00:33:33,180
这涉及到动态类型


639
00:33:33,480 --> 00:33:36,984
左边是美国英语UI
右边是北印度语UI


640
00:33:37,718 --> 00:33:41,522
注意到了吧 事实上
单独的单元格高度并不相同


641
00:33:41,955 --> 00:33:43,991
这是因为单元格自动改变大小


642
00:33:44,558 --> 00:33:46,860
我们允许单元格占用


643
00:33:47,160 --> 00:33:49,363
由于语言行高度变化而多出来的空格


644
00:33:50,197 --> 00:33:53,233
若你使用标准UI控制和UI视图


645
00:33:53,600 --> 00:33:55,869
就可以看到 而且是免费的


646
00:33:56,603 --> 00:33:59,907
作为开发者 
需要注意的一点是你不能假设


647
00:33:59,973 --> 00:34:01,708
提供的表格单元格 有一定的高度


648
00:34:02,176 --> 00:34:06,547
在不同位置它可能扩大
以占用不同数量的空格


649
00:34:08,514 --> 00:34:15,022
在iOS 9中 很重要的关键一点是
我们完全支持从右到左的语言


650
00:34:15,322 --> 00:34:18,358
左边 是英语UI右边是阿拉伯语UI


651
00:34:19,126 --> 00:34:20,827
这些变化非常大


652
00:34:21,360 --> 00:34:23,330
我们已经完成了标准控制和视图


653
00:34:23,630 --> 00:34:26,199
并转化了综合控制流


654
00:34:26,833 --> 00:34:31,237
在英语中你将按照从左到
右从一个菜单转到详细菜单


655
00:34:31,839 --> 00:34:34,741
现在 在从右到左语言里
你按照从右到左的顺序进行


656
00:34:35,242 --> 00:34:37,143
可以看到这些雪佛兰已经转移了


657
00:34:37,444 --> 00:34:39,246
附属视图在另一边


658
00:34:40,179 --> 00:34:42,014
大部分文本被翻转


659
00:34:43,016 --> 00:34:44,818
需要记住一点 在UI中


660
00:34:44,885 --> 00:34:48,922
并不是所有的东西都可以移动
可能不是你可以自行移动的


661
00:34:50,991 --> 00:34:53,126
有时你想自定义行为


662
00:34:53,927 --> 00:34:58,599
可以看到“请勿打扰”的图标


663
00:34:59,233 --> 00:35:02,536
事实上还是从左到右
拉丁文文本也还是从左到右


664
00:35:03,070 --> 00:35:07,307
更多关于这部分的信息
建议你查看昨天的演讲


665
00:35:07,374 --> 00:35:09,443
“国际界面的新UI工具支持”


666
00:35:10,277 --> 00:35:13,180
说的是在iOS9中


667
00:35:13,447 --> 00:35:17,851
如何使用标准控制对完全
从右到左支持加以利用并加以利用


668
00:35:18,452 --> 00:35:20,387
此外 如何在你的个人app上


669
00:35:20,654 --> 00:35:21,822
对其进行自定义


670
00:35:23,457 --> 00:35:28,262
总而言之 在将你的
app国际化时需要注意


671
00:35:28,695 --> 00:35:32,065
第一 定位信息


672
00:35:32,533 --> 00:35:34,168
字符串是如何被转化的


673
00:35:34,468 --> 00:35:38,272
隐藏在译文里的概念
是如何转化成用户所需的


674
00:35:38,906 --> 00:35:44,912
此外 格式化 单位 日期 数字
时间 名字是如何格式化成用户所要的


675
00:35:46,180 --> 00:35:50,584
文本处理 你如何从用户
那获取文本并在文本上执行操作的


676
00:35:51,118 --> 00:35:53,587
又回到这个问题字符是什么


677
00:35:53,921 --> 00:35:55,956
这是你在处理文本过程中
需要时刻牢记的


678
00:35:56,590 --> 00:35:59,593
最后 我们说到布局


679
00:35:59,660 --> 00:36:01,395
如何将UI要素展示给国际用户


680
00:36:02,262 --> 00:36:07,534
很幸运地是如果你用的是现有API
本地化变量 以及标准视图和控制


681
00:36:07,801 --> 00:36:09,336
你就可以免费获得这些功能


682
00:36:10,137 --> 00:36:15,042
如果你牢记这点你就会发现
国际化为你的应用打开了世界的大门


683
00:36:16,577 --> 00:36:20,881
更多信息请查看这些幻灯片
或查看这些文档


684
00:36:22,249 --> 00:36:27,221
联系开发者论坛
或App框架专员 保罗·马科斯


685
00:36:27,888 --> 00:36:30,057
也可查看相关会议


686
00:36:31,592 --> 00:36:35,028
这些已经都有了
你也可在你的app或在线查阅


687
00:36:35,596 --> 00:36:38,298
今天从早上11:00到下午1:10


688
00:36:38,565 --> 00:36:41,535
我们将提供国际化实验室请一定要参加


689
00:36:42,236 --> 00:36:44,204
我和我的团队都将在那里为大家解答


690
00:36:44,271 --> 00:36:46,473
关于app国际化和本地化的相关问题


691
00:36:47,341 --> 00:36:48,609
谢谢

