1
00:00:26,527 --> 00:00:27,227
肯奥尔：早上好


2
00:00:35,102 --> 00:00:38,071
Xcode 7是我们下一步
推出的主要工具


3
00:00:38,372 --> 00:00:40,641
是为了开发 Mac、
iPhone、iPad


4
00:00:40,707 --> 00:00:42,509
和 Apple
Watch app准备的


5
00:00:43,110 --> 00:00:44,778
今天上午
让我们来看一看


6
00:00:44,845 --> 00:00:46,580
Xcode 加了哪些新料


7
00:00:49,483 --> 00:00:52,519
今年最大的变化
是我们添加了


8
00:00:52,819 --> 00:00:56,890
第三方平台Watch OS
的支持 当然了


9
00:00:57,090 --> 00:00:58,992
你仍然可以用Xcode
这款你已经熟悉的


10
00:00:59,193 --> 00:01:02,029
同样工具来开发 Apple
Watch应用


11
00:01:03,964 --> 00:01:07,367
Xcode 7同样也包括
Swift 2


12
00:01:08,368 --> 00:01:10,470
后者是基于去年
我们介绍的


13
00:01:10,537 --> 00:01:11,238
新的编程语言


14
00:01:12,272 --> 00:01:14,942
从整体上说 
Swift 2速度更快


15
00:01:15,542 --> 00:01:18,078
不仅是指你的
app在Xcode中


16
00:01:18,145 --> 00:01:20,781
运行和调试速度更快 


17
00:01:21,248 --> 00:01:23,350
此外app在用户的
设备上也更快


18
00:01:25,485 --> 00:01:28,622
Swift 2
还有一些新的语言功能


19
00:01:29,089 --> 00:01:33,160
比如错误处理 
引入了显式语法


20
00:01:33,560 --> 00:01:36,463
这样处理Swift中的
错误就更快了


21
00:01:37,831 --> 00:01:40,667
可及性 现在Swift
对某些API的最低


22
00:01:40,734 --> 00:01:45,439
OS需求有了深刻理解
这样采纳新API


23
00:01:45,506 --> 00:01:50,777
继续支持现有的OS
也都更加容易


24
00:01:52,279 --> 00:01:53,046
可测试性


25
00:01:53,647 --> 00:01:57,518
现在测试丛就可参阅
内部API


26
00:01:57,851 --> 00:02:01,255
你的测试覆盖更广而无需公开


27
00:02:01,321 --> 00:02:03,724
任何其它源信息


28
00:02:05,392 --> 00:02:09,329
协议扩展使得你
能够为任何类添加方法，


29
00:02:09,630 --> 00:02:11,265
以便实现某一协议


30
00:02:14,401 --> 00:02:17,137
你可以借助Xcode 7的
Migrator


31
00:02:17,504 --> 00:02:19,506
把所有的Swift代码 
转换成Swift 2


32
00:02:20,340 --> 00:02:23,777
它既适合项目 也适合
playgrounds


33
00:02:27,514 --> 00:02:29,216
我们还向
Objective-C中添


34
00:02:29,283 --> 00:02:29,983
加了新语言功能


35
00:02:30,083 --> 00:02:33,887
这样它和Swift
就配合的更好


36
00:02:34,855 --> 00:02:37,925
比如Generics让你
可以指定收集的...


37
00:02:39,493 --> 00:02:40,260
类型信息


38
00:02:41,628 --> 00:02:43,830
Nullability
Annotations


39
00:02:43,897 --> 00:02:45,098
能让你指定你


40
00:02:45,165 --> 00:02:47,701
何时期待零值 何时期待非零


41
00:02:48,001 --> 00:02:49,303
这样
Objective-C


42
00:02:49,369 --> 00:02:51,004
和Swift之间
就真正实现了


43
00:02:51,071 --> 00:02:54,408
无缝交互 这很棒


44
00:02:55,108 --> 00:02:57,477
我们已经先行一步，
在我们的SDK中


45
00:02:57,544 --> 00:02:58,579
采用了这些特性


46
00:02:58,645 --> 00:03:01,949
因此你现在就可以看到好处


47
00:03:04,885 --> 00:03:07,888
如果你想用Swift 2


48
00:03:08,055 --> 00:03:10,824
或者你昨天看到的新的API


49
00:03:11,425 --> 00:03:14,661
在playground中
做就再好不过了


50
00:03:15,762 --> 00:03:17,698
去年 我们引入了
playground


51
00:03:18,265 --> 00:03:20,968
从那时起它们的进展很大


52
00:03:21,768 --> 00:03:25,072
现在你不仅能探索摆弄代码


53
00:03:25,839 --> 00:03:28,041
还可以从一个
playground中


54
00:03:28,108 --> 00:03:31,111
解释一个想法 一个概念


55
00:03:32,579 --> 00:03:35,916
我们引入了像Rich
Comments这样的特性


56
00:03:36,049 --> 00:03:37,484
你就可以用一个标示语法 


57
00:03:37,551 --> 00:03:41,388
来解释环境代码中发生了什么


58
00:03:42,256 --> 00:03:44,191
它们的格式和字体都很漂亮


59
00:03:44,558 --> 00:03:46,493
非常显眼


60
00:03:47,761 --> 00:03:51,999
你可以在这些
评论中添加网页链接列表


61
00:03:52,165 --> 00:03:54,067
甚至添加图像


62
00:03:56,203 --> 00:03:59,439
我们还允许拉取结果并显示在


63
00:03:59,506 --> 00:04:02,142
快速浏览窗中 你可以把它们


64
00:04:02,209 --> 00:04:05,913
拉取到源代码中
对应的那一行代码下面


65
00:04:07,247 --> 00:04:11,852
这对定位因果关系的
作用非常大


66
00:04:12,352 --> 00:04:13,387
这很棒


67
00:04:15,522 --> 00:04:18,458
通过向新支持源文件夹中
添加Swift代码


68
00:04:18,858 --> 00:04:20,459
你几乎可以向
playground


69
00:04:20,527 --> 00:04:22,095
无限添加功能


70
00:04:23,130 --> 00:04:23,830
这有助于帮助你


71
00:04:23,897 --> 00:04:25,599
保持playground
的整洁专注


72
00:04:25,732 --> 00:04:30,170
同时 你也有地方
去放支持功能


73
00:04:31,438 --> 00:04:32,840
这里 还有一项性能


74
00:04:33,340 --> 00:04:34,808
因为是配套代码 


75
00:04:35,042 --> 00:04:38,679
运行时不是交互式的
就能对它们进行编译


76
00:04:39,012 --> 00:04:40,714
它们只是对
playground


77
00:04:40,781 --> 00:04:41,448
提供支持


78
00:04:41,815 --> 00:04:44,151
所以可以运行的很快


79
00:04:48,689 --> 00:04:50,190
我们最新的
playground


80
00:04:50,991 --> 00:04:51,992
特性是 Pages


81
00:04:52,626 --> 00:04:57,231
这使你可以为
某一话题编写内容


82
00:04:58,398 --> 00:05:00,834
例如 如果你想
制作一个与排序相关的


83
00:05:00,901 --> 00:05:05,372
playground 
你就可以添加


84
00:05:05,439 --> 00:05:07,307
一个与排序原则相关的介绍页


85
00:05:07,908 --> 00:05:09,276
然后你可以添加涵盖特定


86
00:05:09,343 --> 00:05:10,911
排序算法、快速排序、


87
00:05:10,978 --> 00:05:14,548
冒泡排序等事情的后续页面


88
00:05:15,649 --> 00:05:18,352
之后 如果你想添加页面导航


89
00:05:18,919 --> 00:05:22,089
你可以添加一些
我们之前介绍的标示语法


90
00:05:23,657 --> 00:05:27,227
Playgrounds是
进行教导的得力方式


91
00:05:28,896 --> 00:05:31,932
去年 我们把教程
做成了playground


92
00:05:32,533 --> 00:05:35,702
今年 我们又升级成了
Pages


93
00:05:39,006 --> 00:05:42,042
这就是Swift 2 
和新playgrounds


94
00:05:44,878 --> 00:05:48,982
除了iOS 9和OS 10
El Capitan


95
00:05:49,049 --> 00:05:51,652
我们还向Watch 
OS 2中 添加了新运动


96
00:05:52,719 --> 00:05:56,890
新的WatchKit能帮助
使你的app更具响应性


97
00:05:57,791 --> 00:05:59,560
并且增强你作为开发者的


98
00:05:59,626 --> 00:06:01,061
控制能力和灵活性


99
00:06:02,196 --> 00:06:03,096
如果你还没看


100
00:06:03,163 --> 00:06:04,898
“Watch OS 2中
有什么新料”


101
00:06:04,965 --> 00:06:05,632
我建议你看看


102
00:06:05,766 --> 00:06:06,800
有些东西很棒。


103
00:06:10,704 --> 00:06:12,906
当然 你也可以
使用Xcode中的故事板


104
00:06:13,340 --> 00:06:17,311
来开发完整的watch
app 你还能快速展示


105
00:06:17,377 --> 00:06:19,746
你的app如何在屏幕间转换


106
00:06:20,881 --> 00:06:23,183
你可以设计并完成
glances


107
00:06:23,250 --> 00:06:25,485
甚至新WatchKit
complications


108
00:06:25,552 --> 00:06:26,220
也可以


109
00:06:27,020 --> 00:06:29,022
对于iOS来说使用新
StackView等


110
00:06:29,089 --> 00:06:30,390
事物来开发


111
00:06:31,091 --> 00:06:34,394
改变屏幕方向
适配不同屏幕


112
00:06:34,461 --> 00:06:38,665
尺寸的app从未如此的简单


113
00:06:39,900 --> 00:06:41,768
有了新iPad
多任务处理功能


114
00:06:41,902 --> 00:06:44,104
你在界面构建器中
定义的大小类


115
00:06:44,171 --> 00:06:47,007
比以往任何时候都要重要


116
00:06:48,742 --> 00:06:53,380
和iOS 9一起， 
我们还引入了一项叫


117
00:06:53,447 --> 00:06:55,282
App Thinning
的新横切特性


118
00:06:56,350 --> 00:07:00,020
App Store
可以量身定制你的app


119
00:07:00,087 --> 00:07:01,388
为每台用户设备


120
00:07:01,455 --> 00:07:05,592
推送最佳、最小版本


121
00:07:07,427 --> 00:07:10,264
这样你就可以集中精力
开发优秀的app


122
00:07:11,164 --> 00:07:13,033
而不用担心app的大小 


123
00:07:13,133 --> 00:07:18,338
因为你知道客户
不会下载到无用内容


124
00:07:19,840 --> 00:07:21,775
当然 Xcode也会帮助你
配置你的app


125
00:07:21,842 --> 00:07:23,944
让你的app瘦身


126
00:07:26,446 --> 00:07:28,916
App Thinning
由三个不同的部分组成


127
00:07:30,217 --> 00:07:31,785
第一个部分
就是Bitcode


128
00:07:32,719 --> 00:07:36,857
当你存档提交时
Xcode会把你的app


129
00:07:36,924 --> 00:07:40,060
编译到一个叫做
Bitcode的中间表述


130
00:07:40,460 --> 00:07:42,062
然后再发送到store


131
00:07:43,330 --> 00:07:47,334
稍后App Store会
重新优化你的代码 


132
00:07:47,601 --> 00:07:51,872
帮助你进一步校对编译器更新


133
00:07:52,072 --> 00:07:54,074
新处理器性能等事情


134
00:07:55,142 --> 00:07:56,677
你不需要做任何事情


135
00:07:57,110 --> 00:07:58,612
就可以坐享
Bitcode的益处


136
00:07:58,679 --> 00:08:00,781
Xcode会替你搞定一切


137
00:08:02,649 --> 00:08:04,484
其次就是Slicing


138
00:08:05,419 --> 00:08:09,923
当App Store向
用户设备推送你的app时


139
00:08:10,958 --> 00:08:14,761
它会只推送那台
需要的设备美术资源


140
00:08:15,062 --> 00:08:19,499
举例来说 如果你的
app中有为iPhone6


141
00:08:19,566 --> 00:08:21,969
和iPhone6s准备的
2x和3x的资源


142
00:08:22,035 --> 00:08:25,072
那么iPhone6
只会收到2x资源


143
00:08:25,439 --> 00:08:28,675
而iPhone6s
只会收到3x资源


144
00:08:29,910 --> 00:08:32,746
要利用Slicing 
你只需要使用


145
00:08:32,813 --> 00:08:35,148
Xcode中的 Asset
Catalogs即可


146
00:08:38,485 --> 00:08:42,923
最后是点播资源你可以控制


147
00:08:43,256 --> 00:08:45,058
何时下载资源


148
00:08:45,792 --> 00:08:48,362
例如 你可以在用户通关


149
00:08:48,428 --> 00:08:52,533
你的游戏第4关时
才开始下载第5关


150
00:08:53,467 --> 00:08:55,202
你可以控制很多东西


151
00:08:55,502 --> 00:08:56,170
这很棒


152
00:08:57,437 --> 00:08:59,439
约翰会给大家演示一下
Watch OS 2


153
00:08:59,506 --> 00:09:01,775
和 App
Thinning


154
00:09:10,017 --> 00:09:10,918
乔恩·赫斯：早上好


155
00:09:11,652 --> 00:09:13,754
今天我会演示Xcode7中
我最爱的两项特色


156
00:09:13,820 --> 00:09:16,190
即 native
watch 扩展功能


157
00:09:16,456 --> 00:09:17,424
和应用瘦身


158
00:09:21,361 --> 00:09:23,263
让我们通过一个小游戏来展示


159
00:09:24,198 --> 00:09:26,767
我们的小游戏 已经为
WatchKit 1 


160
00:09:26,934 --> 00:09:28,936
做好准备了


161
00:09:29,469 --> 00:09:31,738
现在我想升级成
Watch OS 2


162
00:09:32,573 --> 00:09:34,174
Xcode好像和我心有灵犀


163
00:09:34,641 --> 00:09:38,645
我在导航这里看到一个现代项
目的化序列已经放在队列中了


164
00:09:39,279 --> 00:09:40,514
我会选中它


165
00:09:40,647 --> 00:09:43,550
开始把我的项目设置迁移到
Watch OS 2


166
00:09:44,418 --> 00:09:46,987
面板这里 
Xcode给了我一个总览


167
00:09:47,054 --> 00:09:49,022
让我知道接下来会发生什么


168
00:09:49,523 --> 00:09:51,258
我想多向你们谈谈细节


169
00:09:52,392 --> 00:09:55,095
像Watch OS 1
一样 Watch OS 2


170
00:09:55,162 --> 00:09:58,298
应用是由一个app
扩展功能和一个应用组成


171
00:09:59,066 --> 00:10:00,667
你的代码会进入
app扩展功能


172
00:10:00,734 --> 00:10:02,402
然后远程驱动app


173
00:10:03,203 --> 00:10:04,505
Watch OS 2
就不一样了


174
00:10:04,838 --> 00:10:08,342
app扩展功能和app都会
直接运行在watch上


175
00:10:08,775 --> 00:10:12,112
这样应用的响应性
和独立性都更好


176
00:10:12,880 --> 00:10:13,647
听起来很棒


177
00:10:13,714 --> 00:10:15,415
我来试一下


178
00:10:16,283 --> 00:10:17,184
发生了什么？


179
00:10:17,751 --> 00:10:19,319
Xcode帮我搞定了


180
00:10:19,386 --> 00:10:21,922
所有迁移项目设置到
Watch OS 2的细节


181
00:10:22,456 --> 00:10:23,857
昨天它帮我配置了构建


182
00:10:23,924 --> 00:10:25,993
我们发布的新Watch
OS SDK的


183
00:10:26,059 --> 00:10:26,793
Watch目标


184
00:10:27,294 --> 00:10:29,763
它帮我设置了Watch
OS 2 最低部署目标


185
00:10:30,297 --> 00:10:33,567
为它还帮我配置Watch
app扩展功能


186
00:10:33,634 --> 00:10:36,069
Watch app内部复制
这样当在Watch上安装时


187
00:10:36,136 --> 00:10:38,272
它们会一起移过去


188
00:10:38,972 --> 00:10:41,175
好的 这就是升级项目设置到
Watch OS 2的


189
00:10:41,241 --> 00:10:42,009
全部内容


190
00:10:43,410 --> 00:10:45,379
我们的Watch应用都
很美观、很轻便


191
00:10:46,280 --> 00:10:48,982
但是我们的iOS应用
却比较笨重


192
00:10:50,083 --> 00:10:52,452
这主要是因为
我的资源目录中的图片太多


193
00:10:53,520 --> 00:10:56,623
我想让资源变小
但又不想去除任何内容


194
00:10:57,324 --> 00:10:58,926
这就是新App 
Slicing特性


195
00:10:58,992 --> 00:10:59,893ddle
大显身手的时候了


196
00:11:00,561 --> 00:11:05,199
大家看到这些图像有1，2，
3x的不同表达了吧？


197
00:11:05,632 --> 00:11:07,434
有了App Slicing
Xcode 7


198
00:11:07,501 --> 00:11:08,969
就能和App
Store一起


199
00:11:09,036 --> 00:11:10,037
确保每台设备


200
00:11:10,103 --> 00:11:13,173
仅仅获取最最适合的单张图像


201
00:11:13,707 --> 00:11:16,510
这样就可以降低
30%到40%的应用大小


202
00:11:17,010 --> 00:11:18,946
最妙的是这基本上是自动的


203
00:11:19,446 --> 00:11:22,316
我只需在工作
资源目录中使用


204
00:11:22,449 --> 00:11:23,383
Xcode 7就行了


205
00:11:24,751 --> 00:11:28,422
但是如果你想把某些资源推
送给全体设备怎么办？


206
00:11:28,889 --> 00:11:32,125
我们扩展了Xcode 7的
资源目录


207
00:11:32,392 --> 00:11:33,694
以便支持任意数据


208
00:11:34,161 --> 00:11:35,662
你可以把任何数据放到这里


209
00:11:36,763 --> 00:11:38,131
我在目录下面这里


210
00:11:38,398 --> 00:11:39,666
有一个天际线文件夹


211
00:11:40,234 --> 00:11:43,704
里面是世界各地城市的
3D模型


212
00:11:44,037 --> 00:11:45,239
我们把这些模型展示给用户


213
00:11:45,305 --> 00:11:46,673
让他们猜是哪座城市


214
00:11:47,441 --> 00:11:52,279
我想把旧金山的
高质量模型


215
00:11:52,346 --> 00:11:54,248
加到游戏中


216
00:11:54,615 --> 00:11:57,017
但是只推送给最高端的设备


217
00:11:57,584 --> 00:11:58,252
没问题


218
00:11:58,685 --> 00:12:01,855
图像可以按照
比例因子和尺寸变动


219
00:12:02,155 --> 00:12:04,992
数据资产也可以
根据设备的性能特征变动，


220
00:12:05,459 --> 00:12:07,361
比如设备的内存大小


221
00:12:07,561 --> 00:12:08,929
GPU性能。


222
00:12:09,763 --> 00:12:12,933
我想给2G内存的设备
增加专用资源


223
00:12:14,201 --> 00:12:15,602
那么我只需要把高端资源


224
00:12:16,036 --> 00:12:18,338
拖动到这里来 就万事大吉了


225
00:12:18,539 --> 00:12:21,241
每台设备都能得到最佳资源


226
00:12:21,308 --> 00:12:22,309
而不用重付费


227
00:12:24,411 --> 00:12:25,078
好的


228
00:12:25,279 --> 00:12:27,114
现在我想向你展示点播资源


229
00:12:28,248 --> 00:12:30,651
它使得我们可以在
App Store中


230
00:12:30,717 --> 00:12:32,953
远程管理应用内容


231
00:12:34,621 --> 00:12:36,957
通过用字符串做标记


232
00:12:37,224 --> 00:12:39,326
我们把资源加进了点播资源中


233
00:12:39,793 --> 00:12:41,562
字符串可以是任何内容


234
00:12:42,196 --> 00:12:45,299
例如 如果我们是在开发游戏


235
00:12:45,365 --> 00:12:48,535
我们就可以根据关卡名称
标记构成某一个关卡的资源


236
00:12:49,203 --> 00:12:50,838
运行时 我们使用
NS Bundle


237
00:12:50,904 --> 00:12:52,539
Resource
Request 类


238
00:12:52,840 --> 00:12:55,242
就可以把整个
标签的资源提取到游戏中


239
00:12:55,576 --> 00:12:57,578
<br/> 
供本地快速访问


240
00:12:58,011 --> 00:13:00,614
我给你们展示一下
如何使用点播资源


241
00:13:01,815 --> 00:13:03,650
我先从目录中选择一个文件夹


242
00:13:03,984 --> 00:13:07,020
与游戏类型相关的
问题都在这里了


243
00:13:08,055 --> 00:13:09,056
我要在监视窗中


244
00:13:09,122 --> 00:13:11,391
使用新的点播资源标记


245
00:13:13,627 --> 00:13:15,629
把问题部分给标记出来


246
00:13:15,762 --> 00:13:17,931
我只需勾选它们为
点播资源托管即可


247
00:13:19,132 --> 00:13:21,134
那么你可以勾选
目录中的哪些东西呢？


248
00:13:21,902 --> 00:13:23,971
你可以像我一样
标记整个文件夹


249
00:13:24,505 --> 00:13:26,640
你也可以直接标记图像和数据


250
00:13:26,740 --> 00:13:28,242
你还可以标记
资源目录中的...


251
00:13:28,308 --> 00:13:29,610
Sprite
Atlases


252
00:13:29,676 --> 00:13:31,345
Sprite 
Atlases是...


253
00:13:31,411 --> 00:13:33,113
Xcode 7资源目录中的
一个新组件


254
00:13:33,514 --> 00:13:35,616
把你的Sprite 
Atlases放到目录中


255
00:13:35,682 --> 00:13:38,418
就激活了我之前提到的
Splicing 这一功能


256
00:13:39,686 --> 00:13:42,556
你还可以在Xcode项目中
标记松散文件


257
00:13:43,924 --> 00:13:48,662
我可以通过监视窗对某一文件
中的所有标签进行总览


258
00:13:49,196 --> 00:13:51,164
如果我想看到
某个标签中的文件


259
00:13:51,231 --> 00:13:53,033
或者所有标签中的
全部文件，该怎么办？


260
00:13:53,667 --> 00:13:55,736
我可以到 Project
Editor


261
00:13:56,470 --> 00:13:57,137
选择我们的


262
00:13:57,204 --> 00:13:58,505
Application
Target


263
00:13:58,572 --> 00:14:00,374
然后再到 New
Resource 标签中


264
00:14:00,607 --> 00:14:02,042
就可以看到我的全部标签了


265
00:14:02,376 --> 00:14:04,778
如你所见
之前我标记了很多内容


266
00:14:05,913 --> 00:14:09,683
这里可以进行总览 
确保一致性不出问题


267
00:14:11,118 --> 00:14:13,887
例如 我发现这个
标签和其它格式不一致


268
00:14:13,954 --> 00:14:16,323
缺少问号后缀


269
00:14:16,990 --> 00:14:17,691
没问题


270
00:14:19,226 --> 00:14:22,429
我一下子就编辑 更新好了


271
00:14:24,598 --> 00:14:27,301
我们的内容在
点播资源中有标签


272
00:14:28,068 --> 00:14:30,571
现在我演示下
如何在代码中调用


273
00:14:30,838 --> 00:14:33,841
现在是新NS Bundle
资源请求类大显身手的时候了


274
00:14:34,775 --> 00:14:38,312
游戏分类中有两个回调非常
适合这种情景


275
00:14:38,745 --> 00:14:40,747
启用类和终止类


276
00:14:41,815 --> 00:14:43,917
它们非常适用于点播资源 


277
00:14:43,984 --> 00:14:45,752
有两个原因 
第一 它们会适时归类， 


278
00:14:45,853 --> 00:14:49,389
第二 它们发生在
用户启动游戏前


279
00:14:49,456 --> 00:14:51,425
但是我们一知道用户要玩游戏


280
00:14:51,558 --> 00:14:53,493
我们就可以
对点播资源进行预取


281
00:14:54,761 --> 00:14:56,864
我用一个实例变量来延迟


282
00:14:56,930 --> 00:14:58,899
一个 NS Bundle
资源请求


283
00:14:59,867 --> 00:15:02,970
NS Bundle资源请求
是由标签证实的


284
00:15:03,036 --> 00:15:05,072
别忘了 
标签就是简单的字符串


285
00:15:05,572 --> 00:15:09,810
我在类名后面附加批问题
来构成标签


286
00:15:11,278 --> 00:15:14,948
然后我就可以
通过标签创建丛资源请求


287
00:15:16,283 --> 00:15:19,019
最后 我要使用
新的开始获取资源


288
00:15:19,419 --> 00:15:22,589
来完成处理程序方法
来调用请求


289
00:15:23,090 --> 00:15:25,325
这是一种在后台运行的
异步方法


290
00:15:25,926 --> 00:15:27,628
它会从store中下载
全部内容


291
00:15:28,095 --> 00:15:30,330
下载完后会激发完成处理程序


292
00:15:31,031 --> 00:15:34,902
只要它开始运行
我不说资源请求不用了


293
00:15:35,202 --> 00:15:37,638
所有内容的
本地访问一直会很快


294
00:15:38,172 --> 00:15:39,206
我爱死这个了


295
00:15:39,606 --> 00:15:42,743
我已经在用的相同
API的内容都有了


296
00:15:43,010 --> 00:15:44,611
NS Bundle、
Path of


297
00:15:44,678 --> 00:15:46,446
Resource、 
UI Image、


298
00:15:46,513 --> 00:15:48,615
Image Name、
 Texture Name


299
00:15:48,682 --> 00:15:50,717
这些方法的用法
都和之前一模一样


300
00:15:50,984 --> 00:15:55,255
我的应用中其它的
资源了望码都没有变


301
00:15:57,357 --> 00:15:59,927
现在 所有的内容都可用


302
00:15:59,993 --> 00:16:01,895
直到我说不用 
NS Bundle资源请求


303
00:16:01,962 --> 00:16:02,663
我是怎样做的？


304
00:16:03,263 --> 00:16:05,399
在终止类这一方法中


305
00:16:05,899 --> 00:16:09,703
我会调用结束访问 NS
Bundle 资源请求


306
00:16:10,370 --> 00:16:13,040
我读取到缓存中的
内容都删掉了


307
00:16:13,440 --> 00:16:16,643
以后可以继续访问


308
00:16:16,844 --> 00:16:18,378
并且当系统空间不足时


309
00:16:18,445 --> 00:16:19,947
这里会标记为“可清除”


310
00:16:20,881 --> 00:16:24,184
这样我们就搞定了点播资源
所需的代码


311
00:16:24,251 --> 00:16:25,919
我想构建并运行
我们的游戏


312
00:16:26,987 --> 00:16:27,855
开始新游戏


313
00:16:28,822 --> 00:16:30,858
我要演示使用点播资源时的


314
00:16:31,191 --> 00:16:32,593
一些调试功能


315
00:16:33,727 --> 00:16:37,264
调试导航器这里我要选择磁盘


316
00:16:37,331 --> 00:16:41,835
得到磁盘报告 了解应用
在磁盘上的使用情况


317
00:16:42,569 --> 00:16:45,873
我们已经在Xcode 7
这里添加了点播资源标签


318
00:16:46,273 --> 00:16:49,409
在“我的标签”内 你可以
看到它们的大小和当前状态


319
00:16:50,210 --> 00:16:52,145
现在标记为
“未下载”状态的


320
00:16:52,880 --> 00:16:55,215
都由Xcode扮演了
app store的角色


321
00:16:55,549 --> 00:16:58,886
我所有的资源都在Xcode
还没有到模拟器


322
00:16:59,386 --> 00:17:01,221
但是 我点击其中的一个类


323
00:17:02,623 --> 00:17:05,858
我们在后台运行的代码
就会下载内容


324
00:17:05,992 --> 00:17:07,895
现在 “我的标签”
的状态成了“使用中”


325
00:17:08,529 --> 00:17:10,097
我换一个类


326
00:17:10,731 --> 00:17:12,900
你就可以看到
第一个内容从缓存中删除了


327
00:17:13,165 --> 00:17:14,101
“已下载”标记还在


328
00:17:14,468 --> 00:17:16,537
现在正在使用的是
“技术问题”


329
00:17:17,171 --> 00:17:19,006
这就是Slicing 
和点播资源


330
00:17:19,606 --> 00:17:22,675
有了应用 Slicing 
我们就能把iPhone 6


331
00:17:22,742 --> 00:17:27,814
应用的大小从140多MB
降到不足100MB


332
00:17:28,515 --> 00:17:30,083
有了点播资源
我们还能进一步


333
00:17:30,184 --> 00:17:33,887
把初始安装包的
大小降到30MB


334
00:17:34,354 --> 00:17:36,990
现在用户启动游戏就更快了


335
00:17:37,391 --> 00:17:38,192
又轮到你了 肯


336
00:17:45,933 --> 00:17:46,967
肯奥尔：谢谢 乔恩


337
00:17:50,003 --> 00:17:51,738
今年 为了直接增强
你的app品质


338
00:17:51,805 --> 00:17:57,144
我们引入了很多新的特性


339
00:17:58,445 --> 00:18:00,480
我们先来谈谈调试和剖析


340
00:18:02,382 --> 00:18:06,787
Xcode 7我们给iOS
app引入了电量刻度


341
00:18:07,521 --> 00:18:11,458
IOS 9会对比
每进程消耗的电量


342
00:18:11,692 --> 00:18:14,127
会在右边的电量报告这里显示


343
00:18:15,596 --> 00:18:18,065
Xcode中的量规能让你


344
00:18:18,298 --> 00:18:21,134
预期情况和现实情况...


345
00:18:21,468 --> 00:18:23,871
进行对比


346
00:18:24,471 --> 00:18:26,974
如果你发现电量使用中


347
00:18:27,207 --> 00:18:29,910
有尖峰而应用又处于空闲状态


348
00:18:30,310 --> 00:18:33,280
这就提示你可能有问题了


349
00:18:33,780 --> 00:18:36,016
当你遇到此类问题时


350
00:18:36,250 --> 00:18:38,318
你就知道到底应该看哪处代码


351
00:18:39,386 --> 00:18:43,790
或者 你可以跳转到
Xcode 的各个报表的


352
00:18:43,857 --> 00:18:45,359
Instruments
那里


353
00:18:46,059 --> 00:18:49,963
从电量报告那里我们可以跳转
到New Location


354
00:18:50,230 --> 00:18:52,566
仪表那里
然后就可以知道


355
00:18:52,633 --> 00:18:55,969
是否有效利用了
核心位置API


356
00:18:56,703 --> 00:19:01,475
我们可以知道
是否过多请求了用户位置？


357
00:19:02,576 --> 00:19:05,913
是否请求的用户
位置的精度过高？


358
00:19:07,447 --> 00:19:09,516
这些请求很耗电


359
00:19:09,750 --> 00:19:12,653
我们就可以检查一下


360
00:19:14,021 --> 00:19:15,389
iOS中还有一个新...


361
00:19:15,489 --> 00:19:18,325
Metal System 
Trace 工具


362
00:19:18,392 --> 00:19:23,997
你可以了解你的代码
是如何影响帧频的


363
00:19:24,665 --> 00:19:29,036
硬件渲染显卡驱动能让你了解


364
00:19:29,436 --> 00:19:33,273
整个 Graphic 
Stack 功能很强大


365
00:19:34,741 --> 00:19:36,777
你或许还注意到
Instruments


366
00:19:37,144 --> 00:19:39,279
这里有一个重新
设计了的轨迹视图


367
00:19:40,314 --> 00:19:41,515
更清晰了 


368
00:19:42,583 --> 00:19:45,786
并且用起来也更加顺手


369
00:19:46,320 --> 00:19:47,955
通过双指缩放等手势


370
00:19:48,222 --> 00:19:51,658
在数据中导航也很容易


371
00:19:53,193 --> 00:19:55,162
新Instruments 
就介绍到这里


372
00:19:58,098 --> 00:19:59,800le
我敢说


373
00:20:00,434 --> 00:20:02,536
这里的每个开发人员


374
00:20:02,803 --> 00:20:06,840
都遇到过客户报告崩溃了


375
00:20:08,775 --> 00:20:10,344
但你就是没法重现的问题


376
00:20:11,245 --> 00:20:11,912
好的


377
00:20:12,312 --> 00:20:13,614
总有那么一两次吧？


378
00:20:15,082 --> 00:20:16,016
Xcode 7中的


379
00:20:16,083 --> 00:20:17,684
Address
Sanitizer


380
00:20:17,751 --> 00:20:18,452
能助你一臂之力


381
00:20:20,053 --> 00:20:21,655
Address
Sanitizer


382
00:20:21,722 --> 00:20:23,290
会把你的
Objective-C


383
00:20:23,357 --> 00:20:24,091
编译成C代码 


384
00:20:24,625 --> 00:20:28,128
并捕获类似缓冲区溢出的事件


385
00:20:28,362 --> 00:20:32,132
一发生这种事件就可以捕获


386
00:20:32,766 --> 00:20:36,970
Xcode会停在造成这个
问题的那行代码那里


387
00:20:37,604 --> 00:20:40,274
这个新调试特性很厉害


388
00:20:40,974 --> 00:20:42,509
凯特 会给大家演示一下


389
00:20:42,576 --> 00:20:44,178
Address
Sanitizer


390
00:20:49,383 --> 00:20:51,118
凯特·斯通：谢谢 肯


391
00:20:51,185 --> 00:20:53,787
我们的小游戏很适合
和朋友一起玩


392
00:20:54,288 --> 00:20:57,858
但是有时启动游戏时会崩溃


393
00:20:58,992 --> 00:21:01,595
崩溃很难预测
这种故障也很难重现


394
00:21:01,662 --> 00:21:04,665
很难弄清楚原因


395
00:21:05,632 --> 00:21:07,367
你肯定遇到过类似情况 


396
00:21:07,434 --> 00:21:11,572
因为我听说有人会使用指针
来明确地管理内存


397
00:21:13,941 --> 00:21:15,976
这个游戏很美


398
00:21:16,777 --> 00:21:19,179
我们可以开始新游戏


399
00:21:19,880 --> 00:21:20,681
选择一个类


400
00:21:21,815 --> 00:21:25,586
再选择一些用户
好了


401
00:21:26,220 --> 00:21:28,889
看起来很不错 突然...


402
00:21:29,223 --> 00:21:33,293
现在在关卡中 正好重现问题


403
00:21:33,427 --> 00:21:34,528
故障不好找


404
00:21:35,996 --> 00:21:37,297
我们看看这个


405
00:21:37,364 --> 00:21:39,099
是在哪里崩溃的呢？


406
00:21:39,166 --> 00:21:40,067
我怎么调试？


407
00:21:40,934 --> 00:21:43,904
是主类崩溃了


408
00:21:44,505 --> 00:21:46,807
我在那里根本就没写代码


409
00:21:47,007 --> 00:21:49,409
Stack Trace里面
也没有任何提示


410
00:21:49,776 --> 00:21:51,712
这种故障最难处理了


411
00:21:52,279 --> 00:21:54,481
幸亏Address 
Sanitizer能帮上忙


412
00:21:55,115 --> 00:21:58,752
在Xcode中
我们有很多此类诊断工具


413
00:21:58,986 --> 00:22:00,787
你只需要在Scheme
Editor中


414
00:22:00,854 --> 00:22:01,755
运行你的app即可


415
00:22:02,122 --> 00:22:04,958
当我在Scheme 
Editor中点击Run时


416
00:22:05,025 --> 00:22:06,560
<c.color000000><u> </u></c>我会按下选项这个快捷键


417
00:22:07,661 --> 00:22:09,830
我可以对应用的运行方式
进行配置


418
00:22:10,130 --> 00:22:11,832
其中
Diagnostics标记


419
00:22:12,165 --> 00:22:14,768
能让你选择一些旧工具


420
00:22:15,002 --> 00:22:17,337
以及Address
Sanitizer这新工具


421
00:22:17,771 --> 00:22:19,373
Address 
Sanitizer


422
00:22:19,439 --> 00:22:20,841
会重新编译应用 
添加许多新工具


423
00:22:21,008 --> 00:22:23,143
告诉我哪里失效了


424
00:22:23,577 --> 00:22:25,612
以及为什么失效了


425
00:22:25,979 --> 00:22:29,349
这一点与众不同


426
00:22:30,517 --> 00:22:33,620
我们重新运行一下应用看看


427
00:22:34,922 --> 00:22:36,757
现在我发现 当我选择一个类


428
00:22:36,924 --> 00:22:40,427
并移动到下个页面时
应用马上停止了


429
00:22:40,661 --> 00:22:43,830
就是这里发生了内存崩溃


430
00:22:44,364 --> 00:22:47,267
这样我在应用急刹车之前


431
00:22:47,334 --> 00:22:49,670
就能找到问题所在


432
00:22:50,470 --> 00:22:53,373
此时我就知道具体


433
00:22:53,774 --> 00:22:55,375
是停在了哪个堆栈上 
是我调用的某个


434
00:22:55,442 --> 00:22:57,110
Objective-C
代码有问题


435
00:22:57,878 --> 00:23:01,215
并不是每个人都能
全部用Swift写代码


436
00:23:01,515 --> 00:23:03,617
事实上 这个游戏就是
用Objective-C


437
00:23:03,684 --> 00:23:06,286
框架封装C代码写成


438
00:23:06,353 --> 00:23:08,455
我们的问题就出在这里


439
00:23:09,022 --> 00:23:10,457
我不熟悉这种代码。


440
00:23:10,524 --> 00:23:13,227
是我要看看调用的代码


441
00:23:13,293 --> 00:23:14,261
用Swift写的


442
00:23:15,028 --> 00:23:17,898
我正在调用一些登录API


443
00:23:18,432 --> 00:23:21,535
它告诉我到底哪里出故障了


444
00:23:21,869 --> 00:23:23,403
但没说原因


445
00:23:24,505 --> 00:23:26,807
再往侦错导航栏下面看


446
00:23:27,207 --> 00:23:30,244
我发现Address 
Sanitizer 


447
00:23:30,310 --> 00:23:32,846
还告诉我我使用了已经
释放的内存


448
00:23:32,913 --> 00:23:35,382
这就是问题的根源所在


449
00:23:36,316 --> 00:23:39,953
我可以从侦错导航栏中
看到具体是哪个内存


450
00:23:40,320 --> 00:23:43,023
我正在读取一个
50字节热区的首个字节


451
00:23:43,090 --> 00:23:44,424
而这里已经分配出去了


452
00:23:45,192 --> 00:23:48,762
我还可以再点击下
实际看下内存


453
00:23:48,829 --> 00:23:51,798
它之前是用来保存日志消息的


454
00:23:52,299 --> 00:23:53,901
Address 
Sanitizer


455
00:23:54,401 --> 00:23:55,903
用灰色告诉我 这个内存无效


456
00:23:56,136 --> 00:24:00,707
我不应该再继续读取这个内存


457
00:24:01,475 --> 00:24:02,809
它还给了我


458
00:24:02,910 --> 00:24:05,646
内存初始分配调用堆栈


459
00:24:05,712 --> 00:24:09,116
我就知道是我在创建
有意义的使用日志时


460
00:24:09,850 --> 00:24:13,654
产生的更重要的是 
告诉我当时内存分配到了哪里


461
00:24:14,688 --> 00:24:17,724
我能看出来 是我调用


462
00:24:18,358 --> 00:24:20,627
终止登录那个设计欠佳的
API时发生的


463
00:24:20,794 --> 00:24:23,230
我本来以为它只会清除登录


464
00:24:23,497 --> 00:24:26,300
但它却搞坏了关键资源


465
00:24:26,900 --> 00:24:28,402
让我们快速解决这个问题


466
00:24:29,303 --> 00:24:30,737
我把这行代码拿掉


467
00:24:30,804 --> 00:24:33,106
每次录入消息时不再调用它


468
00:24:33,507 --> 00:24:35,843
而改成仅在销毁时调用


469
00:24:37,110 --> 00:24:39,112
连同工具 Address
Sanitizer


470
00:24:39,179 --> 00:24:39,947
重构了应用


471
00:24:40,013 --> 00:24:43,016
仍然很好用 仍然能交互使用


472
00:24:43,083 --> 00:24:46,954
但我还能更进一步


473
00:24:47,020 --> 00:24:50,524
现在一切正常了
除非再有问题


474
00:24:52,526 --> 00:24:54,127
Address 
Sanitizer


475
00:24:54,194 --> 00:24:56,463
不仅仅能提示已释放的内存


476
00:24:56,730 --> 00:24:58,198
它还能告诉我缓冲区溢出


477
00:24:58,265 --> 00:25:01,635
并告诉我正在溢出的流


478
00:25:01,969 --> 00:25:05,272
和堆栈内存


479
00:25:05,739 --> 00:25:07,841
这是件非常强大的工具


480
00:25:08,342 --> 00:25:11,712
你现在就应该把这件工具
用在你的应用上 


481
00:25:11,879 --> 00:25:14,381
找出所有潜藏的内存问题


482
00:25:15,215 --> 00:25:17,551
我们尽量让它容易上手


483
00:25:18,118 --> 00:25:20,320
因为Address 
Sanitizer不仅能以


484
00:25:20,854 --> 00:25:22,890
这种交互方式运行，


485
00:25:23,223 --> 00:25:25,292
你还能把它用在
Xcode服务器中


486
00:25:25,359 --> 00:25:27,194
这样你就能
用它做一系列测试


487
00:25:27,394 --> 00:25:31,598
代码出现问题时及时发现问题


488
00:25:33,734 --> 00:25:35,836
你想尽量减少崩溃次数


489
00:25:35,903 --> 00:25:38,739
但老实说 彻底杜绝崩溃
是不可能的


490
00:25:39,306 --> 00:25:41,975
所以我请板井
给大家讲讲Xcode


491
00:25:42,042 --> 00:25:45,379
如何能帮助你分析得到的


492
00:25:45,445 --> 00:25:46,146
崩溃日志


493
00:25:57,391 --> 00:25:58,492
板井·罗姆：谢谢 凯特


494
00:25:58,559 --> 00:25:59,426
大家早上好


495
00:26:00,460 --> 00:26:02,963
Apple开发者项目成员
可以读取


496
00:26:03,030 --> 00:26:04,565
Xcode中的新崩溃日志


497
00:26:05,232 --> 00:26:06,433
当你通过
App Store


498
00:26:06,500 --> 00:26:08,135
或者TestFlight
分发你的app 


499
00:26:08,202 --> 00:26:10,137
并把符号信息包含在内时


500
00:26:10,437 --> 00:26:12,172
我们会从用户那里
收集崩溃日志


501
00:26:13,040 --> 00:26:17,177
这些日志会聚合成崩溃报告


502
00:26:17,244 --> 00:26:19,279
下载到Xcode中 
你就可以在配置窗口中


503
00:26:19,346 --> 00:26:21,949
查看并分析这些日志


504
00:26:23,116 --> 00:26:25,519
这种集成是无缝的
你可以很容易地


505
00:26:25,586 --> 00:26:28,322
找出并修复关键问题


506
00:26:28,755 --> 00:26:29,923
我来告诉你如何使用


507
00:26:33,827 --> 00:26:35,529
去年 我们引入了
TestFlight


508
00:26:36,263 --> 00:26:38,065
TestFlight是一项
便捷的服务


509
00:26:38,131 --> 00:26:39,600
能够分发你的
apps测试版本


510
00:26:39,666 --> 00:26:42,636
和Xcode中的崩溃日志
配合的很好


511
00:26:43,470 --> 00:26:46,473
昨天我们刚刚分发了
游戏的一个测试版


512
00:26:46,874 --> 00:26:49,309
用户报告了一些崩溃


513
00:26:49,376 --> 00:26:50,744
我想找出并修复


514
00:26:52,479 --> 00:26:53,614
我先启动Xcode


515
00:26:54,147 --> 00:26:55,382
我已经在Xcode的
Account


516
00:26:55,449 --> 00:26:57,117
Preferences
面板中输入了


517
00:26:57,184 --> 00:26:59,486
我的Apple ID 
所以我只需要打开配置窗口


518
00:26:59,553 --> 00:27:02,623e
查看崩溃日志就可以了


519
00:26:59,553 --> 00:27:02,623
查看崩溃日志就可以了


520
00:27:04,491 --> 00:27:07,160
窗口左边是Xcode下载的
我的研发团队通过


521
00:27:07,227 --> 00:27:08,929
iTunes 
Connect 上传到


522
00:27:08,996 --> 00:27:10,797
App Store或
TestFlight的


523
00:27:10,864 --> 00:27:13,600
与apps相关的全部信息


524
00:27:14,434 --> 00:27:15,369
我选择好游戏


525
00:27:16,436 --> 00:27:19,940
我可以从右边选择想要的版本


526
00:27:20,541 --> 00:27:23,310
列表最上面的55号版本


527
00:27:23,377 --> 00:27:25,279
是昨天通过
TestFlight分发的


528
00:27:25,345 --> 00:27:26,079
我点击它


529
00:27:27,781 --> 00:27:31,185
Xcode会在下面下载
全部最近的崩溃信息


530
00:27:31,985 --> 00:27:35,389
它们会按照出现频率排序 
列表最上面的


531
00:27:35,822 --> 00:27:38,859
当然就是测试者
遇到最多的问题


532
00:27:40,394 --> 00:27:42,763
在右边我能看到
崩溃的回溯跟踪


533
00:27:44,131 --> 00:27:46,266
Xcode会很贴心地
以美丽的浅澄色


534
00:27:46,333 --> 00:27:48,268
高亮其中的一个
Stack框架 


535
00:27:49,069 --> 00:27:51,271
这样我就知道app 
可能有问题


536
00:27:52,940 --> 00:27:55,509
尤其是使用日志和登录方法中


537
00:27:55,576 --> 00:27:57,511
app发生崩溃的地方


538
00:27:58,378 --> 00:28:01,248
这与凯特刚才使用
Address 


539
00:28:01,315 --> 00:28:03,317
Sanitizer
捕获并修复的崩溃很相似


540
00:28:03,517 --> 00:28:05,552
我最喜欢这种故障报告
因为会自动修复


541
00:28:05,619 --> 00:28:07,020
我看着就行


542
00:28:08,722 --> 00:28:10,657
我会点击窗口上面的
这个按钮


543
00:28:10,724 --> 00:28:11,959
把它标记为“已解决”。


544
00:28:13,460 --> 00:28:17,097
通过点击窗口下方的过滤器


545
00:28:17,598 --> 00:28:19,733
我还能让Xcode 
过滤已经解决的崩溃


546
00:28:21,502 --> 00:28:24,171
我可以集中精力
解决尚未修复的崩溃


547
00:28:25,172 --> 00:28:26,473
我们刚才已经小试身手了


548
00:28:26,540 --> 00:28:27,875
让我们再来看看下个崩溃


549
00:28:28,642 --> 00:28:31,478
这次是在启动画面视图控制
器内部崩溃的


550
00:28:31,812 --> 00:28:34,481
即app漂亮的着陆页那里
你可以在那里看到


551
00:28:34,548 --> 00:28:35,883
由你的朋友的图像组成的网格


552
00:28:36,183 --> 00:28:37,851
我们想编一个阵列索引


553
00:28:38,018 --> 00:28:39,987
但是我们的索引可能
超过了阵列界限


554
00:28:40,053 --> 00:28:41,688
我想修复这个崩溃


555
00:28:42,389 --> 00:28:44,725
我会点击Open
和Project按钮


556
00:28:44,791 --> 00:28:48,362
先点击后者
再点击前者 回到代码中


557
00:28:50,364 --> 00:28:52,533
现在Xcode不仅
打开了我的项目 


558
00:28:52,633 --> 00:28:54,868
还神奇地把我刚刚
在右边整理器中


559
00:28:54,935 --> 00:28:56,503
查看的崩溃报告传送到了


560
00:28:56,937 --> 00:28:59,239
侦错导航器那里
我就可以点击


561
00:28:59,306 --> 00:29:00,774
Stack Frames，


562
00:29:00,841 --> 00:29:04,278
并导航崩溃报告和源代码


563
00:29:06,280 --> 00:29:08,615
我们好像遇到了下一影像法


564
00:29:09,383 --> 00:29:12,152
这看起来像是乔恩昨天


565
00:29:12,219 --> 00:29:14,054
到我办公室谈到的
他遇到的崩溃


566
00:29:15,322 --> 00:29:17,824
我们正在给朋友图像阵列


567
00:29:17,891 --> 00:29:20,494
编索引并增加一个计数器


568
00:29:21,495 --> 00:29:24,231
我们到达阵列边缘时
我们把计数器设回零


569
00:29:24,598 --> 00:29:28,035
这里有一个
容易忽略的错误


570
00:29:28,368 --> 00:29:30,304
这里应该相等或者更大


571
00:29:30,370 --> 00:29:31,438
我来修复它


572
00:29:32,339 --> 00:29:34,274
如果你的朋友数量不是很多


573
00:29:34,341 --> 00:29:35,475
你就很容易遇到这个崩溃


574
00:29:35,809 --> 00:29:37,611
看来乔恩能发现
这个问题不是没有原因的


575
00:29:39,780 --> 00:29:42,249
现在我回到整理器中
修复更多崩溃


576
00:29:42,516 --> 00:29:43,917
Xcode中的
新崩溃日志功能


577
00:29:43,984 --> 00:29:45,185
和TestFlight
配合的很好


578
00:29:45,252 --> 00:29:46,420
能在你推送给客户之前


579
00:29:46,486 --> 00:29:50,457
帮助你发现并修复
大多数关键问题


580
00:29:50,924 --> 00:29:51,792
肯 ̆轮到你了


581
00:30:00,467 --> 00:30:01,468
肯奥尔：谢谢你 板井


582
00:30:03,871 --> 00:30:09,142
测试 过去几年来 
我们一直在向Xcode中


583
00:30:09,343 --> 00:30:11,178
添加测试支持


584
00:30:11,545 --> 00:30:15,949
让你能测试应用中
越来越多的部分


585
00:30:16,783 --> 00:30:19,486
Xcode 5中我们添加了
一个Test导航器


586
00:30:19,853 --> 00:30:23,223
把这个和助理编辑器结合起来


587
00:30:23,290 --> 00:30:25,225
我们的测试驱动
开发工作流程就很完美了


588
00:30:25,959 --> 00:30:29,162
我们已经介绍了
XC Test单元测试框架


589
00:30:30,063 --> 00:30:33,567
再加上Bots 
你就可以自动在Xcode


590
00:30:34,001 --> 00:30:36,470
服务器上跑单元测试
实现持续集成


591
00:30:37,738 --> 00:30:40,607
Xcode 6中我们
引入了性能测试


592
00:30:40,874 --> 00:30:43,177
让你很快找出性能回归


593
00:30:43,877 --> 00:30:46,680
并为异步API添加测试


594
00:30:47,881 --> 00:30:52,519
在Xcode 7中 
我们还引入了用户界面测试


595
00:30:54,087 --> 00:30:56,857
UI测试使你能够
试app中用户真正看到


596
00:30:57,391 --> 00:31:00,160
触摸的那一部分


597
00:31:01,261 --> 00:31:02,963
此类测试非常重要
因为它们能够帮助你


598
00:31:03,197 --> 00:31:06,066
确保app运行时始终


599
00:31:06,133 --> 00:31:08,669
和初始目的保持一致


600
00:31:09,269 --> 00:31:11,772
即使你稍后做出变动
改进也不影响


601
00:31:14,875 --> 00:31:17,911
和我们添加到Xcode中的
其它测试功能一样


602
00:31:18,278 --> 00:31:20,480
UI Tests也和
code 服务器配合的很好


603
00:31:21,882 --> 00:31:23,617
这对UI Test来说
十分重要


604
00:31:24,218 --> 00:31:26,386
因为运行它们耗时比较久


605
00:31:27,287 --> 00:31:29,890
在Xcode服务器上
你还能使用


606
00:31:29,957 --> 00:31:32,326
比你自己办公桌上多的多设备


607
00:31:33,193 --> 00:31:35,596
这样你的测试覆盖范围更广


608
00:31:36,330 --> 00:31:38,265
频率更高


609
00:31:39,933 --> 00:31:41,935
说到覆盖范围
为了完善Xcode 7 


610
00:31:42,002 --> 00:31:44,137
我们还添加了测试 Code
Coverage


611
00:31:44,771 --> 00:31:49,176
你可以在Schemes 
Test action这里


612
00:31:49,243 --> 00:31:51,178
打开 Code
Coverage


613
00:31:51,845 --> 00:31:54,414
当你打开后Xcode
在编译你的app时


614
00:31:54,581 --> 00:31:56,083
会使用特殊工具


615
00:31:56,550 --> 00:32:00,087
轻松跟踪执行的各行代码


616
00:32:00,888 --> 00:32:02,689
你运行一系列测试后


617
00:32:03,190 --> 00:32:05,325
你会注意到源代码
编辑器右边这里


618
00:32:05,392 --> 00:32:07,561
有一个 New Code
Coverage 栏


619
00:32:08,562 --> 00:32:10,497
你可以很快对调用的代码


620
00:32:10,564 --> 00:32:14,001
有一个直观感受


621
00:32:15,068 --> 00:32:17,638
更重要的是 你可以知道 
哪行代码未被调用


622
00:32:18,805 --> 00:32:22,342
琼会给大家演示下
Xcode 7的UI测试


623
00:32:29,516 --> 00:32:30,551
琼威·福尔：谢谢 肯


624
00:32:31,818 --> 00:32:34,788
使用Xcode中的UI
Testing 真的很容易


625
00:32:36,957 --> 00:32:41,662
像这样 你添加一个新
UI Testing目标


626
00:32:42,362 --> 00:32:44,631
如果你之前用过单元测试


627
00:32:44,798 --> 00:32:46,733
你可以把它
当做一个为你创建的


628
00:32:47,201 --> 00:32:49,102
测试用例子类别和方法


629
00:32:50,070 --> 00:32:52,472
如果这是一个单元测试


630
00:32:52,573 --> 00:32:55,242
你就需要徒手写出测试方法


631
00:32:56,109 --> 00:32:58,679
但现在 我们通过记录应用


632
00:32:58,846 --> 00:33:01,915
为你写好了测试方法


633
00:33:02,416 --> 00:33:03,150
我们来看一下


634
00:33:08,388 --> 00:33:10,924
我把光标放到Test
Method这里


635
00:33:11,124 --> 00:33:14,261
点击窗口底部的


636
00:33:14,528 --> 00:33:16,530
Record按钮 开始记录


637
00:33:18,365 --> 00:33:22,336
记录过程中我的
应用收到的任何事件


638
00:33:22,402 --> 00:33:24,605
都会把源代码投射到我的
Test Method中


639
00:33:25,372 --> 00:33:27,574
我要配置一个新游戏进行测试


640
00:33:27,808 --> 00:33:30,210
我会点击开始新游戏按钮


641
00:33:34,648 --> 00:33:37,084
注意 我点击按钮后
对应的那行代码


642
00:33:37,150 --> 00:33:39,386
就立即在源码编辑器中
显示了出来


643
00:33:41,255 --> 00:33:42,723
我要选一个类


644
00:33:42,890 --> 00:33:44,725
这次测试
我选择sci-fi。


645
00:33:46,393 --> 00:33:50,130
点击下一步 
我会邀请几个玩家


646
00:33:50,464 --> 00:33:52,466
爱丽丝 布兰登 


647
00:33:52,866 --> 00:33:54,935
我搜索一下史黛西


648
00:33:56,904 --> 00:33:57,571
找到了


649
00:33:59,439 --> 00:34:00,107
我点击下


650
00:34:00,874 --> 00:34:05,913
点击下一步 最后点击开关
标记游戏为“准备就绪”


651
00:34:07,381 --> 00:34:10,184
这样我就搞定了
想要记录的内容


652
00:34:10,317 --> 00:34:12,553
我们看看最后得到了什么


653
00:34:15,621 --> 00:34:17,456
第一行代码中包含了


654
00:34:17,658 --> 00:34:20,027
一条寻找标记为开始
新游戏的按钮的查询


655
00:34:20,594 --> 00:34:23,730
然后返回了一个元素


656
00:34:24,264 --> 00:34:26,266
这个元素是应用中
实际按钮的代理


657
00:34:27,100 --> 00:34:29,937
经由这个元素我现在就可以
读取按钮属性


658
00:34:30,003 --> 00:34:32,639
并发送事件
即一次屏幕触摸


659
00:34:35,775 --> 00:34:38,145
下面几行代码
包含了选择sci-fi类


660
00:34:38,212 --> 00:34:41,514
点击“下一步”按钮的
源代码


661
00:34:44,150 --> 00:34:46,853
UI Testing 
APIs设计的非常易读


662
00:34:47,254 --> 00:34:49,889
你能看到写很容易


663
00:34:50,324 --> 00:34:52,793
因此能帮你进行鲁棒测试


664
00:34:54,862 --> 00:34:57,097
既然是测试， 
那就需要真的测试某些东西，


665
00:34:57,164 --> 00:34:59,733
它也确实这么做了


666
00:35:00,767 --> 00:35:02,803
如果我原样运行测试，
它会隐性验证


667
00:35:02,903 --> 00:35:05,472
我交互的所有控件


668
00:35:05,873 --> 00:35:09,343
同时 我还能继续记录


669
00:35:09,409 --> 00:35:12,346
并且如果通不过测
试就让其失败


670
00:35:14,114 --> 00:35:16,016
除了这一隐性验证


671
00:35:16,083 --> 00:35:17,551
我还非常希望在测试中


672
00:35:17,684 --> 00:35:20,254
在不同的点上


673
00:35:20,320 --> 00:35:22,990
对我的应用的其它方面
进行显性验证


674
00:35:24,157 --> 00:35:27,094
在这个测试中 
我选择了一个特定类


675
00:35:27,528 --> 00:35:29,596
并邀请了一组特定的玩家


676
00:35:30,931 --> 00:35:33,467
我们再向测试中添加几组声明


677
00:35:33,534 --> 00:35:35,235
确保我们得得到想要的结果


678
00:35:40,240 --> 00:35:44,444
这些声明验证了
应用中上一个屏幕中


679
00:35:44,511 --> 00:35:45,979
UI有包含类名


680
00:35:46,313 --> 00:35:49,650
以及玩家名称的元素


681
00:35:51,485 --> 00:35:53,287
有了这些声明，
我就可以运行测试


682
00:35:53,387 --> 00:35:55,923
确保它如期工作


683
00:36:05,132 --> 00:36:05,799
没问题


684
00:36:18,145 --> 00:36:19,613
测试通过了


685
00:36:27,354 --> 00:36:28,956
琼威·福尔：这是对
Xcode 7中


686
00:36:29,022 --> 00:36:30,224
测试的快速概览


687
00:36:31,625 --> 00:36:33,227
建议你们都试试


688
00:36:33,927 --> 00:36:35,028
你会爱上它的


689
00:36:35,395 --> 00:36:37,464
最重要的是
你们的客户会爱上它


690
00:36:38,198 --> 00:36:38,866
又轮到你了 肯


691
00:36:47,007 --> 00:36:48,175
肯奥尔：很好 谢谢你 琼


692
00:36:50,911 --> 00:36:51,645
今天上午


693
00:36:51,845 --> 00:36:54,381
我们仅仅看了少数几项特性


694
00:36:55,682 --> 00:36:57,684
但愿它们激起了你的兴趣


695
00:36:58,118 --> 00:37:00,153
本周你还会看到
更多不错的会话


696
00:37:00,220 --> 00:37:01,622
让你能够更加深入了解


697
00:37:01,688 --> 00:37:03,690
Xcode 7的细节内容


698
00:37:04,691 --> 00:37:06,627
如果你还没有
下载新 Xcode 


699
00:37:06,693 --> 00:37:08,695
我建议你去下载 
并且告诉我你的意见


700
00:37:09,329 --> 00:37:09,997
非常感谢

