1
00:00:19,319 --> 00:00:24,124
安全的新特性


2
00:00:24,324 --> 00:00:25,259
下午好！


3
00:00:27,628 --> 00:00:28,862
欢迎大家


4
00:00:28,929 --> 00:00:32,098
感谢各位前来听
安全的新特性


5
00:00:32,399 --> 00:00:36,637
我叫Lucia Ballard
我管理Apple的安全传输团队


6
00:00:36,970 --> 00:00:38,739
与我的同事Simon一起


7
00:00:38,805 --> 00:00:42,943
我们将向大家讲讲我们
一直从事于的大量新内容


8
00:00:43,043 --> 00:00:45,812
来帮助你为客户提升安全


9
00:00:46,246 --> 00:00:49,416
所以 我希望在座的很多人
之前已经听过Evone的演讲


10
00:00:49,616 --> 00:00:52,719
那个演讲非常好地概述了
我们这么做的原因和内容


11
00:00:53,020 --> 00:00:56,190
而且是我们系统安全
的根本性支柱


12
00:00:56,623 --> 00:00:58,859
这里我们会深入到
更多的详细信息


13
00:01:00,360 --> 00:01:01,828
所以内容会有这些


14
00:01:04,998 --> 00:01:09,269
首先 我们会谈谈iOS中
关于网络安全的一些变更


15
00:01:10,938 --> 00:01:14,508
之后我们会讨论几个
对我们加密API的更新


16
00:01:16,009 --> 00:01:19,580
然后Simon会谈谈
macOS上的平台安全


17
00:01:21,915 --> 00:01:24,017
所以 直接进入网络安全


18
00:01:24,418 --> 00:01:26,553
如果你用手机像我一样频繁


19
00:01:26,787 --> 00:01:29,590
你就会知道手机
积累了数量惊人的信息


20
00:01:29,656 --> 00:01:31,158
关于你的私人生活


21
00:01:31,225 --> 00:01:33,093
而且很多是通过网络传递的


22
00:01:33,160 --> 00:01:37,030
无论是你在阅读的文章
或是给朋友发送的消息


23
00:01:37,898 --> 00:01:41,835
所有这些点点滴滴的信息
即使从单个看起来无关紧要


24
00:01:41,902 --> 00:01:45,405
但累积起来 可以
非常惊人地描述出这个人


25
00:01:45,672 --> 00:01:47,341
所以在Apple
我们有理由认为


26
00:01:47,741 --> 00:01:51,311
所有这些信息都
应该默认得到保护


27
00:01:52,546 --> 00:01:55,516
我们认为HTTPS
是新的HTTP


28
00:01:55,716 --> 00:01:58,385
所以对于每个
通过网络加载的资源


29
00:01:58,652 --> 00:02:02,256
你应该为你的用户
提供机密性和数据完整性


30
00:02:04,825 --> 00:02:09,062
另一个关键点是
并非每个HTTPS都是平等的


31
00:02:10,264 --> 00:02:15,335
HTTPS基于SSL
或按现代的说法是TLS


32
00:02:15,969 --> 00:02:20,440
并非这个协议的所有版本
都会提供足够的安全保护


33
00:02:20,674 --> 00:02:23,110
给你的用户来抵抗攻击


34
00:02:24,678 --> 00:02:26,313
所以基于这些原则


35
00:02:26,780 --> 00:02:29,683
去年我们推出了
App Transport Security


36
00:02:30,517 --> 00:02:31,718
App Transport Security


37
00:02:33,153 --> 00:02:37,891
指的是你做的所有加载
使用NSURLSession


38
00:02:38,025 --> 00:02:41,228
或甚至是更旧的
NSURLConnection API


39
00:02:41,562 --> 00:02:46,633
你需要使用最顶级
牢靠的TLS连接


40
00:02:47,568 --> 00:02:52,272
首先 这意味着TLS版本1.2
该版本推出有一段时间了


41
00:02:52,673 --> 00:02:55,542
但只有该版本能够完全抵抗


42
00:02:55,642 --> 00:02:59,580
我们所知的一切漏洞
像是BEAST攻击


43
00:02:59,646 --> 00:03:02,883
或者POODLE攻击
或其他名字可怕的漏洞攻击


44
00:03:04,852 --> 00:03:07,221
这也意味着你必须
使用强大的加密方法


45
00:03:07,554 --> 00:03:11,091
像是AES-128或更强大的密码


46
00:03:11,491 --> 00:03:14,094
以及有SHA-2签名的证书


47
00:03:14,294 --> 00:03:17,297
因为有SHA-1签名的证书
很容易受到攻击


48
00:03:19,299 --> 00:03:21,401
最后 这还意味着正向保密


49
00:03:21,835 --> 00:03:25,372
这种方法可以在服务器
和客户端之间交换密钥


50
00:03:25,606 --> 00:03:30,744
这会带来十分惊人的属性
意味着哪怕将来那个证书...


51
00:03:31,144 --> 00:03:33,113
那个服务器证书被盗取了


52
00:03:33,514 --> 00:03:35,349
你无法显示出来


53
00:03:35,616 --> 00:03:38,185
过去发生的任何通信内容


54
00:03:39,319 --> 00:03:41,088
所以把这些都结合在一起


55
00:03:41,288 --> 00:03:43,924
我们认为 你就有了
一个安全的连接


56
00:03:43,991 --> 00:03:45,893
可以保护客户的数据


57
00:03:47,294 --> 00:03:50,597
现在 我们知道
这需要一段时间来赶上


58
00:03:50,664 --> 00:03:54,168
App Transport Security
的步伐 所以我们还推出了特例


59
00:03:54,501 --> 00:03:55,903
你可以全局关闭


60
00:03:56,203 --> 00:03:59,072
或你可以为
特定域名设置特例


61
00:03:59,239 --> 00:04:01,775
你知道那个域名
无法快速转成TLS


62
00:04:02,976 --> 00:04:06,480
现在我想知道在座的
有多少人在思考 “没错


63
00:04:06,580 --> 00:04:08,315
我去年设置了那个特例


64
00:04:08,682 --> 00:04:13,220
之后就没再考虑了”
好吧 现在是重新考虑的时候了


65
00:04:14,288 --> 00:04:16,890
因为今年
我们会开始在


66
00:04:16,957 --> 00:04:19,593
App Store上
施行App Transport Security


67
00:04:21,195 --> 00:04:23,664
这会在2016年底开始生效


68
00:04:24,865 --> 00:04:26,934
这意味着对于大多数特例


69
00:04:27,334 --> 00:04:29,770
你需要提供正当的理由


70
00:04:30,204 --> 00:04:31,638
所以 对于所有这些特例


71
00:04:31,705 --> 00:04:34,508
真正关闭了
App Transport Security


72
00:04:34,575 --> 00:04:38,212
或其关键属性
像是使用TLS 1.2


73
00:04:38,412 --> 00:04:42,850
你首先需要说明
你要使用该特例的理由


74
00:04:43,617 --> 00:04:45,886
对于其他特例
像是正向保密


75
00:04:45,953 --> 00:04:49,489
我们意识到
对它们的支持并非完全通用


76
00:04:49,656 --> 00:04:52,659
所以目前会
自动授予这些特例


77
00:04:52,726 --> 00:04:54,428
不需要任何理由


78
00:04:56,897 --> 00:05:00,200
例如 如果你在使用
一个伙伴服务器


79
00:05:00,267 --> 00:05:04,037
而且你无法控制
他们提供的加密套件


80
00:05:04,538 --> 00:05:07,808
我们能够让你
继续和那个服务器对话


81
00:05:13,046 --> 00:05:17,117
我们还添加了一些
新的特例来使其易于采用


82
00:05:18,352 --> 00:05:20,988
例如 如果你在使用
Streaming Media


83
00:05:21,154 --> 00:05:23,724
而且那个媒体文件
已经批量加密了


84
00:05:24,224 --> 00:05:27,294
我们可以能够通过
AV Foundation提供特例


85
00:05:27,361 --> 00:05:30,063
让你不需连接TLS
就能加载那个媒体文件


86
00:05:30,464 --> 00:05:32,999
我想说清楚
我们还是认为正确的做法


87
00:05:33,200 --> 00:05:35,102
是将TLS用于一切上面


88
00:05:35,435 --> 00:05:38,839
但有些情况下
我们可以提供特例


89
00:05:39,072 --> 00:05:40,807
来帮助你更顺利地过渡


90
00:05:43,010 --> 00:05:45,312
我们还提供
网页内容特例


91
00:05:45,746 --> 00:05:49,683
这里有时候你的应用需要
加载网页上的任意内容


92
00:05:49,750 --> 00:05:53,420
当然 你无法保证
那是使用HTTPS的


93
00:05:53,987 --> 00:05:56,723
所以如果你用
WKWebView


94
00:05:57,124 --> 00:06:00,561
那你可以将这个密钥
设置在应用的Info.plist里面


95
00:06:01,261 --> 00:06:05,866
NSAllowsArbitraryLoads
inWebContentKey


96
00:06:06,433 --> 00:06:08,702
之后所有的这些
加载都会免去


97
00:06:08,769 --> 00:06:10,971
App Transport Security要求


98
00:06:11,171 --> 00:06:12,906
但你应用所做的其他事


99
00:06:13,040 --> 00:06:15,843
像是和你自己的服务器对话
这还是会得到保护的


100
00:06:19,913 --> 00:06:21,982
所以这是
App Transport Security


101
00:06:23,183 --> 00:06:25,919
但我们还在整个系统
上为TLS做变更


102
00:06:26,720 --> 00:06:30,123
因为加密套件不断进化


103
00:06:30,190 --> 00:06:34,127
与抵御攻击相比 发起
攻击的能力不断变得越加高效


104
00:06:34,728 --> 00:06:37,598
所以无论你的ATS设置是什么


105
00:06:38,065 --> 00:06:42,870
我们现在为所有使用我们
网络API的人默认禁用了RC4


106
00:06:45,005 --> 00:06:48,242
我们还在Secure Transport
中禁用了SSLv3


107
00:06:48,342 --> 00:06:51,211
所以即使你下入到
我们的底层API


108
00:06:51,278 --> 00:06:53,347
你还是无法使用SSLv3


109
00:06:54,214 --> 00:06:57,017
研究已经远远超越
这两项技术了


110
00:06:57,084 --> 00:07:00,687
我们不认为它们能为我们的
用户提供有效的安全


111
00:07:03,490 --> 00:07:04,825
所以被禁用了


112
00:07:05,359 --> 00:07:07,661
其他的算法也开始过时了


113
00:07:07,728 --> 00:07:13,233
特别的 SHA-1变得
越来越容易受到攻击


114
00:07:13,367 --> 00:07:14,568
3DES也是


115
00:07:15,235 --> 00:07:18,839
所以 如果你知道
你依赖于这些算法


116
00:07:20,107 --> 00:07:21,475
现在该放弃它们了


117
00:07:22,242 --> 00:07:25,145
而且我发现在场的
很多人是应用开发者


118
00:07:25,245 --> 00:07:27,414
而且不负责自己的后端


119
00:07:27,648 --> 00:07:29,183
所以你需要联系


120
00:07:29,249 --> 00:07:32,319
你公司或其他
负责托管后端的那些人


121
00:07:32,386 --> 00:07:34,655
来确保他们放弃


122
00:07:34,922 --> 00:07:38,458
对这些老旧算法的依赖
因为这些算法要被弃用了


123
00:07:39,259 --> 00:07:42,729
现在非常适合你去
检查加载内容的状态


124
00:07:42,796 --> 00:07:47,267
使用HTTPS 并且确保你能
使用App Transport Security


125
00:07:47,801 --> 00:07:49,803
然后你就能快速
通过应用审核了


126
00:07:53,240 --> 00:07:55,275
所以这就是
App Transport Security


127
00:07:55,976 --> 00:07:58,779
确保一切都是用
牢靠的TLS进行加载的


128
00:07:58,979 --> 00:08:01,381
不过牢靠的TLS是不够的


129
00:08:02,850 --> 00:08:08,322
你还需要确保你用来验证
TLS连接的证书


130
00:08:08,555 --> 00:08:10,724
能表示正确的服务器


131
00:08:11,625 --> 00:08:14,061
所以我想谈谈几个不同的技术


132
00:08:14,361 --> 00:08:18,198
我们今天使用它们
来帮助你确保你是真正


133
00:08:18,365 --> 00:08:20,634
连接到正确的服务器上


134
00:08:20,801 --> 00:08:23,370
当你在建立这些
安全通信的时候


135
00:08:25,606 --> 00:08:26,707
所以首先我们回来


136
00:08:26,840 --> 00:08:29,409
来稍微谈谈当今
证书的工作原理


137
00:08:32,746 --> 00:08:34,548 line:1
所以如果你要连接一个服务器


138
00:08:34,615 --> 00:08:38,719 line:1
那个服务器一定要有一个
由证书权威机构发放的证书


139
00:08:38,784 --> 00:08:40,621 line:1
那个权威机构会验证主机名


140
00:08:40,687 --> 00:08:43,957 line:1
然后说 “没错 挺好的
你确实是example.com


141
00:08:44,024 --> 00:08:45,592 line:1
这是你的密码证明”


142
00:08:46,693 --> 00:08:49,396 line:1
当你连接的时候
服务器会发来那个证书


143
00:08:52,999 --> 00:08:56,236
但这不总是完美的机制


144
00:08:57,337 --> 00:09:01,575
如果有攻击者设法
得到了你主机名的证书


145
00:09:02,209 --> 00:09:04,178
那他们就能提供那个证书


146
00:09:04,244 --> 00:09:06,780 line:1
而客户端无法分辨出


147
00:09:06,847 --> 00:09:08,849 line:1
攻击者的服务器
和你自己的服务器


148
00:09:09,516 --> 00:09:12,352 line:1
如果证书权威机构
出错的话 这就会发生


149
00:09:12,419 --> 00:09:13,954 line:1
或更糟的情况


150
00:09:14,021 --> 00:09:16,256 line:1
这个证书权威机构被入侵了


151
00:09:16,390 --> 00:09:18,959 line:1
有其他人使用他们的
私人密钥来进行签名


152
00:09:21,728 --> 00:09:24,565
所以今天我很自豪地宣布
我们将加入到


153
00:09:24,698 --> 00:09:26,333
证书透明度的工作中去


154
00:09:27,201 --> 00:09:29,770
证书透明度是一种技术


155
00:09:29,837 --> 00:09:33,674
使用了已发布证书的
公开可验证日志


156
00:09:34,441 --> 00:09:37,277
这些日志从各种源中收集证书


157
00:09:37,344 --> 00:09:39,980
所以有很多
证书权威机构参与进来


158
00:09:40,047 --> 00:09:42,015
但事实上
任何人都可以提交日志


159
00:09:43,717 --> 00:09:46,954
之后 这些日志会发布密码证明


160
00:09:47,087 --> 00:09:50,457
表明这个证书已被记录
然后客户端可以检查那个证明


161
00:09:50,724 --> 00:09:52,459
这里的做法有很多


162
00:09:52,593 --> 00:09:54,695
证明可以嵌入到证书中


163
00:09:54,761 --> 00:09:57,764
或可以在TLS握手中交出


164
00:09:58,432 --> 00:10:02,402
或可以通过OCSP装订传输
这一点我过会再细说


165
00:10:04,638 --> 00:10:07,040
所以这是其工作原理的简单概述


166
00:10:09,076 --> 00:10:11,311
首先 证书权威机构


167
00:10:12,679 --> 00:10:15,182 line:1
不仅向服务器发行证书


168
00:10:15,482 --> 00:10:19,419 line:1
还将证书发送到日志那里
然后添加到公开日志上


169
00:10:20,721 --> 00:10:24,558 line:1
之后日志会发送一个有签名的证明
表明这个证书已被包括进去


170
00:10:25,325 --> 00:10:28,829 line:1
然后服务器将它和原始证书一起


171
00:10:29,096 --> 00:10:30,330 line:1
交给客户端


172
00:10:30,831 --> 00:10:33,100 line:1
这意味着你可以
一同验证这一对


173
00:10:36,069 --> 00:10:39,873 line:1
所以证书透明度
使发起攻击变的更加困难


174
00:10:41,608 --> 00:10:43,510 line:1
基本上这让攻击者身处困境


175
00:10:43,710 --> 00:10:48,315 line:1
如果攻击者可以从未参与的
权威机构那里得到一个证书


176
00:10:48,916 --> 00:10:51,885 line:1
他们无法得到那个密码证明


177
00:10:52,119 --> 00:10:54,588 line:1
因为那个日志中包括着证书


178
00:10:55,022 --> 00:10:58,225 line:1
所以他们只能交出证书
然后客户端就可以拒绝


179
00:10:59,993 --> 00:11:00,961 line:1
或者


180
00:11:01,895 --> 00:11:04,865 line:1
如果他们使用
参与的证书权威机构


181
00:11:05,499 --> 00:11:07,768 line:1
那么那个被感染的证书会被记录


182
00:11:07,835 --> 00:11:10,704 line:1
然后可以公开查看
这就让你有机会


183
00:11:10,771 --> 00:11:13,574 line:1
在证书权威机构级别撤销证书


184
00:11:15,142 --> 00:11:17,311
所以我们认为这是
一种至关重要的技术


185
00:11:18,011 --> 00:11:22,149
来让你确认与你对话的那个证书


186
00:11:22,282 --> 00:11:24,718
的确是你要对话的那个证书


187
00:11:27,654 --> 00:11:29,356
所以你可以这样试试


188
00:11:30,591 --> 00:11:32,559
你可以使用
相同的info.plist


189
00:11:32,626 --> 00:11:35,729
你用它设置了
应用的传输安全配置


190
00:11:36,330 --> 00:11:38,532
这是新的关键字
所以对于每个例子


191
00:11:38,899 --> 00:11:42,336
有一个参与的证书
你设置上关键字


192
00:11:42,536 --> 00:11:44,771
然后你的客户端会拒绝任何


193
00:11:44,838 --> 00:11:47,074
无法证明其有公开日志的证书


194
00:11:50,177 --> 00:11:52,379 line:1
我们当前的策略大概要求


195
00:11:52,446 --> 00:11:54,715 line:1
你需要有至少来自
两个日志的证明


196
00:11:55,749 --> 00:11:59,586 line:1
这些日志...我们会将
认证的新日志添加上去


197
00:11:59,786 --> 00:12:03,223 line:1
若你的证书能用在Chromium上
基本上在我们这里也能行


198
00:12:04,024 --> 00:12:05,626
有更多的信息


199
00:12:05,692 --> 00:12:09,663
关于通用技术的
在certificatetransparency.org


200
00:12:09,796 --> 00:12:11,532
所以我鼓励你去查看一下


201
00:12:15,269 --> 00:12:19,006
证书透明度是这个
生态系统中的一个重要部分


202
00:12:19,106 --> 00:12:21,241
当它无法完全代替吊销


203
00:12:21,375 --> 00:12:23,877
这还有最后一步
当你发现了


204
00:12:23,944 --> 00:12:28,081
证书由于某种原因出现缺陷
你必须要终止对其的信任


205
00:12:29,349 --> 00:12:31,051
所以我想花几分钟时间


206
00:12:31,118 --> 00:12:33,554
来谈谈我们推荐的做法


207
00:12:33,687 --> 00:12:35,289
这叫做OCSP装订


208
00:12:35,989 --> 00:12:38,859
这种标准已经推出很多年了


209
00:12:39,092 --> 00:12:41,028
但是我们认为现在是时候


210
00:12:41,094 --> 00:12:43,764
让大家转移过去
真正开始采用它


211
00:12:44,164 --> 00:12:46,600
因为现在对它的支持
已非常广泛了


212
00:12:47,701 --> 00:12:51,905
OCSP装订是对
在线证书状态协议的增强


213
00:12:51,972 --> 00:12:53,674
并且解决了大量的问题


214
00:12:55,843 --> 00:12:58,712 line:1
所以回顾一下
这就是OCSP的工作原理


215
00:12:59,046 --> 00:13:00,247 line:1
我们有同样的设置


216
00:13:00,314 --> 00:13:03,917 line:1
证书权威机构向
服务器发放证书


217
00:13:05,219 --> 00:13:07,454 line:1
每一次客户端
连接那个服务器


218
00:13:07,521 --> 00:13:11,091 line:1
客户端就会看到那个证书
并且想知道证书是否仍然有效


219
00:13:12,059 --> 00:13:14,461 line:1
所以它会请求证书权威机构


220
00:13:14,528 --> 00:13:16,663 line:1
就在TLS握手过程中间


221
00:13:17,264 --> 00:13:18,899 line:1
然后证书权威机构说


222
00:13:18,966 --> 00:13:22,970 line:1
“是的 证书仍然有效” 或者
“不是 抱歉证书无效的 不要相信”


223
00:13:24,805 --> 00:13:25,906 line:1
这有一些问题


224
00:13:26,707 --> 00:13:28,475 line:1
其中之一是速度慢


225
00:13:28,542 --> 00:13:31,879 line:1
你处在获得资源的握手过程中


226
00:13:31,945 --> 00:13:35,182
你不想等待一些其他
实体来进行连接


227
00:13:35,649 --> 00:13:38,819
尤其是当那个服务器关闭了
你可能要等待一段时间


228
00:13:40,087 --> 00:13:42,956
另一个重大问题是
这会稍微泄露出


229
00:13:43,023 --> 00:13:45,459
关于你在线活动的信息


230
00:13:45,826 --> 00:13:49,229
你的证书权威机构会看
你连接了哪些主机名


231
00:13:49,296 --> 00:13:52,633
因为每次你连接的时候
你都发送一个响应


232
00:13:55,936 --> 00:13:58,705 line:1
OCSP装订
解决了很多这些担忧


233
00:13:58,872 --> 00:14:00,674 line:1
所以工作原理基本上是这样


234
00:14:01,475 --> 00:14:06,013 line:1
进行请求的不是客户端
而是服务器请求证书权威机构


235
00:14:07,481 --> 00:14:11,018 line:1
证书权威机构将一个
有签名的响应交回服务器


236
00:14:11,118 --> 00:14:13,187 line:1
由证书权威机构签名


237
00:14:13,453 --> 00:14:14,788 line:1
这样就可以信任它了


238
00:14:16,056 --> 00:14:19,393 line:1
之后服务器将这个证书和承诺一并


239
00:14:19,459 --> 00:14:23,630 line:1
发给客户端 表明证书是有效的
全部一致 全部是同一个握手过程


240
00:14:27,201 --> 00:14:28,168
所以这意味着


241
00:14:28,235 --> 00:14:32,105
你的吊销信息会
可靠迅速地送达过来


242
00:14:32,172 --> 00:14:34,942
没有多余的等待
没有任何担忧


243
00:14:36,009 --> 00:14:37,911
而且会保护用户的隐私


244
00:14:37,978 --> 00:14:40,981
因为他们唯一建立的
就是返回你服务器的连接


245
00:14:42,950 --> 00:14:46,486
你可能注意到这个图表
看起来和证书透明度的图表相似


246
00:14:46,553 --> 00:14:48,622
那是因为你可以
使用相同的机制


247
00:14:48,689 --> 00:14:50,891
来传递证书透明度证明


248
00:14:51,258 --> 00:14:54,194
只要你的证书
权威机构参与进来


249
00:14:54,461 --> 00:14:57,631
你可以在一次握手中
一同发出所有的信息


250
00:15:00,200 --> 00:15:03,770
如我所说 OCSP装订
广泛地支持于


251
00:15:03,837 --> 00:15:06,840
多种操作系统
而且还能向后兼容


252
00:15:06,907 --> 00:15:10,177
所以你今天就可以启用
在Apache上 在GenX上


253
00:15:10,244 --> 00:15:12,913
你的后端托管
在什么地方都行


254
00:15:13,180 --> 00:15:16,216
而且现在完全支持
所有的Apple平台


255
00:15:19,753 --> 00:15:21,588
所以如果可以回顾


256
00:15:21,655 --> 00:15:24,124
总结我们在网络安全上的进展


257
00:15:24,591 --> 00:15:29,229
现在是时候前进到
应用传输安全标准上了


258
00:15:29,296 --> 00:15:34,101
这是牢靠的算法
和牢靠的密码 TLS 1.2


259
00:15:34,268 --> 00:15:36,737
正向保密和SHA-2证书


260
00:15:38,772 --> 00:15:43,343
还有 现在是时候开始对证书
透明度进行试验了


261
00:15:43,544 --> 00:15:46,413
寻找参与的证书权威机构


262
00:15:46,647 --> 00:15:49,550
然后整合到这个生态系统中


263
00:15:51,251 --> 00:15:53,954
还有 一定要启用OCSP装订


264
00:15:54,021 --> 00:15:57,958
这样我们就万无一失了
而且要知道你可以确保


265
00:15:58,058 --> 00:16:00,594
建立安全的返回服务器连接


266
00:16:01,929 --> 00:16:03,297
所以这就是网络安全


267
00:16:05,999 --> 00:16:10,037
现在我想花几分钟时间
来谈谈一些加密改进


268
00:16:12,005 --> 00:16:16,076
所以 首先是SecKey
SecKey是我们的算法


269
00:16:16,210 --> 00:16:20,981
不好意思 是我们用于
非对称加密操作的API


270
00:16:21,281 --> 00:16:25,485
在这次版本中 我们统一了
macOS和iOS上面的API


271
00:16:26,353 --> 00:16:31,191
SecKey现在支持所有的常见操作
用非对称密钥


272
00:16:31,692 --> 00:16:33,193
RSA 和 ACC 进行的操作


273
00:16:33,493 --> 00:16:37,030
所以这是用非对称密钥
进行签名和验证


274
00:16:38,398 --> 00:16:44,571
这意味着SecKey完全替代了
在macOS上被弃用的CDSA调用


275
00:16:45,339 --> 00:16:48,675
而且它还替代了你可能
使用的SecTransform


276
00:16:48,876 --> 00:16:52,179
来用非对称密钥进行加密


277
00:16:52,546 --> 00:16:55,015
所以我们强烈推荐
前进到SecKey上


278
00:16:57,084 --> 00:17:01,088
我们还将它嵌入到新工具包中
叫做CryptoTokenKit


279
00:17:01,788 --> 00:17:05,592
CryptoTokenKit是对
加密设备的系统支持


280
00:17:05,759 --> 00:17:08,662
所以那张你用来
证明身份的小卡片


281
00:17:08,729 --> 00:17:11,964
在企业中用的那种
或者是USB token


282
00:17:13,300 --> 00:17:16,203
现在我们直接整合了这些


283
00:17:16,603 --> 00:17:18,672
而且它们可以
整合到系统服务中


284
00:17:18,739 --> 00:17:23,010
所以这意味着这些Token内容
可以在keychain中获得


285
00:17:23,210 --> 00:17:24,344
如你所料


286
00:17:24,411 --> 00:17:29,049
而且Token操作可以通过
使用SecKey API实现


287
00:17:29,950 --> 00:17:33,420
这是一个复杂的话题
其中有很多的深层内容


288
00:17:33,820 --> 00:17:35,956
所以请到
security lab见我们


289
00:17:36,023 --> 00:17:38,025
我们可以详细讨论你的使用案例


290
00:17:40,394 --> 00:17:43,430
所以感谢大家的关注
接下来我将交给Simon


291
00:17:43,497 --> 00:17:45,566
来谈谈在平台安全
上的新内容


292
00:17:50,737 --> 00:17:52,072
非常感谢你 Lucia


293
00:17:53,207 --> 00:17:56,910
大家好 我是Simon Cooper
我负责管理信任工程团队


294
00:17:58,011 --> 00:17:59,880
我将谈谈安全上的新内容


295
00:18:00,981 --> 00:18:03,483
但首先我想谈谈...
稍微谈谈


296
00:18:04,051 --> 00:18:06,153
软件是如何传输到Mac上的


297
00:18:07,454 --> 00:18:09,389
稍微谈谈Developer ID


298
00:18:10,490 --> 00:18:12,259 line:1
然后我会谈谈Gatekeeper


299
00:18:12,359 --> 00:18:14,761 line:1
和围绕Gatekeeper
的一些打包问题


300
00:18:15,229 --> 00:18:18,332
我们先开始谈谈
软件是如何传输到


301
00:18:18,398 --> 00:18:20,701
我们几个平台上的


302
00:18:22,736 --> 00:18:25,839
所以对于iOS 你可以从
App Store上获取应用


303
00:18:27,207 --> 00:18:33,180
你能使用Xcode来创建并运行应用
然后将它们安装在你自己的设备上


304
00:18:34,581 --> 00:18:36,383
这有一些Enterprise Program


305
00:18:36,450 --> 00:18:40,320
允许你将内容传输
到设备上并进行管理


306
00:18:41,522 --> 00:18:43,991
你会发现所有这些安装机制


307
00:18:44,057 --> 00:18:46,360
都是由iOS平台
在背后处理完成的


308
00:18:47,427 --> 00:18:49,630
所以现在我想
稍微谈谈macOS


309
00:18:52,432 --> 00:18:55,269
所以你还可以通过
Mac App Store获得应用


310
00:18:55,969 --> 00:18:57,905
而且这种获取应用
的方法十分不错


311
00:18:59,840 --> 00:19:03,644
你还可以得到有
Developer ID签名的应用


312
00:19:06,680 --> 00:19:08,248
你还可以使用Xcode


313
00:19:08,482 --> 00:19:12,152
来创建你自己的应用
然后使用传统命令行UNIX工具


314
00:19:12,219 --> 00:19:14,388
来以普通的UNIX方式创建内容


315
00:19:17,858 --> 00:19:21,328
所以我们回来稍微
谈谈Developer ID


316
00:19:25,165 --> 00:19:27,034
所以什么是Developer ID？


317
00:19:30,103 --> 00:19:33,674
Developer ID允许你
在App Store之外传输应用


318
00:19:35,876 --> 00:19:38,979
这些应用通常使用
网页浏览器下载完成的


319
00:19:41,915 --> 00:19:46,119
Developer ID Program会
发放给你一个Developer ID签名身份


320
00:19:48,822 --> 00:19:52,926
当你以该身份给应用签名时
应用会得到Gatekeeper的特别对待


321
00:19:55,195 --> 00:19:57,831
实际上 在Xcode 8中
有一些改进的流程


322
00:19:57,998 --> 00:20:01,768
允许你正确地导出有
Developer ID签名的应用


323
00:20:08,475 --> 00:20:12,479
所以我们要做的是改变
Developer ID Program


324
00:20:12,546 --> 00:20:13,847
昨天已经宣布了


325
00:20:13,914 --> 00:20:17,351
我们允许Developer ID
和iCloud协同使用


326
00:20:19,786 --> 00:20:22,689
所以Developer ID现在
可以使用iCloud的功能


327
00:20:22,756 --> 00:20:26,193
这包括iCloud Drive
iCloud Keychain


328
00:20:26,627 --> 00:20:29,062
Push Notifications和VPN


329
00:20:32,266 --> 00:20:33,367
所以这意味着什么？


330
00:20:34,201 --> 00:20:37,037
这意味着你可以传输
iCloud驱动的应用


331
00:20:37,237 --> 00:20:39,373
在App Store之外


332
00:20:40,007 --> 00:20:42,976
你现可使用Developer ID
将数据分享给


333
00:20:43,043 --> 00:20:45,612
你的iCloud驱动的iOS应用


334
00:20:46,680 --> 00:20:51,919
你能将新的Developer ID
应用部署回macOS 10.9


335
00:20:52,553 --> 00:20:55,722
所以大家一定想知道
何时能够做到如此


336
00:20:57,124 --> 00:21:00,394
你今天可开始
iCloud Development测试


337
00:21:00,594 --> 00:21:02,796
使用Xcode 8工具


338
00:21:06,433 --> 00:21:10,070
你肯定也注意到了
当你在做iCloud测试的时候


339
00:21:10,137 --> 00:21:12,573
这有一个开发和生产环境


340
00:21:13,073 --> 00:21:16,510
当你在部署
你的iCloud应用时


341
00:21:16,677 --> 00:21:19,079
你要在生产环境中部署


342
00:21:19,146 --> 00:21:20,814
然后要等待即将发布的seed


343
00:21:20,881 --> 00:21:22,482
这样才能开始测试


344
00:21:24,685 --> 00:21:28,755
当你那么做的时候
请使用Xcode 8中的新流程


345
00:21:28,889 --> 00:21:32,926
因为这会确保你是在
生产服务器中进行部署


346
00:21:34,494 --> 00:21:36,997
Xcode团队还让我提醒大家


347
00:21:37,164 --> 00:21:41,301
除非你使用GM工具
否则请不要发布应用


348
00:21:45,339 --> 00:21:49,710
所以Developer ID的
另一边是Gatekeeper


349
00:21:50,477 --> 00:21:54,381
Gatekeeper允许我们控制
哪些应用可以在你的机器上运行


350
00:21:55,582 --> 00:21:59,319
然后这是
Preference Panel


351
00:21:59,486 --> 00:22:01,889
在El Capitan中的
Preference Panel上面


352
00:22:01,955 --> 00:22:05,425
有这些选项 你可以运行来自
Mac App Store的应用


353
00:22:06,126 --> 00:22:09,796
可运行Mac App Store
和未识别开发者的应用


354
00:22:09,897 --> 00:22:11,732
或者你可以运行
来自任何地方的应用


355
00:22:13,267 --> 00:22:18,038
当你第一次运行应用时
Gatekeeper会运行前提示你


356
00:22:19,940 --> 00:22:22,376
其实我们在Gatekeeper
上做了些更改


357
00:22:22,442 --> 00:22:27,114
而且我们对Sierra中的
Gatekeeper UI也做更改


358
00:22:28,549 --> 00:22:32,386
我们改变了默认选项
而且那些默认选项会是


359
00:22:32,452 --> 00:22:34,354
你可以运行
Mac App Store的应用


360
00:22:34,688 --> 00:22:37,324
你可运行Mac App Store
和未识别开发者的应用


361
00:22:38,725 --> 00:22:41,728
现在如果Gatekeeper
出于某种原因拒绝你的应用


362
00:22:42,095 --> 00:22:45,299
这通常在这个Preference Pane中
会出现一个按钮


363
00:22:45,365 --> 00:22:48,969
让你打开...
继续打开


364
00:22:50,604 --> 00:22:54,074
不幸的是 在seed版本中
这项功能并不起作用


365
00:22:54,141 --> 00:22:56,343
但会在之后的seed
版本中得到修复


366
00:22:57,744 --> 00:23:00,614e
我还想说
我们没有改变


367
00:22:57,744 --> 00:23:00,614
我还想说
我们没有改变


368
00:23:00,681 --> 00:23:04,151
基本机制和策略的工作方式


369
00:23:04,351 --> 00:23:06,553
所以如果你已经完成管理配置


370
00:23:06,620 --> 00:23:09,823
或者使用命令行工具和策略工具


371
00:23:09,923 --> 00:23:12,259
你可以重新启用
Allow Anywhere


372
00:23:18,765 --> 00:23:22,002
我想稍微谈谈Gatekeeper
上的其他一些变更


373
00:23:22,202 --> 00:23:25,005
但是我首先要谈谈
重新打包问题


374
00:23:25,639 --> 00:23:29,209
和为解决该问题而
开发的Gatekeeper加强的地方


375
00:23:30,143 --> 00:23:32,679
现在重新打包成为了一个问题


376
00:23:32,913 --> 00:23:34,882
是由于某些应用编写的方法


377
00:23:36,149 --> 00:23:37,651 line:1
有一些类型的应用


378
00:23:37,985 --> 00:23:42,356 line:1
在编写的时候
延伸到了其本身之外


379
00:23:42,422 --> 00:23:44,224 line:1
并且使用了外部资源


380
00:23:46,827 --> 00:23:51,164 line:1
这些应用可能
以多种方式传输


381
00:23:53,700 --> 00:23:55,969 line:1
而且它们可能
确实有正确的签名


382
00:23:57,104 --> 00:24:01,475 line:1
但是它们所延伸的
外部资源可能没有签名


383
00:24:02,376 --> 00:24:04,411 line:1
它们可以是代码或是等价代码


384
00:24:04,511 --> 00:24:06,947 line:1
可以是库
可以是插件


385
00:24:07,214 --> 00:24:08,982 line:1
甚至可以是HTML内容


386
00:24:09,283 --> 00:24:11,785 line:1
你可能没注意到
本地的HTML内容


387
00:24:11,885 --> 00:24:15,856 line:1
如果含有JavaScript
这就可以访问你的整个系统


388
00:24:19,159 --> 00:24:23,030
这些资源还可以是Lua Scripts
或Python Scripts


389
00:24:23,297 --> 00:24:24,765
或甚至是Apple Scripts


390
00:24:27,234 --> 00:24:28,435
所以问题在哪？


391
00:24:29,570 --> 00:24:32,806
如果你将这两个东西
一起放入容器中


392
00:24:32,873 --> 00:24:37,177
然后以这种方式传输应用
可能通过压缩文件或磁盘镜像


393
00:24:37,244 --> 00:24:42,282
或者使用ISO镜像
然后你将应用放入容器中


394
00:24:44,551 --> 00:24:46,820
然后你将资源放在应用旁边


395
00:24:48,822 --> 00:24:52,226
当应用运作并和外部资源对话时


396
00:24:53,560 --> 00:24:56,830
它就会加载这些
有潜在危险的东西


397
00:24:57,297 --> 00:25:00,167
你会发现这里的
应用有绿色的边框


398
00:25:00,234 --> 00:25:01,668
表明有签名


399
00:25:02,236 --> 00:25:05,072 line:1
它延伸到了外面
到签名的外面


400
00:25:05,272 --> 00:25:08,408 line:1
并尝试接触这些潜在资源


401
00:25:10,210 --> 00:25:12,913 line:1
所以如果我将
那个应用重新打包


402
00:25:13,280 --> 00:25:16,583 line:1
我不是将它和外部资源一同打包


403
00:25:16,850 --> 00:25:19,186 line:1
那是你们开发者想放入的内容


404
00:25:20,387 --> 00:25:22,222 line:1
我是将恶意内容放进去


405
00:25:22,789 --> 00:25:24,358 line:1
之后当用户运行应用


406
00:25:24,591 --> 00:25:26,760 line:1
他们不会得到你的体验


407
00:25:26,827 --> 00:25:30,797 line:1
他们体验到的是恶意代码


408
00:25:31,431 --> 00:25:34,301
如果那个恶意代码
是一个动态库


409
00:25:34,368 --> 00:25:37,204
比如你可能把它放入
一个插件目录里了


410
00:25:37,604 --> 00:25:40,574
那这几乎可以肯定
你的应用将不会


411
00:25:40,707 --> 00:25:42,042
执行你所预期的事情


412
00:25:48,582 --> 00:25:50,851
所以我们将其
称为重新打包问题


413
00:25:52,186 --> 00:25:56,390
有一些内容并非直接
受到打包问题的影响


414
00:25:56,990 --> 00:26:00,093
那些内容是从Mac App
Store中传输过来的应用


415
00:26:00,794 --> 00:26:02,563
这是获取应用的最佳方式


416
00:26:04,331 --> 00:26:05,966
其他内容


417
00:26:07,868 --> 00:26:10,237
可以不受直接影响的


418
00:26:10,404 --> 00:26:14,107
是你使用带有签名的Apple
Installer Package来安装应用


419
00:26:14,942 --> 00:26:17,644
这不意味着说
一旦应用安装完成


420
00:26:17,711 --> 00:26:20,848
就无法重新打包
并传输到另一个机制中


421
00:26:20,914 --> 00:26:23,083
但实际的Apple Installer Package


422
00:26:23,150 --> 00:26:26,653
在延伸到外部资源的
方面是没有问题的


423
00:26:30,858 --> 00:26:32,593
有些内容是会受到影响的


424
00:26:32,693 --> 00:26:36,530
前提是你传输应用的方法
是用压缩文件或磁盘镜像


425
00:26:37,364 --> 00:26:39,666
或者如果你将内容组合在


426
00:26:39,733 --> 00:26:43,570
ISO镜像中
以及其他任何一种存档格式


427
00:26:46,173 --> 00:26:48,742
还有可能的是
如果在你的磁盘镜像


428
00:26:48,842 --> 00:26:52,813
的结构中
你组装应用的方式


429
00:26:53,180 --> 00:26:57,851
是使用一种组合
将各处的资源


430
00:26:58,051 --> 00:27:01,555
组合到一起
那你也可能受到影响


431
00:27:07,327 --> 00:27:09,329
所以在此问题上
我们需要你们的帮助


432
00:27:12,733 --> 00:27:15,636
由于这个问题
我们还需要保护我们客户


433
00:27:18,472 --> 00:27:19,540
我们需要做什么？


434
00:27:20,207 --> 00:27:21,909
如果你传输某些内容


435
00:27:21,975 --> 00:27:24,311
其中有带签名的应用
和一些外部资源


436
00:27:24,378 --> 00:27:29,283
你可能通过压缩文件
或磁盘镜像 或ISO镜像来做


437
00:27:30,117 --> 00:27:33,620
我们要请求你们
换成使用磁盘镜像


438
00:27:35,689 --> 00:27:40,194
我们请求你们这样做的原因是
我们现在可以给磁盘镜像签名了


439
00:27:43,096 --> 00:27:48,669
你可以用macOS 10.11.5
来给磁盘镜像签名


440
00:27:48,869 --> 00:27:51,872
这是El Capitan的当前版本


441
00:27:52,439 --> 00:27:55,342
或所有之后发布的OS X


442
00:27:58,011 --> 00:28:00,814
你可以使用共同签署工具
来给应用签名...


443
00:28:01,548 --> 00:28:03,450
来给磁盘镜像签名
不好意思


444
00:28:03,884 --> 00:28:06,353
这基本上会将


445
00:28:06,453 --> 00:28:08,956
外部资源和应用绑定在一起


446
00:28:10,290 --> 00:28:12,860
这些签名实际上
嵌入在磁盘镜像中


447
00:28:12,993 --> 00:28:14,328
并随着磁盘镜像附带


448
00:28:15,128 --> 00:28:19,933
而且这个有签名的磁盘镜像
与旧的OS版本相兼容


449
00:28:22,936 --> 00:28:25,072
现在我想说一些打包建议


450
00:28:25,839 --> 00:28:28,242
避免打包问题的一种方法是...


451
00:28:28,308 --> 00:28:30,744
重新打包方法
就是完全避开它


452
00:28:31,078 --> 00:28:33,480
将你的资源放入应用捆绑包中


453
00:28:33,714 --> 00:28:35,215
之后给整个内容签名


454
00:28:40,854 --> 00:28:42,990
如果你只发布
单个应用捆绑包


455
00:28:43,257 --> 00:28:46,226
你应该考虑通过
Mac App Store传输


456
00:28:47,861 --> 00:28:49,596
你一定要给应用签名


457
00:28:50,597 --> 00:28:52,666
或许在压缩文档中打包


458
00:28:52,766 --> 00:28:56,236
不过请在发布前
验证那个签名


459
00:28:57,504 --> 00:28:59,373
或者 如果你有复杂的安装


460
00:28:59,673 --> 00:29:02,276
你可使用带签名的Apple
Installer Package


461
00:29:02,876 --> 00:29:04,211
对于容器


462
00:29:05,045 --> 00:29:07,481
还有应用和资源
还有磁盘镜像


463
00:29:07,781 --> 00:29:10,384
请使用并换成
有签名的磁盘镜像


464
00:29:11,218 --> 00:29:13,987
容器中的所有内容都要签名


465
00:29:14,121 --> 00:29:17,191
所以其内部的应用
也应该签上名


466
00:29:18,358 --> 00:29:19,927
而且你应该给磁盘镜像签名


467
00:29:20,627 --> 00:29:23,597
并请在发布前
验证所有的签名


468
00:29:27,401 --> 00:29:29,203
关于打包的最后几点


469
00:29:31,004 --> 00:29:34,608
如果你将个性化和
许可信息添加到你的应用上


470
00:29:34,675 --> 00:29:36,009
在下载的时候


471
00:29:36,577 --> 00:29:39,847
请在应用的捆绑包
路径上使用扩展属性


472
00:29:40,447 --> 00:29:42,883
这是描述该做法的技术说明


473
00:29:43,083 --> 00:29:45,419
那就是Tech Note 2206


474
00:29:45,586 --> 00:29:48,789
你也可以通过给个性化
磁盘镜像签名来做到这一点


475
00:29:51,391 --> 00:29:53,894
这里有一些
你一定不要做的事


476
00:29:55,028 --> 00:29:57,297 line:1
给应用签完名之后
不应进行修改


477
00:29:57,364 --> 00:29:58,999 line:1
因为这会破坏代码签名


478
00:29:59,066 --> 00:30:03,203 line:1
当Gatekeeper来验证
你的应用时 就会出现问题


479
00:30:03,770 --> 00:30:06,273 line:1
你绝对不可以传输
签名被破坏的应用


480
00:30:06,607 --> 00:30:10,143 line:1
然后请不要传输ISO镜像了


481
00:30:10,844 --> 00:30:14,348
现在我想谈谈
Gatekeeper增强


482
00:30:14,481 --> 00:30:17,484
这是我们为攻克这一
问题而开发出来的


483
00:30:18,252 --> 00:30:20,721
这重点是为了保护客户


484
00:30:22,256 --> 00:30:26,059
这个机制我们称之为
Gatekeeper Path Randomization


485
00:30:28,195 --> 00:30:33,033
它补充了所有
现有的Gatekeeper保护


486
00:30:34,668 --> 00:30:37,738
而且对于Mac App Store
的应用没有任何变更


487
00:30:41,508 --> 00:30:44,211
当你升级Sierra时
也没有任何变更


488
00:30:44,411 --> 00:30:47,748
对于任何之前在你
系统里运行的应用


489
00:30:50,651 --> 00:30:55,322
这个机制对任何
新下载的应用起作用


490
00:30:56,723 --> 00:31:01,094
并且适用于
无签名磁盘镜像上的应用


491
00:31:03,330 --> 00:31:06,200
我来描述一下究竟
这种机制是如何生效的


492
00:31:09,903 --> 00:31:11,839 line:1
这是一个复杂对象


493
00:31:12,239 --> 00:31:14,174 line:1
这可能在你的下载文件夹里


494
00:31:14,241 --> 00:31:15,642 line:1
而且可能是一个解压缩文件


495
00:31:16,243 --> 00:31:18,412 line:1
或者可能是一个
已装载的磁盘镜像


496
00:31:18,612 --> 00:31:21,715 line:1
包含你的应用和那些额外资源


497
00:31:26,920 --> 00:31:29,022
所以 当你双击应用时


498
00:31:32,059 --> 00:31:36,396
当应用运行后
它会被重新转移


499
00:31:37,898 --> 00:31:39,066
通过一些技巧


500
00:31:39,533 --> 00:31:42,102
放到文件系统里的一个随机位置


501
00:31:42,903 --> 00:31:45,739 line:1
而且它不能访问资源


502
00:31:49,843 --> 00:31:52,045 line:1
所以 这会终止重新打包攻击


503
00:31:54,815 --> 00:31:58,785
所以在一些情况下
这种重新转移是不会发生的


504
00:32:00,687 --> 00:32:04,424
如果用户明确地移动应用
只是移动应用本身


505
00:32:04,491 --> 00:32:07,127
如果他们将应用
和其他东西一同移动


506
00:32:07,427 --> 00:32:10,097
那这个机制不会关闭


507
00:32:10,764 --> 00:32:14,668
如果用户只移动应用本身
可能移动到/Applications


508
00:32:15,369 --> 00:32:17,237
那这个机制会被关闭


509
00:32:19,573 --> 00:32:23,343
如果给磁盘镜像签名
那这就不会发生


510
00:32:23,911 --> 00:32:26,246
所以任何从带有签名的
磁盘镜像运行的应用


511
00:32:26,313 --> 00:32:28,248
这个机制将不会得到应用


512
00:32:31,318 --> 00:32:33,420
这种机制也不会起作用


513
00:32:33,520 --> 00:32:37,157
若你使用带签名的Apple
Installer Package安装软件


514
00:32:40,561 --> 00:32:43,564
这也不会应用于任何来自
Mac App Store的应用


515
00:32:49,403 --> 00:32:52,773
所以简要来说
本次演讲中的两个收获是


516
00:32:53,140 --> 00:32:56,810
给你传输的内容进行签名
然后检查内容是否有效


517
00:32:59,780 --> 00:33:02,416
所以关于本次演讲的
更多信息可以在这里找到

