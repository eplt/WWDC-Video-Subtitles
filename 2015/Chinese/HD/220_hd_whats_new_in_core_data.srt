1
00:00:20,721 --> 00:00:24,324
Core Data 新中的内容


2
00:00:31,465 --> 00:00:34,201
下午好！
欢迎收看第 220 课


3
00:00:34,768 --> 00:00:38,172
我叫瑞西 卫尔玛稍后
斯克特 佩瑞将跟我一道


4
00:00:38,572 --> 00:00:41,408
为您展示今年
Core Data 中的新内容


5
00:00:43,177 --> 00:00:44,778
不过 在我们进入正题之前


6
00:00:45,012 --> 00:00:47,381
我想给大家讲一下什么是
Core Data


7
00:00:48,315 --> 00:00:52,819
现在 你们中的很多已经开发了
这些很棒的有漂亮 UI 的 app


8
00:00:52,886 --> 00:00:55,322
你们已经把它
与从外部数据源获取的


9
00:00:55,389 --> 00:00:57,858
或者来自于提供给你们的


10
00:00:57,925 --> 00:00:59,226
资源框架的数据结合起来


11
00:00:59,726 --> 00:01:02,029
那么当你处理那些对象的时候


12
00:01:02,262 --> 00:01:06,767
你将创建一个复杂的图形
并将所有的那些更改向UI传递


13
00:01:07,434 --> 00:01:09,837
然后当你的用户
对 UI 做出更改的时候


14
00:01:09,903 --> 00:01:11,972
您将把所有的那些改动
推送回到您的对象图


15
00:01:12,072 --> 00:01:16,076
并推送回到您的数据源


16
00:01:16,143 --> 00:01:17,845
那么 Core Data
让这个变得容易


17
00:01:18,679 --> 00:01:20,781
Core Data
将为您管理对象图


18
00:01:21,682 --> 00:01:24,451
简单告诉我们一点
关于您的 Cocoa 模型


19
00:01:24,685 --> 00:01:26,987
以及对象模型编辑器的信息
告诉我们一点


20
00:01:27,054 --> 00:01:29,223
关于您的对象和它们的属性的信息


21
00:01:29,590 --> 00:01:33,260
以及它们的相互关系
而我们将负责剩下的工作


22
00:01:33,594 --> 00:01:37,631
而且我们也将
在您选择的后台维持它


23
00:01:37,998 --> 00:01:41,368
不管它是 SQLite
或是您自己设定的存储方式


24
00:01:42,469 --> 00:01:47,407
于是 随着你不断导入对象
你的各种关系将发生改变


25
00:01:47,774 --> 00:01:49,943
而Core Data
将为您维护这些关系


26
00:01:50,010 --> 00:01:52,446
因此如果您在您的对象模型
设置任何通用删除规则


27
00:01:52,513 --> 00:01:55,082
我们将删除一个对象


28
00:01:55,148 --> 00:01:57,317
并将按照你的定义
根据规则统一删除


29
00:01:59,319 --> 00:02:03,423
在你的对象图里
找到对象也是特别容易的


30
00:02:04,324 --> 00:02:06,493
只须使用一个
NSFetchRequest


31
00:02:07,127 --> 00:02:08,662
并赋给它一个 predicate


32
00:02:08,729 --> 00:02:10,430
来找到你在寻找的对象


33
00:02:10,830 --> 00:02:12,399
我们将为你扎到它们


34
00:02:13,734 --> 00:02:16,036
批处理也很方便


35
00:02:16,770 --> 00:02:20,874
这让你从读取请求得到的数据集里面


36
00:02:20,941 --> 00:02:23,777
仅提取一小部分对象


37
00:02:24,278 --> 00:02:27,614
让您在检查数据集的时候
需要处理的数据变少


38
00:02:27,681 --> 00:02:31,451
此外
NSFetchRequest 的


39
00:02:31,618 --> 00:02:35,022
另一个特性是关系的预读取


40
00:02:35,822 --> 00:02:39,593
告诉我们一个需要读取的对象


41
00:02:39,660 --> 00:02:41,895
我们会预读取所有与其相关的对象
所以当你遍历那一关系的时候


42
00:02:41,962 --> 00:02:44,865
你将仍然在内存中进行


43
00:02:47,067 --> 00:02:50,070
然后你只须把所有这些绑定到 UI


44
00:02:51,071 --> 00:02:54,041
你把一个NSFetchResult
Controller


45
00:02:54,174 --> 00:02:56,376
绑定到一个餐桌视图
就像我们这里所做的一样


46
00:02:56,944 --> 00:02:58,579
而当我删除苹果酱时


47
00:02:59,012 --> 00:03:00,747
我的 UI 会相应地更新


48
00:03:01,882 --> 00:03:06,286
然后当我插入更多对象时
我添加了香蕉面包


49
00:03:06,787 --> 00:03:08,689
我的 UI 也会相应更新


50
00:03:09,356 --> 00:03:12,392
这些都为你处理
所有的关键视图行为


51
00:03:12,693 --> 00:03:15,562
以及更改通知 Core Data
都会为你进行处理


52
00:03:17,064 --> 00:03:18,866
抱歉


53
00:03:19,833 --> 00:03:21,668
不过可能有一种情况


54
00:03:22,069 --> 00:03:25,172
您的用户正在主上下文操作一个对象


55
00:03:25,739 --> 00:03:30,410
而在背景上下文
也在导入同样的新对象


56
00:03:30,477 --> 00:03:34,214
而且可能正在更新目前用户


57
00:03:34,281 --> 00:03:35,449
正在操作的对象


58
00:03:36,216 --> 00:03:38,652
这就引入了“多写入者冲突”的概念


59
00:03:39,553 --> 00:03:42,289
在 Core Data 中
这里它也为您进行了处理


60
00:03:42,990 --> 00:03:46,960
我们为所有对象进行版本描述
并让您设定合并策略


61
00:03:47,728 --> 00:03:50,764
如果您不舍得合并策略
我们将在您将其存入上下文时


62
00:03:50,831 --> 00:03:52,165
默认出错


63
00:03:52,766 --> 00:03:55,202
并提示您出现了冲突错误


64
00:03:55,769 --> 00:03:57,838
让您以自己认为合适的方式
处理冲突


65
00:03:58,605 --> 00:04:01,241
或者您可以从我们已提供的策略中


66
00:04:01,308 --> 00:04:02,543
选择多个合并策略


67
00:04:02,776 --> 00:04:07,014
不管它是在内存中
还是在持久存储中


68
00:04:07,080 --> 00:04:10,951
不管是持久存储优于内存
还是相反


69
00:04:11,618 --> 00:04:14,087
选择最适合您的
最适合您的特定情况的


70
00:04:15,455 --> 00:04:18,058
一旦您选用了 Core Data
你会有几大好处


71
00:04:18,125 --> 00:04:20,560
我要给特别大家讲两个


72
00:04:20,627 --> 00:04:22,963
真正最大的好处


73
00:04:23,664 --> 00:04:27,401
出色的内存可升级性以及
积极的延迟加载


74
00:04:28,135 --> 00:04:32,239
那是什么意思呢？
就是说我们仅当您在内存中


75
00:04:32,472 --> 00:04:34,241
需要那些对象的时候我们才加载它们


76
00:04:35,375 --> 00:04:38,745
采用Core Data会导致
占用空间的大幅减小


77
00:04:39,513 --> 00:04:42,749
您需要维护的代码
减少 50 到 70%


78
00:04:42,816 --> 00:04:44,685
让您有更多的时间


79
00:04:44,751 --> 00:04:47,154
开发您的 app 的新特性


80
00:04:48,088 --> 00:04:49,489
然后您就可以加入


81
00:04:49,556 --> 00:04:51,491
App Store中
已在使用Core Data的


82
00:04:51,558 --> 00:04:53,493
40多万个 app 了


83
00:04:54,728 --> 00:04:56,463
Core Data 的概述到此为止


84
00:04:57,431 --> 00:04:59,366
现在让我们进入新内容


85
00:04:59,666 --> 00:05:01,535
我们为您准备的所有新的 API


86
00:05:03,003 --> 00:05:05,706
首先让我们从
NSManagedObject


87
00:05:06,440 --> 00:05:08,208
和一个新的属性


88
00:05:08,275 --> 00:05:10,310
hasPersistent
ChangedValues开始


89
00:05:12,045 --> 00:05:14,748
以前您可能
已经用过hasChanges


90
00:05:14,982 --> 00:05:19,086
这是一个相当基础的脏标志
如果你碰了这个对象


91
00:05:19,152 --> 00:05:20,821
我们会将其
标志为脏的 dirty


92
00:05:20,888 --> 00:05:24,057
但是通过
hasPersistentchangedValues


93
00:05:24,124 --> 00:05:27,928
我们将确保对象的属性


94
00:05:27,995 --> 00:05:31,331
与持久存储中的不同
确保您不会有任何误报


95
00:05:33,800 --> 00:05:37,171
NSManagedObject
的新特性还包括


96
00:05:37,237 --> 00:05:39,406
objectIDsFor
RelationshipNamed


97
00:05:39,940 --> 00:05:43,577
这个非常适合用于大型关系


98
00:05:44,878 --> 00:05:47,714
因为将不会在内存内
将整个关系实体化


99
00:05:47,781 --> 00:05:49,983
而是会将已经归类的


100
00:05:50,050 --> 00:05:52,653
一系列对象的ID返还给您


101
00:05:53,287 --> 00:05:56,390
这让您能够以更小的规模
检查这些对象的ID


102
00:05:56,456 --> 00:05:58,225
并且以处理您的更小的对象


103
00:05:58,992 --> 00:06:00,961
让我快速地为您
展示一个代码示例


104
00:06:02,763 --> 00:06:04,631
这里是我的人物对象


105
00:06:04,698 --> 00:06:08,635
而我请求它的关系对象
ID“family”


106
00:06:09,303 --> 00:06:11,872
这会给我全部关系
然后我可以


107
00:06:11,939 --> 00:06:15,209
去读取这些关系
每批 100 个


108
00:06:16,276 --> 00:06:18,979
然后以每次100个的速度
遍历这些关系


109
00:06:19,046 --> 00:06:23,083
这让我把向内存的输入
维持在相当小的水平


110
00:06:23,483 --> 00:06:24,852
而且易于管理


111
00:06:26,486 --> 00:06:29,489
让我们继续往下讲NSManaged
ObjectContext


112
00:06:30,057 --> 00:06:34,361
和一个名为refresh
AllObjects的新方法


113
00:06:36,430 --> 00:06:39,666
RefreshAllObjects
所做的事情和你料想的完全一样


114
00:06:39,733 --> 00:06:41,635
它把您的上下文中的对象更新


115
00:06:42,302 --> 00:06:44,137
但是保留未被保存的更改


116
00:06:44,204 --> 00:06:47,040
而且与reset
on the context不同的是


117
00:06:47,107 --> 00:06:49,610
您对对象的引用仍然有效


118
00:06:50,110 --> 00:06:52,713
因此 您不必重取任何引用


119
00:06:52,779 --> 00:06:56,049
而它最适合用于
打破可能已出现的循环引用


120
00:06:56,116 --> 00:06:59,086
循环引用是当你
遍历一个双向关系时


121
00:06:59,152 --> 00:07:01,054dle
你陷入循环中


122
00:06:59,152 --> 00:07:01,054
你陷入循环中


123
00:07:02,923 --> 00:07:05,759
此外NSManagedObjectContext的
新特性还包括：


124
00:07:06,159 --> 00:07:09,329
对于那些在您的存储中
使用多个协调程序的朋友


125
00:07:10,364 --> 00:07:12,999
MergeChangesFrom
RemoteContextSave


126
00:07:13,066 --> 00:07:16,904
将从一个协调程序接收通知


127
00:07:16,970 --> 00:07:19,473
并将其用于另一个
协调程序的上下文


128
00:07:20,007 --> 00:07:21,842
这让您在您的上下文中
有最新的行数据


129
00:07:21,909 --> 00:07:25,279
而我们将为您照看


130
00:07:25,345 --> 00:07:27,247
所有必要的上下文


131
00:07:32,953 --> 00:07:35,322
在 Core Data 中
偶尔你会遇到某个特别的例外


132
00:07:35,389 --> 00:07:37,357
而那对于开发者


133
00:07:37,424 --> 00:07:38,692
将是非常容易识别的


134
00:07:39,193 --> 00:07:41,061
那就是无法加载某个错误


135
00:07:42,529 --> 00:07:44,831
为什么Core Data
无法加载这个错误呢?


136
00:07:45,566 --> 00:07:48,468
好了 正如我早些时候提到的
在延迟加载对象方面


137
00:07:48,535 --> 00:07:52,239
Core Data 是非常积极的
您在内存中


138
00:07:52,306 --> 00:07:55,609
将只有对象图中的一部分
而且当我们试图遍历一个关系时


139
00:07:55,676 --> 00:07:59,246
我们将可以回到磁盘


140
00:07:59,646 --> 00:08:02,015
并发现那个对象已经被删除了


141
00:08:03,483 --> 00:08:05,285
什么是比遇到例外更好的事情？


142
00:08:05,485 --> 00:08:07,054
有很多


143
00:08:07,154 --> 00:08:08,488
我们已经在


144
00:08:08,555 --> 00:08:10,490
NSManagedObjectContext
上面


145
00:08:10,557 --> 00:08:12,226
推出了一个新的属性


146
00:08:12,292 --> 00:08:14,394
它让你能够设置一些基础的


147
00:08:14,461 --> 00:08:16,563
faultingDelegated
API


148
00:08:21,001 --> 00:08:21,935
目前


149
00:08:22,002 --> 00:08:24,171
shouldDelete
InaccessibleFaults


150
00:08:24,238 --> 00:08:25,506
默认为 yes


151
00:08:25,806 --> 00:08:29,576
如果我们遇到一个错误
我们将把它标记为deleted


152
00:08:30,077 --> 00:08:33,280
而任何缺失的属性都将是null或0


153
00:08:33,847 --> 00:08:37,284
这让您的app持续这一对象


154
00:08:37,717 --> 00:08:39,318
并将其当作一个
已被删除的对象处理


155
00:08:40,120 --> 00:08:42,188
您将不会再崩溃
但是您将可以继续下去


156
00:08:42,256 --> 00:08:47,361
并且向用户展示
他们预期将会看到的东西


157
00:08:50,230 --> 00:08:51,098
现在关于


158
00:08:51,164 --> 00:08:54,768
NSPersistentStoreCoordinator


159
00:08:54,835 --> 00:08:56,970
我们要介绍两个新的 API


160
00:08:58,372 --> 00:09:01,542
我们推出了这两个新的API
是因为我们发现开发者


161
00:09:01,642 --> 00:09:05,579
在如何清理他们的
持久存储方面存在问题


162
00:09:06,413 --> 00:09:07,814
你们中的一些人做过这样的事情


163
00:09:07,881 --> 00:09:10,717
您已经经过或绕过
Core Data API 层


164
00:09:11,118 --> 00:09:12,986
而直接操作你的数据库


165
00:09:13,887 --> 00:09:17,724
不幸的是带来了意想不到的后果


166
00:09:18,492 --> 00:09:21,061
您可能让坏卷描述符保持开放状态


167
00:09:21,762 --> 00:09:24,164
所以我们为您提供了


168
00:09:24,698 --> 00:09:27,067
destroyPersistentStoreAtURL


169
00:09:32,773 --> 00:09:34,808
就像 addPersistent StoreAtURL
一样


170
00:09:34,875 --> 00:09:36,076
你做出了同样的选择


171
00:09:36,343 --> 00:09:38,178
而且你可以破坏那一持久存储区


172
00:09:38,712 --> 00:09:42,749
而我们将遵守所有的锁定协议


173
00:09:42,816 --> 00:09:45,819
并将所有相关文件清理出来
放到您已选择使用的


174
00:09:45,886 --> 00:09:46,887
特定类型的存储区


175
00:09:47,688 --> 00:09:49,456
以那种同样的方式


176
00:09:49,523 --> 00:09:52,793
我们推出了
replacePersistentStoreAtURL


177
00:09:53,327 --> 00:09:56,897
这和破坏的模式类似
而如果目标数据库并不存在


178
00:09:57,197 --> 00:10:00,133
我们将只须把它复制到位即可


179
00:10:00,868 --> 00:10:04,872
一个大家都曾遇到的问题是副本


180
00:10:06,039 --> 00:10:08,842
一个带有副本的数据库是无用的


181
00:10:09,309 --> 00:10:10,677
你已经写了大量的代码


182
00:10:10,911 --> 00:10:12,279
来确保你没有副本


183
00:10:13,213 --> 00:10:15,516
这里 Core Data
也可以帮你


184
00:10:16,517 --> 00:10:19,152
首先让我们看下
为了发现副本


185
00:10:19,453 --> 00:10:20,654
你们可能已用过的常见模式


186
00:10:21,154 --> 00:10:22,723
即“寻找或创建”模式


187
00:10:23,924 --> 00:10:28,028
在这里 如你所见
我建立了一个读取请求并且


188
00:10:28,095 --> 00:10:30,998
我必须寻找一个特别的对象


189
00:10:31,064 --> 00:10:34,201
看它是否存在
然后才能创建它


190
00:10:34,268 --> 00:10:36,436
如果它确实存在 我就更新它


191
00:10:37,404 --> 00:10:41,108
不过这种模式可能是相当有风险的
而且如果我有


192
00:10:41,475 --> 00:10:45,712
来自于多个数据源的线程的话
它可能导致多个副本


193
00:10:46,480 --> 00:10:50,284
而Core Data今年已为您
提供了保护


194
00:10:50,350 --> 00:10:53,320
只须告诉我们在一个实体内的
哪些属性应是唯一的


195
00:10:53,587 --> 00:10:56,356
我们就将确保该实体的所有实例


196
00:10:56,723 --> 00:11:00,227
都保持那一唯一属性
不管它是电子邮件 零部件编号


197
00:11:00,294 --> 00:11:02,863
通用产品代码 等等
我们将确保它在


198
00:11:02,930 --> 00:11:04,431
它在所有实例中都是唯一的


199
00:11:11,538 --> 00:11:16,009
当唯一实例
唯一约束条件


200
00:11:16,410 --> 00:11:18,745
被用于对象创建后的
未被修改的数值时


201
00:11:18,812 --> 00:11:21,315
是最佳的


202
00:11:21,381 --> 00:11:24,418
通常当你创建对象的时候
这些唯一约束条件


203
00:11:24,518 --> 00:11:27,087
应被一次性设定
然后在对象存续期间永不更改


204
00:11:28,222 --> 00:11:31,625
更改它们可能导致冲突


205
00:11:32,192 --> 00:11:35,362
因为您的唯一属性可能会与


206
00:11:35,429 --> 00:11:37,197
有同样的唯一属性的
另一个对象冲突


207
00:11:37,731 --> 00:11:40,367
那时候您就可以使用我们之前


208
00:11:40,434 --> 00:11:42,669
在合并策略中讲到的恢复方法


209
00:11:43,337 --> 00:11:44,371
来解决那些问题


210
00:11:45,305 --> 00:11:49,276
此外 任何从具有
唯一约束条件的父实体


211
00:11:49,343 --> 00:11:53,013
继承的实体也将继续那些约束条件


212
00:11:53,714 --> 00:11:56,884
在上面的例子中您可以看出
父实体有一个已被确认的


213
00:11:56,950 --> 00:11:59,119
UUID约束条件
作为唯一约束条件


214
00:11:59,853 --> 00:12:03,857
子实体已经添加了电子邮件


215
00:12:03,924 --> 00:12:05,559
作为对其唯一约束条件的补充


216
00:12:07,895 --> 00:12:11,331
现在我想为您快速展示一下


217
00:12:11,532 --> 00:12:13,600
如何利用唯一约束条件


218
00:12:16,069 --> 00:12:19,373
那么这里我们将使用食谱 app
我们前些年一直在为您展示


219
00:12:19,439 --> 00:12:23,043
可以在开发者门户
将其下载


220
00:12:23,777 --> 00:12:26,680
我们增加了一个新性能
即右下方的 import 导入


221
00:12:27,514 --> 00:12:30,117
这让我可以导入任何我喜欢的


222
00:12:30,384 --> 00:12:31,852
与苹果相关的食谱


223
00:12:33,420 --> 00:12:35,556
这里我们回退
你看到我增加了


224
00:12:35,622 --> 00:12:39,660
所有我喜欢的苹果食谱
然而我的 UI 并不是非常直观


225
00:12:39,726 --> 00:12:42,763
用户在点击的时候


226
00:12:42,829 --> 00:12:44,831
可能会怀疑哪里出错了


227
00:12:44,898 --> 00:12:47,301
不幸的是他们已复制了他们的数据


228
00:12:50,470 --> 00:12:52,773
这里我们可以有很大的改善


229
00:12:53,340 --> 00:12:55,876
让我们回到 Xcode
并看一下我们的对象模型


230
00:12:56,777 --> 00:12:59,847
而这里我们在设置我们的实体
我将选择一个食谱


231
00:13:02,382 --> 00:13:05,185
而现在我这里有了一个新选择


232
00:13:05,252 --> 00:13:07,888
就在右边
叫做 unique 唯一


233
00:13:08,655 --> 00:13:11,391
这让我指定那些属性


234
00:13:11,458 --> 00:13:13,527
对于这个特定实体
是唯一的


235
00:13:14,261 --> 00:13:17,364
在此例中我们将有
源 ID 和永久性 ID


236
00:13:21,468 --> 00:13:24,371
那么现在当我运行这个食谱app时


237
00:13:26,240 --> 00:13:28,108
我们将看到我有一个原始清单


238
00:13:28,575 --> 00:13:32,479
我可以把它导入
然后选择我的苹果食谱


239
00:13:32,980 --> 00:13:34,381
但是我也缺乏耐心


240
00:13:34,448 --> 00:13:37,050
没看到任何 UI
所以我不断点击


241
00:13:37,684 --> 00:13:41,688
这次我们有了单一对象
代表它们全部


242
00:13:42,689 --> 00:13:45,826
不必寻找或创建任何副本
任何代码


243
00:13:46,593 --> 00:13:49,730
您的唯一约束条件确保了您的唯一性


244
00:13:57,671 --> 00:14:02,509
然而有了所有那些副本并不是理想的


245
00:14:03,377 --> 00:14:05,579
删掉副本可能需要做大量工作


246
00:14:05,979 --> 00:14:07,781
这时候就要
斯克特 佩瑞出场了


247
00:14:07,848 --> 00:14:09,616
他将向我们展示
我们对此能做些什么


248
00:14:15,889 --> 00:14:16,723
谢谢 瑞西！


249
00:14:18,058 --> 00:14:20,394
那么假如您已经有了一个app


250
00:14:20,694 --> 00:14:22,496
而且您已经有了所有这些
已被复制的数据


251
00:14:23,197 --> 00:14:25,199
现在您必须把它们全部删除


252
00:14:25,866 --> 00:14:29,203
今天您必须要做的是
将它们全部从内存中提取出来


253
00:14:29,670 --> 00:14:32,639
抱歉 是从存储中...
一旦它们进入内存


254
00:14:32,706 --> 00:14:35,576
你将它们标记以便删除
然后您必须将其


255
00:14:35,642 --> 00:14:37,811
存储到持久性存储中
如果您有很多对象


256
00:14:37,878 --> 00:14:41,315
您将不得不一次又一次地删除


257
00:14:41,682 --> 00:14:44,084
以维持足够低的内存占用


258
00:14:44,151 --> 00:14:45,786
让您的 app 维持活跃状态


259
00:14:47,020 --> 00:14:51,825
若只是为了将它们删除
而将对象加载到内存中


260
00:14:51,892 --> 00:14:54,027
似乎有点愚蠢


261
00:14:54,094 --> 00:14:56,630
今年我们已推出了一种新的 API


262
00:14:56,697 --> 00:14:58,432
它的形式是
NSBatchDeleteRequest


263
00:14:59,766 --> 00:15:01,668
NSBatchDeleteRequest
的工作原理


264
00:15:01,735 --> 00:15:03,437
类似于
NSBatchUpdateRequest


265
00:15:03,670 --> 00:15:07,107
在于它直接在持久性存储中发挥作用
而无须向内存中加载任何对象


266
00:15:08,308 --> 00:15:10,077
你可以使用NSFetchRequest
的一个实例创建它


267
00:15:10,143 --> 00:15:14,181
指定一个实体
一个或更多的存储


268
00:15:14,314 --> 00:15:19,353
并使用predicate
来源或限制来分割数据


269
00:15:19,419 --> 00:15:22,322
以您希望的任何方式


270
00:15:24,691 --> 00:15:26,627
批删除请求会返回一个方框型


271
00:15:26,693 --> 00:15:28,729
NSBatchDeletesResult


272
00:15:28,896 --> 00:15:30,731
而你可以对请求进行配置


273
00:15:30,797 --> 00:15:33,534
以便返回一个默认的成功或失败


274
00:15:34,067 --> 00:15:37,137
被删除的对象的总数


275
00:15:37,204 --> 00:15:39,306
或该方框中的对象的对象ID


276
00:15:41,608 --> 00:15:43,243
这样的做法有几个限制


277
00:15:43,377 --> 00:15:45,145
因为对象都没有被加载到内存中


278
00:15:45,579 --> 00:15:47,781
更改并没有别反映到上下文中


279
00:15:47,848 --> 00:15:49,950
而且您的验证规则都没有被运行


280
00:15:50,817 --> 00:15:54,054
各种关系将被酌情删除或作废


281
00:15:54,121 --> 00:15:56,590
但是那是你得到的所有保证


282
00:15:56,657 --> 00:15:58,292
也有“无对象通知”


283
00:15:59,293 --> 00:16:02,062
我们认为这对有大量副本的人们


284
00:16:02,129 --> 00:16:03,797
将确实是有帮助的


285
00:16:03,864 --> 00:16:05,599
现在我想为大家展示它如何工作


286
00:16:10,037 --> 00:16:12,940
那么我这里有同样的食谱 app


287
00:16:13,006 --> 00:16:14,374
而且带有一份从我的经理那里
拷贝来的数据库


288
00:16:14,441 --> 00:16:18,579
他说他的一个孩子拿到了它


289
00:16:18,645 --> 00:16:21,281
并且添加了大量的食谱
比如数以千计


290
00:16:22,349 --> 00:16:24,451
如果我们以旧的方法检查它


291
00:16:24,518 --> 00:16:28,856
那么我们将只是用一个读取请求


292
00:16:28,922 --> 00:16:32,092
读取我们想要删除的所有对象


293
00:16:32,726 --> 00:16:36,430
然后对它们全部进行迭代
删除它们


294
00:16:36,530 --> 00:16:39,333
然后以我们设置的
每批1000的规模


295
00:16:39,399 --> 00:16:41,368
保存更改


296
00:16:41,869 --> 00:16:43,403
如果您试着这么做


297
00:16:47,241 --> 00:16:51,211
我们可以在这里的控制台看到
它会耗费一点时间


298
00:16:52,346 --> 00:16:53,380
你可以看到我们在...


299
00:16:53,447 --> 00:16:54,781
由于我们在进行
以成千上万计算的批处理


300
00:16:54,848 --> 00:16:58,218
我们现在正在进行第一批
现在仍在进行中


301
00:17:00,320 --> 00:17:02,723
这会耗费一点时间
我们将不会站在这里等着它


302
00:17:02,789 --> 00:17:07,327
如果我们在一个合适的点闯入
我们可以强制停止app


303
00:17:09,229 --> 00:17:12,432
并再次尝试使用批删除


304
00:17:15,969 --> 00:17:17,271
让我们把这些删了


305
00:17:22,809 --> 00:17:25,546
使用与我们之前使用的
同样的读取请求


306
00:17:25,612 --> 00:17:28,849
建立一个重复删除请求
然后我们


307
00:17:28,916 --> 00:17:31,351
将选择一个
计数器resultType


308
00:17:31,418 --> 00:17:33,220
以便我能够看到
我们做了些什么


309
00:17:34,888 --> 00:17:35,923
这里我们将执行它


310
00:17:35,989 --> 00:17:39,426
它的代码少得多
而且只有一个执行请求


311
00:17:39,493 --> 00:17:41,461
没有循环
没有与对象的互动


312
00:17:41,528 --> 00:17:43,063
如果我们运行这段代码


313
00:17:47,801 --> 00:17:49,036
...我们将回到这里


314
00:17:53,207 --> 00:17:56,677
这里你可以看到
在查询语句中编辑器


315
00:17:56,743 --> 00:17:58,745
建立了一个触发器
它删除了所有


316
00:17:58,812 --> 00:18:01,281
需要被清理的关系
我们也就完成了这点工作


317
00:18:03,517 --> 00:18:05,118
回到下边简单地看一些食谱


318
00:18:05,185 --> 00:18:07,187
那么现在我们就可以应用
这些唯一约束条件了


319
00:18:14,595 --> 00:18:16,597
那就是
NSBatchDeleteRequest


320
00:18:18,131 --> 00:18:21,134
接下来我想谈一下模型的版本控制
model versioning


321
00:18:22,135 --> 00:18:24,872
当我们创建新版本的食谱app时


322
00:18:25,706 --> 00:18:27,541
为了支持“导入”这一特性


323
00:18:27,608 --> 00:18:30,410
我们不得不对食谱实体
添加两个属性


324
00:18:30,477 --> 00:18:33,647
来源以及外部 ID
瑞西 早些时候给大家演示过了


325
00:18:34,348 --> 00:18:37,384
在进行这个工作期间
我们打开了模型


326
00:18:37,451 --> 00:18:39,353
添加了两个属性
然后构建并运行


327
00:18:39,419 --> 00:18:41,922
我们立刻就遇到了错误


328
00:18:43,223 --> 00:18:44,858
我突出显示了最重要的部分


329
00:18:45,392 --> 00:18:48,428
我们遇到了一个迁移问题
因为版本已经发生了变化


330
00:18:48,495 --> 00:18:50,564
但是我忘记加入
起初的源模型


331
00:18:50,631 --> 00:18:53,400
因为我们就是在它基础上做出更改的


332
00:18:54,801 --> 00:18:57,004
而为了创建新模型
而复制旧模型的模式


333
00:18:57,070 --> 00:18:58,472
确实不方便


334
00:18:58,539 --> 00:18:59,673
进行您的app的迭代


335
00:18:59,773 --> 00:19:02,776
而如果您忘记将某个模型
部署到运行该版本的客户手中


336
00:19:02,843 --> 00:19:04,578
那确实是危险的


337
00:19:05,279 --> 00:19:09,416
这似乎就是自动的轻量级迁移
为您发挥作用的时候了


338
00:19:10,350 --> 00:19:14,388
现在我们的 iOS 9
和 OS X11


339
00:19:15,222 --> 00:19:16,490
有模型缓存功能


340
00:19:17,524 --> 00:19:20,627
不管你何时创建或迁移存储


341
00:19:20,694 --> 00:19:23,197
或者仅是在新的 iOS 上


342
00:19:23,263 --> 00:19:26,667
打开较旧的模型
用来创建它的受管理的对象模型


343
00:19:26,733 --> 00:19:30,871
被缓存到存储内
并且当轻量级迁移任务


344
00:19:30,938 --> 00:19:32,773
它们无法找到合适的源模型的时候


345
00:19:32,840 --> 00:19:36,610
这可以作为一种最后一搏的尝试


346
00:19:45,185 --> 00:19:46,553
有几个限制


347
00:19:46,620 --> 00:19:48,555
这只适用于 SQLite 存储


348
00:19:48,789 --> 00:19:50,057
而且对重量级迁移


349
00:19:50,123 --> 00:19:51,325
不提供缓存版本


350
00:19:51,625 --> 00:19:54,094
如果您在进行重量级迁移
那您就该让您的版本准备就绪


351
00:19:54,161 --> 00:19:58,198
因为您需要知道您的迁移
是来自何方 去往何处


352
00:20:00,467 --> 00:20:03,403
瑞西 稍早时谈到了
我们添加的 API


353
00:20:03,470 --> 00:20:05,405
而我现在想谈的是一些变化


354
00:20:06,240 --> 00:20:08,742
对于 iOS 9 和
iOS X 1010


355
00:20:08,809 --> 00:20:10,511
Core Data采用了您已经在


356
00:20:10,577 --> 00:20:12,679
Objective-C中看到的
所有语言特性


357
00:20:12,746 --> 00:20:14,147
包括泛型和空值


358
00:20:14,548 --> 00:20:19,820
我们也利用了一个调用的新属性
它让向下转换变得容易一些


359
00:20:20,454 --> 00:20:22,256
您在其他讲座里面可能没有看到


360
00:20:22,322 --> 00:20:25,058
但这对Core Data来说
确实是方便的


361
00:20:25,459 --> 00:20:28,128
因为如果你正在
与一个对象类型ID互动


362
00:20:28,195 --> 00:20:31,465
您可以将其向下转换
到甚至完全不适合的类型


363
00:20:31,932 --> 00:20:34,635
你可以为某个类型设置属性


364
00:20:34,701 --> 00:20:37,538
但是它只能被向下转换
到该种类型的子类型


365
00:20:39,072 --> 00:20:41,208
这将会在编译器上为您的代码
增加很多安全性


366
00:20:41,775 --> 00:20:43,944
因为当一个缓存似乎毫无意义时


367
00:20:44,011 --> 00:20:46,747
它会限制发出警报


368
00:20:49,249 --> 00:20:51,919
为了使用泛型
已生成的子类也已被更新


369
00:20:52,186 --> 00:20:54,521
以便满足大量的关系
以及空值的需求


370
00:20:54,955 --> 00:20:56,423
而且我们已经对子类的生成机制


371
00:20:56,490 --> 00:20:58,625
做出了一些其他的更改


372
00:20:59,359 --> 00:21:04,364
在 Xcode 6 中
您会有一个执行文件


373
00:21:04,431 --> 00:21:07,201
和一个头文件用于使用同时包含
Core Data声明


374
00:21:07,634 --> 00:21:11,905
和放置您的所有代码的空位的
Objective-C


375
00:21:11,972 --> 00:21:14,908
它被用过之后就被扔掉了


376
00:21:14,975 --> 00:21:17,511
但是如果你更改了自己的版本


377
00:21:17,578 --> 00:21:19,279
更新日期就会变得有些不方便


378
00:21:19,346 --> 00:21:21,882
因此在 Xcode 7 中
我们增加了一个新的文件


379
00:21:23,584 --> 00:21:26,119
这个文件是一个扩展或类别


380
00:21:26,186 --> 00:21:27,421
取决于头文件中


381
00:21:27,487 --> 00:21:30,891
包含所有你熟悉的声明的语言


382
00:21:32,926 --> 00:21:35,529
那么现在 头文件
和执行文件是属于你自己的


383
00:21:35,596 --> 00:21:39,199
不管你何时更新模型
你所需做的就是更新这个文件


384
00:21:48,942 --> 00:21:50,344
关于变化就说那么多


385
00:21:50,878 --> 00:21:53,013
我想谈一下我们弃用的东西


386
00:21:53,647 --> 00:21:56,250
我们将在 iOs9 和
OS 1010 中


387
00:21:56,884 --> 00:21:59,019
去掉confinementConcurrency


388
00:21:59,086 --> 00:22:01,421
它已经被标为“弃用”
我们将在以后去掉它


389
00:22:03,490 --> 00:22:06,593
因为对于新的受管理的对象上下文


390
00:22:06,660 --> 00:22:10,063
Confinement是默认行为
因此我们也已经将其弃用


391
00:22:10,797 --> 00:22:13,800
因此未来您将使用
init concurrencyType


392
00:22:13,867 --> 00:22:15,269
为您的上下文使用


393
00:22:15,335 --> 00:22:17,538
专用队列或主队列


394
00:22:18,005 --> 00:22:18,906
如果您已经


395
00:22:18,972 --> 00:22:23,043
进行到了区块 API
这确实是一个不错的主义


396
00:22:23,110 --> 00:22:25,412
封装操作大大简化了您对


397
00:22:25,479 --> 00:22:28,448
自己的模型代码的推演而对Core
Data的并发性调试支持


398
00:22:28,515 --> 00:22:30,150
也增强了很多


399
00:22:31,885 --> 00:22:35,255
我强烈建议查看在线文稿


400
00:22:35,489 --> 00:22:38,292
今年 Core Data
指南已被彻底更新


401
00:22:38,959 --> 00:22:41,028
而 亞當·斯威夫特 也介绍了
区块 API


402
00:22:41,094 --> 00:22:42,863
他在 WWDC 2011 中的


403
00:22:42,930 --> 00:22:44,264
《Core Data on iOS
中的新内容》


404
00:22:44,331 --> 00:22:46,366
讲得确实不错


405
00:22:47,301 --> 00:22:49,770
最后我想谈一下性能


406
00:22:52,172 --> 00:22:55,709
随着时间推移
我们开始为模型增加属性


407
00:22:56,810 --> 00:23:00,380
由于这些年对我们的app不离不弃
您的用户携带的数据量在增大


408
00:23:00,447 --> 00:23:03,784
而我们试图查询和显示数据的方式


409
00:23:03,851 --> 00:23:07,054
也在变得更加有趣 更加先进


410
00:23:07,487 --> 00:23:09,923
我们的 app 也在维持很快的速度


411
00:23:11,925 --> 00:23:14,962
但是您怎样避免
突然出现性能问题呢？


412
00:23:15,963 --> 00:23:17,397
在开发过程中
您处理的是


413
00:23:17,464 --> 00:23:19,266
已知的可能较小的数据集


414
00:23:19,333 --> 00:23:20,534
比您的客户将要处理的要小


415
00:23:20,734 --> 00:23:23,837
而模拟器又比仅仅
维持设备运行所需快得多


416
00:23:24,638 --> 00:23:26,373
尽管它对开发非常有帮助


417
00:23:27,107 --> 00:23:29,443
用户将会使用带有生产数据的设备


418
00:23:30,744 --> 00:23:34,515
幸运的是我们提供一些工具


419
00:23:35,682 --> 00:23:37,751
让您发现能够表明性能问题的模式


420
00:23:37,818 --> 00:23:39,820
因此在它们在您的客户手里
成为问题之前


421
00:23:39,887 --> 00:23:41,488
您就可以解决它们


422
00:23:41,788 --> 00:23:44,858
我想讲三个需要注意的事情


423
00:23:44,925 --> 00:23:47,160
首先是关系错误


424
00:23:48,629 --> 00:23:50,564
这是 Core Data 工具


425
00:23:51,598 --> 00:23:53,500
我们刚刚运行了食谱 app


426
00:23:53,901 --> 00:23:58,539
在缓存缺失的工具项目下
我们立刻看见


427
00:23:58,605 --> 00:24:02,409
我们在三个想要显示的
对象上的缓存丢失了


428
00:24:03,076 --> 00:24:06,513
如果我们查看中间的那一列
我们会看到它们的食谱类型


429
00:24:07,981 --> 00:24:10,384
而现在你还记得我们今年
开发这个食谱 app 时


430
00:24:10,450 --> 00:24:12,819
我们对其进行了更新
以便让主列表视图


431
00:24:12,886 --> 00:24:14,721
在显示食谱本身的同时
显示食谱的类型


432
00:24:14,788 --> 00:24:16,390
但是我们从未更改读取请求


433
00:24:17,791 --> 00:24:19,660
我们可以通过向我们用来查看


434
00:24:19,726 --> 00:24:21,161
NSFetchResultsController
的


435
00:24:21,228 --> 00:24:22,429
查询命令增加一个


436
00:24:22,496 --> 00:24:24,565
relationshipKeypathsForPrefetching


437
00:24:24,631 --> 00:24:26,166
来解决这个问题


438
00:24:27,100 --> 00:24:29,403
现在 那些-那第一组


439
00:24:29,469 --> 00:24:31,872
丢失的缓存将不再是个问题


440
00:24:32,172 --> 00:24:34,374
如果我们回到同样的工具


441
00:24:34,441 --> 00:24:35,843
并且在稍后时再看下app里面


442
00:24:35,909 --> 00:24:38,045
我们可以看到
当我们查看一个食谱的详情时


443
00:24:38,111 --> 00:24:40,314
我们也引发了几个


444
00:24:40,380 --> 00:24:41,682
对数据库的查询


445
00:24:42,549 --> 00:24:47,254
这是因为详情查询控制器
从列表获得模型对象


446
00:24:47,621 --> 00:24:50,123
然后在详细视图里面我们显示


447
00:24:50,190 --> 00:24:51,792
那个食谱中的所有原料


448
00:24:52,392 --> 00:24:53,727
我们不能使用预读取操作


449
00:24:53,794 --> 00:24:55,796
因为那样我们将预读取
列表视图中显示的


450
00:24:55,863 --> 00:24:57,865
所有食谱的所有原料


451
00:24:57,931 --> 00:25:00,868
在详细视图中
在控制器中


452
00:25:01,168 --> 00:25:04,338
我们必须执行另一个读取请求
以便让那些原料出现在内存中


453
00:25:04,671 --> 00:25:07,107
现在我们已经将9个查询变成1个


454
00:25:07,174 --> 00:25:09,843
而我们仍能在食谱上使用这一关系


455
00:25:09,910 --> 00:25:12,079
对其遍历并且与它返回的数据集互动


456
00:25:12,145 --> 00:25:14,114
因为数据是在多个对象间共享的


457
00:25:17,451 --> 00:25:20,721
最后如果我们看一下
Core Data 工具视图中的


458
00:25:20,787 --> 00:25:23,824
读取工具
我们可以看到


459
00:25:23,891 --> 00:25:27,895
第一个读取请求花费的时间
超过了我们的预期


460
00:25:28,896 --> 00:25:31,164
它读取了 85 个对象


461
00:25:31,598 --> 00:25:33,300
当时我们只有 85 个对象


462
00:25:33,367 --> 00:25:35,903
如果我们有3万个对象的话
就像我在的示范中演示的那样


463
00:25:35,969 --> 00:25:38,372
这将确实是糟糕
app 甚至很可能不会启动


464
00:25:40,407 --> 00:25:44,278
在 Mac Pro上
它花费了15 毫秒


465
00:25:45,212 --> 00:25:47,948
那在 iOS 上会有大量的掉帧


466
00:25:48,348 --> 00:25:52,085
那么为解决这个问题
我们能做的就是增加


467
00:25:52,152 --> 00:25:54,855
我们向读取结果控制器
输入的读取请求的批的大小


468
00:25:54,922 --> 00:25:58,358
以便让对象仅按显示的需要
从存储读取


469
00:25:59,359 --> 00:26:03,864
我想展示的最后一项内容是...
sequence blocking


470
00:26:05,132 --> 00:26:08,068
如果您的读取确实复杂
且耗费大量时间


471
00:26:08,836 --> 00:26:11,939
那么您可以通过在程序上
使用这个参数找到它们


472
00:26:12,005 --> 00:26:15,042
而它会在您的读取请求
运行的同时


473
00:26:15,309 --> 00:26:20,180
开始输出相关数据


474
00:26:20,280 --> 00:26:23,617
这种情况下我们有一个查询
而它所花费的时间


475
00:26:23,684 --> 00:26:28,322
大约是十分之一秒


476
00:26:28,388 --> 00:26:29,790
返回了 85 行结果


477
00:26:30,290 --> 00:26:31,491
那是相当慢的


478
00:26:31,558 --> 00:26:33,060
我们将看一下如何做得更好


479
00:26:33,961 --> 00:26:35,762
如果我们向控制台的更高处滚动


480
00:26:35,829 --> 00:26:37,998
我们看到它输出了
我们正在使用的文件


481
00:26:38,432 --> 00:26:40,501
我们可以使用
SQLite连接那个文件


482
00:26:40,567 --> 00:26:42,169
以便弄清楚正在发生的情况


483
00:26:43,670 --> 00:26:44,838
如果我们把查询粘贴进去


484
00:26:44,905 --> 00:26:46,874
在 EXPLAIN QUERY
PLAN之后


485
00:26:46,940 --> 00:26:48,275
SQlite将告诉我们
它将试图做些什么


486
00:26:48,342 --> 00:26:51,512
以便用这个图表来回答我们的查询


487
00:26:52,813 --> 00:26:56,850
这里有几个需要注意的事情


488
00:26:56,917 --> 00:26:59,319
我们可以将其作为
衡量性能如何的度量指标


489
00:26:59,386 --> 00:27:03,323
第一个是扫描表
扫描表就是说SQLite


490
00:27:03,390 --> 00:27:07,427
将触探每行内容 检查每行内容
以完成查询


491
00:27:08,095 --> 00:27:10,364
而在食谱表里面
就像是稍早些时候一样


492
00:27:10,430 --> 00:27:12,599
我们有 3 万行内容
而我们将进行两次检查


493
00:27:12,666 --> 00:27:14,134
因此那将不会太快


494
00:27:14,201 --> 00:27:15,669
我们将进行考查 让它变得更好


495
00:27:16,770 --> 00:27:19,806
此外 我们还使用临时 B 树


496
00:27:20,374 --> 00:27:23,944
在这一步 SQLite利用数据
创建其自身的内存架构


497
00:27:24,011 --> 00:27:28,348
以便实现排序或快速搜索


498
00:27:30,317 --> 00:27:33,453
现在使用临时 B-树
是因为这里的这个group by


499
00:27:33,720 --> 00:27:36,323
如果我们更仔细地看一下


500
00:27:36,390 --> 00:27:38,825
它是因为外部 ID 中的来源


501
00:27:39,893 --> 00:27:42,930
通过使用复合索引
我们应能够让这个过程加快


502
00:27:43,430 --> 00:27:45,933
在Core Data模型编辑器中
我们可以在这里的右侧


503
00:27:46,033 --> 00:27:47,568
添加一个复合索引


504
00:27:50,137 --> 00:27:52,573
现在如果我们退出 SQLite
重建我们的项目


505
00:27:52,739 --> 00:27:55,175
执行迁移并且用SQLite连接
到新的数据库


506
00:27:55,242 --> 00:27:58,312
我们会发现
我们正在使用索引


507
00:27:59,012 --> 00:28:02,583
使用索引意味着搜索将会很快


508
00:28:03,417 --> 00:28:06,753
使用覆盖索引更快
这意味着那一步的结果


509
00:28:06,820 --> 00:28:09,423
是按照下一步需要的
自然顺序排列的


510
00:28:09,990 --> 00:28:12,392
因此我们已经
完全清除了临时 B 树


511
00:28:13,460 --> 00:28:15,829
但我们仍有这个扫描表


512
00:28:17,130 --> 00:28:20,067
在这种情况下
我们将匹配重复对象


513
00:28:20,133 --> 00:28:24,238
这是我们在示范中使用的查询
目的是找到需要删除的对象


514
00:28:24,838 --> 00:28:27,641
它必须扫描整个表格
它的速度是可以更快的


515
00:28:28,775 --> 00:28:31,745
剩下的唯一要做的事是确保
我们不碰主线程


516
00:28:32,379 --> 00:28:34,581
在此例中我们将使用
一个专用队列上下文


517
00:28:35,015 --> 00:28:38,785
但是如果您打算创建某些复合数据


518
00:28:38,852 --> 00:28:40,854
以便向用户展示


519
00:28:40,921 --> 00:28:42,823
您可能希望使用这个同步读取请求


520
00:28:42,890 --> 00:28:45,058
它将在主线程工作的时候
离开主线程


521
00:28:45,125 --> 00:28:46,960
然后当得到结果的时候再返回


522
00:28:47,995 --> 00:28:50,397
那么这些就是在您的 app 中
需要留意的三种主要模式


523
00:28:50,464 --> 00:28:52,099
它们让您能够在性能问题


524
00:28:52,165 --> 00:28:55,235
真正成为问题之前
解决它们


525
00:28:57,905 --> 00:29:00,174
关于今年Core
Data中的新内容就讲到这里


526
00:29:00,240 --> 00:29:02,075
如果您发现任何问题
请将其提交


527
00:29:02,142 --> 00:29:04,478
对立刻重新写出的示例app代码
有一个奖励


528
00:29:04,545 --> 00:29:06,880
它的错误会最先得到修复


529
00:29:07,548 --> 00:29:09,149
但是我们也有兴趣听到


530
00:29:09,216 --> 00:29:11,285
你们希望在Core Data
中看到的东西


531
00:29:11,351 --> 00:29:13,787
功能上的要求 改善方面的想法
而如我所言


532
00:29:13,854 --> 00:29:17,524
今年的文稿指南已全部经过修改
因此如果您发现任何相关问题


533
00:29:17,591 --> 00:29:19,560
我们也将乐于了解


534
00:29:20,794 --> 00:29:23,197
如需更多信息
请访问开发者门户


535
00:29:23,864 --> 00:29:25,799
我们的文稿以及示例代码


536
00:29:25,866 --> 00:29:28,802
您可以在开发者论坛
或通过 DTS 获得支持


537
00:29:29,870 --> 00:29:30,971
感谢您的莅临！

