1
00:00:19,319 --> 00:00:23,957
高级调试和地址消毒剂


2
00:00:27,794 --> 00:00:28,629
早上好


3
00:00:29,296 --> 00:00:32,064
欢迎来参加《高级调试和
地址消毒剂》讲座


4
00:00:32,566 --> 00:00:34,501
我是麦克...
大家怎么样呢？


5
00:00:35,035 --> 00:00:36,503
好吗？准备好啦？


6
00:00:36,870 --> 00:00:37,704
激动吗？


7
00:00:38,105 --> 00:00:39,039
好 现在就开始


8
00:00:42,309 --> 00:00:45,412
那我先来介绍
Xcode中加入的新功能


9
00:00:45,479 --> 00:00:47,414
还有一些大家


10
00:00:47,481 --> 00:00:49,283
可能不知道的
新旧技巧和诀窍


11
00:00:50,184 --> 00:00:51,552
先来说说视图调试器


12
00:00:51,785 --> 00:00:53,820
来看怎样才能
获得更多洞察力


13
00:00:53,887 --> 00:00:55,722
关于你的app UI及其用户...


14
00:00:57,391 --> 00:01:00,127
界面元素 以及它们
在运行时间如何表现


15
00:01:00,727 --> 00:01:02,996
我们会调试
AutoLayout Constraint问题


16
00:01:03,063 --> 00:01:05,364
至少对我而言
我需要一些帮助


17
00:01:05,432 --> 00:01:07,868
理解AutoLayout在
运行时间做些什么


18
00:01:08,969 --> 00:01:10,838
接下来 我们将详细分析用


19
00:01:10,904 --> 00:01:12,606
Advanced Breakpoints
调试代码


20
00:01:13,106 --> 00:01:16,276
我想给大家看看
如何设置自定义操作和条件


21
00:01:16,577 --> 00:01:18,245
快速分析例外情况


22
00:01:18,478 --> 00:01:19,947
在一定条件下打印值


23
00:01:20,180 --> 00:01:22,916
而不会因NSLogs和
打印把代码搞乱


24
00:01:23,917 --> 00:01:26,987
之后 我的同事安娜
会来介绍


25
00:01:27,054 --> 00:01:29,356
最新最兴奋的调试功能
这就是我们新加入


26
00:01:29,423 --> 00:01:32,559
Xcodes调试工具箱的
Address Sanitizer


27
00:01:33,460 --> 00:01:35,395
她会详细介绍
其工作方式


28
00:01:35,462 --> 00:01:36,997
可以捕捉到哪些问题


29
00:01:37,064 --> 00:01:40,634
以及今天就用它
来整理代码


30
00:01:41,134 --> 00:01:44,037
为了这两个话题
我觉得先用


31
00:01:44,304 --> 00:01:46,773
演示设备
给大家看看


32
00:01:55,849 --> 00:01:58,785
这里是个应用
名为Jogr


33
00:02:00,087 --> 00:02:03,490
这个健身应用
可以为跑步计时


34
00:02:03,557 --> 00:02:07,127
记录跑步路线
沿途会为照片加标签


35
00:02:07,828 --> 00:02:10,497
几年来我们都用Jogr
来做示范app


36
00:02:10,564 --> 00:02:13,800
今年我们添加了
一些使用Swift的新功能


37
00:02:14,101 --> 00:02:17,437
并转换了Objective-C
的若干类


38
00:02:17,671 --> 00:02:19,206
这是个非常混合的应用


39
00:02:19,940 --> 00:02:22,643
在故事板中也用了尺寸类


40
00:02:22,709 --> 00:02:24,378
并完全采用了AutoLayout


41
00:02:25,379 --> 00:02:27,915
因为今年我们改变并增加了
所有这些新代码


42
00:02:28,215 --> 00:02:30,117
可想而知其中会有程序错误


43
00:02:30,384 --> 00:02:31,552
来找找看


44
00:02:32,452 --> 00:02:35,889
先来点击这里的计时器


45
00:02:36,523 --> 00:02:40,127
第一个非常明显的问题是


46
00:02:40,194 --> 00:02:43,630
计时器周围的圆环
不是很整齐


47
00:02:44,131 --> 00:02:48,101
在我提供的最初设计中
并不是这样


48
00:02:49,036 --> 00:02:50,904
这可能是Jogr是在iPhone5


49
00:02:50,971 --> 00:02:53,740
的屏幕上运行有关的


50
00:02:54,474 --> 00:02:56,410
而当初是在
iPhone 6上开发的


51
00:02:56,510 --> 00:02:58,145
可能是我没有完全测试


52
00:02:58,212 --> 00:03:01,315
来看布局是否在小号的
屏幕上也适用


53
00:03:01,648 --> 00:03:05,352
为了想了解
到底出了什么问题


54
00:03:05,686 --> 00:03:08,522
我在下面的Debug条上


55
00:03:08,589 --> 00:03:12,192
点击了DebugView
Hierarchy按钮


56
00:03:12,993 --> 00:03:16,196
现在 获得了所有
视图的快照


57
00:03:16,263 --> 00:03:19,399
并在Xcode中装载了
关于视图


58
00:03:19,466 --> 00:03:21,702
会如何互动的运行时间信息


59
00:03:23,203 --> 00:03:26,406
我点击并拖动画布


60
00:03:26,773 --> 00:03:29,409
你会看到我可以
怎样扭动场景


61
00:03:29,476 --> 00:03:31,545
显示所有的不同视图
以及它们如何在


62
00:03:31,612 --> 00:03:32,646
彼此上方分层


63
00:03:32,713 --> 00:03:35,382
我甚至还点击具体视图来选择


64
00:03:36,083 --> 00:03:39,219
我们可以在对象检测器中看到


65
00:03:39,286 --> 00:03:40,487
所有细节


66
00:03:41,688 --> 00:03:43,557
现在有许多内容在继续


67
00:03:43,891 --> 00:03:47,294
有导航条和背景所有这些


68
00:03:47,361 --> 00:03:49,463
可我只想关注大家在意的一点


69
00:03:49,530 --> 00:03:52,299
也就是我放在中心的内容部分


70
00:03:53,400 --> 00:03:56,970
只要双击视图就可以做到


71
00:03:57,337 --> 00:04:00,641
万一你忘记了
我给大家看看怎么失焦


72
00:04:00,707 --> 00:04:02,409
就是在画布上双击即可


73
00:04:03,110 --> 00:04:06,446
这里可以继续只关注这一点


74
00:04:07,648 --> 00:04:11,451
你会注意到在这里
在Debug Navigator


75
00:04:11,618 --> 00:04:13,654
UI堆栈视图上的


76
00:04:15,222 --> 00:04:18,225
所有层次都已经省略


77
00:04:18,291 --> 00:04:20,928
因为我们最近
在关注UI堆栈视图


78
00:04:24,765 --> 00:04:30,237
如果我点击修剪后的图像


79
00:04:30,804 --> 00:04:34,041
我可以用这里的尺寸检测器


80
00:04:34,141 --> 00:04:39,112
检测平衡和约束条件


81
00:04:39,780 --> 00:04:43,183
尺寸检测器不仅是显示x y


82
00:04:43,250 --> 00:04:47,120
和这个的矩形坐标
还显示了


83
00:04:47,187 --> 00:04:49,423
影响视图运行时间的约束


84
00:04:49,957 --> 00:04:53,560
约束并非是现在在发挥作用


85
00:04:53,627 --> 00:04:56,930
它影响了大小 边界
或是x y


86
00:04:57,331 --> 00:04:58,999
在这里用灰色显示


87
00:04:59,833 --> 00:05:01,869
那么这就有点奇怪


88
00:05:02,135 --> 00:05:05,706
我看到高度约束是249点


89
00:05:05,806 --> 00:05:07,941
这实际是这个
图像内容的实际尺寸


90
00:05:08,041 --> 00:05:09,843
在运行时间
却没有真正运行


91
00:05:10,177 --> 00:05:11,345
如果我来看约束


92
00:05:11,411 --> 00:05:15,649
表示父视图应该和
图像同等大小


93
00:05:15,916 --> 00:05:17,184
我们看到它在运行


94
00:05:17,618 --> 00:05:20,020
看似是有其他部分在约束


95
00:05:20,087 --> 00:05:21,455
父视图的大小


96
00:05:22,122 --> 00:05:25,092
我们来看视图层次


97
00:05:25,192 --> 00:05:26,660
了解一下父视图发生了些什么


98
00:05:29,429 --> 00:05:32,399
这里
我们看到与其他视图


99
00:05:33,300 --> 00:05:38,272
是四分之三
或.75的关系


100
00:05:38,539 --> 00:05:40,274
我知道另一个视图


101
00:05:40,340 --> 00:05:42,643
包括下面的起始按钮


102
00:05:43,443 --> 00:05:45,479
在调试导航器上
我们还看到


103
00:05:45,546 --> 00:05:46,980
所有的同样约束


104
00:05:47,247 --> 00:05:49,716
可以像这样 打开


105
00:05:51,652 --> 00:05:54,388
我们看到
约束按钮的视图上


106
00:05:54,621 --> 00:05:56,456
有着相同的
四分之三约束


107
00:05:56,890 --> 00:05:58,725
所有这些
看上去都很正常


108
00:05:58,792 --> 00:06:01,328
上下关系
都是有条理的


109
00:06:01,395 --> 00:06:02,930
顶部高于底部


110
00:06:02,996 --> 00:06:06,300
底部和父视图底部相连
没别的了


111
00:06:06,500 --> 00:06:09,803
为什么我们
不能把视图层次再提高一层


112
00:06:11,839 --> 00:06:16,577
我们可以看出 这里有些奇怪


113
00:06:17,277 --> 00:06:19,947
我们有个中心 y-约束


114
00:06:20,013 --> 00:06:23,217
它想把整个堆栈视图中心


115
00:06:23,283 --> 00:06:25,352
垂直于容器中


116
00:06:25,419 --> 00:06:28,722
但是我们把这个自身顶部


117
00:06:28,789 --> 00:06:31,692
与父视图顶部相连
在50点


118
00:06:32,192 --> 00:06:33,961
这也有些奇怪


119
00:06:36,530 --> 00:06:38,699
我觉得50点的
约束不应该在这里


120
00:06:39,066 --> 00:06:40,367
我觉得在我开始


121
00:06:40,434 --> 00:06:42,903
打开视图到尺寸类时
它可能就已经加上了


122
00:06:42,970 --> 00:06:45,639
我告知IB
加入所有丢掉的约束


123
00:06:46,073 --> 00:06:47,941
之后我设置了垂直中心对齐


124
00:06:48,008 --> 00:06:49,910
我可能是忘记删除了


125
00:06:49,977 --> 00:06:53,580
我们在故事板上做修改


126
00:06:55,182 --> 00:06:56,517
来看是不是问题所在


127
00:06:57,518 --> 00:07:01,388
我可以选择堆栈视图
就在这里


128
00:07:01,455 --> 00:07:03,090
这是50点约束


129
00:07:03,156 --> 00:07:04,258
我会删掉它


130
00:07:04,992 --> 00:07:06,059
重新运行


131
00:07:09,396 --> 00:07:10,230
不错！


132
00:07:10,297 --> 00:07:13,300
现在圆形没问题了


133
00:07:13,433 --> 00:07:16,370
没有缺失
视图也完全可以修改


134
00:07:17,571 --> 00:07:20,407
我们再来运行计时器


135
00:07:22,876 --> 00:07:24,811
好的看似有异常


136
00:07:25,846 --> 00:07:28,448
我会打开
Debug Navigator


137
00:07:28,515 --> 00:07:31,852
查看异常的线程


138
00:07:32,452 --> 00:07:34,488
但是看似不是很有用


139
00:07:34,988 --> 00:07:37,124
应该是主函数出了问题


140
00:07:37,658 --> 00:07:41,628
如果从控制台来看


141
00:07:41,695 --> 00:07:45,732
可以看到
是抛出了部分异常


142
00:07:46,033 --> 00:07:48,302
但是现在对我来说帮助不大


143
00:07:48,368 --> 00:07:51,271
因为我想停止程序


144
00:07:51,338 --> 00:07:52,172
在抛出异常的时刻


145
00:07:52,239 --> 00:07:53,941
对它进行调试


146
00:07:55,075 --> 00:07:59,079
为此 我可以进入
Breakpoint Navigator


147
00:07:59,680 --> 00:08:04,451
点击下面的加号
添加异常断点


148
00:08:05,052 --> 00:08:06,820
我接下来要配置这个断点


149
00:08:06,887 --> 00:08:09,289
来停止Objective-C异常


150
00:08:12,993 --> 00:08:13,827
像这样


151
00:08:14,361 --> 00:08:17,164
我们从新运行应用


152
00:08:19,333 --> 00:08:21,869
希望我们在问题发生时


153
00:08:22,503 --> 00:08:25,105
能准确找到问题


154
00:08:26,306 --> 00:08:28,075
非常好 但是...


155
00:08:29,076 --> 00:08:32,379
如果我去看控制台
却什么都看不到


156
00:08:32,513 --> 00:08:36,416
没有信息描述
异常是什么


157
00:08:37,116 --> 00:08:38,552
这里有个技巧


158
00:08:38,619 --> 00:08:40,953
是我从LLVM团队的
朋友那里学来的


159
00:08:41,355 --> 00:08:42,422
导航进入


160
00:08:42,556 --> 00:08:44,758
Ob-C Exception
Throw函数


161
00:08:44,825 --> 00:08:46,460
在Ob-C的运行时间中


162
00:08:46,527 --> 00:08:49,563
打印函数的首个参数


163
00:08:49,997 --> 00:08:52,366
实际上是异常对象本身


164
00:08:52,799 --> 00:08:55,135
我说 打印对象


165
00:08:55,903 --> 00:08:56,737
arg1


166
00:08:57,271 --> 00:09:01,275
这就是 异常信息本身


167
00:09:02,109 --> 00:09:03,844
因此我会调整异常断点


168
00:09:03,911 --> 00:09:08,315
为所出现的异常
始终这么做


169
00:09:08,382 --> 00:09:09,716
这样会很有帮助


170
00:09:10,317 --> 00:09:12,653
我可以在这里添加一个操作


171
00:09:13,320 --> 00:09:16,456
输入的内容和
输入控制台的完全一样


172
00:09:17,157 --> 00:09:19,660
打印对象 arg1


173
00:09:21,161 --> 00:09:24,464
现在
如果我再次运行应用


174
00:09:27,334 --> 00:09:28,402
运行计时器


175
00:09:29,469 --> 00:09:31,738
现在我仍然停在


176
00:09:31,805 --> 00:09:35,642
异常被抛出的准确时刻


177
00:09:36,210 --> 00:09:40,214
我实际上在控制台
有异常信息本身


178
00:09:41,181 --> 00:09:43,884
现在
当我看着异常


179
00:09:44,184 --> 00:09:46,753
被抛出的代码行


180
00:09:47,020 --> 00:09:49,656
可以看到我构建的范围


181
00:09:50,591 --> 00:09:54,795
范围超出了边界
估计是用了


182
00:09:54,962 --> 00:09:57,798
索引1开头
而不是索引0


183
00:09:57,865 --> 00:09:59,766
并且在设定字体属性时


184
00:09:59,833 --> 00:10:01,835
执行了
字符串的全长


185
00:10:02,569 --> 00:10:05,272
我们重新运行


186
00:10:06,840 --> 00:10:09,176
再看看效果


187
00:10:09,543 --> 00:10:13,847
看似计时器
现在工作正常


188
00:10:14,882 --> 00:10:18,418
我们成功发现了
两处程序错误


189
00:10:18,519 --> 00:10:20,187
我再看第三个


190
00:10:21,088 --> 00:10:24,691
现在来看
来这里之前


191
00:10:24,791 --> 00:10:28,362
我今天早上跑步的路线


192
00:10:29,296 --> 00:10:31,999
看似没问题


193
00:10:33,367 --> 00:10:36,537
但如果我们返回


194
00:10:36,670 --> 00:10:39,940
则有些不对劲
我不是从莫斯科尼出发


195
00:10:40,007 --> 00:10:41,408
跑到码头大街


196
00:10:41,475 --> 00:10:44,678
然后跳到了水里
这是在太蠢了


197
00:10:44,811 --> 00:10:47,581
我们再试一遍


198
00:10:48,815 --> 00:10:50,684
这里出现了异常


199
00:10:50,751 --> 00:10:56,456
我不知道
看似是数据模型出现了问题


200
00:10:56,757 --> 00:10:59,560
所以我想找出
放在地图上的各点


201
00:11:00,360 --> 00:11:02,529
出现覆盖时


202
00:11:02,863 --> 00:11:04,398
我们在做什么


203
00:11:06,567 --> 00:11:10,771
现在进入类
是这里


204
00:11:10,904 --> 00:11:14,575
使路线出现了覆盖


205
00:11:15,175 --> 00:11:18,011
我们在这里
用了一束数据点


206
00:11:18,512 --> 00:11:20,514
从字典里拿出


207
00:11:20,747 --> 00:11:23,083
生成并构造了代表我的...


208
00:11:24,618 --> 00:11:28,288
跑步路线的多段线


209
00:11:29,489 --> 00:11:32,593
我会设置一个断点


210
00:11:32,693 --> 00:11:34,761
来看获得的数据值是什么


211
00:11:35,896 --> 00:11:39,166
我会打开
Debug Console


212
00:11:39,533 --> 00:11:44,304
来看变量视图
在下面 可以看到


213
00:11:44,571 --> 00:11:45,906
我所感兴趣的点


214
00:11:46,440 --> 00:11:47,875
它有着这些值


215
00:11:47,941 --> 00:11:50,844
我会向前推进


216
00:11:51,245 --> 00:11:54,681
这很有趣
但是有些麻烦


217
00:11:54,748 --> 00:11:56,650
这些值看似相似


218
00:11:56,850 --> 00:11:59,219
我在这里的处理
会让进程快些


219
00:11:59,286 --> 00:12:01,021
来看所有这些值


220
00:12:01,088 --> 00:12:02,556
我会编辑这个断点


221
00:12:03,156 --> 00:12:06,527
打印出Struct点


222
00:12:07,861 --> 00:12:12,366
实际上在变量视图上
我检测过这里


223
00:12:12,566 --> 00:12:14,868
然后我会说
评价过操作后


224
00:12:15,202 --> 00:12:16,503
自动继续


225
00:12:16,570 --> 00:12:18,672
其实
这不是条件


226
00:12:18,739 --> 00:12:20,574
是个操作
就这样


227
00:12:22,009 --> 00:12:24,912
我们继续运行


228
00:12:25,746 --> 00:12:30,884
我们可以看到
所有的点都看似一样


229
00:12:31,385 --> 00:12:34,087
但是还会在
不知什么地方


230
00:12:34,154 --> 00:12:35,489
会出现瞬移


231
00:12:36,223 --> 00:12:39,693
但是所有的值看似合理


232
00:12:40,093 --> 00:12:42,396
我不太确定问题是什么


233
00:12:42,462 --> 00:12:45,866
也许从别人那里...


234
00:12:47,267 --> 00:12:49,469
能得到更多帮助


235
00:12:51,338 --> 00:12:53,373
我们回到幻灯片


236
00:13:00,514 --> 00:13:02,015
总结一下看到的内容


237
00:13:02,449 --> 00:13:05,085
首先在Jogr的计时器视图


238
00:13:05,152 --> 00:13:07,020
深入了解
约束问题


239
00:13:07,254 --> 00:13:10,357
我想给大家看看
怎样双击视图


240
00:13:10,424 --> 00:13:11,725
关注具体部件


241
00:13:12,092 --> 00:13:14,294
我们检测部分约束


242
00:13:14,361 --> 00:13:17,464
发现当我们在其他屏幕
尺寸上运行时


243
00:13:17,531 --> 00:13:19,233
需要将之删除


244
00:13:20,200 --> 00:13:23,203
然后 我们在运行
计时器时 出现异常


245
00:13:23,370 --> 00:13:25,339
并使用异常断点 来停在


246
00:13:25,405 --> 00:13:27,007
出现异常的准确时刻


247
00:13:27,107 --> 00:13:28,709
并打印异常信息


248
00:13:29,343 --> 00:13:32,679
最后 我们可以
添加打印并继续添加了


249
00:13:32,980 --> 00:13:35,449
日志的断点
所有这些都不会因NSLogs


250
00:13:35,516 --> 00:13:37,251
或打印语句搞乱代码


251
00:13:37,918 --> 00:13:40,320
现在来解决下一个谜题
为什么今天早上的


252
00:13:40,387 --> 00:13:43,290
跑步会有那么
奇怪的结果


253
00:13:43,557 --> 00:13:45,192
有请安娜


254
00:13:53,267 --> 00:13:54,101
谢谢 麦克


255
00:13:54,334 --> 00:13:57,204
大家好 那么回到
麦克刚刚在演示中


256
00:13:57,271 --> 00:13:59,239
给大家看的那条路线


257
00:14:00,107 --> 00:14:02,943
在测试演示app时
大家会看到


258
00:14:03,010 --> 00:14:05,479
所有的路线
而且包括正确路线


259
00:14:06,280 --> 00:14:08,515
我们非常希望麦克刚刚没有


260
00:14:08,582 --> 00:14:11,718
找出正确的跑步路线
因为这样的话


261
00:14:11,785 --> 00:14:14,755
我们的讲座
就没什么可说的了


262
00:14:15,956 --> 00:14:19,293
这种不可预见的行为通常是
内存出错而导致


263
00:14:19,393 --> 00:14:21,028
例如 分配给一个对象的内存


264
00:14:21,094 --> 00:14:23,964
可能被其他对象所重写


265
00:14:24,765 --> 00:14:27,367
或者也许由于某些计算错误


266
00:14:27,434 --> 00:14:29,236
你用了并不属于你的内存


267
00:14:30,871 --> 00:14:34,541
相信大家之前也遇过类似情况


268
00:14:34,842 --> 00:14:37,244
代码中出现随机异常


269
00:14:37,611 --> 00:14:40,581
也许在测试app的
某个侧面时


270
00:14:40,647 --> 00:14:42,115
每次会出现这个问题


271
00:14:42,182 --> 00:14:45,085
或者只是当你周五晚上


272
00:14:45,219 --> 00:14:47,254
准备回家时出现这个问题！


273
00:14:49,389 --> 00:14:50,724
最糟糕的用例场景


274
00:14:50,791 --> 00:14:53,927
是用户看到这些
不稳定性或随机异常


275
00:14:53,994 --> 00:14:55,762
而你却无法把它们重现眼前


276
00:14:57,364 --> 00:15:00,400
内存出错是出了名的很难


277
00:15:00,467 --> 00:15:03,337
一致性复现 那么也就很难


278
00:15:03,403 --> 00:15:05,906
发现这一异常的根本原因


279
00:15:06,974 --> 00:15:07,875
那该怎么办呢？


280
00:15:08,642 --> 00:15:11,512
最好的办法就是尽量减少
面对内存出错的情况


281
00:15:11,845 --> 00:15:14,615
要避免内存操控


282
00:15:15,249 --> 00:15:18,085
例如使用Swift这类
语言勾选并


283
00:15:18,151 --> 00:15:21,555
自动参考计数
这才会长久


284
00:15:22,723 --> 00:15:26,293
即便内存出错
在技术上仍然可能


285
00:15:26,360 --> 00:15:29,129
由于编码而产生这类问题
则较为不可能


286
00:15:30,264 --> 00:15:34,334
另一方面
如果代码会直接操控内存


287
00:15:34,401 --> 00:15:37,104
通过调用动态分配[unintell
igible]运算


288
00:15:37,171 --> 00:15:41,842
或者代码可以
与C和C++ API可以互操作


289
00:15:42,309 --> 00:15:45,579
你所在的风险组
会非常需要帮助


290
00:15:47,814 --> 00:15:51,685
Address Sanitizer
是基于C语言的LLVM工具


291
00:15:51,752 --> 00:15:55,622
这与Guard Malloc
起到相同的作用


292
00:15:55,689 --> 00:15:58,792
因为它可以在运行时间
发现内存错误


293
00:15:58,859 --> 00:16:02,362
并且较其他工具
有更多好处


294
00:16:03,063 --> 00:16:05,365
它的运行时间
开销会少的很多


295
00:16:05,599 --> 00:16:09,203
还会产生
综合详细的诊断分析


296
00:16:09,269 --> 00:16:11,972
可以直接
整合到Xcode UI


297
00:16:12,372 --> 00:16:15,742
还有一点很重要
只有这种工具


298
00:16:15,809 --> 00:16:17,477
可以在iOS设备上运行


299
00:16:18,312 --> 00:16:22,282
这些是Address Sanitizer
可以捕捉到的常见错误清单


300
00:16:23,050 --> 00:16:29,089
例如 它可以很好地
捕捉到缓冲区溢出


301
00:16:29,756 --> 00:16:31,859
这是个很常见的错误


302
00:16:32,426 --> 00:16:35,562
因为与安全性攻击的关联
而臭名昭著


303
00:16:36,997 --> 00:16:38,765
正如大家所见
它发现了部分工具


304
00:16:38,832 --> 00:16:41,034
通过 Valgrind 和
Guard Malloc


305
00:16:41,101 --> 00:16:42,135
发现的错误


306
00:16:42,202 --> 00:16:44,738
但是它也发现了
新种类的程序错误


307
00:16:44,972 --> 00:16:47,174
是其他工具没有注意的


308
00:16:48,408 --> 00:16:49,776
我们回到演示


309
00:16:49,843 --> 00:16:52,646
来看怎样才能
把这些用于项目中


310
00:17:03,190 --> 00:17:06,260
我接着麦克讲到的内容继续


311
00:17:06,326 --> 00:17:08,962
来看我们看看是否
Address Sanitizer


312
00:17:09,029 --> 00:17:10,696
可以帮我们找出路线问题


313
00:17:11,431 --> 00:17:13,634
为了启动
Address Sanitizer


314
00:17:13,934 --> 00:17:15,469
进入Edit Scheme


315
00:17:18,438 --> 00:17:20,207
进入Diagnostics选项卡


316
00:17:21,108 --> 00:17:23,242
勾选 Enable
Address Sanitizer


317
00:17:23,644 --> 00:17:25,945
与其他内存管理工具不同


318
00:17:26,012 --> 00:17:28,248
Address Sanitizer
需要重新编译


319
00:17:28,315 --> 00:17:32,219
选中复选框后
Xcode就会知道


320
00:17:32,286 --> 00:17:35,355
要打开 Address
Sanitizer 重建应用


321
00:17:35,656 --> 00:17:37,457
它会启动特殊模式


322
00:17:37,524 --> 00:17:39,326
允许Address
Sanitizer


323
00:17:39,393 --> 00:17:41,728
在运行时间更多地
干预进程


324
00:17:43,263 --> 00:17:46,400
我们继续重建
并重新运行app


325
00:17:48,001 --> 00:17:50,470
来看像刚才的路线会怎样


326
00:17:51,905 --> 00:17:54,741
现在Address Sanitizer
发现了问题


327
00:17:54,975 --> 00:17:57,444
它的诊断直接整合到了


328
00:17:57,511 --> 00:17:59,713
Xcode Debugger UI


329
00:17:59,980 --> 00:18:03,317
这与出现异常时
情况非常相似


330
00:18:03,650 --> 00:18:05,786
但是与使用Sec的
情况不同


331
00:18:05,853 --> 00:18:07,988
这次可以对情况有更好的诊断


332
00:18:08,555 --> 00:18:12,426
这里它告诉我们
查出堆缓冲区溢出


333
00:18:13,360 --> 00:18:15,162
还可以看到堆栈轨迹


334
00:18:15,262 --> 00:18:17,998
在这里出现了内存错误


335
00:18:19,800 --> 00:18:22,703
如大家所见 我们称之为
Poly Line With Points


336
00:18:22,769 --> 00:18:24,071
和Map Kit的常用方法


337
00:18:24,137 --> 00:18:28,242
我们在缓冲区做测试
通过缓冲区的长度


338
00:18:28,308 --> 00:18:30,611
来进行
计算点的数量


339
00:18:30,677 --> 00:18:33,947
再用每个点的大小
来相除


340
00:18:34,414 --> 00:18:36,250
看上去可以


341
00:18:36,316 --> 00:18:39,987
随着应用在 Address
Sanitizer 中执行


342
00:18:40,053 --> 00:18:42,055
它会收集过程中


343
00:18:42,122 --> 00:18:44,725
堆对象的重要信息


344
00:18:44,825 --> 00:18:47,027
例如 分配
堆分配


345
00:18:47,094 --> 00:18:48,395
和取消分配事件


346
00:18:48,962 --> 00:18:53,267
当发现内存出错
它会使用启发法


347
00:18:53,333 --> 00:18:56,837
来关联错误地址
到有效的堆对象


348
00:18:57,404 --> 00:19:00,307
在内存项下信息都呈现在这里


349
00:19:00,841 --> 00:19:03,877
这里它告诉我们
错误地址是在


350
00:19:03,944 --> 00:19:08,148
在2240字节堆区域后的
一个字节


351
00:19:08,615 --> 00:19:12,553
还告诉我们堆区域
所分配的位置


352
00:19:13,554 --> 00:19:15,756
即使这不是激活线程


353
00:19:15,923 --> 00:19:21,395
而是在分配事件发生时
进程执行的历史快照


354
00:19:21,461 --> 00:19:22,930
我们可以把流


355
00:19:23,764 --> 00:19:25,432
视作激活线程


356
00:19:26,600 --> 00:19:30,504
它会把我们带到
内存分配的点的位置


357
00:19:31,338 --> 00:19:34,274
好的
我们来看缓冲区的大小


358
00:19:34,341 --> 00:19:38,478
是用每个点的大小
乘以点的数量得出


359
00:19:39,446 --> 00:19:42,749
我们使用
MK Map Point


360
00:19:43,450 --> 00:19:45,352
作为点的代表


361
00:19:45,419 --> 00:19:46,854
这是带双精度的Struct


362
00:19:48,055 --> 00:19:49,423
那么问题是什么？


363
00:19:50,090 --> 00:19:52,326
我们回到Use站点


364
00:19:53,861 --> 00:19:57,497
你传递到这里的类型是不同的


365
00:19:58,131 --> 00:20:01,368
我们传递了MK Map Point星级


366
00:20:02,402 --> 00:20:06,139
但是我们知道
刚分配了Struct的缓冲区


367
00:20:06,206 --> 00:20:07,641
而不是指针的缓冲区


368
00:20:08,642 --> 00:20:12,279
因为每个
指针的大小小于


369
00:20:12,346 --> 00:20:14,414
结构体的大小
包括两个双精度


370
00:20:15,015 --> 00:20:17,918
这里获得的计数
要大于缓冲区


371
00:20:17,985 --> 00:20:20,020
包括的元素数量


372
00:20:20,654 --> 00:20:22,890
这就会解释
为什么在地图上


373
00:20:22,956 --> 00:20:25,058
我们会有那些额外的点


374
00:20:26,627 --> 00:20:29,196
为解决问题
我们需要删掉星级


375
00:20:29,263 --> 00:20:30,731
如大家所见


376
00:20:30,797 --> 00:20:33,667
这是个人们非常容易犯的错误


377
00:20:33,800 --> 00:20:38,071
只看代码是非常难发现的


378
00:20:39,039 --> 00:20:42,309
在本例中
这个信息已经


379
00:20:42,376 --> 00:20:44,578
足以诊断和解决问题


380
00:20:45,112 --> 00:20:50,517
不过 如果觉得
想更多地看看这个报告


381
00:20:50,584 --> 00:20:53,053
可以前往Memory View


382
00:20:53,120 --> 00:20:54,955
来看哪个内存是有效的


383
00:20:55,122 --> 00:20:57,057
哪个内存是被视为无效


384
00:20:57,124 --> 00:20:59,326
从Address Sanitizer
的视角来看


385
00:20:59,660 --> 00:21:03,297
前往Memory View
可以点击这个地址


386
00:21:03,864 --> 00:21:07,801
这里可以看到所有变灰的内容
都是无效内存


387
00:21:08,068 --> 00:21:12,873
所有黑色内存都被视为有效


388
00:21:14,441 --> 00:21:17,644
我们返回并重新运行app


389
00:21:17,711 --> 00:21:20,547
来看删掉星号
是否可以解决问题


390
00:21:23,317 --> 00:21:25,252
我来继续返回Route视图


391
00:21:27,487 --> 00:21:31,592
啊 这就是麦克
今天早上的跑步路线


392
00:21:31,859 --> 00:21:33,427
还有早上
Bash之后的部分


393
00:21:33,994 --> 00:21:35,095
我很受感动


394
00:21:35,429 --> 00:21:36,930
我们返回
打开幻灯片


395
00:21:37,831 --> 00:21:40,701
大家已经看到
打开Address Sanitizer很容易


396
00:21:40,767 --> 00:21:44,271
进入Scheme Editor
打开Diagnostics选项卡


397
00:21:44,638 --> 00:21:47,441
勾选Enable
Address Sanitizer复选框


398
00:21:47,941 --> 00:21:50,210
接着可以构建
并运行自己的项目


399
00:21:52,513 --> 00:21:55,082
同样
正如大家在演示app所见


400
00:21:55,148 --> 00:21:58,118
使用Address Sanitizer的
开销几乎很难注意到


401
00:21:58,619 --> 00:22:01,788
较低的运行时间开销
允许你使用Address Sanitizer


402
00:22:02,122 --> 00:22:06,126
不仅是在调试
部分内存出错问题的时候


403
00:22:06,360 --> 00:22:09,463
而且是在进行UI驱动的测试


404
00:22:09,530 --> 00:22:12,533
这里要手动测试
app的不同方面


405
00:22:13,500 --> 00:22:15,769
再进一步 我们推荐


406
00:22:15,836 --> 00:22:18,572
在连续整合过程中
使用Address Sanitizer


407
00:22:19,273 --> 00:22:21,708
因为这是运行时间
程序错误发现工具


408
00:22:21,775 --> 00:22:25,045
它仅会捕捉已执行
代码中的程序错误


409
00:22:25,712 --> 00:22:27,748
那么应该提供尽可能多的覆盖


410
00:22:27,814 --> 00:22:29,449
以实现最好结果


411
00:22:30,651 --> 00:22:36,723
在Xcode或Xcode Server
的任务中启动


412
00:22:36,790 --> 00:22:40,227
Address Sanitizer
进入Edit Scheme选择Task


413
00:22:40,460 --> 00:22:42,829
然后再次进入
Diagnostics选项卡


414
00:22:42,896 --> 00:22:45,699
勾选Enable
Address Sanitizer复选框


415
00:22:45,766 --> 00:22:46,767
构建并测试你的app


416
00:22:47,501 --> 00:22:49,236
还可以用命令行启动


417
00:22:49,303 --> 00:22:52,039
通过向Xcode Build
传递额外的参数


418
00:22:54,808 --> 00:22:56,476
我们建议在Debug构建


419
00:22:56,543 --> 00:22:58,378
使用Address
Sanitizer


420
00:22:58,445 --> 00:22:59,680
并将编译器优化关闭


421
00:23:00,414 --> 00:23:03,917
但是它也得到
Fast优化水平的支持


422
00:23:05,052 --> 00:23:07,521
是与01编辑器旗标相对应


423
00:23:08,488 --> 00:23:10,157
需要牢记一点


424
00:23:10,224 --> 00:23:13,260
当在这两个优化水平之间
进行决定时


425
00:23:14,361 --> 00:23:17,030
如果有任何编译优化
是启动状态


426
00:23:17,164 --> 00:23:20,467
调试体验就不会十分流畅


427
00:23:23,036 --> 00:23:26,607
现在我们进入
讲座的最激动环节


428
00:23:26,740 --> 00:23:28,075
我会告诉大家一个


429
00:23:28,141 --> 00:23:30,410
驱动这个工具的很酷的技术


430
00:23:32,646 --> 00:23:36,049
传统而言Xcode
使用clang编译器来


431
00:23:36,116 --> 00:23:40,053
编译源代码
可以生成可执行的二进制代码


432
00:23:41,221 --> 00:23:43,223
为使用
Address Sanitizer


433
00:23:43,290 --> 00:23:45,359
Xcode将特殊的旗标
传递给clang


434
00:23:45,592 --> 00:23:47,294
它会生成工具二进制代码


435
00:23:47,361 --> 00:23:48,996
其中包括
更多的内存检测


436
00:23:50,130 --> 00:23:55,569
在运行时间 这个二进制代码
与asan运行时间dylib连接


437
00:23:55,636 --> 00:23:57,437
其中包括更多检测


438
00:23:57,504 --> 00:24:00,174
而且dylib是工具所要求的


439
00:24:02,042 --> 00:24:03,877
但是这些内存检测
如何发挥作用？


440
00:24:04,278 --> 00:24:07,381
Address Sanitizer
检测进程中的所有位置


441
00:24:07,447 --> 00:24:09,416
如果这是进程内存


442
00:24:11,218 --> 00:24:14,154
Address Sanitizer会成为
所谓的影子内存


443
00:24:14,521 --> 00:24:17,424
可以跟踪真实内存中的
每个字节


444
00:24:18,492 --> 00:24:22,896
它有着字节是否为可访问
地址的相关信息


445
00:24:24,131 --> 00:24:26,700
无效内存的字节就是红区


446
00:24:26,767 --> 00:24:28,702
或者说内存中毒


447
00:24:30,737 --> 00:24:33,140
当使用Address Sanitizer
编译程序时


448
00:24:33,207 --> 00:24:35,242
它会影响每个内存访问


449
00:24:35,409 --> 00:24:37,010
并在前缀加上检测


450
00:24:37,811 --> 00:24:38,946
如果内存中毒


451
00:24:39,012 --> 00:24:41,215
Address Sanitizer
就会跟踪程序


452
00:24:41,582 --> 00:24:43,750
并生成诊断报告


453
00:24:44,151 --> 00:24:46,053
否则 它会允许你继续


454
00:24:47,721 --> 00:24:49,122
我们再来仔细看看


455
00:24:49,256 --> 00:24:50,524
假设p为指针


456
00:24:50,958 --> 00:24:55,395
然后IsPoisoned函数会
检测影子内存中的相关字节


457
00:24:56,129 --> 00:24:57,764
在本例中 内存是有效的


458
00:24:57,831 --> 00:25:01,435
因此程序可以编写那个
内存位置


459
00:25:04,738 --> 00:25:06,940
不过 如果它并未指向有效内存


460
00:25:07,207 --> 00:25:08,509
条件将会为真


461
00:25:09,142 --> 00:25:11,612
程序将卡在无效内存


462
00:25:11,845 --> 00:25:14,448
就是访问可能要发生的地方


463
00:25:15,249 --> 00:25:18,051
这就是Address
Sanitizer生成报告的方法


464
00:25:18,118 --> 00:25:20,087
并将这个问题报告给用户


465
00:25:21,922 --> 00:25:25,158
查找影子内存需要非常快才行


466
00:25:26,260 --> 00:25:28,729
为实现这点
我们保留了查找表


467
00:25:28,795 --> 00:25:33,700
在影子内存中每8个字节
就会有1个字节被跟踪


468
00:25:35,002 --> 00:25:36,970
这是个很大的查找表


469
00:25:37,037 --> 00:25:38,939
我们并未真正分配 而是在


470
00:25:39,239 --> 00:25:42,910
进程启动的时候保存
在需要的时候使用


471
00:25:44,344 --> 00:25:46,113
这样我们就可以查找地址


472
00:25:46,180 --> 00:25:50,717
通过将原始指针的值除以8


473
00:25:50,784 --> 00:25:52,653
再添加常数补偿


474
00:25:52,719 --> 00:25:55,822
就是在内存影子的
位置上添加


475
00:25:56,390 --> 00:25:58,859
即便计算地址的字节为非零


476
00:25:59,126 --> 00:26:00,527
我们知道内存中毒了


477
00:26:03,130 --> 00:26:05,165
现在 我们聊聊堆的内容


478
00:26:06,099 --> 00:26:08,802
捕获溢出和
堆中的其他程序错误


479
00:26:09,369 --> 00:26:12,206
Address Sanitizer会提供
自定义分配器


480
00:26:12,272 --> 00:26:15,209
以替代默认的Malloc执行


481
00:26:16,710 --> 00:26:19,713
默认分配器
可以用不同方式组织对象


482
00:26:20,347 --> 00:26:23,984
例如
它可以逐个排布对象


483
00:26:24,718 --> 00:26:27,921
这对于优化内存消耗十分有利


484
00:26:28,655 --> 00:26:30,691
但是这对捕捉程序错误不太好


485
00:26:30,757 --> 00:26:33,260
因为一个对象的溢出会落到


486
00:26:33,327 --> 00:26:34,661
另一个对象上


487
00:26:34,728 --> 00:26:38,232
因此无法与有效的内存访问区别开来


488
00:26:39,900 --> 00:26:42,402
为解决这个问题
ASan的分配器


489
00:26:42,469 --> 00:26:45,239
会让对象彼此间距更大


490
00:26:46,006 --> 00:26:48,742
这些对象之间未用的内存


491
00:26:49,176 --> 00:26:51,011
在影子部分会标记为中毒


492
00:26:53,280 --> 00:26:54,848
当对象被取消分配


493
00:26:54,915 --> 00:26:57,050
我们将对象在影子部分
标记为中毒


494
00:26:59,319 --> 00:27:03,790
总之 自定Malloc执行
在有效的分配周围


495
00:27:03,857 --> 00:27:06,560
插入中毒的红区


496
00:27:06,860 --> 00:27:09,263
以捕捉堆下溢和溢出


497
00:27:10,464 --> 00:27:12,666
这会延迟用户释放的内存


498
00:27:12,799 --> 00:27:16,236
使得Address
Sanitizer更有效地捕捉


499
00:27:16,303 --> 00:27:18,238
用户释放的和双重释放的错误


500
00:27:19,306 --> 00:27:23,343
它还会为分配和解除分配
搜集Sect痕迹


501
00:27:23,544 --> 00:27:26,713
允许它提供这些综合详细的诊断


502
00:27:27,014 --> 00:27:28,415
这些我们在演示中都见过


503
00:27:28,615 --> 00:27:30,217
能立即明白问题在何处


504
00:27:30,584 --> 00:27:32,186
和花费大量时间去调试


505
00:27:32,452 --> 00:27:34,788
再找出具体发生了什么


506
00:27:35,689 --> 00:27:37,191
这二者是完全不同的效果


507
00:27:38,759 --> 00:27:41,562
现在 我们来谈谈堆栈


508
00:27:43,630 --> 00:27:45,699
与之相似 对于堆内存而言


509
00:27:45,766 --> 00:27:47,801
红区是放在独立的
堆栈变量之间


510
00:27:48,902 --> 00:27:52,206
假设我们有个数组和整数
作为本地变量


511
00:27:52,739 --> 00:27:55,509
那么在Address Sanitizer
编译时


512
00:27:56,009 --> 00:27:59,346
这些变量之间
会插入额外的红区


513
00:27:59,413 --> 00:28:03,483
这样我们可以发现
堆栈变量的任何溢出


514
00:28:05,085 --> 00:28:07,287
在运行时间进入函数时


515
00:28:07,354 --> 00:28:09,790
堆栈红区会中毒在运行时间


516
00:28:09,857 --> 00:28:13,026
退出函数时它们会解毒


517
00:28:16,697 --> 00:28:19,600
处理全局变量也非常相似


518
00:28:19,666 --> 00:28:24,204
在编译期间
检测全局变量


519
00:28:24,671 --> 00:28:27,241
额外的红区会插入它们四周


520
00:28:29,376 --> 00:28:32,246
现在堆栈和全局编译器检测


521
00:28:32,312 --> 00:28:34,848
是Address Sanitizer
非常有用的功能


522
00:28:35,249 --> 00:28:37,784
这会允许它发现其他工具


523
00:28:37,851 --> 00:28:39,453
无法捕获的程序错误


524
00:28:41,588 --> 00:28:44,925
Address Sanitizer
还能找到其他类型的独特程序错误


525
00:28:45,158 --> 00:28:49,530
在座的Avid C++开发
人员会对此特别感兴趣


526
00:28:50,864 --> 00:28:53,066
我们有个C++容器矢量


527
00:28:53,667 --> 00:28:55,969
即便所有的内存
都给了v.begin


528
00:28:56,036 --> 00:28:58,472
v.begin加容量
都已经分配


529
00:28:59,173 --> 00:29:02,476
访问内存过去
v.end是个错误


530
00:29:03,944 --> 00:29:06,947
检测Leap C++
向Address Sanitizer


531
00:29:07,014 --> 00:29:10,017
提供更多信息
这样就会像这里一样


532
00:29:10,384 --> 00:29:11,251
发现错误


533
00:29:16,089 --> 00:29:20,160
正如我们所见
我们谈到的所有检测


534
00:29:20,227 --> 00:29:21,995
都需要编译器检测


535
00:29:22,062 --> 00:29:25,032
但是
我们知道部分错误会出现在


536
00:29:25,799 --> 00:29:29,469
即便代码没有
重新编译的时候也会触发


537
00:29:29,636 --> 00:29:31,738
例如我们调用
内存拷贝函数的时候


538
00:29:32,973 --> 00:29:37,411
Address Sanitizer
会使用一个技术名为BYOD函数


539
00:29:37,978 --> 00:29:40,647
插补用运行时间的自身版本


540
00:29:41,081 --> 00:29:43,450
来替代数十种标准库函数


541
00:29:44,218 --> 00:29:46,019
因为这是一个运行技术


542
00:29:46,119 --> 00:29:47,855
这些检测甚至会触发


543
00:29:47,921 --> 00:29:49,823
未经重新编译的代码


544
00:29:50,991 --> 00:29:54,061
这里是个内存拷贝包裹示例


545
00:29:54,228 --> 00:29:58,899
正如你所预期
在转发原始内存拷贝执行前


546
00:29:59,166 --> 00:30:03,270
首先会检查源和目的地
缓冲区是否有效


547
00:30:06,673 --> 00:30:10,077
所有这些额外检查意味着
会有运行时间开销


548
00:30:10,143 --> 00:30:11,478
而且你可能会考虑这是什么


549
00:30:13,180 --> 00:30:16,483
这些细节很大程度上
取决于各自的程序


550
00:30:16,550 --> 00:30:20,354
Address Sanitizer
通常会导致CPU减速2倍左右


551
00:30:20,954 --> 00:30:24,758
但是我们看到在一些边缘情况下
曾高达5倍


552
00:30:25,592 --> 00:30:28,095
而内存开销从2倍到3倍


553
00:30:29,429 --> 00:30:30,797
需要注意的一点是


554
00:30:30,864 --> 00:30:32,966
这些开销要比


555
00:30:33,033 --> 00:30:36,703
可以找到相似问题的
其他工具要小很多


556
00:30:37,971 --> 00:30:40,741
通过运行时间技术
编译编译器检测


557
00:30:40,807 --> 00:30:43,410
是令Address Sanitizer
更为有效和


558
00:30:43,477 --> 00:30:46,880
可扩展的关键所在


559
00:30:47,781 --> 00:30:52,152
例如 我们在Address Sanitizer
运行并测试Safari


560
00:30:53,053 --> 00:30:53,921
这是个大app


561
00:30:56,657 --> 00:30:59,793
这是Xcode 7
新增的Address Sanitizer


562
00:31:01,862 --> 00:31:02,729
谢谢


563
00:31:09,603 --> 00:31:12,272
我们调整一下关注点
来仔细看看


564
00:31:12,339 --> 00:31:16,310
我们平台上可用的
其他内存管理工具


565
00:31:16,376 --> 00:31:18,912
它们可以做什么
你何时应该使用


566
00:31:20,214 --> 00:31:22,082
那我们先从
Guard Malloc开始


567
00:31:22,149 --> 00:31:25,052
像Address Sanitizer一样
它也可以发现同样问题


568
00:31:25,252 --> 00:31:27,221
使用Guard Malloc的
主要优势是


569
00:31:27,287 --> 00:31:29,523
它不需要进行重新编译


570
00:31:30,624 --> 00:31:32,960
另一方面
它还有其他局限性


571
00:31:33,627 --> 00:31:35,896
Guard Malloc不能在
iOS设备上运行


572
00:31:36,063 --> 00:31:38,165
而且不能发现
Address Sanitizer


573
00:31:38,232 --> 00:31:39,666
发现的所有问题


574
00:31:40,267 --> 00:31:42,903
例如 因为它使用保护页面


575
00:31:43,604 --> 00:31:47,107
它将无法捕捉到
所有的单字节缓冲区溢出


576
00:31:47,207 --> 00:31:49,243
这是个常见错误


577
00:31:50,410 --> 00:31:54,081
再选择两者间该使用哪个时
要考虑其他的权衡因素


578
00:31:55,282 --> 00:31:57,751
可供大家考虑的
还有NSZombie


579
00:31:58,285 --> 00:32:01,755
它善于捕捉Objective-C
对象过度释放


580
00:32:02,623 --> 00:32:05,526
可以通过发送信息时
困住的僵尸对象


581
00:32:05,926 --> 00:32:09,329
替代取消分配对象
以发挥作用


582
00:32:10,330 --> 00:32:12,432
这个基本功能
可以从Xcode中的


583
00:32:12,666 --> 00:32:15,469
相同Diagnostics选项卡
来启动


584
00:32:15,802 --> 00:32:18,739
但是 如果希望
获得该功能的全部效用


585
00:32:18,805 --> 00:32:20,774
还是要使用
Zombies Instrument


586
00:32:22,376 --> 00:32:27,114
Malloc Scribble会帮助
调查未初始化的内存问题


587
00:32:27,481 --> 00:32:29,716
它可以通过预设常数
填入分配和


588
00:32:29,983 --> 00:32:34,087
取消分配的内存
更能预见这些错误的出现


589
00:32:35,556 --> 00:32:37,624
最后
泄露Instrument会帮助你


590
00:32:37,691 --> 00:32:41,562
发现保留周期
以及导致更高内存


591
00:32:41,628 --> 00:32:43,096
消耗的放弃内存


592
00:32:45,999 --> 00:32:47,968
总之
我们见识了三种不同的技术


593
00:32:48,035 --> 00:32:51,805
可以帮助我们
更深入地理解程序


594
00:32:52,306 --> 00:32:54,842
首先 使用View
Debugger来发现


595
00:32:54,908 --> 00:32:57,277
并解决布局的约束问题


596
00:32:58,245 --> 00:33:00,080dle
第二 设置断点操作


597
00:32:58,245 --> 00:33:00,080
第二 设置断点操作


598
00:33:00,147 --> 00:33:03,917
以便自动评估和
打印任何LLVD表达式


599
00:33:04,351 --> 00:33:05,786
并使用异常断点


600
00:33:05,853 --> 00:33:10,390
让程序调试恰好停在
异常出现的位置


601
00:33:11,024 --> 00:33:12,359
最后 第三


602
00:33:12,793 --> 00:33:15,863
使用Address Sanitizer
整理应用


603
00:33:16,230 --> 00:33:18,932
清除那些难以捉摸的
内存出错问题


604
00:33:20,467 --> 00:33:23,170
关于今天谈到的问题
还有其他的资源


605
00:33:23,237 --> 00:33:24,771
帮助大家了解更多内容


606
00:33:25,739 --> 00:33:28,275
本周早些时候
有几次讲座介绍了


607
00:33:28,342 --> 00:33:31,345
LLDB连续整合和测试问题


608
00:33:31,645 --> 00:33:34,214
大会结束后
大家就可以立即观看


609
00:33:34,681 --> 00:33:36,750
非常感谢
祝大家今天过得愉快

