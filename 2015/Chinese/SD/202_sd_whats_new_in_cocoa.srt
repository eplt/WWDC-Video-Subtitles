1
00:00:20,087 --> 00:00:23,223
Cocoa最新内容


2
00:00:23,290 --> 00:00:23,957
下午好


3
00:00:24,358 --> 00:00:26,059
欢迎参加《Cocoa最新内容》讲座


4
00:00:30,464 --> 00:00:31,832
我是阿里•厄泽尔


5
00:00:32,299 --> 00:00:36,370
我是来介绍
今年Cocoa新增了什么内容


6
00:00:36,570 --> 00:00:37,337
主要在三方面：


7
00:00:37,404 --> 00:00:40,707
Swiftificaiton
AppKit和Foundation


8
00:00:40,908 --> 00:00:43,243
我们有许多学习内容
大家一起来深入研究吧


9
00:00:45,179 --> 00:00:48,549
Swiftification 是指
刚完成的API增强版


10
00:00:48,615 --> 00:00:52,853
在多个框架之间
支持Swift语言


11
00:00:53,153 --> 00:00:56,590
这些改进同时完善了
Objective-C API功能


12
00:00:58,692 --> 00:01:00,494
要知道 Swift语言
的功能是


13
00:01:00,561 --> 00:01:02,429
更准确表达API特性


14
00:01:02,829 --> 00:01:05,299
例如可以
声明这是个数组


15
00:01:05,364 --> 00:01:07,134
子视图属性
是NSView数组


16
00:01:07,201 --> 00:01:09,169
但不仅仅是个数组


17
00:01:09,736 --> 00:01:12,472
还可以声明System Font
Of Size方法


18
00:01:12,539 --> 00:01:15,309
返回到NSFont
而且永远不会返回空


19
00:01:16,043 --> 00:01:18,345
例如在Image For
Resource方法中　


20
00:01:18,412 --> 00:01:20,914
NSBundle可以返回零值空
因为它被声明


21
00:01:20,981 --> 00:01:22,249
作为可选的NSImage


22
00:01:24,518 --> 00:01:27,020
我们在Objective-C
启动这些功能


23
00:01:27,087 --> 00:01:28,455
具备通用列的为空性


24
00:01:28,922 --> 00:01:31,491
我会简要介绍
这两方面内容


25
00:01:31,758 --> 00:01:33,961
接着再做
几处调整


26
00:01:34,194 --> 00:01:37,231
让我们的Objective-C和
Swift API效果更好


27
00:01:38,565 --> 00:01:41,335
我们将这些用于
许多框架的API中


28
00:01:41,401 --> 00:01:44,605
不仅是AppKit
和Foundation


29
00:01:45,072 --> 00:01:48,041
这样不仅可以更好地
接触到Swift语言中的API


30
00:01:48,108 --> 00:01:51,912
而且会让
API更为清晰


31
00:01:52,112 --> 00:01:54,114
还能提供编译时间
类型检查功能


32
00:01:54,181 --> 00:01:55,649
这一点当然
很重要


33
00:01:57,551 --> 00:02:00,888dle
为空性是指
值能否为零


34
00:01:57,551 --> 00:02:00,888
为空性是指
值能否为零


35
00:02:02,890 --> 00:02:06,093
若是使用Swift语言
X v10或iOS 8 SDK


36
00:02:06,159 --> 00:02:09,930
大家已经了解Swift API
具有适当的为空性


37
00:02:09,997 --> 00:02:11,431
和可选的声明
内容


38
00:02:11,698 --> 00:02:15,169
我们已经管理过
手工端数据


39
00:02:15,235 --> 00:02:16,370
以及端文件这方面的内容


40
00:02:16,436 --> 00:02:19,773
在X v11和iOS 9中我们将这
种能力赋予了Objective-C


41
00:02:20,040 --> 00:02:23,010
并有了若干新的关键词这些都加在了O
bjective-C上


42
00:02:23,443 --> 00:02:27,681
非零表示永远不为零值
可为零表示可以为零值


43
00:02:28,182 --> 00:02:31,652
可重置零表示
属性可以设为零值


44
00:02:31,718 --> 00:02:33,187
不过不会返回归零值


45
00:02:33,320 --> 00:02:35,956
马上会给出
一个例子


46
00:02:36,023 --> 00:02:38,625
最后一项也很重要就
是Null Unspecified


47
00:02:38,692 --> 00:02:39,826
也就是未指定的意思


48
00:02:40,194 --> 00:02:43,063
这个用于
不支持的内容


49
00:02:43,130 --> 00:02:45,065
或未经审查的内容


50
00:02:47,434 --> 00:02:51,471
由于API大部分
是非零值的状态


51
00:02:51,538 --> 00:02:52,906
我们还有这样
两种声明：


52
00:02:52,973 --> 00:02:55,475
Assume Nonnull
Begin and End


53
00:02:55,542 --> 00:02:57,377
假设首尾为零
中间即为我们的页眉文件


54
00:02:57,444 --> 00:02:59,446
这样 非零值声明
就没有必要


55
00:02:59.513 --> 00:03:00.547 align:middle
继续存在了


56
00:02:59,513 --> 00:03:00,547
继续存在了


57
00:03:00,614 --> 00:03:03,150
非零就没必要了


58
00:03:03,217 --> 00:03:05,419
我们在API上
还有另外的声明


59
00:03:05,752 --> 00:03:08,188
我们建议你在页眉文件中
这样使用


60
00:03:08,255 --> 00:03:10,090
如果你有很多
自己的页眉文件


61
00:03:11,992 --> 00:03:15,262
来看部分实例
看看这会怎样影响API


62
00:03:15,762 --> 00:03:18,265
你会看到
NSColorWell的颜色属性


63
00:03:18,699 --> 00:03:22,102
我们没有发布任何声明
那它就该是非零值


64
00:03:22,503 --> 00:03:25,539
在Swift语言中
作为非可选值


65
00:03:25,606 --> 00:03:26,507
色彩属性


66
00:03:27,040 --> 00:03:29,276
另外一方面
NSImageView的图像属性


67
00:03:29,343 --> 00:03:33,747
是可以为零值
也就是说可以设为零值


68
00:03:33,814 --> 00:03:36,383
在Swift语言中
可以作为可选值


69
00:03:36,783 --> 00:03:39,553
最后声明的是
NSMenu的字体属性


70
00:03:39,620 --> 00:03:42,556
是可重置零
这就会成为


71
00:03:42,623 --> 00:03:44,224
隐式解析
可选值


72
00:03:44,925 --> 00:03:48,095
在本例中 这说明
我们可以将值设为零


73
00:03:48,595 --> 00:03:50,030
不过它永远不会返回零值归零


74
00:03:50,230 --> 00:03:53,700
如果从来都不把它设为零
那么NSMenu就会


75
00:03:53,767 --> 00:03:56,737
恢复系统已有的
默认字体


76
00:03:56,803 --> 00:03:58,672
因此 永远不会返回零值归零


77
00:04:00,407 --> 00:04:03,010
存在为空性 你可能会看到
一些建造时间警告


78
00:04:03,744 --> 00:04:04,878
我来给大家看一个例子


79
00:04:05,179 --> 00:04:07,848
如果你有这样的代码
设置颜色属性


80
00:04:07,915 --> 00:04:11,151
ColorWell为零
编译器现在就会给出警告


81
00:04:11,451 --> 00:04:13,153
因为我们做过声明
这个值是非零


82
00:04:13,720 --> 00:04:16,790
这非常好 因为就会成为
如果你有这个代码


83
00:04:16,857 --> 00:04:19,493
并且经过运行
就应该提出一个


84
00:04:19,560 --> 00:04:20,459
参数断言才对


85
00:04:20,861 --> 00:04:22,863
这种情况下
你会收到有关


86
00:04:22,930 --> 00:04:23,830
编译器的警告


87
00:04:23,897 --> 00:04:24,565
非常好


88
00:04:25,999 --> 00:04:31,071
你也许知道 一般而言
在我们的API中


89
00:04:31,138 --> 00:04:32,306
零不是有效目标值


90
00:04:32,506 --> 00:04:36,076
NSString NSArray
NSDictionary等等很容易


91
00:04:36,143 --> 00:04:40,848
表达空值
接受或归零的API


92
00:04:40,914 --> 00:04:43,951
应该把零作为
特殊情况


93
00:04:44,017 --> 00:04:45,219
记录下来


94
00:04:45,586 --> 00:04:47,721
我从API中给出
几个例子来


95
00:04:48,322 --> 00:04:51,491
如果将NSTextView目标
背景色设为零


96
00:04:51,625 --> 00:04:53,126
表示不得有
背景颜色


97
00:04:53,927 --> 00:04:55,429
在许多API的零区域设置


98
00:04:55,495 --> 00:04:58,632
都表示
未经区域设置处理


99
00:04:58,699 --> 00:04:59,900
因此 可以确定一个区域设置


100
00:04:59,967 --> 00:05:02,703
但是如果确定为零
则表示未经区域设置处理


101
00:05:05,272 --> 00:05:07,341
再来谈谈泛型


102
00:05:08,542 --> 00:05:12,312
泛型正如听上去那样
是个轻量级的


103
00:05:12,379 --> 00:05:16,316
参数化类型我们将之加到Object
ive-C上


104
00:05:16,383 --> 00:05:19,720
这对具体元素种类集合
效果很好


105
00:05:20,687 --> 00:05:23,123
这里是个NSSearchField
方面的例子


106
00:05:23,190 --> 00:05:26,059
NSSearchField的
Recent Search属性


107
00:05:26,126 --> 00:05:27,794
是这样声明的
X v10


108
00:05:27,861 --> 00:05:31,598
Recent Searches这一
名称并不十分清晰


109
00:05:31,665 --> 00:05:33,066
其中包括什么内容？


110
00:05:33,133 --> 00:05:34,635
字符串？URL?


111
00:05:34,701 --> 00:05:35,903
搜索目标是什么？


112
00:05:36,370 --> 00:05:39,907
通过X v11 SDK
我们可以进行澄清


113
00:05:39,973 --> 00:05:42,009
这里是NSString数组


114
00:05:42,376 --> 00:05:45,512
Swift声明就是
从任何目标数组


115
00:05:45,779 --> 00:05:47,281
到任何字符串数组


116
00:05:49,650 --> 00:05:53,187
我们采取的方法就是从Foundat
ion中取得NSArray


117
00:05:53,520 --> 00:05:56,190
在加上Object Type数据
等等之类


118
00:05:56,256 --> 00:05:59,393
我们把这个目标类型适用于
所有API


119
00:05:59,893 --> 00:06:02,763
适当的API
以往都是获取或恢复ID


120
00:06:02,829 --> 00:06:06,133
诸如索引目标
包括目标等等


121
00:06:06,533 --> 00:06:09,903
还有许多其他的API
这都适用于NSArray


122
00:06:10,237 --> 00:06:13,874
有了这样的代码
连同Recent Searches


123
00:06:14,474 --> 00:06:15,809
可以说你是有
这样的代码


124
00:06:16,276 --> 00:06:19,012
Recent Searches包括
目标 部分URL


125
00:06:19,947 --> 00:06:21,181
我们在传递NSURL


126
00:06:21,481 --> 00:06:24,551
编译器现在就会给出警告
你在传递URL


127
00:06:25,118 --> 00:06:27,321
这种方式可能会出现
字符串数组


128
00:06:27,688 --> 00:06:30,190
这里非常棒的是
这个代码永远不会出问题


129
00:06:30,257 --> 00:06:32,626
或是出现崩溃
因为URL从来不会


130
00:06:32,693 --> 00:06:33,861
在之前被发现


131
00:06:33,927 --> 00:06:36,496
编译器在告诉你
编码中存在潜在的bug


132
00:06:36,563 --> 00:06:39,233
我们在Foundation中增加了
泛型支持


133
00:06:39,299 --> 00:06:40,868
不仅是对NSArray


134
00:06:40,934 --> 00:06:43,937
而是对所有其他集合
NSEnumerator也包括在内


135
00:06:44,004 --> 00:06:48,108
严格来讲 当然
甚至不止是集合


136
00:06:48,542 --> 00:06:50,477
将之适用于
非集合也同样可行


137
00:06:51,078 --> 00:06:55,249
现在连同泛型一起
也可以通过不同的声明


138
00:06:55,315 --> 00:06:57,451
使用这些
按照自己的分类


139
00:06:57,885 --> 00:07:00,854
如果你拿到Recent
Searches的结果 并将之


140
00:07:00,921 --> 00:07:04,691
赋予自己的属性
那就可以继续 并且声明


141
00:07:04,758 --> 00:07:07,861
这是NSArray of
NSString 可以将该类型


142
00:07:07,961 --> 00:07:09,530
通过自己的代码
进行传播


143
00:07:10,664 --> 00:07:12,065
你可以声明
自己的API属性


144
00:07:12,132 --> 00:07:14,401
这里是文件NSS数组


145
00:07:14,468 --> 00:07:15,235
是什么？


146
00:07:15,302 --> 00:07:16,403
字符串还是URL?


147
00:07:16,904 --> 00:07:17,938
可以更明确些


148
00:07:18,605 --> 00:07:21,275
将通用列适用于
自定义集合


149
00:07:21,341 --> 00:07:23,610
如果有任何这样的集合
甚至是在基础集合中


150
00:07:23,677 --> 00:07:24,811
有你的自定义类别


151
00:07:25,546 --> 00:07:28,215
例如
NSArray的类别


152
00:07:29,082 --> 00:07:32,219
你可以直接进入添加
就在自己的代码中即可


153
00:07:32,286 --> 00:07:34,721
这些泛型通用列
也同样适用于类别


154
00:07:37,991 --> 00:07:43,163
现在又有一个功能
加在了Objective-C上


155
00:07:43,630 --> 00:07:46,200
我们来讲解一下
为什么需要这么做


156
00:07:46,667 --> 00:07:48,235
这就是子视图
声明在


157
00:07:48,302 --> 00:07:49,837
X v10中的模样


158
00:07:49,903 --> 00:07:54,775
这是我们第一次尝试
应用泛型


159
00:07:55,442 --> 00:07:58,145
子视图改变为
NSArray of NSView


160
00:07:58,812 --> 00:08:02,482
那么代码就是这样
即把数组之外的元素


161
00:08:02,549 --> 00:08:04,117
赋值给NSButton


162
00:08:04,952 --> 00:08:07,221
这就轮到编译器
着急了


163
00:08:07,754 --> 00:08:10,991
编译器总是替我们担心
很是操心


164
00:08:11,458 --> 00:08:12,492
它会发出警告


165
00:08:12,960 --> 00:08:15,562
为什么？因为我们在把外明显
声明属于NSView的内容


166
00:08:15,629 --> 00:08:18,632
赋值给了
NSView的子类


167
00:08:18,832 --> 00:08:20,801
难怪编辑器会
有所担心了


168
00:08:21,335 --> 00:08:23,670
但是这类代码
我们使用得很多


169
00:08:23,737 --> 00:08:25,038
而且还常常有效


170
00:08:25,639 --> 00:08:28,575
因此 添加了这类关键字
并且将


171
00:08:28,842 --> 00:08:33,480
子视图属性的声明改为这类NSArr
ay of NSViews的


172
00:08:33,914 --> 00:08:35,148
得出的就是...


173
00:08:39,886 --> 00:08:40,554
谢谢


174
00:08:41,621 --> 00:08:44,858
...感谢大家没注意
这边栏目下的内容


175
00:08:45,626 --> 00:08:48,028
这是说 调用者
可以访问


176
00:08:48,095 --> 00:08:50,764
数组元素
如具体类的例子


177
00:08:50,831 --> 00:08:54,101
或者是说
子类的例子也可


178
00:08:54,835 --> 00:08:56,937
现在来看 效果可以


179
00:08:57,604 --> 00:09:02,042
注意
这类编译时功能


180
00:09:02,109 --> 00:09:04,211
和我在这里谈到的
大多数其他内容一样


181
00:09:04,678 --> 00:09:07,347
并没有改变
运行时间代码


182
00:09:08,382 --> 00:09:11,185
例如 并未检查
运行时间类型


183
00:09:11,585 --> 00:09:13,987
有些时候 我们希望
调用者可以考虑一下


184
00:09:14,054 --> 00:09:16,924
元素的情况
再去访问它们


185
00:09:17,391 --> 00:09:20,460
我们将在API中
做少量使用


186
00:09:20,527 --> 00:09:22,162
并推荐大家
也这么做


187
00:09:22,396 --> 00:09:24,398
当调用者可以安全使用时
它们就应该能用了


188
00:09:24,464 --> 00:09:25,566
假设一下


189
00:09:25,899 --> 00:09:27,434
如果你希望调用者
审慎行事


190
00:09:27,501 --> 00:09:29,803
或是进行运行时间查询
那就别这么用


191
00:09:30,237 --> 00:09:31,872
举例来说
NSImage的


192
00:09:31,939 --> 00:09:33,974
Representations法
就是这样


193
00:09:34,041 --> 00:09:35,876
它返还成NSImage
数组表示法


194
00:09:36,076 --> 00:09:40,080
它经常会被细分成子类
而且几乎总是如此


195
00:09:40,547 --> 00:09:42,082
不过我们不会
在这里用到这类


196
00:09:42,149 --> 00:09:44,618
因为这类表示法
并非总是能够


197
00:09:44,918 --> 00:09:47,621
具有可预见性
实际上


198
00:09:47,688 --> 00:09:50,324
可能会在应用运行时间内
在OS发布期间


199
00:09:50,390 --> 00:09:52,159
发生改变


200
00:09:52,226 --> 00:09:54,494
最好是让调用者
在这里多加小心


201
00:09:54,561 --> 00:09:55,863
进行运行时间检查


202
00:09:59.166 --> 00:10:00.968 align:middle
我们在来谈谈
错误处理


203
00:09:59,166 --> 00:10:00,968
我们在来谈谈
错误处理


204
00:10:01,034 --> 00:10:03,837
昨天大家听到了
Swift 2具备神奇的


205
00:10:03,904 --> 00:10:06,340
错误处理功能


206
00:10:08,242 --> 00:10:11,345
对于这种在NSData上
写入URL选项的错误方法


207
00:10:11,445 --> 00:10:15,349
具体意思就是
在Swift里的样子


208
00:10:15,415 --> 00:10:18,218
Boolean回归值不见了
现在非常明显


209
00:10:18,552 --> 00:10:21,421
错误可以参考
NSError参数


210
00:10:21,722 --> 00:10:24,525
也不见了 因为是被
抛出语句所捕捉


211
00:10:24,958 --> 00:10:27,861
这类代码
就是需要处理的


212
00:10:28,495 --> 00:10:29,997
正如你可以在
捕捉语句中所见


213
00:10:30,063 --> 00:10:32,933
可以捕捉到错误
如果是可以自动


214
00:10:32,999 --> 00:10:34,835
被捕获
或是由你来发出声明


215
00:10:34,902 --> 00:10:36,737
你可以声明不同的
捕捉语句


216
00:10:36,803 --> 00:10:38,005
这也完全可以


217
00:10:38,071 --> 00:10:39,806
非常好 直截了当


218
00:10:39,873 --> 00:10:41,875
现在还有一点


219
00:10:42,042 --> 00:10:45,145
注意这里的所有术语
抛出 异常捕捉


220
00:10:45,212 --> 00:10:47,447
等等 无外乎
就是这些


221
00:10:47,514 --> 00:10:48,916
对Objective-C而言


222
00:10:48,982 --> 00:10:50,551
我们也不会
特殊对待


223
00:10:50,617 --> 00:10:53,720
我们实际是在返回错误
通过这样的堆栈


224
00:10:53,787 --> 00:10:58,125
妥善解决问题
就这么处理NSErrors


225
00:10:58,825 --> 00:11:01,361
实际上 NSError指南
还适用于


226
00:11:01,461 --> 00:11:03,697
Swift错误处理


227
00:11:03,797 --> 00:11:08,001
使用NSErrors和Swift
错误处理应对运行时间问题


228
00:11:08,068 --> 00:11:10,604
准备给用户展示的错误
或是需要处理


229
00:11:10,671 --> 00:11:12,940
运行时间 如文件未能找到
等等


230
00:11:13,006 --> 00:11:16,510
我们继续使用例外
或Swift断言


231
00:11:16,577 --> 00:11:19,513
处理编程问题
如界外索引数组


232
00:11:20,314 --> 00:11:22,683
当然最后一类
错误是


233
00:11:22,749 --> 00:11:24,751
不可能被
捕捉到的


234
00:11:25,752 --> 00:11:28,388
还有一个Swiftificatio
n项叫做清理


235
00:11:29,189 --> 00:11:32,326
你们可能是该走了
我们还有许多名称可以列举


236
00:11:32,392 --> 00:11:35,829
从很久以前开始
我们用公共后缀


237
00:11:35,896 --> 00:11:38,498
而不是公共前缀
在部分情况中


238
00:11:38,565 --> 00:11:40,501
我们做了修改 不是全部
有了公共前缀


239
00:11:40,567 --> 00:11:41,702
也就是说


240
00:11:41,768 --> 00:11:43,370
在Swift语言中
会有更好的名称


241
00:11:43,437 --> 00:11:45,405
不是按照点左边文本对齐
而是改成了


242
00:11:45,472 --> 00:11:46,807
dot.left格式


243
00:11:46,874 --> 00:11:48,475
这样的例子
还有许多


244
00:11:48,709 --> 00:11:51,378
注意很多情况下
我们实际上不支持


245
00:11:51,445 --> 00:11:54,414
旧名称 因此你的源文件
将会继续编译


246
00:11:54,481 --> 00:11:56,884
但是可以改为新名称
重写编码即可


247
00:11:59.019 --> 00:12:00.621 align:middle
这类还有很多


248
00:11:59,019 --> 00:12:00,621
这类还有很多


249
00:12:01,021 --> 00:12:03,156
这样我们就可以
来谈AppKit


250
00:12:04,291 --> 00:12:06,193
有许多AppKit方面的话题
我都很喜欢


251
00:12:06,260 --> 00:12:08,028
来聊聊
先来谈一部分


252
00:12:08,095 --> 00:12:13,600
说明一点：从这里
我会更多通过Swift


253
00:12:13,667 --> 00:12:15,602
介绍API
和代码样本


254
00:12:16,203 --> 00:12:18,639
如果你对Swift
还不是很习惯


255
00:12:19,072 --> 00:12:21,408
也不必担心
因为我提到的代码


256
00:12:21,475 --> 00:12:22,643
不会那么难


257
00:12:22,743 --> 00:12:23,911
毕竟 我不过是个经理


258
00:12:24,478 --> 00:12:25,612
需要注意的是...


259
00:12:26,180 --> 00:12:27,314
这一点非常重要


260
00:12:27,381 --> 00:12:31,451
这些API在Objective-C
和Swift中均可得到


261
00:12:31,552 --> 00:12:33,253
那么 我们就不是只给
大家展示仅适用于


262
00:12:33,320 --> 00:12:35,322
Objective-C或Swift
的东西


263
00:12:35,389 --> 00:12:37,090
无论是使用哪种语言
均可以适用


264
00:12:38,492 --> 00:12:43,630
要知道 新的Force Touch
触摸板使用压力感应的同时


265
00:12:43,697 --> 00:12:46,700
也用到了
触觉反馈


266
00:12:46,800 --> 00:12:49,636
这就为更多有趣应用
带来了可能


267
00:12:49,703 --> 00:12:51,471
来看部分实例


268
00:12:53,006 --> 00:12:56,877
例如这里在部分文字上使用Force
Click


269
00:12:56,944 --> 00:12:59,713
可以实现查找
或是自动生成


270
00:12:59.780 --> 00:13:00.881 align:middle
日历活动


271
00:12:59,780 --> 00:13:00,881
日历活动


272
00:13:01,615 --> 00:13:03,617
这种情况下
通过按压


273
00:13:03,684 --> 00:13:05,752
快进按钮
就可以让影片


274
00:13:05,819 --> 00:13:07,354
快进速度加快


275
00:13:08,488 --> 00:13:12,993
这里通过划细线或粗线
进行点压


276
00:13:13,260 --> 00:13:16,029
就可以签上自己的名字
或是在标记中写写画画


277
00:13:17,331 --> 00:13:20,934
最后 在这种情况下
把目标移到程序


278
00:13:21,001 --> 00:13:23,937
比如Xcode的界面
把开发程序或绘图程序


279
00:13:24,304 --> 00:13:27,574
作为对齐目标
就会得到触感反馈


280
00:13:29,243 --> 00:13:32,613
现在还有部分Force Touch
API在 X v10.3中出现


281
00:13:32,679 --> 00:13:34,781
有人可能见过


282
00:13:35,148 --> 00:13:37,384
首先 用加速器
控制API


283
00:13:38,252 --> 00:13:40,888
这些API诠释不同压力
可以用于创建


284
00:13:40,954 --> 00:13:43,557
类似快进按钮
或是在


285
00:13:43,624 --> 00:13:45,025
类似地图应用中
生成放大按钮


286
00:13:45,092 --> 00:13:48,629
还可以在NSButton上在NS
SegmentedControl里


287
00:13:48,695 --> 00:13:50,063
设置加速器控制


288
00:13:50,230 --> 00:13:51,665
如果希望再
玩的高深一些


289
00:13:51,732 --> 00:13:55,235
我们可以提供一个事件
新的压力事件类型


290
00:13:55,302 --> 00:13:57,704
与 NSResponder
和手势识别等


291
00:13:57,971 --> 00:13:59,706
对应方式相匹配
也同样可行


292
00:13:59,773 --> 00:14:01,842
通过事件实现
Pressure Change


293
00:14:01,909 --> 00:14:03,410
可以自己来诠释
压力事件


294
00:14:04,378 --> 00:14:08,215
在X v11当中
我们引入了诸多新类型


295
00:14:08,282 --> 00:14:10,117
一个是压力配置
分类


296
00:14:10,517 --> 00:14:12,452
你来设置压力配置
通过视图


297
00:14:12,519 --> 00:14:13,754
或手势识别


298
00:14:14,021 --> 00:14:16,390
表明触摸板
该如何反应


299
00:14:16,924 --> 00:14:18,926
一般来说
为用户提供的触感反馈


300
00:14:18,992 --> 00:14:20,227
将取决于


301
00:14:20,294 --> 00:14:22,462
所确定的
压力配置


302
00:14:22,963 --> 00:14:26,033
还有另外两个分类
触感反馈管理器


303
00:14:26,099 --> 00:14:28,335
和对齐反馈过滤器
允许你对此类


304
00:14:28,402 --> 00:14:31,038
提供给用户的触感反馈
进行定制化处理


305
00:14:34,074 --> 00:14:38,345
很多人可能都用过
弹簧载荷


306
00:14:38,745 --> 00:14:41,949
就是说拖动一下
并且在目标附近


307
00:14:42,015 --> 00:14:44,651
围绕时 目标会
向你开放


308
00:14:44,818 --> 00:14:46,220
在Finder中可以这么使用


309
00:14:46,687 --> 00:14:47,988
通过Force Click


310
00:14:48,055 --> 00:14:51,124
可以肯定的是
只需用力点击目标


311
00:14:51,191 --> 00:14:54,361
弹簧载荷就会
立即启动


312
00:14:55,128 --> 00:14:59,466
我们还有新的API
让弹簧载荷更加便捷


313
00:14:59,533 --> 00:15:02,703
就是个简单的Boolean属性
NSButton和


314
00:15:02,769 --> 00:15:05,372
NSSegmentedContro
l就启用了弹簧载荷


315
00:15:05,439 --> 00:15:08,408
可以感知附近的动作或是Force
Click给出的指示


316
00:15:08,475 --> 00:15:09,576
非常直观


317
00:15:09,943 --> 00:15:14,381
如果这并不能完全满足需求
我们还有新的协议


318
00:15:14,448 --> 00:15:17,651
NSSpringLoadingDe
stination通过它即可


319
00:15:17,718 --> 00:15:19,520
在任意目标上
实现弹簧载荷


320
00:15:20,020 --> 00:15:22,322
例如 Finder的那个例子
就很适合这里


321
00:15:24,291 --> 00:15:26,827
手指滑动即可删除
大家对这都很熟悉


322
00:15:26,894 --> 00:15:29,663
昨天在主旨演讲中
就见过类似的东西


323
00:15:29,963 --> 00:15:33,233
iOS里这种东西也很常见
可以在桌面视图


324
00:15:33,300 --> 00:15:37,971
例如邮箱信息上
左右滑动


325
00:15:38,038 --> 00:15:40,908
标识信息是否读过
或是否删除等等


326
00:15:40,974 --> 00:15:43,477
我们现在也有这样的API
也是在EI Capitan中


327
00:15:43,544 --> 00:15:45,312
是NSTableView的委托方式


328
00:15:45,379 --> 00:15:47,047
Row Action是
用于Row


329
00:15:47,548 --> 00:15:50,684
只需返回到
NSTableView行处理数组


330
00:15:51,051 --> 00:15:55,422
本类的例子
只是声明这些项和行


331
00:15:55,489 --> 00:15:59,193
应该怎样拖动
当用户选择


332
00:15:59,259 --> 00:16:01,662
当用户选择通过
代码块处理时


333
00:16:01,762 --> 00:16:02,696
最后是代码块


334
00:16:04,498 --> 00:16:05,832
这些话题
简单讲一下即可


335
00:16:06,233 --> 00:16:08,969
有个讲座
《采用触控板新功能》


336
00:16:09,036 --> 00:16:11,772
是周四上午十点
其中会介绍


337
00:16:11,839 --> 00:16:14,408
这类话题的
更多详细内容


338
00:16:15,576 --> 00:16:18,178
全屏部分
昨天已经介绍过了


339
00:16:18,312 --> 00:16:21,548
全屏可以将分散注意
的因素去除 便于集中精力


340
00:16:21,615 --> 00:16:24,218
处理单项任务
就像现在这样


341
00:16:24,484 --> 00:16:28,956
通过在全屏分割视图
可以关注一个任务


342
00:16:29,022 --> 00:16:30,791
但可以打开
其他窗口


343
00:16:30,858 --> 00:16:33,961
例如 你在使用
Xcode 再启用Safari


344
00:16:34,027 --> 00:16:36,697
查询部分文档
或其他论坛


345
00:16:36,997 --> 00:16:38,899
可以想象
把信息放到Xcode旁边


346
00:16:38,966 --> 00:16:41,969
因为你想和
一个朋友聊聊


347
00:16:42,035 --> 00:16:43,070
正在编的代码


348
00:16:43,704 --> 00:16:45,973
这叫做叠加
窗口放在


349
00:16:46,540 --> 00:16:47,541
分割视图中


350
00:16:48,642 --> 00:16:51,445
叠加自动会用于
多个窗口的情况


351
00:16:52,880 --> 00:16:55,682
叠加可以自动适用于
可调整窗口的情况


352
00:16:55,749 --> 00:16:56,984
也就是说 你的应用


353
00:16:57,050 --> 00:16:58,318
应用中
的窗口


354
00:16:58,385 --> 00:17:01,355le
将自动在全屏状态
彼此叠加


355
00:16:58,385 --> 00:17:01,355
将自动在全屏状态
彼此叠加


356
00:17:01,421 --> 00:17:02,789
你这边无需
做任何调整


357
00:17:03,156 --> 00:17:05,392
无论是窗口是
可以全屏还是不可


358
00:17:06,093 --> 00:17:09,162
不过有个API
可以选择出入叠加状态


359
00:17:09,262 --> 00:17:12,065
这是NSWindow的
NSWindow集合行为


360
00:17:12,132 --> 00:17:13,200
选项的一部分


361
00:17:13,700 --> 00:17:15,602
例如 你有个
不可调整的窗口


362
00:17:15,669 --> 00:17:17,237
而你以为是可以
进行叠加


363
00:17:17,704 --> 00:17:19,973
可以使用
Allowd Tiling选项


364
00:17:20,140 --> 00:17:22,075
若你有一个非社交窗口


365
00:17:22,142 --> 00:17:23,277
而且不希望
被叠加


366
00:17:23,343 --> 00:17:25,579
可是设置
Disallows Tiling


367
00:17:25,646 --> 00:17:28,248
我不清楚那个例子
不过它就在那里


368
00:17:28,649 --> 00:17:31,685
这些是全屏的
主要设置


369
00:17:31,752 --> 00:17:34,221
这些已经在
X v7中都有


370
00:17:34,288 --> 00:17:37,024
很重要的是
要注意全屏主要是这样


371
00:17:37,090 --> 00:17:41,361
需要确定
需要全屏的窗口


372
00:17:41,728 --> 00:17:44,097
注意还有许多
选择性加入


373
00:17:44,698 --> 00:17:47,668
因为你需要了解窗口
在全屏的整个


374
00:17:47,801 --> 00:17:50,003
屏幕空间
如何反应


375
00:17:50,337 --> 00:17:53,073
还有一个可选择
功能可以考虑


376
00:17:53,140 --> 00:17:55,142
怎样让你的窗口
在全屏工作


377
00:17:55.209 --> 00:17:56.743 align:middle
这一项仍可以选择


378
00:18:00,247 --> 00:18:03,116
当然也可以在Xcode
属性检查器中设置


379
00:18:03,183 --> 00:18:04,785
当然可以是设置


380
00:18:04,852 --> 00:18:06,687
叠加或窗口是否
该全屏之类


381
00:18:06,753 --> 00:18:10,190
我说过 很多窗口都
可以自动叠加


382
00:18:10,490 --> 00:18:12,159
不过AppKit可以查看


383
00:18:12,226 --> 00:18:14,795
确定窗口是否可以
在同一个屏幕共存


384
00:18:15,195 --> 00:18:16,964
设想你的屏幕
相对较小


385
00:18:17,030 --> 00:18:20,801
还有两个很大的窗口
你希望能把它们叠加


386
00:18:20,868 --> 00:18:22,970
如果窗口无法
缩小到足够小


387
00:18:23,036 --> 00:18:24,838
AppKit将无法
实现叠加窗口


388
00:18:24,905 --> 00:18:29,176
我希望你想想
怎样让窗口足够小


389
00:18:29,243 --> 00:18:31,812
如何才能灵活
处理使其


390
00:18:31,879 --> 00:18:35,582
能在更小的空间
叠加分割视图


391
00:18:36,149 --> 00:18:38,218
为实现这一点
我们有一些API


392
00:18:39,253 --> 00:18:41,855
例如 分割视图项
现在是侧边栏的动作


393
00:18:42,155 --> 00:18:44,725
侧边栏变小
并消失


394
00:18:44,791 --> 00:18:47,127
这样就可以
实现重叠


395
00:18:47,561 --> 00:18:48,996
也可以有适当的震动


396
00:18:49,830 --> 00:18:53,233
NSStackView可以自动
查出隐藏的视图


397
00:18:53,300 --> 00:18:56,036
帮你创建类似
NSToolbar的体验


398
00:18:56,103 --> 00:18:58,338
适用于定制化视图
可以把


399
00:18:58.405 --> 00:19:00.207 align:middle
拖到边缘的项


400
00:18:58,405 --> 00:19:00,207
拖到边缘的项


401
00:19:00,340 --> 00:19:04,444
放入菜单
诸如此类 还有许多


402
00:19:04,678 --> 00:19:05,679
你可以去听听


403
00:19:05,746 --> 00:19:07,814
《改善全屏视窗体验》
的讲座


404
00:19:07,881 --> 00:19:09,082
时间是周四下午


405
00:19:11,885 --> 00:19:14,555
要知道Auto Layout
也很重要


406
00:19:14,621 --> 00:19:16,690
我们做了部分
重要调整


407
00:19:16,757 --> 00:19:19,626
极大提高了
Auto Layout的表现


408
00:19:19,960 --> 00:19:21,161
首先是堆栈视图


409
00:19:21,595 --> 00:19:25,265
堆栈视图是个
很重要的分类


410
00:19:25,532 --> 00:19:28,302
在满足Auto Layout需求时
应该首先想到这个


411
00:19:28,368 --> 00:19:29,970
如果你可以了解
堆栈视图中


412
00:19:30,037 --> 00:19:31,104
可以做什么


413
00:19:31,171 --> 00:19:33,140
而不是直接使用
种种约束会好得多


414
00:19:33,507 --> 00:19:36,410
这是很大程度上的抽象
非常强大


415
00:19:36,844 --> 00:19:39,813
关于堆栈视图的好消息是
在iOS上也可以使用


416
00:19:39,880 --> 00:19:43,116
因为UI堆栈视图
和在API的效果不相上下


417
00:19:43,183 --> 00:19:46,119
这和我们一直以来的努力
相一致


418
00:19:46,186 --> 00:19:49,056
即在不同平台间
实现奇偶校验效果


419
00:19:49,122 --> 00:19:50,457
这就是具体的
一个实例


420
00:19:50,858 --> 00:19:52,759
第二 现在这方面
比以往做得更好


421
00:19:52,826 --> 00:19:55,495
我已经说过
有个分离功能


422
00:19:55,929 --> 00:19:58,031
还有几个
新视图分布选项


423
00:19:58,098 --> 00:19:59,600ddle
具备这个属性
叫做分布


424
00:20:01,201 --> 00:20:03,203
这里有一个值
是重力区


425
00:20:03,270 --> 00:20:07,441
在介绍X v9的第一天起
大家就见过


426
00:20:07,508 --> 00:20:09,309
堆栈视图的选项


427
00:20:09,376 --> 00:20:11,245
我们已经加上其他设置


428
00:20:11,311 --> 00:20:12,613
这些就不必
继续解释了


429
00:20:13,046 --> 00:20:14,548
给大家看一个短视频


430
00:20:15,582 --> 00:20:18,452
有6个堆栈视图
构成这些设置


431
00:20:18,519 --> 00:20:20,954
我重新调整窗口
稍大一些


432
00:20:21,021 --> 00:20:22,523
小一些 再大些


433
00:20:22,723 --> 00:20:25,292
你们看 还是有些
强大的功能的


434
00:20:25,359 --> 00:20:27,861
比如设定等大
等距这些


435
00:20:27,928 --> 00:20:31,231
等等 希望能够
满足你们的需要


436
00:20:31,431 --> 00:20:34,334
堆栈视图可以
任意放置


437
00:20:34,401 --> 00:20:36,336
方便设置布局


438
00:20:36,937 --> 00:20:40,140
NSLayoutAnchor是个新
类别可以提供


439
00:20:40,374 --> 00:20:42,643
边或尺寸的
精确表示法


440
00:20:43,043 --> 00:20:44,311
比如 你有
两个视图


441
00:20:44,378 --> 00:20:45,712
打算创建
二者间的约束


442
00:20:46,313 --> 00:20:47,881
这就是必须
编写的代码


443
00:20:48,549 --> 00:20:51,919
有着布局锚点
可以编写这个代码


444
00:20:52,519 --> 00:20:55,355
注意 这两项
基本上是布局锚点


445
00:20:55,422 --> 00:20:58,292
是指那些
视图的边缘


446
00:20:58,659 --> 00:21:00,694ddle
结果不仅更短
更好看


447
00:20:58,659 --> 00:21:00,694
结果不仅更短
更好看


448
00:21:00,761 --> 00:21:03,964
而且还提供了
更多编辑时间类型检查


449
00:21:04,031 --> 00:21:04,698
非常好


450
00:21:10,270 --> 00:21:13,040
NSLayout Guide 是又一个新分类


451
00:21:13,674 --> 00:21:15,809
如果你在做
这类事情


452
00:21:15,876 --> 00:21:20,514
创建虚拟视图
实现视图间


453
00:21:20,581 --> 00:21:24,051
等距效果 那么
可以试试创建布局指南


454
00:21:24,117 --> 00:21:27,187
这是个轻量级对象
占据了视图的位置


455
00:21:27,254 --> 00:21:29,756
不过其实它的量级更轻
可以参与


456
00:21:29,823 --> 00:21:31,792
Auto Layout
而不会生成视图


457
00:21:33,293 --> 00:21:35,863
我们已经了解过
集合视图


458
00:21:36,296 --> 00:21:39,666
要知道 UICollection
View 也有过几个


459
00:21:39,766 --> 00:21:41,368
版本了


460
00:21:41,802 --> 00:21:44,371
有着X v11 我们将
NSCollectionView


461
00:21:44,438 --> 00:21:47,608
iOS版本进行奇偶校验
都是保持重要功能


462
00:21:47,674 --> 00:21:50,210
用于桌面 例如
拖拽和批量选择


463
00:21:50,811 --> 00:21:53,347
现在是新的集合视图中
部分功能


464
00:21:53,814 --> 00:21:56,283
有些功能如
异构项


465
00:21:56,350 --> 00:21:58,385
选择性分组
可定制布局


466
00:21:58,852 --> 00:22:01,622
我来给大家看个短视频
是样本应用


467
00:22:02,055 --> 00:22:03,490
会有很多图像
显示出来


468
00:22:03,557 --> 00:22:08,328
我首先依照页眉和页脚
进行分组 会用到


469
00:22:08,395 --> 00:22:10,497
部分定制布局
是本款app所提供


470
00:22:11,665 --> 00:22:14,935
来看app的实际应用
了解具体功能


471
00:22:15,002 --> 00:22:17,204
以及如何用于自己的应用中
《集合视图最新内容》


472
00:22:17,271 --> 00:22:20,207
周四下午4:30
会有介绍


473
00:22:22,442 --> 00:22:23,877
在文本方面
我们的改动很多


474
00:22:24,178 --> 00:22:25,946
首先是新的系统UI字体


475
00:22:27,514 --> 00:22:30,384
新系统的字体
是这样San Francisco


476
00:22:30,450 --> 00:22:35,122
要知道　这和iOS和watchOS
上的字体一样


477
00:22:35,822 --> 00:22:39,092
字体是自动
提供应用的


478
00:22:39,159 --> 00:22:41,895
在 El Capitan的
X v11 运行你的应用


479
00:22:41,962 --> 00:22:42,930
就会得到这个字体


480
00:22:42,996 --> 00:22:44,765
不过可能
你做了什么


481
00:22:44,831 --> 00:22:45,966
阻止了这项功能


482
00:22:46,033 --> 00:22:49,570
如果看到这个字体
这是在X v10中推出的


483
00:22:49,736 --> 00:22:53,540
还有些内容在继续
检查一下是否是你所需


484
00:22:53,607 --> 00:22:56,343
确保你是在使用San
Francisco这种字体


485
00:22:56,443 --> 00:23:00,280
如果在用这种字体
我们是在X v0当中推出


486
00:23:00,347 --> 00:23:02,516
还会有更多内容继续


487
00:23:02,983 --> 00:23:05,886
最后 如果你在
使用这款字体...


488
00:23:08,088 --> 00:23:09,690
...那么会有很多工作要做


489
00:23:09,756 --> 00:23:10,624
稍等一下


490
00:23:11,491 --> 00:23:13,827
这就是我们不再
使用的Mac OS 9字体


491
00:23:16,163 --> 00:23:18,332
这是在API可以使用的
NSFont字体


492
00:23:18,398 --> 00:23:20,734
确保自己用的是
最新版本的系统字体


493
00:23:21,134 --> 00:23:22,769
还有系统字体大小等等


494
00:23:22,836 --> 00:23:25,873
这些字体
这些API


495
00:23:25,939 --> 00:23:27,274
我们用了很久


496
00:23:28,742 --> 00:23:32,212
可以通过Xcode属性检查器
设置系统字体


497
00:23:32,713 --> 00:23:34,748
非常简单
会有弹出窗口


498
00:23:34,815 --> 00:23:36,683
选择适当的
系统字体


499
00:23:36,750 --> 00:23:37,885
用于自己的应用


500
00:23:39,453 --> 00:23:41,922
我们还有一款新API
可用于不同粗细的系统字体


501
00:23:42,489 --> 00:23:45,959
如果设计师让你
使用不同粗细字体


502
00:23:46,426 --> 00:23:49,062
现在就可以用这个
API调整系统字体


503
00:23:49,263 --> 00:23:51,331
系统字体大小和粗细


504
00:23:52,032 --> 00:23:54,635
有预设的9种
不同粗细


505
00:23:54,701 --> 00:23:56,403
我只给大家看
其中三种


506
00:23:56,603 --> 00:23:58,038
从超细
到黑体都有


507
00:23:58,472 --> 00:24:00,574
常规设置是
系统字体大小


508
00:24:00,641 --> 00:24:02,109
默认值


509
00:24:02,676 --> 00:24:06,914
我们还有一款API
单距系统字体大小粗细


510
00:24:07,481 --> 00:24:08,949
我给大家看看
为什么这东西有用


511
00:24:09,983 --> 00:24:14,221
如果调用应用中的
字体大小API


512
00:24:14,288 --> 00:24:16,590
链接是X v11 SDK


513
00:24:16,657 --> 00:24:19,092
在写几个数字
就是这个效果


514
00:24:19,626 --> 00:24:24,031
对字体很敏感的眼睛
估计一下子就会感到不同


515
00:24:24,131 --> 00:24:26,433
这些数字
不是定距


516
00:24:26,500 --> 00:24:27,467
宽度都不同


517
00:24:28,068 --> 00:24:31,004
这就很奇怪了
因为传统的系统字体


518
00:24:31,071 --> 00:24:33,473
一般都是
等宽数字


519
00:24:33,941 --> 00:24:39,413
要确保表格数字
都要井井有条


520
00:24:39,479 --> 00:24:43,250
或是UI文本中数字变化时
不会拧成一团


521
00:24:43,317 --> 00:24:44,685
因为数字是不断变化的


522
00:24:45,519 --> 00:24:47,154
不过现在 如果你的app


523
00:24:47,221 --> 00:24:50,624
连在 X v11上就会
得到这样的系统字体


524
00:24:50,858 --> 00:24:53,260
如果必须
要定距字体


525
00:24:53,360 --> 00:24:56,830
那么在使用这个
API时 就要放弃


526
00:24:56,897 --> 00:24:59,266
等宽数字


527
00:24:59,733 --> 00:25:02,769
从活版印刷角度来看
效果不理想 不过问题解决了


528
00:25:03,203 --> 00:25:05,506
效果很是不同


529
00:25:05,772 --> 00:25:08,809
现在是按比例
也是固定宽度了


530
00:25:09,009 --> 00:25:10,077
这就是给大家的工具


531
00:25:10,711 --> 00:25:13,747
大家还可以听到
更多API方面的内容


532
00:25:13,814 --> 00:25:15,349
《最新系统字体介绍》


533
00:25:15,415 --> 00:25:17,284
讲座时间 周五下午
2:30


534
00:25:19,186 --> 00:25:23,123
我也提到了新款API
在科技系统有新款API


535
00:25:23,490 --> 00:25:26,927
可以实现新功能以及对TextKit
和iOS进行奇偶校验


536
00:25:27,427 --> 00:25:28,495
这里还有很多项


537
00:25:28,562 --> 00:25:30,731
我只介绍其中
两三种


538
00:25:31,131 --> 00:25:32,533
首先是路径排除


539
00:25:33,133 --> 00:25:36,203
这种功能可以
很容易安排路径


540
00:25:36,270 --> 00:25:38,739
在目标周围
摆好文字 就像这蝴蝶


541
00:25:38,805 --> 00:25:41,475
非常简单


542
00:25:42,209 --> 00:25:44,845
还有一个是文本域的
两个属性：最大线条数


543
00:25:44,912 --> 00:25:48,115
特别适用于
Auto Layout


544
00:25:48,515 --> 00:25:51,018
或是允许
默认缩紧截断


545
00:25:52,019 --> 00:25:55,389
这可以确定文字域


546
00:25:55,455 --> 00:25:59,726
内容是否应该缩紧
然后再真正将之截断


547
00:25:59,793 --> 00:26:02,496
以前有过控制方法
但是现在是


548
00:26:02,563 --> 00:26:04,164
使用Boolean属性控制


549
00:26:05,232 --> 00:26:07,634
还有很多调整变化
以及部分亮点


550
00:26:10,270 --> 00:26:11,772
那么关于AppKit部分


551
00:26:11,839 --> 00:26:14,641
最后讲一点
视觉原子性


552
00:26:15,275 --> 00:26:17,611
大家可能会奇怪
视觉原子性是什么


553
00:26:18,278 --> 00:26:19,279
是山吗？


554
00:26:19,713 --> 00:26:21,481
这和Half Dome
有什么关系?


555
00:26:21,582 --> 00:26:25,018
我给大家看个短片
解释我所说的


556
00:26:25,085 --> 00:26:28,422
视觉原子性或
缺乏视觉原子性是什么意思


557
00:26:28,755 --> 00:26:30,557
两次看到
打开面板


558
00:26:31,391 --> 00:26:33,093
第一次没问题 还可以


559
00:26:33,760 --> 00:26:35,429
第二次 你们自己想


560
00:26:39,766 --> 00:26:44,938
除非你们什么都看不到
否则都明白我的意思


561
00:26:45,205 --> 00:26:46,740
我给大家慢动作播放


562
00:26:47,241 --> 00:26:50,344
阴影部分面板
面板其他部分


563
00:26:50,677 --> 00:26:53,780
这就是打开面板
是在约塞米蒂


564
00:26:54,548 --> 00:26:57,084
打开面板很粗糙
因为是多项进程


565
00:26:57,150 --> 00:27:00,120
在带动
不过这不是借口


566
00:27:00,454 --> 00:27:03,257
这样的UI让用户
感觉仿佛是一次


567
00:27:03,323 --> 00:27:05,926
走一步 一次走一帧
不应该是


568
00:27:05,993 --> 00:27:08,862
这样的视觉
步骤的


569
00:27:09,563 --> 00:27:11,164
这就是我所说的
视觉原子性的意思


570
00:27:11,231 --> 00:27:14,434
需要的时候
一步到位


571
00:27:15,269 --> 00:27:18,805
你们当中视窗 视图


572
00:27:19,072 --> 00:27:21,575
还有Core Animation
层次都很清晰


573
00:27:21,642 --> 00:27:24,111
要知道实现
视觉原子性并非


574
00:27:24,178 --> 00:27:25,078
都那么简单


575
00:27:26,547 --> 00:27:28,715
这些是API
大家不用仔细


576
00:27:28,782 --> 00:27:30,217
看明细
这不是考试


577
00:27:30,684 --> 00:27:32,886
这些就是完成这项任务
所需要的API


578
00:27:32,953 --> 00:27:35,556
但是不一定要一起
工作才行


579
00:27:35,923 --> 00:27:37,824
在X v11中我们解决了问题


580
00:27:38,258 --> 00:27:41,562
所以可以用
NSAnimationContex


581
00:27:41,628 --> 00:27:42,963
实现视觉原子性


582
00:27:44,097 --> 00:27:47,000
可以调用Begin Group
ing或End Grouping


583
00:27:47,067 --> 00:27:47,801
或类似功能


584
00:27:47,868 --> 00:27:50,470
运行Animation Group
周围是一系列


585
00:27:50,838 --> 00:27:53,507
你在做的独立画作
就像这里这样


586
00:27:53,574 --> 00:27:55,442
这就可以实现
视觉原子性


587
00:27:55,509 --> 00:27:57,778
除此之外


588
00:27:58,011 --> 00:28:00,614
我们不鼓励使用Disable
Screen Updates


589
00:28:00,681 --> 00:28:02,716
和Enable Screen
Updates


590
00:28:02,783 --> 00:28:05,352
以及Disable Screen
until Flush


591
00:28:05,419 --> 00:28:07,754
并非是不支持
只是不再推荐使用


592
00:28:07,821 --> 00:28:09,156
应该没必要


593
00:28:11,124 --> 00:28:15,362
这样 我们可以继续
介绍Foundation


594
00:28:15,996 --> 00:28:18,298
关于Foundation
可以讲的也很多


595
00:28:19,700 --> 00:28:20,868
首先是管理撤销


596
00:28:21,835 --> 00:28:25,572
用过Swift中管理撤销的
都知道管理撤销


597
00:28:25,639 --> 00:28:28,509
API在Swift中
并不太好用


598
00:28:29,209 --> 00:28:30,677
API是这个样子


599
00:28:30,978 --> 00:28:34,448
第一个有个选择器
部分情况才会管用


600
00:28:34,515 --> 00:28:36,149
第二个是有
指示


601
00:28:36,550 --> 00:28:39,653
NSIndication in
Objective-C当然相当棒


602
00:28:39,887 --> 00:28:42,990
还是Swift里面那些
花哨的种类 它不太清楚


603
00:28:43,590 --> 00:28:45,959
所以我们加上了
基于代码块的撤销


604
00:28:46,927 --> 00:28:48,829
这就是在
Objective-C中的样子


605
00:28:48,896 --> 00:28:50,097
在Swift中
是这个样子


606
00:28:50,964 --> 00:28:52,633
你们看
这有个目标论证


607
00:28:52,900 --> 00:28:55,135
也是个代码块
基本上就是执行


608
00:28:55,202 --> 00:28:57,938
刚做过的
撤销应用


609
00:28:59,139 --> 00:29:01,808e
目标方式的不同论证
大家不用


610
00:28:59,139 --> 00:29:01,808
目标方式的不同论证
大家不用


611
00:29:01,875 --> 00:29:03,443
去参考
代码块的目标


612
00:29:03,510 --> 00:29:05,245
以避免循环保留


613
00:29:05,712 --> 00:29:07,414
在Swift声明中
也用到泛型类型


614
00:29:07,481 --> 00:29:09,616
我会告诉大家
具体是怎么工作的


615
00:29:10,284 --> 00:29:11,251
这是个例子


616
00:29:11,552 --> 00:29:13,654
我们有个类别
名为Colorful Shape


617
00:29:13,720 --> 00:29:15,355
还有个属性名为Color


618
00:29:17,090 --> 00:29:20,060
我们为这个属性
加上Did Set属性观察器


619
00:29:20,427 --> 00:29:22,529
这不过是可以实现撤销的
多种方式之一


620
00:29:22,596 --> 00:29:24,865
还可以通过其他方式撤销
不过我们是通过


621
00:29:24,932 --> 00:29:25,999
Did Set属性完成


622
00:29:26,466 --> 00:29:28,635
这里是调用
目标注册撤销


623
00:29:29,369 --> 00:29:32,272
这里是实际上执行
撤销应用的代码


624
00:29:32,339 --> 00:29:33,607
针对我刚做过的事情


625
00:29:35,042 --> 00:29:38,645
注意这里多亏对目标的
注册撤销中用了泛型


626
00:29:38,712 --> 00:29:41,481
这些都发挥了作用


627
00:29:41,548 --> 00:29:43,617
目标被自动识别
为是彩色形状


628
00:29:43,684 --> 00:29:46,253
这要归功于
注册撤销栏的


629
00:29:46,320 --> 00:29:48,055
自参考


630
00:29:48,121 --> 00:29:50,524
你不必将目标转化为
彩色形状


631
00:29:53,026 --> 00:29:55,162
NSCoder现在就可以处理错误


632
00:29:55,495 --> 00:29:58,699
用过NSCoders的人们比如NS
KeyedArchiver之类


633
00:29:58,765 --> 00:30:01,802
要知道并没有对这些东西的
错误论证


634
00:30:02,569 --> 00:30:04,638
我们已经添加了外显
错误处理


635
00:30:05,405 --> 00:30:07,908
这类方式包括Decode
Object for Key


636
00:30:07,975 --> 00:30:10,711
Decode Object of
Classes for Key


637
00:30:10,777 --> 00:30:11,612
都有不同版本


638
00:30:11,678 --> 00:30:13,981
都可以在实际中返还错误
将错误抛入Swift当中


639
00:30:14,114 --> 00:30:15,916
这些叫做
Decode Top Level


640
00:30:15,983 --> 00:30:17,184
Object for Key


641
00:30:17,251 --> 00:30:18,952
以及Decode Top
Level


642
00:30:19,019 --> 00:30:21,154
Object of
Classes for Key


643
00:30:21,221 --> 00:30:23,290
注意它们抛出声明表示了
它们在返回还错误


644
00:30:23,624 --> 00:30:25,926
还要注意它们
返回了可选目标


645
00:30:25,993 --> 00:30:28,996
因为空返回
实际上是有效返回


646
00:30:29,062 --> 00:30:32,032
这表明对象
并不在档案中


647
00:30:32,999 --> 00:30:33,934
注意这些名为


648
00:30:34,001 --> 00:30:36,603
Decode Top Level
Object for Key


649
00:30:36,670 --> 00:30:39,273
我们有意在
未归档的


650
00:30:39,339 --> 00:30:41,208
根对象中
将其放在顶层


651
00:30:41,508 --> 00:30:44,311
我们不想在你实施代码期间


652
00:30:44,378 --> 00:30:45,279
调用这些


653
00:30:46,713 --> 00:30:48,615
请注意 这里
只有两种方式


654
00:30:48,682 --> 00:30:50,951
我们还有两三种
方式可以适用


655
00:30:51,018 --> 00:30:53,921
所有的解码对象
类型方式


656
00:30:56,190 --> 00:30:59,660
现在由NSError提供值
我们以此为模型


657
00:31:00,260 --> 00:31:04,431
通过这种简单的方式
可以生成NSError对象


658
00:31:04,498 --> 00:31:06,633
相当简单
直接 不过


659
00:31:06,700 --> 00:31:08,235
注意 它不可向
用户呈现


660
00:31:08,569 --> 00:31:10,437
如果用户
见过了


661
00:31:10,504 --> 00:31:11,605
那就是这个样子


662
00:31:12,172 --> 00:31:16,210
不太好你们其实是想给
他们看看


663
00:31:16,276 --> 00:31:17,978
是否曾给
用户见过


664
00:31:18,245 --> 00:31:20,414
即便不给用户提供
要知道


665
00:31:20,480 --> 00:31:22,516
除错器中 有这类东西
也会很有帮助


666
00:31:22,583 --> 00:31:24,618
与得到42号错误相反


667
00:31:25,252 --> 00:31:28,355
因此编写的代码
是类似这样


668
00:31:29,389 --> 00:31:33,460
因此要明确各个键的值
如果想要给用户


669
00:31:33,527 --> 00:31:36,230
出示 需要对之
进行本地化


670
00:31:36,864 --> 00:31:38,398
因此这是
一大堆代码


671
00:31:38,932 --> 00:31:41,001
你就可以永远地
创建方式


672
00:31:41,201 --> 00:31:44,137
代码不是问题
编写代码是我们的工作


673
00:31:44,204 --> 00:31:46,306
对 我们就是靠这个挣钱的
不过这不是问题


674
00:31:46,607 --> 00:31:48,842
问题是所有这些
都是发生在


675
00:31:48,909 --> 00:31:51,879
出现错误的时候
即使错误的消费端


676
00:31:51,945 --> 00:31:53,680
和错误没有任何关系
也是如此


677
00:31:53,747 --> 00:31:55,816
因此从性能考虑
这是浪费


678
00:31:56,450 --> 00:31:58,719
因此我们加入了
这种功能


679
00:31:58,785 --> 00:32:01,088ddle
可以按需创建
并返回所需值


680
00:31:58,785 --> 00:32:01,088
可以按需创建
并返回所需值


681
00:32:02,289 --> 00:32:05,592
我们有这个方式
为域名提供方的


682
00:32:05,659 --> 00:32:07,227
用户信息值提供方进行设置


683
00:32:07,461 --> 00:32:11,131
你基本上在应用中
为NSError


684
00:32:11,198 --> 00:32:13,901
明确域名
并提供提供方


685
00:32:13,967 --> 00:32:17,137
即可以将在用户信息字典中
丢失的任何键值


686
00:32:17,204 --> 00:32:18,238
返回的代码块


687
00:32:18,305 --> 00:32:20,240
因此 会按需
惰性生成


688
00:32:20,574 --> 00:32:24,144
你可以回去使用这个
漂亮的短小代码


689
00:32:24,211 --> 00:32:26,013
来生成错误
用户信息


690
00:32:26,079 --> 00:32:27,548
会动态填写


691
00:32:30,751 --> 00:32:32,819
你也许熟悉
NSProgress


692
00:32:32,953 --> 00:32:35,222
这是报告
进度的对象


693
00:32:35,289 --> 00:32:36,657
还有个不错的功能


694
00:32:36,723 --> 00:32:41,662
将在多个操作类型层次中
隐形记录进度


695
00:32:41,728 --> 00:32:43,564
并且它会
作为单独数字


696
00:32:43,630 --> 00:32:45,666
呈现
给用户


697
00:32:46,133 --> 00:32:47,968
相当不错
但是这是隐形的


698
00:32:48,669 --> 00:32:52,139
作为隐形
你可能会


699
00:32:52,206 --> 00:32:53,207
遇到一些问题


700
00:32:53,540 --> 00:32:55,542
我们介绍
管理进度报告的


701
00:32:55,609 --> 00:32:57,110
线性模式


702
00:32:57,778 --> 00:33:00,380e
包括两部分
一个是直接向


703
00:32:57,778 --> 00:33:00,380
包括两部分
一个是直接向


704
00:33:00,447 --> 00:33:03,383
操作类型层次
添加并去除子进度对象


705
00:33:03,450 --> 00:33:06,420
第二个就是这个协议


706
00:33:06,486 --> 00:33:09,423
可以让你
直接声明对象进度


707
00:33:09,857 --> 00:33:12,025
例如 如有
NSOperation子类


708
00:33:12,092 --> 00:33:16,396
这可以实现部分一步操作
要知道 它会开始和结束


709
00:33:16,463 --> 00:33:19,533
是这个进度属性
不错的候选


710
00:33:19,833 --> 00:33:23,270
可以实现选择
外显进度报告


711
00:33:24,438 --> 00:33:27,040
NSProgress也可以
从头开始


712
00:33:27,441 --> 00:33:30,477
以前是可以停顿
我们有加入第二部分


713
00:33:32,079 --> 00:33:34,815
NSNotification
Center现在可以


714
00:33:34,882 --> 00:33:37,451
自动解除注册
分配的观察


715
00:33:43,657 --> 00:33:45,559
这就是你们必须
把自己加成


716
00:33:45,959 --> 00:33:47,394
观察者需要
编写的内容


717
00:33:47,461 --> 00:33:48,328
这是需要把自己


718
00:33:48,395 --> 00:33:49,863
作为观察者删除
所需编写的代码


719
00:33:49,930 --> 00:33:51,465
如果想把自己
作为观察者删除


720
00:33:51,532 --> 00:33:53,367
作为观察者删除
所需编写的代码


721
00:33:53,867 --> 00:33:57,271
如果不然 你会被自动
取消注册


722
00:33:57.404 --> 00:33:59.540 align:middle
相当棒
这样很好


723
00:34:01,408 --> 00:34:05,879
这个类别名称 就是
Toby 昨天在


724
00:34:05,946 --> 00:34:07,481
联盟会议上不敢提到的


725
00:34:07,714 --> 00:34:09,683
NSFirstNameComponentsFormatter


726
00:34:10,016 --> 00:34:13,053
规则是 如果它没有
长到可以在


727
00:34:13,120 --> 00:34:15,022
幻灯片标题上封装起来
那它并不算太长


728
00:34:15,222 --> 00:34:18,025
那么NSFirstName
ComponentsFomatter


729
00:34:18,091 --> 00:34:20,661
它可以让名称的格式
得以恰当本地化


730
00:34:20,928 --> 00:34:23,563
它又和其他
我们过去几年加入的格式器


731
00:34:23,630 --> 00:34:26,667
联合了起来 比如
日期部件格式器


732
00:34:27,034 --> 00:34:29,369
字节数格式器
长度格式器等等


733
00:34:30,603 --> 00:34:34,208
它还为几种不同形式
提供了样式


734
00:34:34,341 --> 00:34:35,809
让我举一个简单的例子


735
00:34:36,310 --> 00:34:39,612
假设你创建了一个基于人名的
实体组件 它有名称的


736
00:34:39,679 --> 00:34:42,282
几部分 你指定
你有的名称部分


737
00:34:42,482 --> 00:34:45,252
但是还剩很多 比如说
在这里 我们指定其中三个


738
00:34:46,719 --> 00:34:49,322
然后 你在格式器中创建
一个人名 然后把它


739
00:34:49,389 --> 00:34:50,591
格式化


740
00:34:51,190 --> 00:34:54,161
取决于你
你给的样式


741
00:34:54,228 --> 00:34:56,396
你会得到不同形式的
名称 如长的


742
00:34:56,463 --> 00:34:58,298
默认的、短的等等


743
00:34:58,699 --> 00:35:01,802
请注意 如果你需要短的
但在其它语言中


744
00:35:01,869 --> 00:35:05,506
你可能会得到一个形式完全不同的
名称 这个具体取决于


745
00:35:05,572 --> 00:35:07,374
这种语言的
本地化规则


746
00:35:07,441 --> 00:35:09,076
不要对你会从
这种API得到的


747
00:35:09,142 --> 00:35:11,345
名称的类别
做出假设


748
00:35:11,912 --> 00:35:14,181
这个 API 的目的
主要的目的之一就是


749
00:35:14,248 --> 00:35:16,216
让你从编写全球通用


750
00:35:16,283 --> 00:35:18,352
应用的复杂工作中
解放出来


751
00:35:19,319 --> 00:35:22,456
NSString 有新的 API
其可以帮助你编写全球通用


752
00:35:22,523 --> 00:35:24,191
国际化的
应用


753
00:35:24,625 --> 00:35:27,494
这将促进
有条件的引用


754
00:35:27,761 --> 00:35:31,565
不论其是否为技术词语
其应由引用包围


755
00:35:31,832 --> 00:35:34,401
而其规则会根据
语言不同而变化


756
00:35:34,768 --> 00:35:37,571
更为简单的本地化情况
用于变更和搜索的 API


757
00:35:38,105 --> 00:35:41,241
音译API它们之前
都在 CFString 中


758
00:35:41,308 --> 00:35:44,244
现在它们在 NSString 中
也能更好地协助


759
00:35:44,311 --> 00:35:47,281
自适应字符串
和用户界面表达


760
00:35:47,614 --> 00:35:51,351
在你的字符串文件中
你可以提供多个形式


761
00:35:51,418 --> 00:35:54,655
多种长度
并根据你在


762
00:35:54,721 --> 00:35:57,357
你在用户界面上所剩
空间多少来选择合适的


763
00:35:58,125 --> 00:36:00,928
你会在国际化新特性讲座中
了解到关于名称部件格式器


764
00:36:01,295 --> 00:36:03,764
和所有这些协助方法
的具体信息


765
00:36:03,830 --> 00:36:06,366
当然还有更多内容
它在星期五上午9点开始


766
00:36:08,268 --> 00:36:10,003
我再谈谈
关于热状况的情况


767
00:36:10,070 --> 00:36:15,075
这些 API 是在 X
v10.3 中引入的 也是我们


768
00:36:15,142 --> 00:36:18,078
动感新 MacBook 出来之刻
当然 你们也知道


769
00:36:18,145 --> 00:36:20,280
没有多少人真的喜欢
这个新东西


770
00:36:20,380 --> 00:36:23,550
而事实上它是
一个很好的 API 案例研究


771
00:36:23,884 --> 00:36:27,654
请注意 虽然此 API
和新 MacBook 同时引入


772
00:36:27,721 --> 00:36:30,757
它也适用于我们的其它机器


773
00:36:30,824 --> 00:36:32,326
而且通常都是
可用并能正常运作的


774
00:36:32,392 --> 00:36:33,927
它不仅仅适用于
MacBook


775
00:36:34,795 --> 00:36:37,831
此 API 使用
属性捕获


776
00:36:37,898 --> 00:36:40,400
一种在 NSProcessInfo
上的热状况属性


777
00:36:40,467 --> 00:36:43,203
它有四个值：象征性
普通、 严重 、极其严重


778
00:36:43,570 --> 00:36:46,840
每当值更改时
你都会收到通知


779
00:36:48,509 --> 00:36:51,411
如果值为严重
那么风扇是以


780
00:36:51,478 --> 00:36:53,780
最高速度运作
当然 这是假设你的电脑有风扇


781
00:36:54,248 --> 00:36:56,884
你可以想象如果你没有风扇
那会发生什么事情


782
00:36:57,184 --> 00:36:59,520
严重通常是要
你采取某些行动的时候


783
00:36:59,586 --> 00:37:02,389e
例如 你可能
在做自定义的动画


784
00:36:59,586 --> 00:37:02,389
例如 你可能
在做自定义的动画


785
00:37:03,390 --> 00:37:05,225
而且帧数达到 60 FIPS
这时你要考虑


786
00:37:05,292 --> 00:37:07,361
减少你的帧数到
30 FIPS


787
00:37:07,861 --> 00:37:10,497
这就是 NSScrollView
会自动为你做的事情


788
00:37:10,564 --> 00:37:13,433
这样一来 你就不必担心有关
NSScrollView 的情况


789
00:37:13,500 --> 00:37:16,069
假设你正在应用程序中
使用高解析度的材质


790
00:37:16,136 --> 00:37:18,105
而且你收到一个
严重的热状态的提示


791
00:37:18,172 --> 00:37:21,108
也许你需要
使用低解析度的材质


792
00:37:22,176 --> 00:37:25,245
此款 API 在
你需要它时很有帮助 但


793
00:37:25,312 --> 00:37:28,649
但要注意 此款 API 是
反应性的 并不是主动的


794
00:37:29,183 --> 00:37:31,985
此 API 让
系统提示你 告诉你


795
00:37:32,052 --> 00:37:35,088
目前的困难 然后你需要
采取行动 当然


796
00:37:35,155 --> 00:37:36,890
你采取的行动
不能反而


797
00:37:36,957 --> 00:37:38,058
增加对系统的负载


798
00:37:38,692 --> 00:37:40,894
我们有很多其它
主动 API


799
00:37:40,961 --> 00:37:43,664
我们已在
最新的讲座中介绍


800
00:37:44,398 --> 00:37:46,900
这些类型的 API
会告诉系统


801
00:37:46,967 --> 00:37:51,705
你在做什么 然后
系统会基于你


802
00:37:51,772 --> 00:37:55,676
目前的操作
优化你的活动和任务


803
00:37:56,043 --> 00:37:58,045
例如 计时器
公差


804
00:37:58,412 --> 00:38:01,582ddle
处理信息活动
API 并


805
00:37:58,412 --> 00:38:01,582
处理信息活动
API 并


806
00:38:01,648 --> 00:38:03,784
使用 NSURLSession
在后台进行下载


807
00:38:03,851 --> 00:38:06,520
设置服务质量 等等


808
00:38:07,487 --> 00:38:10,757
这些 API 不仅可以允许
高效操作


809
00:38:10,824 --> 00:38:13,093
但它们还能够
引导合适的热行为


810
00:38:13,160 --> 00:38:17,497
它们可以带来更长的电池
使用寿命 并让你的系统冷却


811
00:38:17,865 --> 00:38:19,833
无论是表面上的降温
还是内部降温


812
00:38:22,135 --> 00:38:26,340
最后 我简单地提及下 Core
Data因为讲座剩下时间不多了


813
00:38:26,707 --> 00:38:29,076
Core Data
中有很多强大功能唯一约束


814
00:38:29,142 --> 00:38:31,812
批量删除
和其他 API 增强功能


815
00:38:32,045 --> 00:38:33,113
这就是我要说的


816
00:38:34,181 --> 00:38:35,682
当然 这不算一个
新特性讲座 如果


817
00:38:35,749 --> 00:38:38,118
如果我没有提到很多
新事物


818
00:38:38,452 --> 00:38:40,587
这些都是许多其他
我没时间提到的主题


819
00:38:40,654 --> 00:38:42,756
你应该可以在
发布说明中阅读到


820
00:38:43,190 --> 00:38:45,659
它甚至没有包括
令人惊讶的新技术


821
00:38:45,726 --> 00:38:48,095
比如 Metal 或者
GameplayKit


822
00:38:50,397 --> 00:38:53,300
总的来说 我们有很多
泛型通用 API 改进


823
00:38:53,367 --> 00:38:55,569
在 Swiftification
各个层面上都有


824
00:38:55,636 --> 00:38:57,971
此外 我们有很多
强大的功能和增强功能


825
00:38:58,672 --> 00:39:03,410
看看这些材料 想想如何
采用它们


826
00:39:03,477 --> 00:39:06,113
如果你有任何问题
就来我们的实验室来讨论吧


827
00:39:07,748 --> 00:39:10,384
最后 我
再总结下要点


828
00:39:10,617 --> 00:39:12,553
AppKit和Foundation
发布


829
00:39:12,619 --> 00:39:13,554
说明已经可以从


830
00:39:13,620 --> 00:39:16,223
developer.apple.
com.osx上获取


831
00:39:16,290 --> 00:39:19,526
发布说明是为了抛砖引玉
所以它是一个很好的来源


832
00:39:20,093 --> 00:39:21,428
感谢你们今天到场


833
00:39:21,495 --> 00:39:22,863
会议后
好好休息吧

