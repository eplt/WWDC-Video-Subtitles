1
00:00:21,355 --> 00:00:23,056
欢迎参加《Swift最新内容》讲座


2
00:00:29,096 --> 00:00:31,832
我是克里斯·拉特纳
我来主讲前半部分


3
00:00:31,899 --> 00:00:35,702
我的同事约翰·迈克考尔
则会在下半部分介绍最新内容


4
00:00:36,637 --> 00:00:38,705
在开始之前我觉得先来看看


5
00:00:38,772 --> 00:00:41,475
我们想做什么
这很有趣也许会有帮助


6
00:00:41,542 --> 00:00:44,444
Swift 2的目标是什么
以及它背后的思想是什么？


7
00:00:45,412 --> 00:00:47,548
我们主要追求三个目标


8
00:00:48,282 --> 00:00:49,950
首先 基础架构 


9
00:00:50,350 --> 00:00:55,155
我们希望Swift语言的核心功能
和核心行为以及工具都非常出色


10
00:00:55,856 --> 00:00:59,426
许多内容都需要很多在座的朋友


11
00:00:59,793 --> 00:01:01,395
在使用Swift过程中产生的反馈


12
00:01:01,461 --> 00:01:06,133
其中很多都是...


13
00:01:06,700 --> 00:01:09,770
我非常感谢大家所提供的所有反馈


14
00:01:10,170 --> 00:01:11,872
大家通过实际使用产生的出色反馈


15
00:01:12,272 --> 00:01:14,675
才使得Swift得以不断完善


16
00:01:15,909 --> 00:01:17,277
第二 是安全


17
00:01:18,712 --> 00:01:20,247
安全性是Swift的核心价值


18
00:01:21,315 --> 00:01:24,451
我们的确希望能很容易地编写安全代码


19
00:01:24,885 --> 00:01:27,287
我们觉得错误处理结构的新可用性


20
00:01:27,821 --> 00:01:29,990
将成为实现这一目的的杰出方式


21
00:01:30,791 --> 00:01:32,092
第三是 美观


22
00:01:33,093 --> 00:01:34,528
我们希望代码可以非常美观


23
00:01:35,028 --> 00:01:38,365
作为编程人员 
我们整天都在和代码打交道


24
00:01:38,432 --> 00:01:40,000
这一点对我们非常重要


25
00:01:40,400 --> 00:01:44,771
我们在Swift中的新增内容使其
更容易写出自然美观的代码


26
00:01:45,839 --> 00:01:48,709
今天我们介绍Swift的五项新内容


27
00:01:50,811 --> 00:01:53,180
在我们详细介绍
Swift 2最新内容之前


28
00:01:53,247 --> 00:01:54,448
我认为有必要说明


29
00:01:54,515 --> 00:01:57,351
Swift 1.2
已经实现了长足进步


30
00:01:57,518 --> 00:01:58,986
它不过是在三个月前发布


31
00:02:00,153 --> 00:02:02,756
由于时间所限我们没办法
详细介绍这个版本


32
00:02:02,890 --> 00:02:05,158
但是如果你感兴趣而且还没有看到过


33
00:02:05,459 --> 00:02:09,530
可以看看Swift编程语言书籍
和Xcode 6版本发布说明


34
00:02:10,663 --> 00:02:12,432
我们来详细介绍基础架构部分


35
00:02:14,134 --> 00:02:18,372
基础架构是关于改进Swift语言的
核心行为以及它该如何通力配合


36
00:02:18,872 --> 00:02:20,574
这里有许多小细节


37
00:02:20,641 --> 00:02:23,810
这感觉像是在漫无目的地漫步
但是要跟上思路


38
00:02:24,511 --> 00:02:25,579
我们先从枚举讲起


39
00:02:26,780 --> 00:02:29,917
枚举是Swift最好的功能之一


40
00:02:30,284 --> 00:02:33,153
这里我用枚举来
列举一些常见的家养宠物


41
00:02:34,755 --> 00:02:37,658
枚举的出色在于它们很容易定义和使用


42
00:02:38,659 --> 00:02:42,596
另一方面
如果你已将它们用于游乐场或打印出来


43
00:02:43,063 --> 00:02:45,098
你可能就会想要更多


44
00:02:46,300 --> 00:02:50,470
在Swift 2枚举可以携带足够的
可以打印的反射信息且效果非常好


45
00:02:56,610 --> 00:02:58,111
接下来相关值


46
00:02:59,046 --> 00:03:03,183
枚举的出色还在于
它们是差别联合类型的理想模型


47
00:03:03,417 --> 00:03:04,484
当有两种不同类型的值


48
00:03:04,551 --> 00:03:08,522
需要在同一内容中进行保存时
这就会非常有用


49
00:03:08,589 --> 00:03:09,423
对吗？


50
00:03:09,690 --> 00:03:11,391
相关值非常强大


51
00:03:11,458 --> 00:03:13,961
也许你会用任何一个类型
编写明显的内容


52
00:03:15,462 --> 00:03:16,964
这是用来做模型的理想方法


53
00:03:17,030 --> 00:03:20,901
但是当你使用时
会有些不快之处


54
00:03:22,069 --> 00:03:24,571
这就太糟糕了
大家都不希望是这样


55
00:03:24,705 --> 00:03:26,807
有了Swift 2这就不成问题


56
00:03:32,579 --> 00:03:33,914
我们再看看递归


57
00:03:34,515 --> 00:03:37,384
Swift中的枚举就是代数数据类型


58
00:03:37,651 --> 00:03:41,655
在其他语言中
递归代数数据类型非常强大


59
00:03:41,722 --> 00:03:42,890
可以做出相当棒的事情


60
00:03:43,624 --> 00:03:47,094
问题在Swift中
这些值在枚举中都是内联保存


61
00:03:47,761 --> 00:03:49,263
这意味着如果是递归枚举


62
00:03:49,396 --> 00:03:53,534
它将会无限令当前的设备很难承受


63
00:03:53,700 --> 00:03:58,505
也许在明年会有这方面的变通方案


64
00:03:58,672 --> 00:04:02,943
大家可能都见过箱型
可以以此作为参考


65
00:04:03,010 --> 00:04:05,245
但是要打破模式匹配
就会很难看 很可怕


66
00:04:07,014 --> 00:04:08,415
在Swift 2中有更好的方法


67
00:04:08,615 --> 00:04:10,784
在beta 1中还不太好


68
00:04:10,984 --> 00:04:13,120
不过很快
你就可以间接标识自己的情况


69
00:04:13,687 --> 00:04:16,656
可以自然地进行表达模式匹配
效果也很棒


70
00:04:18,291 --> 00:04:20,127
我们来继续介绍范围


71
00:04:24,932 --> 00:04:26,967
有些时候你想重复使用某个名称


72
00:04:27,167 --> 00:04:29,770
也许是想确定某个之前发布的资源


73
00:04:30,804 --> 00:04:34,808
我们引入了可以介绍显性范围的
新Do语句


74
00:04:35,542 --> 00:04:38,879
在本例中 我们只想
时不时和网络挑衅打交道


75
00:04:38,946 --> 00:04:41,381
但是我们需要紧紧地约束它们


76
00:04:42,349 --> 00:04:46,153
在讲座稍后 我们介绍错误处理部分时
Do语句就会非常重要


77
00:04:46,753 --> 00:04:50,023
但是把Do作为关键字
会导致一些潜在歧义


78
00:04:50,591 --> 00:04:53,961
这种歧义不是针对编译器
而是在我们读码时会有歧义


79
00:04:54,895 --> 00:04:57,231
你不会常常看太长的语句底部


80
00:04:57,297 --> 00:04:58,599
我们还有Do While循环


81
00:04:59,867 --> 00:05:05,038
通过语句的字符集了解它在做什么


82
00:05:06,540 --> 00:05:08,041
我们需要让它变得非常简单


83
00:05:08,408 --> 00:05:11,578
通过看语句的字符集关键字就一目了然


84
00:05:11,912 --> 00:05:15,649
所以我们把Do While
循环更名为Repeat


85
00:05:16,049 --> 00:05:18,852
一看到顶部
你就可以知道这是个循环


86
00:05:18,986 --> 00:05:19,953
这样就非常简单


87
00:05:24,491 --> 00:05:25,826
我们再看看选项集合


88
00:05:26,460 --> 00:05:31,198
选项集合是轻量级超级高效的方法
来表现一组布林值


89
00:05:31,765 --> 00:05:34,234
如果你们以前见过
并用过不同的Cocoa API


90
00:05:34,368 --> 00:05:36,870
并且用过See Like句法
和Or句法


91
00:05:37,804 --> 00:05:39,773
这类基本句法实际上非常不错


92
00:05:41,141 --> 00:05:45,512
问题在于当你使用其他句法时
就不会是这样


93
00:05:45,579 --> 00:05:48,081
你用零值生成选项集合...


94
00:05:48,582 --> 00:05:49,449
这不太合理


95
00:05:49,516 --> 00:05:53,620
因为选项集合和可选类型是
完全不同的概念结果却混为一谈


96
00:05:54,188 --> 00:05:56,089
你从按位操作将之提取出来


97
00:05:56,156 --> 00:05:59,826
这样非常麻烦而且非常容易出错
你也会很容易犯错


98
00:06:00,427 --> 00:06:02,796
有了Swift 2
我们会采用选项集合


99
00:06:02,863 --> 00:06:04,198
这样会更糟糕


100
00:06:04,264 --> 00:06:06,800
因为Swift1.2 是 
一类集合类型


101
00:06:07,234 --> 00:06:12,005
上述组合使得选项集合
似乎退回到C语言


102
00:06:12,573 --> 00:06:13,407
而事实就是如此


103
00:06:15,742 --> 00:06:18,345
但是Swift 2解决了这个问题
它将选项集合变得像集合


104
00:06:18,879 --> 00:06:21,682
这就是说选项集合和集合
现在都是带方括号


105
00:06:22,216 --> 00:06:25,052
也就是说你会获得
带方括号空集的空集


106
00:06:25,485 --> 00:06:29,089
你也会得到整套标准集合API
来与选项集合相配合


107
00:06:29,223 --> 00:06:30,757
这样做非常容易而且效果极佳


108
00:06:36,563 --> 00:06:37,431
还有一个好处是


109
00:06:37,497 --> 00:06:40,234
你可以用更简单的方式
定义自己的选项集合


110
00:06:40,968 --> 00:06:43,270
你现在只需要定义自己的集合类型


111
00:06:43,470 --> 00:06:47,107
或结构类型
集合的结构类型


112
00:06:48,075 --> 00:06:50,744
以符合新的选项集合类型协议


113
00:06:51,478 --> 00:06:53,881
找到存放位数的存储


114
00:06:53,947 --> 00:06:57,217
定义需要放入选项集合中的元素


115
00:06:58,318 --> 00:07:01,955
只需要简单进行定义
你就可以获得我们谈到的所有句法


116
00:07:02,589 --> 00:07:05,959
这就是相当棒的一点
它不需要进行任何编译器匹配


117
00:07:06,460 --> 00:07:08,929
这可以通过一个新功能


118
00:07:08,996 --> 00:07:11,398
名为Default Implementations


119
00:07:12,065 --> 00:07:14,368
和选项集合类型提供的
Protocols自动实现


120
00:07:14,434 --> 00:07:17,304
我们实在没时间在这里详细介绍


121
00:07:17,571 --> 00:07:19,540
Default Implementations
和Protocols


122
00:07:19,606 --> 00:07:22,142
但是我们有一场相当棒的讲座
详细介绍协议方面的内容


123
00:07:23,710 --> 00:07:25,579
我们来谈谈函数和方法


124
00:07:27,414 --> 00:07:31,451
Swift将函数和方法统到
单一的函数声明中


125
00:07:31,818 --> 00:07:37,291
将两个完全不同的概念放在类型系统中
构成一个漂亮的函数核


126
00:07:37,457 --> 00:07:38,859
这样做非常棒


127
00:07:39,560 --> 00:07:42,062
这个漂亮的函数核
就是Swift的关键部分


128
00:07:42,696 --> 00:07:45,032
在你想要调用这些内容时
就会立刻分解


129
00:07:45,933 --> 00:07:47,734
因为它们用的是不同的参数标签


130
00:07:48,435 --> 00:07:50,938
这对很多人来讲都相当麻烦


131
00:07:52,406 --> 00:07:53,841
如果我们来看这是从何而来


132
00:07:53,974 --> 00:07:56,610
可以看出Swift是效仿
Objective-C的先例


133
00:07:57,244 --> 00:07:58,812
C语言并无参数标签


134
00:07:59,079 --> 00:08:01,648
参数标签对Objective-C
的方法而言非常重要


135
00:08:01,915 --> 00:08:02,883
Swift也是如此


136
00:08:04,017 --> 00:08:06,119
在Swift 2中
我们不仅解决了个问题


137
00:08:06,954 --> 00:08:10,390
现在函数和方法是同样的声明句法


138
00:08:10,958 --> 00:08:12,326
它们按照同样的方式发生作用


139
00:08:13,827 --> 00:08:17,297
当你调用全局函数时
你在默认状态下提供参数标签


140
00:08:19,433 --> 00:08:20,834
所有内容都是统一的


141
00:08:25,806 --> 00:08:29,176
因此需要了解的关键内容是
这会影响到纯粹的Swift代码


142
00:08:29,243 --> 00:08:32,145
如果声明Swift中的全局函数
你就会在默认状态获得这个行为


143
00:08:33,246 --> 00:08:37,083
从C语言引入的函数会继续
按照它们一贯的方法行为


144
00:08:37,150 --> 00:08:41,020
因为在C语言函数中的参数名称
不是API的组成部分


145
00:08:41,087 --> 00:08:42,256
也不会被当做是API


146
00:08:42,990 --> 00:08:46,860
但是我们希望Swift代码可以继续
将函数标签包括在参数中


147
00:08:47,794 --> 00:08:51,732
如果要想要深入了解
这里还有更多内容


148
00:08:52,666 --> 00:08:55,202
Swift函数使用参数


149
00:08:55,536 --> 00:08:58,972
参数为每个值有不同名称


150
00:08:59,573 --> 00:09:01,808
当你用句法声明某项内容时


151
00:09:02,075 --> 00:09:03,644
你会获得默认行为


152
00:09:04,678 --> 00:09:09,216
参数获得的两个名称
一个是调用者看到的外部名称


153
00:09:09,483 --> 00:09:11,618
一个是执行方看到的内部名称


154
00:09:12,186 --> 00:09:17,724
在默认状态下第一个的参数并未
向其外部客户端显示标签名称


155
00:09:17,925 --> 00:09:20,327
你可能会在
执行方法时用到


156
00:09:21,495 --> 00:09:26,333
同样 第二个和之后的参数
都是默认为内外相同


157
00:09:26,400 --> 00:09:30,504
这就是为何你会看到
有该参数的参数标签


158
00:09:31,238 --> 00:09:35,042
这种模型最棒的一点是
当你理解这点就可以对之进行自定义


159
00:09:35,375 --> 00:09:39,179
例如 在本例中可以将标签


160
00:09:39,246 --> 00:09:41,415
放在第一个参数上
这样你会知道它是什么


161
00:09:41,882 --> 00:09:44,451
只要重复参数名称
即可实现


162
00:09:44,785 --> 00:09:45,719
这非常简单


163
00:09:46,320 --> 00:09:47,821
同样 如果想要删除某些内容


164
00:09:47,888 --> 00:09:52,292
你可以用下划线显性设置该名称
表明要删除参数标签


165
00:09:52,926 --> 00:09:56,763
这么做我们就犯下了
最严重的命名错误


166
00:09:56,830 --> 00:09:58,232
让布林值没有标签


167
00:09:58,966 --> 00:09:59,800ddle
好的!


168
00:10:02,336 --> 00:10:04,071
更好的一点是


169
00:10:04,137 --> 00:10:07,808
发生的整个改变会令标签在
系统中更为显著


170
00:10:07,875 --> 00:10:10,344
让API如此便于使用


171
00:10:10,944 --> 00:10:13,914
而且这会让我们将复杂简化很多


172
00:10:14,381 --> 00:10:16,116
现在函数和方法都在同样发挥作用


173
00:10:16,583 --> 00:10:18,919
我们还可以取消默认函数的特殊规定


174
00:10:19,319 --> 00:10:20,654
这里还有非常奇怪的句法


175
00:10:20,721 --> 00:10:23,290
谁也不记得它是什么
现在也不见了


176
00:10:23,423 --> 00:10:24,258
这样就会好得多


177
00:10:25,792 --> 00:10:27,094
我们接着会谈到编译器


178
00:10:27,561 --> 00:10:30,230
谈到警告和错误消息
是编译器而成的


179
00:10:31,131 --> 00:10:33,734
这里的代码是合理代码


180
00:10:33,800 --> 00:10:35,235
也许你之前写过类似内容


181
00:10:35,302 --> 00:10:36,503
我要更新一点内容


182
00:10:37,771 --> 00:10:41,008
如果你使用Swift 1编译器
它会生成这个样子


183
00:10:42,476 --> 00:10:46,213
我不了解大家会怎样
这并没有什么用


184
00:10:47,247 --> 00:10:48,949
Swift 1.2则要好很多


185
00:10:49,116 --> 00:10:53,053
Swift 1.2会生成错误消息
并告知我出现了问题


186
00:10:53,153 --> 00:10:55,756
现在我发现无法对之赋值


187
00:10:56,156 --> 00:10:57,624
当然这还不够好


188
00:10:57,791 --> 00:11:01,128
我们继续研究编译器
生成的错误消息和警告


189
00:11:01,495 --> 00:11:05,566
在Swift 2中 它表示
“你不能给x赋值因Self不可变”


190
00:11:06,099 --> 00:11:10,270
Xcode会告知你可以把方法
标为可变 这样就解决了问题


191
00:11:11,171 --> 00:11:13,273
这是个很棒的方法
我觉得很多人...


192
00:11:13,340 --> 00:11:16,343
它会帮助很多人
更好地了解Swift中的可变性模型


193
00:11:16,643 --> 00:11:17,978
并让代码更为出色


194
00:11:24,818 --> 00:11:27,287
当然这才只是一个实例
这样的例子还有很多


195
00:11:27,688 --> 00:11:31,992
我们还添加了警告的实例


196
00:11:32,059 --> 00:11:34,728
如果你的变量声明为常数


197
00:11:34,795 --> 00:11:37,464
我们就会生成警告
要使用Let来替代Are


198
00:11:37,931 --> 00:11:42,936
Swift移植工具会在许多情况下
用Let替代Are自动移动许多代码


199
00:11:43,804 --> 00:11:47,708
我们都会警告如果你声明一个值
无论是Let还是Are都不要使用


200
00:11:48,275 --> 00:11:51,044
如果你使用函数方法


201
00:11:51,912 --> 00:11:52,913
然后忽略结果


202
00:11:52,980 --> 00:11:56,283
因为你可能是想使用变异方法


203
00:11:56,450 --> 00:11:57,851
我们会对所有这些生成警告


204
00:11:58,051 --> 00:11:59,653
还有简单的实例


205
00:12:00,754 --> 00:12:01,955
我们来谈谈SDK


206
00:12:05,425 --> 00:12:08,829
这是Swift的核心内容
它与Cocoa配合很好


207
00:12:09,062 --> 00:12:10,931
有了Objective-C API


208
00:12:11,265 --> 00:12:16,203
Swift编译器不清楚指针是否应为
零以及集合的元素类型是什么


209
00:12:16,837 --> 00:12:19,139
我们引入了若干
Objective-C的新功能


210
00:12:19,406 --> 00:12:21,275
包括表达可空性的能力


211
00:12:21,642 --> 00:12:24,745
Objective-C的
集合元素类型


212
00:12:25,412 --> 00:12:27,948
有整系列的其他功能


213
00:12:28,115 --> 00:12:31,118
为Swift的Objective-C
代码提供优质体验


214
00:12:31,952 --> 00:12:33,387
最棒的一点是


215
00:12:33,487 --> 00:12:37,057
Apple的框架工程师
完成一项杰出的工作


216
00:12:37,124 --> 00:12:39,593
他们采用了所有这些
现代Objective-C功能


217
00:12:39,893 --> 00:12:44,398
在Swift的各种平台上
Cocoa SDK整体表现都很出色


218
00:12:44,464 --> 00:12:45,532
而你无需做任何工作


219
00:12:46,567 --> 00:12:49,169
不过
如果你有Objective-C代码


220
00:12:49,236 --> 00:12:51,872
也许在你项目中混合并
匹配了Objective-C代码


221
00:12:52,206 --> 00:12:55,776
也许你想在Swift中拥有更美观的
Objective-C框架


222
00:12:56,210 --> 00:12:59,580
今天晚些时候
可以看看部分讲座内容了解更多功能


223
00:12:59,646 --> 00:13:02,216
这样你就可以提供
出色的Swift体验


224
00:13:02,983 --> 00:13:04,651
你可能需要看看视频


225
00:13:06,720 --> 00:13:07,788
我们来谈谈单元测试


226
00:13:08,355 --> 00:13:11,558
在整个工具组
测试都是非常重要的


227
00:13:11,625 --> 00:13:13,427
Swift中的测试功能非常不错


228
00:13:14,561 --> 00:13:16,096
不过访问控制则不然


229
00:13:16,530 --> 00:13:22,503
问题是Swift要求你将符号
Public标为对单元测试束可见


230
00:13:22,736 --> 00:13:26,373
如果可以测试
就不应该公开大量内容


231
00:13:27,007 --> 00:13:29,576
Swift 2和Xcode 7
解决了这一问题


232
00:13:30,277 --> 00:13:32,479
现在你的代码会自动搭建成特殊模式


233
00:13:32,779 --> 00:13:34,147
表示这是测试中


234
00:13:34,381 --> 00:13:37,651
它们默认可以访问你的公开和内部符号


235
00:13:38,051 --> 00:13:40,220
你必须要用到新的app...


236
00:13:45,125 --> 00:13:49,196
更棒的一点是
这不但非常容易 而且...


237
00:13:49,429 --> 00:13:51,465
你仍可以为发布构建
获得正确的行为


238
00:13:51,532 --> 00:13:55,102
这样可以获得很好的性能
以及访问控制的保护收益


239
00:13:55,602 --> 00:13:57,171
我们有一系列关于测试的讲座


240
00:13:57,437 --> 00:14:01,308
我强力推荐《Xcode的UI测试》


241
00:14:02,075 --> 00:14:03,243
我们来谈谈富批注


242
00:14:04,044 --> 00:14:06,413
游乐场非常棒


243
00:14:06,480 --> 00:14:09,249
Xcode可能帮你在编辑器中
使用批注句法 富批注句法


244
00:14:09,416 --> 00:14:13,587
搭建漂亮的Swift游乐场


245
00:14:13,954 --> 00:14:16,056
句法是Markdown中的一个变量


246
00:14:16,390 --> 00:14:19,927
非常不错 很出名 很流行
是很好的句法


247
00:14:20,260 --> 00:14:22,095
我们也可以使用文档评论


248
00:14:22,496 --> 00:14:28,202
这是说你可以
构建漂亮的富文档评论


249
00:14:28,435 --> 00:14:30,103
并在API上为客户显示


250
00:14:30,170 --> 00:14:32,539
如果你在生成库
你可以做很棒的事情


251
00:14:34,041 --> 00:14:35,375
最后 Xcode的移植工具


252
00:14:36,043 --> 00:14:38,946
在Xcode 7中
一打开Swift 1项目


253
00:14:39,012 --> 00:14:40,447
它就会弹出信息


254
00:14:40,881 --> 00:14:42,482
“我可以为你升级到Swift 2”


255
00:14:42,983 --> 00:14:44,284
这大概需要两步骤


256
00:14:44,351 --> 00:14:46,720
你可以选择自己的目标
然后它会提供一个dif


257
00:14:47,221 --> 00:14:49,590
Swift 2移植工具
实际上非常不错


258
00:14:49,823 --> 00:14:52,159
这其中包括从Swift 1


259
00:14:52,226 --> 00:14:55,529
转移到Swift 2的
大部分问题和情况


260
00:14:55,829 --> 00:15:00,234
包括错误处理模型 
从内容到方法的转移和SDK的改变


261
00:15:00,434 --> 00:15:05,639
及诸多的选项集合改变
都搭建在移植工具之中


262
00:15:05,873 --> 00:15:07,007
效果相当不错


263
00:15:08,041 --> 00:15:12,613
Swift 2中还有相当多的内容 
现在我们没时间一一介绍


264
00:15:13,413 --> 00:15:14,648
如果你们对更多详情感兴趣


265
00:15:14,715 --> 00:15:17,284
建议看看Swift编程语言书籍


266
00:15:17,351 --> 00:15:18,352
已经有新版本推出


267
00:15:19,186 --> 00:15:22,689
Xcode 7版本发布说明中
也详细介绍了这方面的改变


268
00:15:23,690 --> 00:15:25,626
我们来继续讲模式匹配


269
00:15:27,628 --> 00:15:31,832
大家最初遇到模式匹配
也许是在if-let语句中


270
00:15:32,566 --> 00:15:35,936
最好使用可选类型


271
00:15:37,304 --> 00:15:42,109
有条件地打开
然后将结果捆绑到安全的名称上


272
00:15:42,609 --> 00:15:43,577
这非常棒


273
00:15:44,111 --> 00:15:46,346
当然 好东西远不止这些


274
00:15:46,413 --> 00:15:49,650
我们都曾经见过“金字塔厄运”


275
00:15:50,150 --> 00:15:52,853
是指太多if-let语句堆在一起


276
00:15:52,920 --> 00:15:55,022
突然代码已经有15层高


277
00:15:55,088 --> 00:15:56,156
你完全搞不懂它


278
00:15:56,723 --> 00:16:01,762
Swift 1.2通过在if语句中
引入复合条件解决了这个问题


279
00:16:02,062 --> 00:16:03,397
这会就自然多了


280
00:16:03,463 --> 00:16:04,965
你可以在内联


281
00:16:05,399 --> 00:16:09,002
查看多个可选类型和布林条件 
效果好多了


282
00:16:09,536 --> 00:16:11,505
这并没有解决提早退出的问题


283
00:16:12,272 --> 00:16:18,178
我给大家看几个也许是
最可怕的JSON处理代码


284
00:16:18,712 --> 00:16:20,280
随着时间的推移 情况会改善


285
00:16:20,380 --> 00:16:21,582
我们来看这个


286
00:16:22,115 --> 00:16:25,219
我从无类型JSON字典中取出各种域


287
00:16:25,352 --> 00:16:28,388
我取出名称转化为字符串生成可选类型


288
00:16:28,555 --> 00:16:29,723
如果不匹配 我就要想办法


289
00:16:30,290 --> 00:16:32,960
同样 取出年信息
转化为In


290
00:16:33,026 --> 00:16:34,161
如果不匹配 需要救助


291
00:16:34,695 --> 00:16:37,664
如果取出很多值
更常见是最好能采取救助方式


292
00:16:37,731 --> 00:16:42,236
而不是深埋在代码中
这种模式更常见


293
00:16:43,036 --> 00:16:47,741
这种方式的问题在于
完成时需要强迫打开可选值


294
00:16:49,076 --> 00:16:50,177
这里我只使用一次


295
00:16:50,244 --> 00:16:53,013
但是如果你有一组代码都使用它们
你就需要到处都要强迫打开


296
00:16:53,747 --> 00:16:55,382
你需要做些事情来解决


297
00:16:55,449 --> 00:16:57,618
打开可选类型是不错方法


298
00:16:57,684 --> 00:17:02,155
它将强迫打开放入不安全的Mecca


299
00:17:03,557 --> 00:17:08,762
可能这样做也不大对
也非常难看


300
00:17:09,229 --> 00:17:10,931
我们引入了新的Guard语句


301
00:17:11,098 --> 00:17:13,400
看待Guard的方法就是
它要做检查


302
00:17:13,599 --> 00:17:16,203
若是检查不匹配
就会做救助


303
00:17:16,770 --> 00:17:18,739
你可以用过很多Guard语句


304
00:17:18,872 --> 00:17:20,840
现在我们来做可选检查


305
00:17:20,907 --> 00:17:22,643
我们将一个值绑在名称上


306
00:17:23,109 --> 00:17:25,012
它可以发挥作用的方式是


307
00:17:25,078 --> 00:17:28,949
是确保Else退出当前的范围


308
00:17:29,383 --> 00:17:31,552
可以用两种方式的一种来完成


309
00:17:31,618 --> 00:17:36,523
返回 抛出 跳出
有很多方式可以退出范围


310
00:17:37,758 --> 00:17:38,592
很好


311
00:17:38,659 --> 00:17:41,261
你还可以调用No Return函数


312
00:17:41,328 --> 00:17:43,197
例如Precondition Fail
或Abort


313
00:17:43,263 --> 00:17:44,731
这些都是停止的不错方法


314
00:17:45,699 --> 00:17:49,336
这还可以确保编译器了解安全性和


315
00:17:49,403 --> 00:17:54,074
和贯穿代码之后可以看到的确定性


316
00:17:54,741 --> 00:17:57,444
如果把这个用在我们的例子中
肯定会边的更好


317
00:17:57,578 --> 00:17:58,979
因为我们可以用Guard校对


318
00:17:59,046 --> 00:18:03,584
如我们所愿
进行安全 简洁的检查


319
00:18:04,785 --> 00:18:05,953
还有一点很棒的是


320
00:18:06,153 --> 00:18:11,725
这些都构建在If语句的富复合条件中


321
00:18:12,226 --> 00:18:13,493
现在可以将它们合并在一起


322
00:18:13,560 --> 00:18:16,330
根据Guard语句 
检查多个布林值和可选类型


323
00:18:16,396 --> 00:18:19,566
和我们稍后介绍的其他情况


324
00:18:19,633 --> 00:18:20,467
这相当棒


325
00:18:27,608 --> 00:18:32,813
我们再看看模式匹配
更强大更有趣的形式 开关语句


326
00:18:33,680 --> 00:18:37,985
我觉得开关语句也许是
许多人喜爱的Swift功能


327
00:18:38,318 --> 00:18:41,288
因为在开关语句中可以
实现许多模式匹配功能


328
00:18:41,622 --> 00:18:43,557
你可以检查可选类型 


329
00:18:43,790 --> 00:18:46,960
可以做类分层结构检查
可以检查范围


330
00:18:47,427 --> 00:18:49,696
在开关语句中可以实现许多功能


331
00:18:50,697 --> 00:18:53,600
当你要写许多条件语句时
这会很棒


332
00:18:53,700 --> 00:18:55,569
但是当你只想检查一个条件时 


333
00:18:55,636 --> 00:18:57,204
在语句构成方面些笨重


334
00:18:57,738 --> 00:19:01,041
它们只能是表达详尽
你必须承认这很麻烦


335
00:19:01,808 --> 00:19:04,244
我们所做的是
将模式匹配和开关 条件结合


336
00:19:04,645 --> 00:19:08,348
将其带到其他控制语句中


337
00:19:08,782 --> 00:19:11,451
这个实例可以写成新的If条件 


338
00:19:11,785 --> 00:19:15,422
检查之后 可以做模式匹配
将可变名称绑到语句中


339
00:19:21,228 --> 00:19:25,265
我们又向前进了一步
Swift还有一个出色的语句 循环


340
00:19:26,066 --> 00:19:28,836
在...循环中
需要完成一些过滤的情况是很常见的


341
00:19:29,369 --> 00:19:32,739
有些语言甚至需要
引入全新的语言结构


342
00:19:32,806 --> 00:19:35,943
例如列出对此类模式的模型理解


343
00:19:36,577 --> 00:19:38,178
通过Swift 2我们完成两项任务


344
00:19:38,245 --> 00:19:43,183
我们在...语句中
添加了简单的布林值内联过滤器


345
00:19:43,917 --> 00:19:47,621
但是大家也可以在循环中完成


346
00:19:48,722 --> 00:19:50,390
全面的模式匹配为你提供强大的条件


347
00:19:56,163 --> 00:19:59,399
关于模式匹配的内容
我只能匆匆介绍这些


348
00:19:59,700 --> 00:20:02,703
我们介绍了新的Guard语句
非常适合提前退出


349
00:20:03,003 --> 00:20:06,507
讲了将模式匹配放到语言各处


350
00:20:06,874 --> 00:20:08,742
我们并未谈及其他的改进内容


351
00:20:08,809 --> 00:20:10,611
在你开始使用Swift时
就会发现它们


352
00:20:11,178 --> 00:20:12,946
谢谢
接下来有请约翰上台


353
00:20:13,013 --> 00:20:15,082
他会告知大家
可用性检测方面的内容


354
00:20:21,355 --> 00:20:22,189
谢谢 克里斯


355
00:20:23,557 --> 00:20:25,392
我们经常推出新功能


356
00:20:25,626 --> 00:20:28,262
大家可能听说过
Force Touch


357
00:20:30,030 --> 00:20:34,735
Force Touch是硬件功能
当然它还有一系列API


358
00:20:34,935 --> 00:20:36,970
正如NSButton中的这个


359
00:20:37,471 --> 00:20:42,242
可以让我来改变按钮
对拖拽的反应方式


360
00:20:43,343 --> 00:20:46,280
如果我想在自己的app中
采用这个功能


361
00:20:46,880 --> 00:20:48,081
将非常简单 对吧？


362
00:20:48,148 --> 00:20:50,517
我得编写一些新的事件处理代码


363
00:20:50,918 --> 00:20:52,452
然后我需要用到按钮


364
00:20:52,519 --> 00:20:55,422
设置热加载属性


365
00:20:56,223 --> 00:21:00,394
问题是这在我的开发
设备上效果可能会不错


366
00:21:00,460 --> 00:21:03,130
但是当我把它移交到测试硬件时


367
00:21:04,131 --> 00:21:06,266
几乎肯定就会出现崩溃


368
00:21:07,000 --> 00:21:10,370
这是因为这是个新的API


369
00:21:10,437 --> 00:21:12,172
是在X v10.3中引入


370
00:21:12,706 --> 00:21:16,944
在这种情况下 和大多数人一样


371
00:21:18,378 --> 00:21:24,685
你仍然会需要支持较早版本的OS


372
00:21:25,552 --> 00:21:28,388
我怎么解决这个问题呢?


373
00:21:28,455 --> 00:21:34,661
我以前常用的解决办法是
我会让方法的错误信息不存在


374
00:21:34,728 --> 00:21:36,897
我来看看这种方法是否存在


375
00:21:37,831 --> 00:21:41,134
一方面人们开发了
许多不同的惯用语法来实现这一点


376
00:21:41,201 --> 00:21:44,972
这是个常见惯用语
使用Responds到Selector


377
00:21:46,740 --> 00:21:50,577
问题是这是个容易出错的模式


378
00:21:51,311 --> 00:21:57,584
例如 我必须指出选择器是什么


379
00:21:57,684 --> 00:22:00,988
从部分Swift语言功能做映射


380
00:22:01,054 --> 00:22:04,157
到部分Objective-C选择器


381
00:22:04,424 --> 00:22:06,760
这些细节没有必要全部了解


382
00:22:07,461 --> 00:22:11,265
要知道编译器也没有帮我检查


383
00:22:11,331 --> 00:22:15,536
因为我本来也不愿检查
编译器所提供的内容


384
00:22:16,436 --> 00:22:19,673
例如 在本例中我实际上忘记加冒号


385
00:22:19,740 --> 00:22:22,709
意思是说检查永远不会为真


386
00:22:23,410 --> 00:22:25,746
有了Swift 2
我们有更好的解决方案


387
00:22:26,680 --> 00:22:29,650
在默认状态下要确保


388
00:22:29,716 --> 00:22:35,022
不要使用部署目标上
最小且不可用的API


389
00:22:35,756 --> 00:22:37,257
如果我做这样的事情...


390
00:22:42,863 --> 00:22:45,666
如果我做这样的事情
我会经常进行诊断


391
00:22:46,099 --> 00:22:50,938
这样我可以有
某种安全核心假设


392
00:22:51,004 --> 00:22:54,508
只要我的代码...
只要我的项目完全编译


393
00:22:54,775 --> 00:22:58,345
它至少不会包含这种小的部署问题


394
00:22:58,912 --> 00:23:02,816
当然这还不全是兼容性的问题


395
00:23:02,916 --> 00:23:08,155
但这可以帮你使用新的API


396
00:23:09,389 --> 00:23:13,627
我确实想要用这个
怎么办呢?


397
00:23:14,261 --> 00:23:17,731
我们添加了新的
#available条件


398
00:23:18,532 --> 00:23:24,304
在#available中
你可以列出想要测试的OS版本


399
00:23:24,671 --> 00:23:27,407
最后你会用这个星号确定


400
00:23:27,541 --> 00:23:32,613
是否在代码里没有的新OS


401
00:23:32,713 --> 00:23:35,516
你至少要在这里诊断可用性


402
00:23:36,850 --> 00:23:38,519
我已经用了If语句 


403
00:23:38,585 --> 00:23:42,055
但是我可以使用克里斯刚
展示给大家的Guard语句


404
00:23:42,256 --> 00:23:45,592
这是在所有的地方
都完全相同的条件逻辑


405
00:23:45,726 --> 00:23:46,560
就是这样


406
00:23:47,728 --> 00:23:49,630
这是可用性检测


407
00:23:49,696 --> 00:23:51,632
我们认为这是


408
00:23:51,698 --> 00:23:58,172
让你在项目中 自动安全使用新版OS
 新功能的不错方法


409
00:23:59,072 --> 00:24:02,943
稍后 我们会介绍更多详情
我非常建议大家能来听


410
00:24:05,712 --> 00:24:08,215
接下来 我想谈谈协议扩展


411
00:24:09,149 --> 00:24:11,852
扩展是Swift一大特色功能


412
00:24:12,486 --> 00:24:15,189
我可以使用任意类型 如Array


413
00:24:15,489 --> 00:24:17,391
并在其中加上我自己的方法


414
00:24:18,125 --> 00:24:23,463
这一点很重要
但并不明显


415
00:24:23,530 --> 00:24:26,033
方法是核心内容


416
00:24:26,099 --> 00:24:31,338
这就是类型原生API表达的方式


417
00:24:31,605 --> 00:24:33,073
当我添加扩展时


418
00:24:33,140 --> 00:24:38,979
我实际添加了感觉像第一类型新功能


419
00:24:39,379 --> 00:24:45,853
正如该类型的设计人员已经
加上的API核心类型


420
00:24:46,486 --> 00:24:49,022
这会有很多优势


421
00:24:50,991 --> 00:24:54,461
这里我加上了Count If方法


422
00:24:54,528 --> 00:24:58,498
这就会针对间隔的数组


423
00:24:58,699 --> 00:25:02,002
和返回True的次数调用闭包


424
00:25:02,636 --> 00:25:08,008
在这种方法中并没有具体针对数组


425
00:25:08,275 --> 00:25:10,644
这应该适用于任意集合


426
00:25:12,379 --> 00:25:17,551
不过 在Swift 1
我无法用这方法来表达


427
00:25:18,118 --> 00:25:20,888
为将这个泛型加到任意集合中


428
00:25:21,221 --> 00:25:23,023
我必须要编写像这个样子的编码


429
00:25:24,491 --> 00:25:28,395
正如很多人所指出的那样
这并不绝对优化


430
00:25:28,896 --> 00:25:32,833
首先 这里有很多额外的句法


431
00:25:32,966 --> 00:25:36,904
在其中所有这些尖角括号中有些盲区 


432
00:25:36,970 --> 00:25:40,040
所有这些额外的外壳构成了这个泛型


433
00:25:41,275 --> 00:25:44,511
其二 这不再是一种方法


434
00:25:45,312 --> 00:25:47,247
因为首先它不再是方法


435
00:25:47,347 --> 00:25:50,884
它不再像使用该类型的自然部分


436
00:25:51,518 --> 00:25:54,121
第二 它很难被发现


437
00:25:54,555 --> 00:25:58,125
它不会出现在数组的任何功能列表中


438
00:25:58,492 --> 00:26:04,164
特别是它不会出现在功能列表
被完成提供的代码中


439
00:26:04,665 --> 00:26:10,704
这意味着你写出
这么漂亮的Count If语句 


440
00:26:11,238 --> 00:26:16,043
可是使用它的人都不知道它的存在
除非你指出来


441
00:26:19,179 --> 00:26:20,414
好
那我们先回来


442
00:26:20,747 --> 00:26:24,151
我们有这个扩展的数组
只要把方法加到数组中即可


443
00:26:24,484 --> 00:26:27,487
为什么我们不能扩展...
我不知道...


444
00:26:27,588 --> 00:26:29,656
执行集合类型的每项内容?


445
00:26:30,357 --> 00:26:33,427
在Swift 2中 
我很高兴地说你可以


446
00:26:34,561 --> 00:26:38,966
你可以扩展集合类型
而不是扩展数组


447
00:26:39,499 --> 00:26:40,334
当你这么做的时候


448
00:26:40,400 --> 00:26:46,240
你会自动把各处的方法
加到执行集合类型的每个类型中


449
00:26:46,573 --> 00:26:48,642
不仅是从标准库中或是任何内容中


450
00:26:48,809 --> 00:26:55,082
而是就在恰好
符合要求的你自己的类型中


451
00:26:56,283 --> 00:26:59,453
这不仅有利于编写自己的泛型代码


452
00:26:59,520 --> 00:27:06,360
而且我们发现这可以让我们修改
在Swift 1中不满意的许多内容


453
00:27:07,427 --> 00:27:12,432
在Swift 1中有很多内容
都必须是全局函数


454
00:27:12,733 --> 00:27:16,003
因为它们必须是泛型
或者因为我们写成了泛型


455
00:27:16,737 --> 00:27:21,842
更糟糕的是 为了制作方法
我们选择了特殊条件的部分类型


456
00:27:21,909 --> 00:27:25,612
例如
数组有许多这样的映射和过滤方法


457
00:27:26,079 --> 00:27:29,049
其他类似Set的类型也许不会有


458
00:27:30,284 --> 00:27:34,721
在Swift 2会有这些功能


459
00:27:34,955 --> 00:27:39,860
这类过滤和映射功能
会通过扩展表达


460
00:27:39,960 --> 00:27:42,829
这意味着在每个内容上都可用


461
00:27:43,297 --> 00:27:44,998
还会更容易找到


462
00:27:45,332 --> 00:27:48,468
这意味着使用标准库会更为统一


463
00:27:49,036 --> 00:27:51,104
我们的确认为大家会喜欢它


464
00:27:58,378 --> 00:28:01,882
我还没有介绍到新功能的


465
00:28:01,949 --> 00:28:05,519
复杂度的三分之一


466
00:28:07,254 --> 00:28:11,258
明天我们有场专门介绍
这方面内容的精彩讲座


467
00:28:11,725 --> 00:28:14,127
我强烈建议大家能来听


468
00:28:14,194 --> 00:28:19,399
它是关于Swift支持的协议中
杰出的新设计模式


469
00:28:20,334 --> 00:28:22,369
讲座的其余部分是关于错误处理


470
00:28:23,270 --> 00:28:26,507
我觉得很少有人
会喜欢琢磨错误处理


471
00:28:27,374 --> 00:28:29,076
如果大家和我一样的话


472
00:28:30,344 --> 00:28:34,314
思想深处都埋藏着这样的想法


473
00:28:36,483 --> 00:28:38,719
但它真的很重要


474
00:28:38,785 --> 00:28:42,422
当我们在看可以用Swift做点什么


475
00:28:42,890 --> 00:28:46,760
使其真正成为更稳健
更具表现力的语言


476
00:28:47,127 --> 00:28:51,698
我们觉得这里最重要的问题就是
要进行错误处理


477
00:28:53,634 --> 00:29:00,440
当我们看其他语言Cocoa
中的解决方案


478
00:29:01,575 --> 00:29:03,177
我们对这些并不满意


479
00:29:03,777 --> 00:29:08,282
其中有太多问题
我们真的不很喜欢


480
00:29:09,316 --> 00:29:13,854
要知道其中有些是基于自动传播错误


481
00:29:13,921 --> 00:29:16,323
比如Objective-C语言中的
NSError


482
00:29:16,390 --> 00:29:19,793
它生成了许多重复性的容易出错的代码


483
00:29:19,860 --> 00:29:23,730
最后你不得不到处复制


484
00:29:23,997 --> 00:29:26,567
这意味着很容易出错


485
00:29:26,900 --> 00:29:31,305
更重要的是当你在自己周围传播错误时


486
00:29:31,772 --> 00:29:36,543
隐形的默认行为就是
你在忽略错误


487
00:29:37,077 --> 00:29:39,146
而这永远都不是正确的默认状态


488
00:29:39,413 --> 00:29:42,115
你应该至少考虑一下错误


489
00:29:43,283 --> 00:29:48,388
从另外一个角度而言
还有些语言可以显示传播错误


490
00:29:48,922 --> 00:29:50,324
例如异常处理


491
00:29:50,624 --> 00:29:52,893
但是我们也不喜欢这些的效果


492
00:29:52,960 --> 00:29:59,933
很显然在这方面
人们很容易不去考虑这些错误 


493
00:30:00,000 --> 00:30:02,069
最后你会掉到坑里


494
00:30:02,936 --> 00:30:07,274
自己也不知道到底程序里出现哪些问题


495
00:30:07,474 --> 00:30:12,045
你不明白控制怎样会
从一处流到另一处


496
00:30:12,513 --> 00:30:15,482
而且这样也不是
安全可靠的编程模型


497
00:30:19,586 --> 00:30:22,422
其实函数有三种以不同的方式出现问题


498
00:30:23,790 --> 00:30:28,128
一种是许多函数以非常简单


499
00:30:28,495 --> 00:30:32,499
而明显的方式出问题


500
00:30:32,999 --> 00:30:35,002
例如 除非你在运行编译器


501
00:30:35,102 --> 00:30:39,840
你可能并不在乎为什么要分析
字符串失败的整数


502
00:30:39,973 --> 00:30:45,279
这种事情报告给用户没什么意思
也不会有趣


503
00:30:45,546 --> 00:30:48,015
也许你想直接处理


504
00:30:48,782 --> 00:30:51,118
以前我们就是
这样看待这个问题的


505
00:30:51,251 --> 00:30:53,820
现在在Swift中
它得到了很好的解决


506
00:30:53,887 --> 00:30:55,689
有了可选的结果


507
00:30:56,256 --> 00:30:58,091
我们觉得不需要做任何事情


508
00:30:58,158 --> 00:31:00,060
我们对现在的办法很是满意


509
00:31:01,695 --> 00:31:06,800
从另外一个角度而言
在你的程序中有许多逻辑问题


510
00:31:07,134 --> 00:31:12,773
比如程序 人员的错误
索引越界


511
00:31:13,073 --> 00:31:16,977
人们使用NSException的
主要方式等等


512
00:31:18,812 --> 00:31:22,316
对于这些问题
它们实际上不应该是可恢复的


513
00:31:22,649 --> 00:31:24,952
当你可以恢复这类问题时


514
00:31:25,018 --> 00:31:30,357
就会导致程序整体不太稳定


515
00:31:30,657 --> 00:31:37,164
如果你随机从越界索引中恢复
你不清楚程序的状态究竟如何


516
00:31:37,564 --> 00:31:40,968
你可能甚至会在应用中
产生安全问题


517
00:31:43,370 --> 00:31:44,771
在中间的


518
00:31:45,672 --> 00:31:51,612
是API可能出现错误的
各种具体情况


519
00:31:52,346 --> 00:31:54,281
这些是我们真正想关注的内容


520
00:31:54,581 --> 00:31:58,285
如今在Cocoa的内容
可以使用NSError 


521
00:32:01,788 --> 00:32:03,490
我想给大家举个例子


522
00:32:03,957 --> 00:32:06,627
这是个预飞方式
我有某个操作需要预飞


523
00:32:06,693 --> 00:32:09,062
以确定它是否可以发挥作用


524
00:32:09,129 --> 00:32:11,965
我相信 很多人之前都写过这样的内容


525
00:32:12,599 --> 00:32:15,469
我想看看是否部分文档可以访问


526
00:32:15,536 --> 00:32:18,839
然后我会重设与操作相关的状态


527
00:32:20,674 --> 00:32:23,343
现在来看资源是否可访问


528
00:32:23,410 --> 00:32:25,712
这个操作会发生错误


529
00:32:25,979 --> 00:32:27,981
可以出现各种各样的错误


530
00:32:28,048 --> 00:32:29,583
它应该报告一些内容


531
00:32:29,650 --> 00:32:35,255
因为调用者希望知道为什么
有些内容不可访问


532
00:32:35,489 --> 00:32:38,091
也许会根据原因进行不同的处理


533
00:32:40,160 --> 00:32:43,764
如果我想使用NSError


534
00:32:44,598 --> 00:32:46,834
最后代码就会变成这样


535
00:32:47,201 --> 00:32:50,904
我会采用这个错误
在调用者之外进行传播


536
00:32:52,773 --> 00:32:56,143
就是这种情况


537
00:32:56,210 --> 00:32:58,312
有许多问题
我们当真不喜欢


538
00:32:59,346 --> 00:33:02,449
它在我的逻辑中增添了许多模板


539
00:33:02,983 --> 00:33:07,387
我原本是只有两行的紧凑函数


540
00:33:07,454 --> 00:33:09,690
结果变成这样...


541
00:33:09,756 --> 00:33:13,026
要知道其中有If语句
额外的嵌套 额外的参数


542
00:33:13,227 --> 00:33:14,494
这里有很多内容


543
00:33:14,761 --> 00:33:20,400
其目的就是为了表达有错误
我们正将它向调用者传播


544
00:33:22,169 --> 00:33:23,971
更糟糕的是


545
00:33:26,807 --> 00:33:28,008
这里还有个约定


546
00:33:28,609 --> 00:33:30,611
你需要了解这个约定


547
00:33:30,677 --> 00:33:33,413
根据这个约定
你必须手动执行才行


548
00:33:34,214 --> 00:33:36,350
编译器无法帮到你


549
00:33:36,416 --> 00:33:40,521
事实上我这里又犯了错


550
00:33:40,988 --> 00:33:44,825
在这个约定中
当你返回False时就会有错误发生


551
00:33:44,892 --> 00:33:48,028
我检查的时候
方法也不对


552
00:33:48,395 --> 00:33:51,298
我不知道
他们怎么会信得过我来用编译器


553
00:33:54,067 --> 00:33:57,137
我需要加上Not才能
得到我想要的行为


554
00:33:58,438 --> 00:34:01,175
好的啊 不好意思


555
00:34:02,442 --> 00:34:05,946
这就是不利因素
这也是我们喜欢它的原因


556
00:34:07,447 --> 00:34:10,984
首先 可以通过读取这个代码


557
00:34:11,385 --> 00:34:14,955
检查资源找到出现问题的部分


558
00:34:15,222 --> 00:34:17,491
在名称上就说得很清楚
这就是在说错误


559
00:34:17,791 --> 00:34:21,594
这是显性的错误处理内容
这是显性错误参数


560
00:34:22,728 --> 00:34:27,000
同样很明显地
预飞也是很容易出有问题的操作


561
00:34:27,201 --> 00:34:31,438
同样是显性错误参数 返回值 等等


562
00:34:32,672 --> 00:34:36,810
其三是没有显性控制流


563
00:34:37,710 --> 00:34:43,016
我可以看着它并了解其中
所有的内容


564
00:34:43,449 --> 00:34:48,054
我可以像人类那样分析
而不是像编译器那样静态分析代码


565
00:34:48,188 --> 00:34:50,023
作为人类
我可以看到这个代码


566
00:34:50,324 --> 00:34:51,958
分析它在做什么


567
00:34:52,458 --> 00:34:56,563
而不需要了解
每个我在调用的函数细节


568
00:34:59,733 --> 00:35:00,567ddle
好


569
00:34:59,733 --> 00:35:00,567
好


570
00:35:00,701 --> 00:35:01,935
我们返回这个例子中


571
00:35:02,069 --> 00:35:03,337
它之前是这样


572
00:35:04,304 --> 00:35:07,040
如果我用Swift编译
会发生什么情况？


573
00:35:09,610 --> 00:35:12,379
我会受到错误消息
因为我没有处理错误


574
00:35:13,881 --> 00:35:19,586
在Swift中有两个组件
可用来处理错误


575
00:35:21,221 --> 00:35:26,727
第一个是在你调用API出现问题时
必须要用Try关键字


576
00:35:27,528 --> 00:35:29,096
Try可以交流


577
00:35:29,363 --> 00:35:32,266
它主要就是便于他人读取代码


578
00:35:32,466 --> 00:35:36,270
它与你交流道，
“这里就是会出现问题的部分”


579
00:35:36,570 --> 00:35:40,040
这是说 当你返回时
当你以后做维护的时候


580
00:35:40,374 --> 00:35:42,776
我会直接...


581
00:35:43,644 --> 00:35:49,249
Reset State
但并不是每次调用都需要这个函数


582
00:35:49,650 --> 00:35:51,718
这里也许还有
很重要的内容需要我知道


583
00:35:52,085 --> 00:35:54,721
当我首先编写代码时


584
00:35:55,055 --> 00:35:56,590
这是我需要考虑的问题


585
00:35:56,857 --> 00:36:01,962
Reset State在我每次
退出函数时 都需要调用吗？


586
00:36:02,663 --> 00:36:04,398
对于预飞操作呢？
也许这还不够 


587
00:36:06,333 --> 00:36:10,037
我没有以任何方式处理造成错误


588
00:36:10,404 --> 00:36:15,108
这是因为在Swift中
在默认状态下 函数不可抛出


589
00:36:16,109 --> 00:36:19,513
这是我们的设计的核心内容 


590
00:36:20,981 --> 00:36:23,984
因为它意味着错误不可避免


591
00:36:24,551 --> 00:36:30,724
你不必考虑所有内容都会
像Java或C#语言那样抛出异常


592
00:36:30,824 --> 00:36:32,960
或是基本上
每种语言都在使用异常


593
00:36:35,128 --> 00:36:38,966
相反 它是相当具体的内容


594
00:36:39,032 --> 00:36:42,069
你知道自己需要是否要考虑将之抛出


595
00:36:42,269 --> 00:36:45,372
当你在代码中调用它们时
它会标明Try


596
00:36:45,672 --> 00:36:47,674
这一组合可以交流很多


597
00:36:49,276 --> 00:36:53,347
好的 假设我先要向调用者
传播一个错误


598
00:36:53,914 --> 00:36:57,050
为此 我只需告知编译器


599
00:36:57,117 --> 00:37:00,020
“可以让它把错误抛出”


600
00:37:00,721 --> 00:37:01,889
我就会抛出


601
00:37:03,457 --> 00:37:05,959
这可能不是我想要处理的方式


602
00:37:06,093 --> 00:37:07,828
这是个预飞方式


603
00:37:08,061 --> 00:37:11,765
我可能想容忍错误


604
00:37:11,832 --> 00:37:15,469
告知调用方预飞是否
成功


605
00:37:16,570 --> 00:37:18,005
为此 我只能处理它


606
00:37:18,238 --> 00:37:21,141
我就编写了Do Catch


607
00:37:22,509 --> 00:37:24,211
在Do中的任何代码


608
00:37:24,811 --> 00:37:30,217
其中转发的任何错误都会
像过滤所一样被捕获


609
00:37:31,251 --> 00:37:33,120
在捕获之后会是什么


610
00:37:34,721 --> 00:37:36,423
你在开关语句中
可以编写的任何内容


611
00:37:36,757 --> 00:37:42,829
Swift的模式匹配句法
最强大之处在于它可以捕获


612
00:37:44,431 --> 00:37:47,668
作为非常简单的常见句法改进


613
00:37:48,035 --> 00:37:54,241
这类捕获是捕获的短板


614
00:37:54,308 --> 00:37:57,477
并会带入这种特殊的错误变量


615
00:37:58,312 --> 00:38:00,647
我还可以写出更精致的内容


616
00:38:00,714 --> 00:38:04,818
例如 我可以处理某种错误


617
00:38:05,319 --> 00:38:08,288
作为特殊情况
也许在我的预飞中可以接受


618
00:38:10,657 --> 00:38:13,627
我不知道为什么不存在的文档可以接受


619
00:38:13,694 --> 00:38:17,731
也许我真想看看它是否存在


620
00:38:18,031 --> 00:38:21,602
出于某些许可原因它会不会真的使用


621
00:38:21,969 --> 00:38:23,003
如果我想


622
00:38:23,136 --> 00:38:30,077
我可以对错误代码和域名
直接做像这样的模式匹配


623
00:38:34,548 --> 00:38:38,619
另外 还有第三种“处理错误”的方法


624
00:38:39,286 --> 00:38:41,555
经常会有这种情况


625
00:38:42,022 --> 00:38:44,057
你前提设置了


626
00:38:44,291 --> 00:38:51,031
不应该抛出的具体调用


627
00:38:51,932 --> 00:38:55,469
例如 也许这个文件在我的app束


628
00:38:55,802 --> 00:39:02,743
我知道如果我无法
在自己的app束中读取文件


629
00:39:03,076 --> 00:39:04,711
那就真的有问题了


630
00:39:04,912 --> 00:39:07,347
也许没有办法可以恢复


631
00:39:08,382 --> 00:39:10,017
在这个常见模式中


632
00:39:10,083 --> 00:39:14,421
你可能会需要一个致命错误
因为错误抛出


633
00:39:16,023 --> 00:39:21,061
它有个非常精简的关联句法 Try!


634
00:39:21,795 --> 00:39:24,097
这会生成一个断言


635
00:39:24,598 --> 00:39:29,603
其中Try中的代码
不会真正抛出


636
00:39:29,937 --> 00:39:32,272
如果抛出
你的程序就会崩溃


637
00:39:32,339 --> 00:39:33,807
就像是其他断言错误一样


638
00:39:34,474 --> 00:39:36,810
这类问题可以很容易地调试解决


639
00:39:37,811 --> 00:39:39,580
你不会总是想要用这类内容


640
00:39:39,646 --> 00:39:41,582
但是当你需要它时
这非常方便


641
00:39:44,885 --> 00:39:45,886
回来看一下


642
00:39:47,721 --> 00:39:48,689
我捕获一个错误


643
00:39:49,389 --> 00:39:51,391
错误是什么类型？


644
00:39:52,492 --> 00:39:54,328
我们有个协议


645
00:39:54,461 --> 00:39:57,764
搭建成标准库ErrorType


646
00:39:59,132 --> 00:40:05,906
你可以抛出任何满足
ErrorType类型的值


647
00:40:06,540 --> 00:40:07,875
当你捕获到问题时


648
00:40:09,042 --> 00:40:13,847
也就是模式匹配的
ErrorType任意值


649
00:40:14,281 --> 00:40:15,949
我们觉得重要的是


650
00:40:17,050 --> 00:40:23,390
我们不会只跟踪是否要抛出的错误


651
00:40:23,790 --> 00:40:28,262
这和Java不同 
你最后会有一个详尽的清单


652
00:40:28,328 --> 00:40:29,997
列出可能会抛出的所有异常


653
00:40:30,130 --> 00:40:34,468
然后每次改变错误时
你可能都会面对这个复杂的传播问题


654
00:40:36,003 --> 00:40:39,473
跟踪错误是否抛出已经足够


655
00:40:39,706 --> 00:40:41,642
几乎一直是如此


656
00:40:42,009 --> 00:40:43,243
我们认为这是个很好的模型


657
00:40:45,212 --> 00:40:47,548
你可以让自己的类型
符合ErrorType


658
00:40:47,614 --> 00:40:52,319
这个过程要比Cocoa容易得多


659
00:40:54,188 --> 00:40:56,823
枚举是表达的不错方法


660
00:40:57,424 --> 00:41:00,494
它们可以很棒地表达一组相关问题


661
00:41:00,861 --> 00:41:01,929
正如它们...


662
00:41:03,497 --> 00:41:04,831
要知道的确如此


663
00:41:04,898 --> 00:41:09,303
因为在枚举中
可以关联每个条件的数据


664
00:41:09,870 --> 00:41:12,339
如果我想报告更丰富的错误消息


665
00:41:12,573 --> 00:41:15,175
其中包括也许关于...


666
00:41:15,242 --> 00:41:17,411
也许我在查看一些无效状态


667
00:41:17,477 --> 00:41:20,047
我希望记住无效状态是什么


668
00:41:20,414 --> 00:41:26,286
我可以将特例中的相关值
直接嵌入枚举中


669
00:41:28,522 --> 00:41:32,125
为了让枚举作为错误可用 
你只需要让它


670
00:41:32,860 --> 00:41:35,395
符合ErrorType即可


671
00:41:35,829 --> 00:41:39,499
编译器会自动处理合成的细节


672
00:41:40,000 --> 00:41:45,939
这要胜过处理生成
新NSError域名和相关内容


673
00:41:46,340 --> 00:41:48,375
我们认为当你需要的时候


674
00:41:48,642 --> 00:41:53,981
这将会对大家很有帮助
在自己的代码中表达抛出错误API


675
00:41:58,952 --> 00:42:01,388
我们回到克里斯之前介绍的例子中来


676
00:42:01,922 --> 00:42:03,223
这个JSON处理器


677
00:42:04,291 --> 00:42:07,761
我用字符串中的Either返回错误


678
00:42:09,162 --> 00:42:11,899
我们让它看起来
更像是Swift中的效果


679
00:42:12,933 --> 00:42:15,969
首先 不是用字符串


680
00:42:16,236 --> 00:42:21,341
我会用刚谈过的数据错误枚举


681
00:42:22,776 --> 00:42:23,911
我必须抛出


682
00:42:24,077 --> 00:42:26,747
为了抛出这些值 
我使用新的抛出语句


683
00:42:27,080 --> 00:42:28,115
效果不错


684
00:42:29,183 --> 00:42:32,152
另一方面是我需要修改返回类型


685
00:42:32,219 --> 00:42:34,121
我不再返回Either类型


686
00:42:34,488 --> 00:42:39,359
对于这类问题
每个调用者为检查错误


687
00:42:39,526 --> 00:42:42,129
不会对返回值认真进行微管理


688
00:42:43,497 --> 00:42:49,136
我做了修改
这样就会返回Person即抛出方式


689
00:42:49,469 --> 00:42:52,773
这样我就不必在这些小细节上操心


690
00:42:54,608 --> 00:42:58,011
我们再来一个新的例子
去除我们刚生成的方法


691
00:42:59,947 --> 00:43:05,352
我们来解析JSON语句
我们解析一个人


692
00:43:06,220 --> 00:43:12,426
我们用它来解析
涉及此人和一些内容的整个销售记录


693
00:43:17,664 --> 00:43:22,636
有时候碰巧你需要知道


694
00:43:22,703 --> 00:43:26,206
这是个人为的例子


695
00:43:26,273 --> 00:43:31,178
不好意思
有时候我需要观察这类进程


696
00:43:31,812 --> 00:43:33,614
我需要进行某种委托


697
00:43:34,648 --> 00:43:38,085
我需要让它知道
我开始读取销售数据


698
00:43:39,820 --> 00:43:42,456
我现在告知它
我开始读取


699
00:43:42,756 --> 00:43:45,993
显然 我在完成读取时
也应该告知它


700
00:43:47,828 --> 00:43:49,563
我可以把代码加在下面


701
00:43:49,630 --> 00:43:55,002
问题是我在错误处理方面做得不对


702
00:43:55,369 --> 00:43:57,404
很容易会...


703
00:43:57,471 --> 00:44:01,308
如果我的委托在销售结束时


704
00:44:01,642 --> 00:44:08,048
每次都调用Careful和
Variants设置


705
00:44:08,649 --> 00:44:13,453
如果我的委托有变化
它希望在两端调用时都保持


706
00:44:13,687 --> 00:44:16,290
如果我要搞糟进程
我把这事儿弄混了


707
00:44:16,690 --> 00:44:22,296
这类问题常常会出现
会使得错误处理看似很脆弱


708
00:44:23,697 --> 00:44:27,534
好的 当然
我可以这样解决问题


709
00:44:30,671 --> 00:44:34,741
只要在这些抛出站点 
Did End Reading Sale加入调用


710
00:44:35,542 --> 00:44:39,813
随后我仍没有处理
调用Process Person


711
00:44:39,880 --> 00:44:42,850
为了做点什么
我必须把它加入Do Catch


712
00:44:43,984 --> 00:44:47,487
这相当...相当繁琐


713
00:44:47,554 --> 00:44:48,856
但是它的确容易出错


714
00:44:48,922 --> 00:44:53,427
因为很容易
让我增添新的代码 新的处理方式


715
00:44:53,727 --> 00:44:57,898
如果我当真做什么的话
它就会立刻过期


716
00:44:58,532 --> 00:45:00,267
如果我忘记添加


717
00:45:00,334 --> 00:45:05,405
Did End Reading Sale
到这个特殊路径


718
00:45:06,373 --> 00:45:08,475
Swift 2有着更好的选项


719
00:45:09,042 --> 00:45:11,478
叫做Defer


720
00:45:13,947 --> 00:45:16,750
Defer语句生成一个动作


721
00:45:17,651 --> 00:45:19,019
当你执行时


722
00:45:20,454 --> 00:45:25,959
无论当前的范围
是什么动作都会 得以执行


723
00:45:27,094 --> 00:45:29,630
如果我返回
如果我出现问题


724
00:45:29,963 --> 00:45:32,799
如果我抛出错误
无论怎样


725
00:45:33,600 --> 00:45:36,270
我都知道它会得到执行


726
00:45:37,437 --> 00:45:40,073
这意味着当有人读取代码


727
00:45:40,474 --> 00:45:41,909
维护代码时 


728
00:45:42,209 --> 00:45:44,411
我会绝对有信心


729
00:45:44,912 --> 00:45:47,648
无论我怎样结束读取销售数据


730
00:45:48,115 --> 00:45:51,418
Did End Reading Sale都会执行


731
00:45:52,019 --> 00:45:54,621
这是需要掌握的重要内容


732
00:46:07,467 --> 00:46:09,436
我简要介绍一下执行情况


733
00:46:10,270 --> 00:46:15,175
如果有谁习惯进行异常处理
也许会知道


734
00:46:15,242 --> 00:46:19,079
在许多语言中 异常处理的执行方式


735
00:46:19,313 --> 00:46:23,450
会非常受到被抛出的错误的影响


736
00:46:24,218 --> 00:46:29,122
抛出错误的函数返回


737
00:46:29,389 --> 00:46:33,393
也许会比按照正常方式


738
00:46:33,627 --> 00:46:36,797
返回慢3个 甚至4个数量级


739
00:46:37,898 --> 00:46:42,703
出于语言设计的某些方面的需要


740
00:46:43,337 --> 00:46:46,507
我们并非是想在Swift中模仿什么


741
00:46:49,243 --> 00:46:50,611
大家在这里只需要知道


742
00:46:50,677 --> 00:46:54,214
Swift执行得更为平衡


743
00:46:55,315 --> 00:46:59,219
基本上更像是调用者的If语句


744
00:46:59,686 --> 00:47:04,791
这是说并非完全自由地
调用可抛出错误的内容 


745
00:47:05,225 --> 00:47:07,361
但是这意味着你不必担心


746
00:47:08,729 --> 00:47:13,233
我们的错误处理功能造价太高


747
00:47:14,501 --> 00:47:17,704
如果出于实际情况中


748
00:47:17,905 --> 00:47:21,775
对错误路径 效率的考虑
有些具体原因会令你无法使用它


749
00:47:25,112 --> 00:47:27,748
最后 我要说一下Swift


750
00:47:28,348 --> 00:47:32,619
Swift的错误处理设计
在Cocoa API中可以发挥作用


751
00:47:33,921 --> 00:47:38,959
我们自动识别你在Cocoa中
见到的最常用约定


752
00:47:39,526 --> 00:47:44,865
例如
具备NSError Out参数的方法


753
00:47:44,932 --> 00:47:45,933
并将返回Bool值


754
00:47:46,567 --> 00:47:48,435
自动变为抛出方法


755
00:47:48,502 --> 00:47:50,470
Bool的返回值也会返回


756
00:47:51,371 --> 00:47:52,206
同样地


757
00:47:53,106 --> 00:47:54,942
如果它返回可选结果


758
00:47:55,075 --> 00:48:00,180
我们会将模式识别为零值
表明是无效内容


759
00:48:01,849 --> 00:48:04,084
因为是零值


760
00:48:04,985 --> 00:48:09,756
它就不会再返回包括在
错误处理之内可选结果


761
00:48:15,362 --> 00:48:17,831
有着这两条非常简单的规则


762
00:48:17,931 --> 00:48:22,603
我们发现系统的大部分API都会输入


763
00:48:22,870 --> 00:48:28,408
并自动无缝完美配合
这些新的Swift错误处理模型


764
00:48:28,809 --> 00:48:31,645
我认为这是在Swift中
处理错误的伟大新方式


765
00:48:34,848 --> 00:48:37,351
我强烈推荐大家去看看


766
00:48:37,451 --> 00:48:39,219
你可能没有太多选择


767
00:48:39,286 --> 00:48:40,454
它们到处都是


768
00:48:44,591 --> 00:48:47,060
要知道
我们对这个设计非常自豪


769
00:48:47,394 --> 00:48:52,900
我们认为这将极大改善
编码的稳健性和表达性


770
00:48:53,133 --> 00:48:56,570
让你可以设计出非常不错的API


771
00:48:59,306 --> 00:49:00,274
我来总结一下


772
00:49:01,475 --> 00:49:04,311
我们一直在Swift 2方面
投入大量精力


773
00:49:04,378 --> 00:49:06,513
为大家提供新的语言


774
00:49:06,580 --> 00:49:08,815
通过Swift中的工具


775
00:49:09,383 --> 00:49:15,322
推出Swift的编程的核心方面


776
00:49:16,390 --> 00:49:19,293
为大家提供更安全更稳健的环境


777
00:49:20,227 --> 00:49:22,629
整体提高产品水平


778
00:49:24,898 --> 00:49:28,068
整个过程中
对我们而言 最珍贵的工具


779
00:49:28,335 --> 00:49:29,837
就是大家的反馈


780
00:49:30,137 --> 00:49:31,905
我们非常非常重视这些


781
00:49:32,139 --> 00:49:33,540
我承诺一定会听取意见


782
00:49:35,542 --> 00:49:37,878
如果你要告诉我们什么


783
00:49:38,245 --> 00:49:40,914
当然 大家可以仅使用
错误报告工具即可实现这一点


784
00:49:41,281 --> 00:49:46,987
但是大家也可以联系
斯蒂凡·莱瑟来开发人员论坛


785
00:49:47,054 --> 00:49:49,056
我们大部分人始终都会在那里待着


786
00:49:49,356 --> 00:49:51,825
我们非常乐于对任何问题进行答复


787
00:49:52,125 --> 00:49:53,527
想听到大家的反馈


788
00:49:53,861 --> 00:49:56,029
我们非常非常重视你们


789
00:49:57,164 --> 00:49:59,833
非常感谢


790
00:50:03,036 --> 00:50:04,605
希望大家喜欢WWDC 2015

