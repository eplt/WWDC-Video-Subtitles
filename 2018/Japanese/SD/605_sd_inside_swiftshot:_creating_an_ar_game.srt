
1
00:00:07,107 --> 00:00:16,583
(音楽)

2
00:00:22,356 --> 00:00:28,996
(拍手)

3
00:00:29,530 --> 00:00:33,233
私はアレックス
Tools Foundation所属です

4
00:00:33,333 --> 00:00:38,872
OSなどの担当部署ですが
今年はゲームを作りました

5
00:00:38,972 --> 00:00:41,041
“SwiftShot”です

6
00:00:41,141 --> 00:00:45,245
既に階下で遊んだ方も
いるでしょう

7
00:00:45,846 --> 00:00:52,486
SwiftShotはARKitの
新機能を紹介しています

8
00:00:52,920 --> 00:00:57,291
ARKit 2は多くの
デバイスで利用可能です

9
00:00:57,391 --> 00:01:01,094
AR体験を生む
プラットフォームで

10
00:00:57,391 --> 00:01:01,094
AR体験を生む
プラットフォームで

11
00:01:01,195 --> 00:01:04,665
幅広いユーザに届けられます

12
00:01:04,965 --> 00:01:10,270
特別な設定はなく
デバイスのカメラを使うだけ

13
00:01:11,839 --> 00:01:14,308
iOSに統合されています

14
00:01:14,641 --> 00:01:18,045
SceneKitや
SpriteKitだけでなく

15
00:01:18,278 --> 00:01:24,184
他社のUnrealやUnityにも
完全に統合されています

16
00:01:28,622 --> 00:01:29,790
本日の予定です

17
00:01:29,890 --> 00:01:36,330
まずは今回の開発で学んだ
ARゲームの設計原則について

18
00:01:36,864 --> 00:01:39,766
次にゲームを掘り下げます

19
00:01:39,867 --> 00:01:44,171
ARKit 2の新機能である
World Mapの共有や

20
00:01:44,538 --> 00:01:48,141
ネットワーキングと
物理にも触れます

21
00:01:48,909 --> 00:01:52,379
まずゲームを観察しましょう

22
00:01:55,349 --> 00:02:05,359
(音楽)

23
00:01:55,349 --> 00:02:05,359
(音楽)

24
00:02:26,680 --> 00:02:29,683
“勝ち！”

25
00:02:34,254 --> 00:02:38,025
ARゲームの設計を
ご説明します

26
00:02:40,460 --> 00:02:43,430
ゲームプレイが最優先です

27
00:02:44,998 --> 00:02:46,900
自問してみましょう

28
00:02:47,000 --> 00:02:51,905
70年代のグラフィックスで
楽しめる内容か？

29
00:02:52,039 --> 00:02:55,876
灰色の立方体でも
楽しめるか？

30
00:02:56,343 --> 00:02:59,847
こうしたアートワークを
用いて

31
00:02:59,980 --> 00:03:02,082
レベルを下げてみます

32
00:02:59,980 --> 00:03:02,082
レベルを下げてみます

33
00:03:02,182 --> 00:03:07,754
それで楽しければ
画や音の改善でより楽しめます

34
00:03:08,922 --> 00:03:11,191
よく練りましょう

35
00:03:11,291 --> 00:03:14,928
多少の画質改善や
機能の追加で

36
00:03:15,028 --> 00:03:18,232
劇的に面白くはなりません

37
00:03:18,499 --> 00:03:22,769
こうした失敗例は
山ほどありますから

38
00:03:22,870 --> 00:03:25,305
自分に正直に

39
00:03:27,040 --> 00:03:28,609
まずゲームプレイです

40
00:03:31,445 --> 00:03:32,913
尺は短めに

41
00:03:34,047 --> 00:03:38,919
気軽に出入りできる
ゲームにしましょう

42
00:03:41,455 --> 00:03:44,992
多様なコンテンツを
用意しましょう

43
00:03:45,092 --> 00:03:49,496
繰り返しばかりだと
疲れてしまいます

44
00:03:52,332 --> 00:03:56,303
ゲームの観戦も
楽しまれています

45
00:03:56,503 --> 00:04:00,574
スポーツ観戦のような
感覚ですね

46
00:03:56,503 --> 00:04:00,574
スポーツ観戦のような
感覚ですね

47
00:04:01,008 --> 00:04:05,245
ですから その点も
考慮しましょう

48
00:04:07,648 --> 00:04:10,984
ゲームは重要な交流の形です

49
00:04:12,653 --> 00:04:16,423
ARはふれあいを演出できます

50
00:04:16,523 --> 00:04:21,894
親戚とカードゲームをした
経験があるでしょう

51
00:04:22,062 --> 00:04:25,966
技術を用いて
それに近づけます

52
00:04:29,036 --> 00:04:34,041
目の前に3Dゲームを
置くだけでは不十分です

53
00:04:34,374 --> 00:04:37,377
ARではデバイスの位置や

54
00:04:37,644 --> 00:04:40,814
ユーザの環境も分かります

55
00:04:40,948 --> 00:04:46,954
それを生かしてARならではの
体験にしましょう

56
00:04:52,159 --> 00:04:56,530
カメラでオブジェクト内部を
見られます

57
00:04:57,064 --> 00:05:02,102
この3Dパズルでは
割れた花瓶を直します

58
00:04:57,064 --> 00:05:02,102
この3Dパズルでは
割れた花瓶を直します

59
00:05:02,202 --> 00:05:06,974
周りを見ながら
はまるピースを探すんです

60
00:05:07,641 --> 00:05:09,910
SwiftShotもこんな概念で

61
00:05:10,043 --> 00:05:13,747
中心は机で
動きながら遊べます

62
00:05:13,981 --> 00:05:17,417
でも机は単なる面ではなく

63
00:05:17,518 --> 00:05:19,286
プレイの一部です

64
00:05:19,920 --> 00:05:22,489
机の高さは重要です

65
00:05:22,990 --> 00:05:28,929
ブロックの上のぱちんこの
高さはそれぞれ違います

66
00:05:29,062 --> 00:05:34,968
ユーザが狙いを定めたり
かわしたりできるからです

67
00:05:37,804 --> 00:05:41,775
カメラを使って
周囲も見られます

68
00:05:43,377 --> 00:05:44,578
この例では…

69
00:05:46,246 --> 00:05:50,918
ユニコーンを見つけて
写真を撮ります

70
00:05:53,420 --> 00:05:55,889
周辺を探すんです

71
00:06:00,027 --> 00:06:02,863
別の宇宙も見せられます

72
00:06:02,963 --> 00:06:05,632
実際の被写体と違う世界です

73
00:06:06,366 --> 00:06:07,968
環境を置換し

74
00:06:08,535 --> 00:06:14,041
物理法則を曲げたりして
楽しいゲームを作ります

75
00:06:14,208 --> 00:06:17,177
昼に星を見せていますね

76
00:06:21,315 --> 00:06:23,517
コントローラにもできます

77
00:06:25,986 --> 00:06:30,691
そうすることで仮想世界に
溶け込めます

78
00:06:30,924 --> 00:06:36,163
この例ではブロックを
持ち上げ はめ込みます

79
00:06:36,663 --> 00:06:38,732
こんなインタラクションです

80
00:06:39,733 --> 00:06:42,369
動きはゆっくりと

81
00:06:42,903 --> 00:06:47,474
ブレなくなりトラッキングの
精度も上がります

82
00:06:48,675 --> 00:06:54,615
いくらデバイスが小型でも
振り回せば腕が疲れます

83
00:06:54,715 --> 00:06:57,251
ゆっくり動かしましょう

84
00:06:59,753 --> 00:07:02,389
プレーヤーも動かします

85
00:06:59,753 --> 00:07:02,389
プレーヤーも動かします

86
00:07:02,556 --> 00:07:07,728
例えば敵のぱちんこの前に
ブロックがあります

87
00:07:07,961 --> 00:07:12,032
だから移動して障害物を
攻撃します

88
00:07:19,306 --> 00:07:21,508
操作のフィードバックも
重要です

89
00:07:22,910 --> 00:07:27,047
SwiftShotは聴覚と
触覚で没入感を高めます

90
00:07:27,648 --> 00:07:32,085
動きによって変わる
ゴムを伸ばす音と

91
00:07:32,386 --> 00:07:37,257
電話を持つ感覚で
リアルな体験になります

92
00:07:37,391 --> 00:07:40,460
音に関しては また後ほど

93
00:07:43,230 --> 00:07:47,701
SwiftShotの詳細は
デビッドが説明します

94
00:07:47,801 --> 00:07:48,535
ありがとう

95
00:07:49,069 --> 00:07:50,137
(拍手)

96
00:07:50,237 --> 00:07:50,938
デビッド

97
00:07:53,707 --> 00:07:56,543
ありがとうアレックス
皆さんこんにちは

98
00:07:56,944 --> 00:08:02,916
SwiftShotに関する皆さんの
反応はすばらしいです

99
00:07:56,944 --> 00:08:02,916
SwiftShotに関する皆さんの
反応はすばらしいです

100
00:08:03,016 --> 00:08:08,422
既にサンプルコードを
使っている方もいるそうで

101
00:08:08,522 --> 00:08:11,291
今後の展開が楽しみです

102
00:08:11,525 --> 00:08:16,430
さてSwiftShotに用いた
技術を紹介します

103
00:08:17,064 --> 00:08:18,999
まずはARKit

104
00:08:19,099 --> 00:08:24,805
コンテンツと現実世界の
融合を かなえてくれます

105
00:08:26,573 --> 00:08:31,578
SceneKitの3Dレンダリングと
物理演算で

106
00:08:31,678 --> 00:08:33,813
制御し描写します

107
00:08:35,115 --> 00:08:39,520
MetalではGPUデバイスの
力を利用します

108
00:08:39,620 --> 00:08:43,890
SceneKitのシェーディングや
レンダリング―

109
00:08:43,991 --> 00:08:47,427
旗シミュレーションに
関連しています

110
00:08:48,762 --> 00:08:52,666
“GameplayKit”で
オブジェクト間の

111
00:08:52,766 --> 00:08:56,103
振る舞いを簡単に
共有できます

112
00:08:57,571 --> 00:09:01,041
“Multipeer Connectivity”の
ネットワーキングレイヤで

113
00:08:57,571 --> 00:09:01,041
“Multipeer Connectivity”の
ネットワーキングレイヤで

114
00:09:01,141 --> 00:09:06,346
付近のデバイスを見つけ
同期し暗号化します

115
00:09:07,514 --> 00:09:12,953
“AV Foundation”で
音楽と効果音を制御し

116
00:09:13,053 --> 00:09:15,122
没入感を高めます

117
00:09:16,023 --> 00:09:19,226
そして“Swift”で
アプリケーションを作ります

118
00:09:19,326 --> 00:09:23,464
Swiftはタイプセーフで
高性能

119
00:09:24,031 --> 00:09:26,600
機能も充実しています

120
00:09:26,700 --> 00:09:28,235
プレイに集中でき

121
00:09:28,335 --> 00:09:32,506
クラッシュやミスマッチの
心配が減ります

122
00:09:35,275 --> 00:09:41,515
ではiOSの技術で機能を
実装した方法をお話しします

123
00:09:41,782 --> 00:09:44,384
共有の座標空間の設定

124
00:09:44,718 --> 00:09:45,819
ネットワーキング

125
00:09:46,053 --> 00:09:47,087
物理

126
00:09:47,588 --> 00:09:49,389
アセットの管理

127
00:09:49,590 --> 00:09:50,924
旗シミュレーション

128
00:09:51,024 --> 00:09:52,359
ダイナミックオーディオ

129
00:09:55,128 --> 00:09:58,432
まず共有の座標空間の
設定です

130
00:09:59,566 --> 00:10:04,705
２台でオブジェクトを
同じ場所に見せるため

131
00:09:59,566 --> 00:10:04,705
２台でオブジェクトを
同じ場所に見せるため

132
00:10:04,805 --> 00:10:07,641
共有の座標空間が必要です

133
00:10:07,941 --> 00:10:11,712
同じ物を見て
話せるようになります

134
00:10:13,614 --> 00:10:16,884
ARKitの機能で設定します

135
00:10:17,351 --> 00:10:20,787
iOS 11.3で導入した
イメージの認識で

136
00:10:20,888 --> 00:10:23,657
周りの世界を認識します

137
00:10:24,758 --> 00:10:28,395
iOS 12では技術を
２つ加えました

138
00:10:28,495 --> 00:10:29,796
物体検出と

139
00:10:29,997 --> 00:10:31,331
World Mapの共有

140
00:10:32,299 --> 00:10:37,805
検出機能で実世界に
コンテンツを加えられますが

141
00:10:37,905 --> 00:10:41,241
事前の録画が必要です

142
00:10:41,608 --> 00:10:46,413
LEGOデモでご覧のとおり
認識して追加します

143
00:10:47,915 --> 00:10:50,918
このゲームは
World Mapの共有で

144
00:10:51,018 --> 00:10:54,788
机さえあれば
どこでも遊べます

145
00:10:55,656 --> 00:11:01,929
この技術はゲームだけでなく
店舗や博物館でも使えます

146
00:10:55,656 --> 00:11:01,929
この技術はゲームだけでなく
店舗や博物館でも使えます

147
00:11:02,696 --> 00:11:08,035
階下のゲームルームでは
“iBeacon”でデバイスが

148
00:11:08,135 --> 00:11:12,039
配置を把握し
マップをロードしました

149
00:11:12,206 --> 00:11:14,208
すばらしい体験ができます

150
00:11:16,510 --> 00:11:19,646
SwiftShotの機能を使えば

151
00:11:19,746 --> 00:11:24,618
プレーヤーがゲームボードを
配置できます

152
00:11:24,852 --> 00:11:27,287
事前にマップを入れず―

153
00:11:27,387 --> 00:11:31,658
ボードを配置する例を
お見せしましょう

154
00:11:33,827 --> 00:11:35,362
手順はこうです

155
00:11:36,029 --> 00:11:41,168
まず面をスキャンし
ARKitがマップを作ります

156
00:11:42,569 --> 00:11:46,840
そのデータを
シリアライズして転送

157
00:11:47,941 --> 00:11:53,146
相手がマップをARKitへ
ロードし 同じ面を認識

158
00:11:53,280 --> 00:11:56,316
これで共有の基準点ができ

159
00:11:56,450 --> 00:12:00,654
ボードが同じ場所に
表示されます

160
00:11:56,450 --> 00:12:00,654
ボードが同じ場所に
表示されます

161
00:12:02,823 --> 00:12:07,594
まずWorld Mapを１台目の
ARSessionから取得

162
00:12:08,228 --> 00:12:13,133
iOS 12の新API
“getCurrentWorldMap”です

163
00:12:13,300 --> 00:12:18,038
把握した世界から
オブジェクトを作り

164
00:12:18,138 --> 00:12:20,641
非同期コールバックで
返します

165
00:12:20,874 --> 00:12:26,113
“NSKeyedArchiver”でデータ
オブジェクトへシリアライズ

166
00:12:26,313 --> 00:12:29,249
データを保存か送信します

167
00:12:31,518 --> 00:12:36,290
次に受信デバイスの
データ取得方法です

168
00:12:36,523 --> 00:12:39,293
アドホックゲームのように

169
00:12:39,393 --> 00:12:43,630
SwiftShotはピアツーピアを
使っています

170
00:12:44,498 --> 00:12:46,833
２台目が加わる前に

171
00:12:46,934 --> 00:12:50,404
１台目はマップを
シリアライズし送信

172
00:12:50,737 --> 00:12:56,443
面さえあれば どこでも
簡単に設定できます

173
00:12:58,745 --> 00:13:01,482
階下の方法は違いました

174
00:12:58,745 --> 00:13:01,482
階下の方法は違いました

175
00:13:01,615 --> 00:13:06,753
World Mapを机ごとに
録画し 複数の角度から

176
00:13:06,887 --> 00:13:10,824
共有の座標空間の
ローカライズを確認

177
00:13:11,124 --> 00:13:16,163
机には光の加減や位置などの
特徴があります

178
00:13:16,997 --> 00:13:20,033
そのファイルを
ローカルに保存

179
00:13:20,567 --> 00:13:25,339
Mobile Device Managementで
各デバイスを管理し

180
00:13:25,439 --> 00:13:31,211
各デバイス内のファイルが
同じだと確認しました

181
00:13:32,479 --> 00:13:36,583
iBeaconを置けば
より円滑にできます

182
00:13:36,683 --> 00:13:40,821
識別子とWorld Mapを
関連づければ

183
00:13:40,921 --> 00:13:44,958
各インスタンスがマップを
自動でロードします

184
00:13:45,592 --> 00:13:47,928
消費者向け
アプリケーションなら

185
00:13:48,228 --> 00:13:54,701
オンデマンドリソースや
ご自身のソリューションで

186
00:13:54,802 --> 00:13:56,970
World Mapを共有できます

187
00:13:57,104 --> 00:14:03,744
例えば ある店舗の正確な
World Mapを選べます

188
00:13:57,104 --> 00:14:03,744
例えば ある店舗の正確な
World Mapを選べます

189
00:14:04,278 --> 00:14:09,183
すばらしい体験を生む
可能性に満ちています

190
00:14:12,119 --> 00:14:16,023
では２台目がデータを
取得した後に

191
00:14:16,323 --> 00:14:19,493
ロードする方法を
ご紹介します

192
00:14:19,827 --> 00:14:23,297
“NSKeyedUnarchiver”で

193
00:14:23,897 --> 00:14:27,367
受信データを
ブローアップします

194
00:14:28,168 --> 00:14:32,105
“ARWorldTracking
Configuration”で

195
00:14:32,206 --> 00:14:35,676
World Mapを追加し
設定します

196
00:14:36,710 --> 00:14:40,681
最後にARSessionで実行し

197
00:14:40,814 --> 00:14:44,117
アンカーやトラッキングを
リセット

198
00:14:44,885 --> 00:14:48,755
２台目のARKitが
スキャンを始め

199
00:14:48,856 --> 00:14:53,994
マップの特徴点と現実世界を
関連づけます

200
00:14:54,094 --> 00:14:57,531
これで座標空間の
共有が完了

201
00:14:57,631 --> 00:15:01,502
２台とも実世界の同じ点に
000があります

202
00:14:57,631 --> 00:15:01,502
２台とも実世界の同じ点に
000があります

203
00:15:04,037 --> 00:15:06,540
プライバシーにも
触れましょう

204
00:15:06,740 --> 00:15:11,311
World Mapを録画する過程で
周りの環境や

205
00:15:11,411 --> 00:15:13,914
オブジェクトの配置を
把握します

206
00:15:14,948 --> 00:15:18,652
これは緯度と経度などの
情報です

207
00:15:18,752 --> 00:15:23,090
位置情報の許可を
求める必要はありませんが

208
00:15:23,790 --> 00:15:28,262
個人を特定できる
情報かもしれません

209
00:15:28,595 --> 00:15:35,102
他のプライベートデータと
同じ方法で扱いましょう

210
00:15:35,536 --> 00:15:40,140
保存されたデータと
通信中のデータの

211
00:15:40,507 --> 00:15:43,143
暗号化が必要です

212
00:15:43,610 --> 00:15:49,750
またWorld Mapを
長期間 保存する場合も

213
00:15:49,850 --> 00:15:52,152
ユーザに伝えましょう

214
00:15:53,220 --> 00:15:57,825
SwiftShotでは
保存されたデータを

215
00:15:57,991 --> 00:16:01,061
iOSで暗号化しました

216
00:15:57,991 --> 00:16:01,061
iOSで暗号化しました

217
00:16:01,328 --> 00:16:06,867
次にお話しするのは
通信中のデータの暗号化です

218
00:16:09,203 --> 00:16:13,207
共有の座標空間の
設定に加えて

219
00:16:13,307 --> 00:16:17,044
ゲームボードの
場所も伝えます

220
00:16:17,678 --> 00:16:19,613
使うのはARAnchor

221
00:16:20,247 --> 00:16:22,783
作成時に必要なのは
名前と

222
00:16:23,116 --> 00:16:27,287
４×４の行列という
位置と回転の情報です

223
00:16:28,655 --> 00:16:34,027
ARKitがARWorldMapに
アンカーを含みシリアライズ

224
00:16:34,128 --> 00:16:37,831
これでボードの情報を
転送できます

225
00:16:39,466 --> 00:16:44,037
ARAnchorクラスは
名前と方向を持っていて

226
00:16:44,138 --> 00:16:47,774
名前でアンカーを
調べられます

227
00:16:48,141 --> 00:16:52,646
しかし別のデバイス用に
情報を加えます

228
00:16:52,746 --> 00:16:56,016
ボードのサイズの情報です

229
00:16:56,250 --> 00:17:00,220
小さな机のサイズ
かもしれないし

230
00:16:56,250 --> 00:17:00,220
小さな机のサイズ
かもしれないし

231
00:17:00,320 --> 00:17:03,924
バスケットボールのコート
かもしれない

232
00:17:06,593 --> 00:17:12,532
ネットワークプロトコルに
含めようかとも思いました

233
00:17:13,367 --> 00:17:17,503
ですがサブクラスの
“BoardAnchor”を作り

234
00:17:17,804 --> 00:17:21,375
サイズの情報を加えました

235
00:17:22,175 --> 00:17:27,748
そしてNSCodingの
必須クラスを実装または

236
00:17:27,848 --> 00:17:33,020
オーバーライドしているかを
シリアライズ時に確認

237
00:17:33,320 --> 00:17:39,059
これでWorld Mapに
情報を含めて転送できます

238
00:17:39,159 --> 00:17:41,061
簡単になりました

239
00:17:42,029 --> 00:17:45,232
ひとつ注意点があります

240
00:17:45,432 --> 00:17:49,603
Swiftでのサブクラスの
シリアライズ時は

241
00:17:49,736 --> 00:17:55,676
クラス名にモジュールなどの
名前を含めてください

242
00:17:55,943 --> 00:18:00,881
アプリケーション間の
World Mapの移動に重要です

243
00:17:55,943 --> 00:18:00,881
アプリケーション間の
World Mapの移動に重要です

244
00:18:00,981 --> 00:18:03,584
NSKeyedArchiverで
対応できます

245
00:18:05,185 --> 00:18:08,956
これがiOS 12の新機能
World Mapの共有

246
00:18:09,056 --> 00:18:12,192
どう活用されるのか
楽しみです

247
00:18:14,461 --> 00:18:16,897
ネットワーキングに
使ったのは―

248
00:18:17,831 --> 00:18:24,037
iOS 7以来 搭載のMultipeer
ConnectivityのAPIです

249
00:18:24,605 --> 00:18:29,176
ローカルネットワークでの
ピアツーピア通信で

250
00:18:29,543 --> 00:18:33,981
専用サーバを介さずに
通信できます

251
00:18:34,448 --> 00:18:38,385
今回は１台を
サーバにしましたが

252
00:18:38,485 --> 00:18:41,889
プロトコルには
備わっていません

253
00:18:42,956 --> 00:18:46,426
暗号化と認証は
組み込まれています

254
00:18:46,793 --> 00:18:51,365
今回は出入りの速度を優先し
認証は使わず

255
00:18:51,465 --> 00:18:53,367
暗号化だけ使いました

256
00:18:53,700 --> 00:18:57,504
パフォーマンスは
不利にならず

257
00:18:57,604 --> 00:19:01,475
影響があったのは
データサイズなどです

258
00:18:57,604 --> 00:19:01,475
影響があったのは
データサイズなどです

259
00:19:01,575 --> 00:19:03,443
だから使いました

260
00:19:05,012 --> 00:19:09,650
アドバタイズと発見の
APIを使えば

261
00:19:10,184 --> 00:19:14,087
ゲームのブロードキャストが
可能です

262
00:19:15,189 --> 00:19:16,924
設定はこうです

263
00:19:17,458 --> 00:19:22,329
まずホストになる
デバイスを設定します

264
00:19:23,297 --> 00:19:26,333
周辺をスキャンし
ボードを置き

265
00:19:27,201 --> 00:19:31,438
Multipeer Connectivityの
セッションを開始

266
00:19:31,538 --> 00:19:34,608
ローカルネットワークで
アドバタイズします

267
00:19:36,009 --> 00:19:39,379
他のデバイスが
ゲームを見つけ

268
00:19:39,947 --> 00:19:44,084
セッションに
参加リクエストを送信

269
00:19:45,519 --> 00:19:50,891
承認されるとピアツーピアの
通信が設定され

270
00:19:51,024 --> 00:19:55,529
メッセージの送受信が
可能になります

271
00:19:55,896 --> 00:20:01,568
今回はセッションを始めた
１台が情報源ですが

272
00:19:55,896 --> 00:20:01,568
今回はセッションを始めた
１台が情報源ですが

273
00:20:01,668 --> 00:20:07,441
Multipeer Connectivity本来の
プロトコルではありません

274
00:20:10,043 --> 00:20:15,816
設定が済むと次の３つの
方法でデータを送れます

275
00:20:15,916 --> 00:20:17,518
データパケット

276
00:20:17,751 --> 00:20:20,921
ローカル上のURLという
リソース

277
00:20:21,021 --> 00:20:22,256
ストリーム

278
00:20:22,689 --> 00:20:25,893
データオブジェクトは
全ピアに送れますが

279
00:20:25,993 --> 00:20:29,162
リソースとストリームは
デバイス間です

280
00:20:29,696 --> 00:20:33,300
SwiftShotでは
データパケットで

281
00:20:33,400 --> 00:20:38,005
ゲームイベントと
物理ステートを共有しました

282
00:20:38,472 --> 00:20:41,542
リソースで
World Mapを転送し

283
00:20:42,142 --> 00:20:44,511
ストリームは不採用

284
00:20:46,013 --> 00:20:51,218
デバイス間の転送は
UDPに依存しています

285
00:20:51,318 --> 00:20:55,889
レイテンシが低く
ゲームに適しています

286
00:20:56,457 --> 00:21:01,929
UDPは本来デリバリーを
保証しないので

287
00:20:56,457 --> 00:21:01,929
UDPは本来デリバリーを
保証しないので

288
00:21:02,029 --> 00:21:07,000
こちらでデータパケットを
確実に送るかどうか決めます

289
00:21:07,568 --> 00:21:11,905
Multipeer Connectivityの
リトライに

290
00:21:12,005 --> 00:21:14,842
任せることもできます

291
00:21:15,742 --> 00:21:19,112
対象が全員でも大丈夫です

292
00:21:21,615 --> 00:21:25,919
次にアプリケーション
プロトコルの作成です

293
00:21:26,420 --> 00:21:30,090
SwiftEnumsを使えば
簡単です

294
00:21:30,691 --> 00:21:36,597
各ケースにデータ構造があり
タイプセーフを保証します

295
00:21:37,431 --> 00:21:39,700
具体例をご紹介します

296
00:21:39,833 --> 00:21:43,003
この“GameAction”が
含む情報は

297
00:21:43,103 --> 00:21:46,673
ぱちんこをつかむなどの
動きです

298
00:21:47,107 --> 00:21:52,079
“PhysicsSyncData”の
エンコードについては後ほど

299
00:21:53,580 --> 00:21:55,449
Swiftなら簡単です

300
00:21:55,549 --> 00:22:01,788
全メンバーが“Codable”なら
構造体をCodableでマークし

301
00:21:55,549 --> 00:22:01,788
全メンバーが“Codable”なら
構造体をCodableでマークし

302
00:22:01,889 --> 00:22:06,960
Swiftコンパイラに
後の対応を任せます

303
00:22:07,995 --> 00:22:12,332
列挙型は自分たちで
対応しました

304
00:22:12,432 --> 00:22:19,072
initを実装し メソッドを
コーディングして動かします

305
00:22:20,841 --> 00:22:22,609
シリアライズは簡単で

306
00:22:22,709 --> 00:22:26,547
“PropertyListEncoder”で
オブジェクトをエンコード

307
00:22:27,247 --> 00:22:31,218
これでデータパケットを
送れます

308
00:22:32,419 --> 00:22:37,491
サイズとパフォーマンスは
どうでしょうか？

309
00:22:38,525 --> 00:22:42,930
プロパティリストは小さく
エンコーダは速い

310
00:22:43,630 --> 00:22:49,169
しかしこうしたソフト実装は
最適化されていて

311
00:22:49,269 --> 00:22:52,172
開発の時間は貴重です

312
00:22:54,007 --> 00:22:59,546
次の新機能はこうした
制限にも関連しています

313
00:23:01,815 --> 00:23:04,685
物理シミュレーションです

314
00:23:04,918 --> 00:23:09,656
今回のようなゲームでは
リアルな物理表現が

315
00:23:09,756 --> 00:23:12,659
面白さを左右します

316
00:23:12,759 --> 00:23:18,932
ブロックや敵のぱちんこを
倒すという楽しい体験の肝は

317
00:23:19,633 --> 00:23:21,802
物理シミュレーションです

318
00:23:23,637 --> 00:23:27,541
SceneKitの
物理エンジンを使って

319
00:23:27,641 --> 00:23:30,744
オブジェクトの位置を
更新し

320
00:23:30,844 --> 00:23:33,514
コリジョンを通知します

321
00:23:34,548 --> 00:23:39,219
今回は１台のデバイスを
情報源または

322
00:23:39,319 --> 00:23:41,955
サーバとしました

323
00:23:42,222 --> 00:23:47,060
Multipeer Connectivityの
メソッドを使って

324
00:23:47,161 --> 00:23:51,231
物理ステートの定期更新を
共有しました

325
00:23:52,633 --> 00:23:57,337
別のデバイスも
シミュレーションします

326
00:23:57,671 --> 00:24:01,008
全オブジェクトの
情報ではなく

327
00:23:57,671 --> 00:24:01,008
全オブジェクトの
情報ではなく

328
00:24:01,108 --> 00:24:06,713
ブロックなどプレイ関連の
情報だけ共有するからです

329
00:24:06,980 --> 00:24:13,453
ロープやぱちんこなどの
揺れのシミュレーションは

330
00:24:13,954 --> 00:24:20,060
正確な位置が不要なので
各デバイスが行います

331
00:24:23,997 --> 00:24:27,768
オブジェクトの規模によって

332
00:24:27,868 --> 00:24:31,972
物理エンジンの反応が
異なります

333
00:24:32,172 --> 00:24:37,978
現実のサイズの約10倍の
シミュレーションが

334
00:24:38,212 --> 00:24:42,716
最高の体験と
パフォーマンスを生みます

335
00:24:43,116 --> 00:24:46,353
物理法則を曲げましたが

336
00:24:46,453 --> 00:24:51,792
見た目と感覚がしっくりきて
楽しければ正解です

337
00:24:53,794 --> 00:24:59,433
これを実現するために
４つの情報を共有しました

338
00:24:59,600 --> 00:25:00,701
位置

339
00:24:59,600 --> 00:25:00,701
位置

340
00:25:02,236 --> 00:25:03,370
速度

341
00:25:04,605 --> 00:25:06,240
角速度

342
00:25:06,573 --> 00:25:07,875
方向です

343
00:25:08,308 --> 00:25:11,011
膨大な情報量になるので

344
00:25:11,111 --> 00:25:14,414
ビット数を最小限に
抑えました

345
00:25:14,982 --> 00:25:17,718
具体例をお見せします

346
00:25:18,786 --> 00:25:22,790
SceneKitは浮動小数で
位置を表します

347
00:25:23,290 --> 00:25:28,395
計算の性能を最高にする
ネイティブ形式です

348
00:25:30,063 --> 00:25:34,668
しかし位置を知るには
ビット数が多すぎます

349
00:25:35,135 --> 00:25:39,640
８ビットの指数部と
23ビットの仮数部

350
00:25:39,740 --> 00:25:42,843
範囲はプラスマイナス
10の38乗メートル

351
00:25:43,010 --> 00:25:45,379
こんなに要りません

352
00:25:47,314 --> 00:25:51,685
シミュレーションでは
机は27メートル

353
00:25:51,985 --> 00:25:56,790
そこで80メートルで
十分だと判断しました

354
00:25:58,592 --> 00:26:00,260
コーディング時に

355
00:25:58,592 --> 00:26:00,260
コーディング時に

356
00:26:00,794 --> 00:26:06,500
０～80メートルで正規化し
符号部を外しました

357
00:26:06,600 --> 00:26:08,969
原点は机の中心ですが

358
00:26:09,369 --> 00:26:11,104
これで値は正です

359
00:26:12,139 --> 00:26:15,475
値を０～１の範囲にすれば

360
00:26:15,642 --> 00:26:20,948
プロトコルに備わる
指数部の情報は不要です

361
00:26:22,616 --> 00:26:26,920
最後に利用できる
ビット数に調整します

362
00:26:27,254 --> 00:26:33,227
全ての１は浮動小数点数１で
０は浮動小数点数０

363
00:26:34,061 --> 00:26:36,897
ミリ単位の正確さになり

364
00:26:37,097 --> 00:26:41,802
円滑に同期するのに
十分だと分かりました

365
00:26:43,337 --> 00:26:46,540
他の値についても同様です

366
00:26:46,640 --> 00:26:49,877
速度と角速度と方向

367
00:26:51,011 --> 00:26:57,751
範囲とビット数を減らして
転送データを最小限にします

368
00:26:57,951 --> 00:27:02,890
各オブジェクトのビット数は
半分以下になりました

369
00:26:57,951 --> 00:27:02,890
各オブジェクトのビット数は
半分以下になりました

370
00:27:04,591 --> 00:27:08,896
数字は圧縮しましたが
プロパティリストには

371
00:27:09,029 --> 00:27:14,167
膨大なオーバーヘッドがあり
名前でフィールドを送ります

372
00:27:14,735 --> 00:27:20,174
オブジェクトは把握しており
不要な情報でした

373
00:27:20,674 --> 00:27:27,648
そこで“BitStream”という
新方策でシリアライズします

374
00:27:28,315 --> 00:27:31,818
高速シリアライズと
デシリアライズで

375
00:27:31,919 --> 00:27:35,322
最小限のバイトに
情報を詰めます

376
00:27:35,789 --> 00:27:42,429
この実装はバイナリデータの
レイテンシを抑える目的です

377
00:27:42,830 --> 00:27:47,835
なので この方策は
永続性を要するデータや

378
00:27:47,935 --> 00:27:51,939
長期的に追うデータには
不向きです

379
00:27:52,473 --> 00:27:56,009
こうした短いものには
最適です

380
00:27:58,111 --> 00:28:01,048
プロトコルも２つ作りました

381
00:27:58,111 --> 00:28:01,048
プロトコルも２つ作りました

382
00:28:01,148 --> 00:28:04,184
“BitStreamEncodable”と
“BitStreamDecodable”

383
00:28:04,585 --> 00:28:06,753
合わせて“BitStreamCodable”

384
00:28:07,354 --> 00:28:11,959
これでシリアライズする
全オブジェクトをマークし

385
00:28:12,059 --> 00:28:13,660
実装しました

386
00:28:14,027 --> 00:28:17,798
データオブジェクトと
システム内の

387
00:28:17,898 --> 00:28:22,736
SIMDの浮動小数点
ベクトルなども含みます

388
00:28:25,172 --> 00:28:28,141
浮動小数の圧縮は

389
00:28:28,475 --> 00:28:33,580
最小および最大範囲と
指定のビット数で設定

390
00:28:35,082 --> 00:28:36,884
値をクランプし

391
00:28:36,984 --> 00:28:41,955
指定のビット数で
エンコード用の整数値に変換

392
00:28:42,790 --> 00:28:46,126
各オブジェクトに
これを適用します

393
00:28:46,560 --> 00:28:51,665
追加ビットを使って
動きの更新状況を把握し

394
00:28:51,999 --> 00:28:55,035
動きがなければ
情報は再送しない

395
00:28:57,204 --> 00:29:02,376
アクションの列挙型には
BitStreamを用いました

396
00:28:57,204 --> 00:29:02,376
アクションの列挙型には
BitStreamを用いました

397
00:29:03,811 --> 00:29:07,414
Codableの
シリアライズでは

398
00:29:07,514 --> 00:29:11,318
列挙型用の
“CodingKeys”を指定

399
00:29:12,119 --> 00:29:17,124
BitStreamでは
整数値を使いました

400
00:29:18,492 --> 00:29:23,130
エンコードのメソッドで
その値をアペンドし

401
00:29:23,297 --> 00:29:27,801
ケースに関連した
データ構造が続きます

402
00:29:28,402 --> 00:29:31,472
ここに落とし穴があります

403
00:29:31,738 --> 00:29:36,810
３つのケースがあり
エンコードに必要なのは

404
00:29:37,177 --> 00:29:39,513
２ビットですね

405
00:29:40,647 --> 00:29:45,619
ケースが１つ追加されても
問題ありません

406
00:29:45,719 --> 00:29:48,689
ケースが５つになると

407
00:29:48,789 --> 00:29:53,560
３ビット使用に
変更しなくてはなりません

408
00:29:54,027 --> 00:29:57,097
このコードは くどいですね

409
00:29:57,197 --> 00:30:02,770
それにうっかりして
ひどい結果になりかねません

410
00:29:57,197 --> 00:30:02,770
それにうっかりして
ひどい結果になりかねません

411
00:30:03,737 --> 00:30:08,976
そこでSwiftが手助けする
方法を考えました

412
00:30:11,044 --> 00:30:15,749
Swift 4.2の新機能
“CaseIterable”です

413
00:30:16,250 --> 00:30:22,089
このプロトコル準拠を
列挙型に追加しました

414
00:30:22,422 --> 00:30:27,828
追加される“allCases”という
静的メンバーは

415
00:30:27,928 --> 00:30:30,130
各ケースを含みます

416
00:30:30,597 --> 00:30:34,168
これでケース数を
自動取得します

417
00:30:34,935 --> 00:30:38,672
“RawRepresentable”にも
Extentionを追加

418
00:30:38,772 --> 00:30:44,344
全列挙型が準拠し
CaseIterableで

419
00:30:44,444 --> 00:30:46,613
整数値になっています

420
00:30:47,014 --> 00:30:50,017
ケース数を自動で取得し

421
00:30:50,117 --> 00:30:54,588
全ケースで必要な
ビット数を算出します

422
00:30:56,290 --> 00:31:01,061
“WritableBitStream”では
ジェネリックメソッドを加え

423
00:30:56,290 --> 00:31:01,061
“WritableBitStream”では
ジェネリックメソッドを加え

424
00:31:01,161 --> 00:31:02,930
エンコード可能に

425
00:31:03,363 --> 00:31:04,765
アペンドし

426
00:31:04,865 --> 00:31:09,770
新たな静的プロパティで
ビットを計算します

427
00:31:11,638 --> 00:31:13,807
シンプルになりましたね

428
00:31:14,141 --> 00:31:19,580
CodingKeysで“appendEnum”を
使えば後はお任せです

429
00:31:19,947 --> 00:31:23,817
ケースを加えると
ビットフィールドが拡張し

430
00:31:23,917 --> 00:31:27,955
削除すれば自動で縮小します

431
00:31:31,592 --> 00:31:34,528
BitStreamCodableの
実力とは？

432
00:31:34,962 --> 00:31:38,532
オブジェクトの動きに関する
メッセージで

433
00:31:38,632 --> 00:31:42,669
送信時のパフォーマンスを
検査しました

434
00:31:43,971 --> 00:31:47,741
サイズは10分の１
エンコード速度は２倍

435
00:31:47,841 --> 00:31:49,610
デコード速度は10倍

436
00:31:50,144 --> 00:31:54,548
75マイクロ秒が
６マイクロ秒になっても

437
00:31:54,648 --> 00:31:56,417
大差はない

438
00:31:56,884 --> 00:32:00,254
よく使うオブジェクト
200個なら

439
00:31:56,884 --> 00:32:00,254
よく使うオブジェクト
200個なら

440
00:32:00,354 --> 00:32:03,323
円滑なプレイを左右します

441
00:32:03,457 --> 00:32:04,925
このフォーマットなら

442
00:32:05,025 --> 00:32:08,562
60fpsで物理の
情報を更新し

443
00:32:08,695 --> 00:32:11,398
全員が円滑に遊べます

444
00:32:13,367 --> 00:32:18,605
さて使ったのはCodableと
BitStreamCodable

445
00:32:18,806 --> 00:32:22,142
異なる方法には
問題がつきもので

446
00:32:22,242 --> 00:32:25,345
コードパスも２つ必要です

447
00:32:26,079 --> 00:32:29,216
Swiftで
組み合わせましょう

448
00:32:30,083 --> 00:32:36,523
限定的な拡張を加えて
BitStreamCodable内の

449
00:32:36,623 --> 00:32:39,993
CodableにBitStreamの
エンコードを実装

450
00:32:40,394 --> 00:32:43,063
それからバイナリで…

451
00:32:44,598 --> 00:32:48,435
エンコードし
BitStreamに入れます

452
00:32:49,570 --> 00:32:54,541
Codableの構造体は
BitStreamCodableでマーク

453
00:32:54,842 --> 00:33:01,515
BitStreamCodableだけの
時ほど速く小さくないですが

454
00:32:54,842 --> 00:33:01,515
BitStreamCodableだけの
時ほど速く小さくないですが

455
00:33:01,815 --> 00:33:06,653
頻繁なメッセージへの
適用だけで十分でした

456
00:33:06,854 --> 00:33:10,891
ゲーム内の動きは
高速になりました

457
00:33:12,493 --> 00:33:14,027
物理はここまで

458
00:33:14,161 --> 00:33:17,030
次はアセットの対処です

459
00:33:17,130 --> 00:33:20,234
階下でも質問を受けました

460
00:33:21,168 --> 00:33:26,106
3Dモジュールやテクスチャや
アニメーションです

461
00:33:26,373 --> 00:33:31,311
今回は商業ツールで
ビジュアルを作りました

462
00:33:31,411 --> 00:33:33,714
ブロックやぱちんこなどです

463
00:33:34,014 --> 00:33:38,151
それをDAE形式で
エクスポート

464
00:33:38,252 --> 00:33:42,956
USDZをサポートする
ツールが待ち遠しいです

465
00:33:44,324 --> 00:33:46,693
Swiftで
コマンドラインツールを作り

466
00:33:46,793 --> 00:33:52,866
SceneKitのAPIでDAEを
SceneKitファイルに変換

467
00:33:53,100 --> 00:33:57,171
iOSとmacOS共通の
APIがあるからです

468
00:33:57,271 --> 00:34:01,175
macOSでツールを
使って作成し

469
00:33:57,271 --> 00:34:01,175
macOSでツールを
使って作成し

470
00:34:01,275 --> 00:34:05,145
そのファイルを
直接iOSに取り込めます

471
00:34:06,747 --> 00:34:11,685
構築データを各種ブロックの
ファイルにして

472
00:34:11,952 --> 00:34:14,788
各レベルで組み合わせます

473
00:34:15,422 --> 00:34:20,060
この外見と振る舞いを
各ブロックで反復し

474
00:34:20,226 --> 00:34:24,197
ゲームプレイの設計でも
反復します

475
00:34:24,297 --> 00:34:28,302
ソースコードの別レベルも
ご活用ください

476
00:34:30,270 --> 00:34:33,739
異なる距離を
さらに生かすには

477
00:34:33,841 --> 00:34:38,277
SceneKitでアセットに
変化をつけます

478
00:34:39,045 --> 00:34:42,049
近くのオブジェクトは
ポリゴンの数が多く

479
00:34:42,149 --> 00:34:45,786
遠くなら減らして
質感も変える

480
00:34:45,918 --> 00:34:48,621
レンダリングを
最適化できます

481
00:34:51,125 --> 00:34:54,328
しかし一貫性も大事なので

482
00:34:54,428 --> 00:34:57,130
物理ボディを別々に
指定しました

483
00:34:57,731 --> 00:35:02,903
SceneKitに組み込まれた
立方体などを使えば

484
00:34:57,731 --> 00:35:02,903
SceneKitに組み込まれた
立方体などを使えば

485
00:35:03,237 --> 00:35:06,206
最高のパフォーマンスを
発揮します

486
00:35:06,773 --> 00:35:11,445
指定しなければ自動で
凸包が作られます

487
00:35:11,578 --> 00:35:17,084
ただしパフォーマンスは
低下するかもしれません

488
00:35:17,184 --> 00:35:23,357
今回は既存のオブジェクトで
パフォーマンスを上げました

489
00:35:25,893 --> 00:35:28,762
具体例を見てみましょう

490
00:35:28,929 --> 00:35:34,201
まずはゲーム内の
木目調の円柱ブロックです

491
00:35:35,035 --> 00:35:37,538
次はぱちんこです

492
00:35:37,871 --> 00:35:43,677
シェーダを使って色を加え
アニメーションも作りました

493
00:35:44,812 --> 00:35:48,549
これはゲームでは
使いませんでしたが

494
00:35:48,649 --> 00:35:53,253
サンプルコードには
残しておきました

495
00:35:56,123 --> 00:35:59,560
旗シミュレーションも
楽しいですね

496
00:35:59,660 --> 00:36:02,095
没入感を高めます

497
00:35:59,660 --> 00:36:02,095
没入感を高めます

498
00:36:02,496 --> 00:36:04,932
リアルな風の動きです

499
00:36:05,065 --> 00:36:08,268
物理エンジンの
布シミュレーションではなく

500
00:36:09,503 --> 00:36:13,240
GPUとMetalで
やることにしました

501
00:36:15,242 --> 00:36:18,345
まずはSceneKitの
アセットです

502
00:36:18,445 --> 00:36:22,616
Appleロゴを乗せるため
テクスチャを貼りました

503
00:36:23,650 --> 00:36:26,587
次にSwiftクラスを作成

504
00:36:26,720 --> 00:36:29,056
Metalのコマンドキューを
作り

505
00:36:29,156 --> 00:36:33,427
風向きなどゲームの状態の
情報を挿入

506
00:36:34,495 --> 00:36:37,397
コンピュートシェーダを
実行します

507
00:36:37,764 --> 00:36:40,000
これはＣの
レガシーコードから来ていて

508
00:36:40,100 --> 00:36:45,138
MetalはモダンC++に
基づくため変換は簡単でした

509
00:36:45,772 --> 00:36:49,843
コンピュートシェーダで
法線を算出し

510
00:36:50,077 --> 00:36:54,848
ポリゴンの数を抑え
滑らかな旗を見せます

511
00:36:55,549 --> 00:36:57,551
上出来ですね

512
00:36:58,218 --> 00:37:02,956
各フレームでシェーダが
位置を更新します

513
00:36:58,218 --> 00:37:02,956
各フレームでシェーダが
位置を更新します

514
00:37:03,223 --> 00:37:05,559
GPUを効果的に活用し

515
00:37:05,659 --> 00:37:09,997
メインCPUには
影響を与えません

516
00:37:12,299 --> 00:37:16,069
最後は音声の
実装についてです

517
00:37:16,603 --> 00:37:20,040
音はゲームの魅力を高めます

518
00:37:20,674 --> 00:37:26,747
リアルな効果音をゲーム内に
適切に配置することで

519
00:37:26,847 --> 00:37:30,184
ユーザの没入感を高めました

520
00:37:30,818 --> 00:37:36,623
速度やアプリケーションの
サイズにも配慮が必要です

521
00:37:36,924 --> 00:37:39,593
そこで名案が出ました

522
00:37:40,260 --> 00:37:46,300
同僚の家庭から玩具を借りて
音のサンプルを録音し

523
00:37:46,833 --> 00:37:52,639
Audio Unitsのプリセット
ファイルと合わせたんです

524
00:37:52,740 --> 00:37:55,309
そしてMIDI
インストゥルメントを

525
00:37:55,409 --> 00:37:58,845
AV Foundationで
作りました

526
00:37:59,413 --> 00:38:04,818
これで展開に応じて
適切な音を簡単に出せます

527
00:37:59,413 --> 00:38:04,818
これで展開に応じて
適切な音を簡単に出せます

528
00:38:06,920 --> 00:38:08,956
微調整もしました

529
00:38:09,089 --> 00:38:14,461
ぱちんこを引く音には
バリエーションがあります

530
00:38:14,795 --> 00:38:18,832
引く距離に応じて
ピッチを変えました

531
00:38:19,366 --> 00:38:21,535
それから…

532
00:38:21,635 --> 00:38:24,671
速度に応じて
音量も変えました

533
00:38:24,771 --> 00:38:27,641
MIDIノートを選んで

534
00:38:27,741 --> 00:38:32,212
追加のMIDIコマンドで
修正します

535
00:38:32,312 --> 00:38:34,915
では聴いてみましょう

536
00:38:37,818 --> 00:38:47,828
(効果音)

537
00:38:53,667 --> 00:38:57,504
音声で判断できる
情報があります

538
00:38:57,604 --> 00:39:03,444
ユーザと ぱちんこの
距離感はどの程度かや

539
00:38:57,604 --> 00:39:03,444
ユーザと ぱちんこの
距離感はどの程度かや

540
00:39:03,544 --> 00:39:04,812
既につかんだのか

541
00:39:04,912 --> 00:39:07,081
最初にした音です

542
00:39:07,448 --> 00:39:10,083
UIフィードバックなので

543
00:39:10,184 --> 00:39:14,788
当該ユーザの
デバイスでだけで聞こえます

544
00:39:14,888 --> 00:39:17,458
ですが他の人たちが

545
00:39:17,558 --> 00:39:21,962
ぱちんこを使う様子も
音で共有します

546
00:39:22,062 --> 00:39:25,532
ポジショナルオーディオで

547
00:39:25,666 --> 00:39:30,170
他者の音を
自分の音より小さくします

548
00:39:30,404 --> 00:39:33,006
音量と配置を調整するんです

549
00:39:35,142 --> 00:39:38,845
ブロックの衝突音は
微妙に違います

550
00:39:39,046 --> 00:39:41,782
欲しかったのは耳障りな…

551
00:39:43,150 --> 00:39:43,984
エフェクトです

552
00:39:44,084 --> 00:39:46,854
ブロックは遠くにあるので

553
00:39:46,954 --> 00:39:51,225
SceneKitで音の位置を
調整しました

554
00:39:51,992 --> 00:39:56,663
各デバイスで音は違い
同期していません

555
00:39:56,763 --> 00:40:00,033
あえて耳障りにするためです

556
00:39:56,763 --> 00:40:00,033
あえて耳障りにするためです

557
00:40:00,400 --> 00:40:05,138
MIDIインストゥルメントで
少数の音を作りました

558
00:40:05,305 --> 00:40:11,278
衝突の衝撃の強さに応じて
アタックレートを変えます

559
00:40:13,414 --> 00:40:17,784
音は3D座標で
ローカライズされているため

560
00:40:17,885 --> 00:40:21,321
遠くの衝突は小さく聞こえる

561
00:40:21,555 --> 00:40:22,990
聴きましょう

562
00:40:26,326 --> 00:40:36,336
(効果音)

563
00:40:38,539 --> 00:40:39,640
もう一発

564
00:40:40,641 --> 00:40:41,508
そうです

565
00:40:42,409 --> 00:40:43,110
はい

566
00:40:46,246 --> 00:40:50,417
音の設定中に
他にも発見がありました

567
00:40:50,751 --> 00:40:55,289
プロパティリストで
ファイル名パス変換の

568
00:40:55,389 --> 00:40:59,226
スクリプトの実行が
必要でした

569
00:41:00,194 --> 00:41:04,965
Swiftでコマンドライン
ツールとして設定できます

570
00:41:05,499 --> 00:41:10,537
上にUnixのシバンらしき
部分がありますよね？

571
00:41:10,637 --> 00:41:14,608
これがSwiftを起動し
実行させます

572
00:41:15,442 --> 00:41:18,979
これでスクリプト言語として
扱えます

573
00:41:19,880 --> 00:41:26,220
Swift Playgroundsで
開発することもできます

574
00:41:26,887 --> 00:41:31,358
準備が整ったら保存し
上にシバンを追加

575
00:41:31,458 --> 00:41:34,595
ファイルシステムで
実行可能にします

576
00:41:35,195 --> 00:41:40,367
アプリケーションの外でも
Xcodeの中でも

577
00:41:40,467 --> 00:41:43,170
コマンドラインツールが
使えます

578
00:41:43,704 --> 00:41:48,108
全てのSystem frameworkに
アクセスできます

579
00:41:48,208 --> 00:41:54,781
今回はプロパティリストを
直接編集した便利な技術です

580
00:41:57,351 --> 00:42:02,990
本日はARがもたらす
体験についてお話ししました

581
00:41:57,351 --> 00:42:02,990
本日はARがもたらす
体験についてお話ししました

582
00:42:03,657 --> 00:42:06,326
ARで設計してみてください

583
00:42:06,427 --> 00:42:11,498
ゲームはプレイの楽しさが
肝心です

584
00:42:13,100 --> 00:42:19,373
SwiftShotのサンプル
コードをお使いください

585
00:42:19,473 --> 00:42:24,678
iOS 12リリース後に
随時更新する予定です

586
00:42:24,978 --> 00:42:31,151
ぜひ会場のSwiftShotで
遊んでみてくださいね

587
00:42:32,452 --> 00:42:37,558
この後ARKitラボと
懇親会を開催します

588
00:42:37,824 --> 00:42:40,928
さらにイベント情報です

589
00:42:41,028 --> 00:42:44,431
金曜にSwiftShotの
大会を開きます

590
00:42:44,531 --> 00:42:45,933
ぜひご参加ください

591
00:42:46,400 --> 00:42:47,334
ありがとう

592
00:42:47,434 --> 00:42:48,936
(拍手)