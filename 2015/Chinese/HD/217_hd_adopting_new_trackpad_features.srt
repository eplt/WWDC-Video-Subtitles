1
00:00:20,988 --> 00:00:21,822
早上好


2
00:00:22,155 --> 00:00:24,958
采用新Trackpad特性


3
00:00:25,025 --> 00:00:26,493
欢迎来到会议217：


4
00:00:26,560 --> 00:00:28,195
“采用新Trackpad特性”


5
00:00:28,495 --> 00:00:30,764
我叫罗利·雷德 我是一名
AppKit工程师


6
00:00:30,831 --> 00:00:33,700
我是使用新的压力触控tra
ckpads方面的“大师”


7
00:00:34,735 --> 00:00:37,037
我们接下来要讲的
就是这个


8
00:00:37,104 --> 00:00:38,739
新的压力触控
trackpads


9
00:00:39,273 --> 00:00:42,309
它们是很酷很酷的
技术


10
00:00:42,409 --> 00:00:44,845
与我们之前的trackpads
不同之处在于


11
00:00:45,045 --> 00:00:48,182
它没有可供你按压的
实体键


12
00:00:48,715 --> 00:00:51,218
代替实体键的
是四个力传感器


13
00:00:51,485 --> 00:00:53,954
这样我们就可以测量
用户对trackpad


14
00:00:54,021 --> 00:00:55,822
施加了多大的力
然后我们会把它


15
00:00:55,889 --> 00:00:57,524
和我们的Taptic引擎
结合起来


16
00:00:57,925 --> 00:00:58,759
当我们确定用户
在trackpad


17
00:00:58,825 --> 00:01:01,361
按压的力足够大
足以触发鼠标的时候


18
00:01:01,428 --> 00:01:02,829
我们就会使用
Taptic引擎


19
00:01:02,896 --> 00:01:04,998
把trackpad向侧面


20
00:01:05,331 --> 00:01:07,968
稍微
拉一下


21
00:01:08,502 --> 00:01:10,304
这样用户就会感觉


22
00:01:10,370 --> 00:01:12,673
他们实际上已经按压到了
一个按钮


23
00:01:13,173 --> 00:01:15,108
就是这样 trackpad
向侧面移动


24
00:01:15,342 --> 00:01:16,977
但是你的大脑会让你以为


25
00:01:17,044 --> 00:01:18,579
你实际上已经按压到了
一个按钮


26
00:01:18,879 --> 00:01:21,281
这种感觉真的很棒
这样欺骗你的大脑


27
00:01:21,348 --> 00:01:23,150
让你的大脑以为你已经


28
00:01:23,217 --> 00:01:24,685
按压到了一个按钮
这真的很奇妙


29
00:01:24,751 --> 00:01:26,587
我们楼下实验室有一些
trackpad


30
00:01:26,653 --> 00:01:28,155
如果你还没有
体验过它


31
00:01:28,589 --> 00:01:29,756
请下来试试


32
00:01:30,591 --> 00:01:33,460
在那里顺便看看
Taptic引擎


33
00:01:34,061 --> 00:01:35,195
真的很棒


34
00:01:35,395 --> 00:01:38,265
概括一下
你施加了一点压力


35
00:01:38,332 --> 00:01:41,535
我们给你算一次单击 但是当
你向trackpad施加


36
00:01:41,602 --> 00:01:45,305
更大的力
我们也可以辨别出来


37
00:01:45,372 --> 00:01:46,373
我们也可以感觉得到


38
00:01:46,440 --> 00:01:47,941
我们称之为
Force click


39
00:01:48,008 --> 00:01:48,876
我们也会给你一个
更加强烈的


40
00:01:48,942 --> 00:01:49,943
触觉感受


41
00:01:50,878 --> 00:01:52,312
那么有了
Force click


42
00:01:52,379 --> 00:01:53,647
你就可以很多
好玩的事


43
00:01:53,847 --> 00:01:54,982
事实上 让我给你演示一些


44
00:01:55,048 --> 00:01:57,451
你现在就可以用Force
click做的好玩的事


45
00:02:03,423 --> 00:02:05,993
像我这样
你可以看到我四处移动光标


46
00:02:06,126 --> 00:02:09,329
你可以看到我对trackpad
施加的力


47
00:02:09,395 --> 00:02:12,799
如果我再进一步 你就可以得
到Force click


48
00:02:12,999 --> 00:02:14,401
那么
大家都听到了吧？


49
00:02:14,468 --> 00:02:15,502
是我添加的 你知道


50
00:02:15,569 --> 00:02:16,837
通常情况下 当你进行
Force click


51
00:02:16,904 --> 00:02:19,039
的时候 你的电脑并不会
发出声音 我加了这个声音


52
00:02:19,106 --> 00:02:21,241
是因为你们并不能实际
感受到这个触觉反馈 因为


53
00:02:21,308 --> 00:02:22,342
你们在那里 而我在这里


54
00:02:22,910 --> 00:02:27,147
这样 当我在演示中向tra
ckpad施加力的时候


55
00:02:27,214 --> 00:02:28,415
你们就可以
观看了


56
00:02:29,149 --> 00:02:31,885
你能做的一件事
就是在取景器中重命名文件


57
00:02:31,952 --> 00:02:33,620
有时候
这有点棘手


58
00:02:33,687 --> 00:02:37,191
你必须点击它
然后像这样


59
00:02:37,257 --> 00:02:39,293
再来一次...
我又失败了


60
00:02:39,359 --> 00:02:40,294
你的时间选择要正好


61
00:02:40,360 --> 00:02:41,695
这样你才不会双击
打开它


62
00:02:42,196 --> 00:02:43,764
但是有了
Force Touch


63
00:02:43,830 --> 00:02:45,699
我就可以
Force click它


64
00:02:45,766 --> 00:02:48,302
然后就立即
可以编辑文件名了


65
00:02:48,502 --> 00:02:49,336
编辑文件名就非常容易了


66
00:02:49,403 --> 00:02:51,271
但这只是你可以
用Force click


67
00:02:51,338 --> 00:02:52,606
完成的事情中的
小小的一件


68
00:02:52,673 --> 00:02:54,608
我要很快打开
TextEdit


69
00:02:55.242 --> 00:02:59.646 align:middle
我来捕获窗口


70
00:03:00,347 --> 00:03:02,049
你也已经看过这个例子了


71
00:03:02,115 --> 00:03:03,417
你可以
Force click


72
00:03:03,483 --> 00:03:05,686
你就可以看到
“快速浏览”


73
00:03:05,752 --> 00:03:08,255
非常奇妙
你可以坐在那儿 如果你


74
00:03:08,322 --> 00:03:12,492
调整你施加的力的程度的话
你就可以“调戏”下动画


75
00:03:12,659 --> 00:03:15,495
我们还有另外一项
功能特性


76
00:03:15,562 --> 00:03:18,065
我刚才快速向你演示了
一些东西 这个你是知道的


77
00:03:18,131 --> 00:03:20,701
通过改变力的大小
我可以改变速度


78
00:03:20,767 --> 00:03:23,470
照片显示的速度


79
00:03:23,537 --> 00:03:27,341
显示的指示器的量


80
00:03:27,407 --> 00:03:29,109
你可以控制力的量


81
00:03:29,176 --> 00:03:31,612
当然了
没有绘制区


82
00:03:31,678 --> 00:03:34,781
你就没法绘制任何东西
压力演示也就没法完成


83
00:03:35,582 --> 00:03:38,452
最后
不要像这样连接音响


84
00:03:38,519 --> 00:03:40,821
而是要在
这个控制器上...


85
00:03:40,921 --> 00:03:42,256
当你把照片
归零时


86
00:03:42,322 --> 00:03:43,957
你会感受到
轻微的触觉反馈


87
00:03:44,258 --> 00:03:45,459
就是在trackpad上


88
00:03:45,893 --> 00:03:47,694
真的很奇妙


89
00:03:48,161 --> 00:03:49,429
我们再回到幻灯片中


90
00:03:50,564 --> 00:03:51,765
我们已经讲了很多东西


91
00:03:52,299 --> 00:03:53,433
我们再来讲讲
API


92
00:03:53,500 --> 00:03:56,970
就是那个应用程序用的API
就是我们在系统中使用的


93
00:03:57,037 --> 00:03:59,039
各种API
这样你就可以在你的应用程序


94
00:03:59,106 --> 00:04:01,441
中使用Force To
Touch trackpad


95
00:04:01,508 --> 00:04:04,211
添加
各种各样的


96
00:04:04,278 --> 00:04:05,112
新的功能特性


97
00:04:06,947 --> 00:04:08,315
我今天会教你如何成为


98
00:04:08,382 --> 00:04:09,783
在OS X上使用Force
Touchtrackpad


99
00:04:09,850 --> 00:04:11,285
的“大师”


100
00:04:11,351 --> 00:04:12,286
要成为


101
00:04:12,352 --> 00:04:13,887
Force Touch
trackpad方面的大师


102
00:04:13,954 --> 00:04:14,955
尽管我们会让你在
一天内速成


103
00:04:15,022 --> 00:04:15,923
你也得从小处着手


104
00:04:15,989 --> 00:04:17,089
你得学习
所有的事情


105
00:04:17,156 --> 00:04:18,192
你得学习一个“侍从”在使用


106
00:04:18,257 --> 00:04:19,358
Force Touch
trackpad方面


107
00:04:19,426 --> 00:04:20,427
全部的知识


108
00:04:20,494 --> 00:04:22,729
这些都是与高级
API


109
00:04:23,030 --> 00:04:25,199
以及内置工具相关
这些API和工具


110
00:04:25,265 --> 00:04:26,767
有些是在我们的掌控下


111
00:04:27,301 --> 00:04:28,502
然后我们会继续 我们需要
学习一名“骑士”在使用


112
00:04:28,569 --> 00:04:29,970
Force Touch
trackpad方面


113
00:04:30,037 --> 00:04:31,538
全部
的知识


114
00:04:31,905 --> 00:04:34,842
这些都与压力流在
系统内的变化有关


115
00:04:34,908 --> 00:04:37,211
事件流
我们会讲讲如何在你的


116
00:04:37,277 --> 00:04:39,646
应用程序定制“弹性加载”
然后讲一讲进行


117
00:04:39,713 --> 00:04:41,081
“对齐反馈”的方式


118
00:04:41,148 --> 00:04:43,417
给用户提供
更多的触觉反馈


119
00:04:44,151 --> 00:04:47,087
最后
我们会让你成为


120
00:04:47,154 --> 00:04:48,322
Force Touch
trackpad


121
00:04:48,388 --> 00:04:49,223
方面的“大师”


122
00:04:49,289 --> 00:04:50,390
这与力的控制有关


123
00:04:50,524 --> 00:04:52,059
对trackpad
进行配置


124
00:04:52,359 --> 00:04:54,795
这样它可以在给定的情景中
给出适当的触觉反馈


125
00:04:54,862 --> 00:04:57,531
以便你
进行控制


126
00:04:57,931 --> 00:05:00,234le
并且在适当时机
手动进行触觉反馈


127
00:04:57,931 --> 00:05:00,234
并且在适当时机
手动进行触觉反馈


128
00:05:01,068 --> 00:05:02,703
我们来看看吧


129
00:05:05,205 --> 00:05:08,408
要成为一名“侍从” 我们要
说的是“表格行动作”


130
00:05:08,475 --> 00:05:10,010
它是一项很棒 很奇妙的
新功能


131
00:05:10,077 --> 00:05:12,145
你在克雷格在keynote
上进行的电子邮件应用程序


132
00:05:12,212 --> 00:05:13,380
演示中
已经看到过了


133
00:05:13,814 --> 00:05:15,182
我们来讲讲
弹性加载控制


134
00:05:15,249 --> 00:05:18,252
内置的一些东西
还有加速器控制


135
00:05:18,619 --> 00:05:20,387
我们会通过一些案例研究
来实现这一点


136
00:05:21,021 --> 00:05:24,124
比如说 在邮件这里
如果你在邮件的某行上做


137
00:05:24,191 --> 00:05:27,194
双指滑动这个动作
你会看到更多的


138
00:05:27,261 --> 00:05:28,762
“表格行动作”
你就可以点击它们


139
00:05:28,896 --> 00:05:31,665
或者你可以进行平滑的滑动
一个时间更长的滑动


140
00:05:31,732 --> 00:05:35,169
实际上
它会激活默认动作


141
00:05:35,269 --> 00:05:37,171
这是用户的完整手势
之一


142
00:05:37,538 --> 00:05:39,473
这样向你的应用程序中


143
00:05:39,573 --> 00:05:41,141
添加一些其它的功能
就


144
00:05:41,208 --> 00:05:42,075
非常棒


145
00:05:42,142 --> 00:05:43,677
我自己每天都在
邮件中用它


146
00:05:44,211 --> 00:05:45,913
它用的API
非常简单


147
00:05:46,246 --> 00:05:47,347
在你的tableView
授权中


148
00:05:47,414 --> 00:05:48,282
只要实现


149
00:05:48,348 --> 00:05:49,183
tableView ow


150
00:05:49,249 --> 00:05:50,250
ActionsForRow
界限即可


151
00:05:50,317 --> 00:05:52,252
我们会告诉你是什么界限
要么是前面的


152
00:05:52,319 --> 00:05:54,121
要么是后面的
这样我们就可以为你处理为


153
00:05:54,188 --> 00:05:55,189
从右到左 从左到右


154
00:05:56,523 --> 00:05:59,726
然后你只要返回一个
“表格行动作”阵列


155
00:06:00,727 --> 00:06:04,998
创建一个新NS表格行动作
你以一个类型 一个标题


156
00:06:05,065 --> 00:06:07,234
以及一个处理程序
如果选中了一个项目


157
00:06:07,634 --> 00:06:11,104
那么回调的就是这个处理程序
无论是点击选中


158
00:06:11,171 --> 00:06:13,207
或者是完成了默认的
完整的滑动


159
00:06:13,574 --> 00:06:15,976
那么它就会调用
处理程序


160
00:06:17,344 --> 00:06:20,080
我们有这么几种类型：
“规则的”以及“破坏的”


161
00:06:20,881 --> 00:06:22,883
蓝色高亮的
就是“规则的” 在你的


162
00:06:22,950 --> 00:06:25,552
“表格行动作”大部分类型中
你都应该使用


163
00:06:25,619 --> 00:06:27,221
“规则的”


164
00:06:27,855 --> 00:06:29,223
红色的是
“破坏的”


165
00:06:29,957 --> 00:06:31,825
不要因为它们的颜色
而做出选中


166
00:06:31,959 --> 00:06:33,360
它不仅仅只是红色那么简单


167
00:06:35,128 --> 00:06:38,398
破坏性的项目 因为它们
本质上就是破坏性的


168
00:06:38,465 --> 00:06:39,967
事实上
我们也让用户更难完成一次


169
00:06:40,033 --> 00:06:41,635
完整的滑动


170
00:06:41,768 --> 00:06:44,004
他们必须在trackpad
上滑动较长的距离


171
00:06:44,271 --> 00:06:47,541
这样才能触发
默认的


172
00:06:47,608 --> 00:06:48,442
破坏性的动作


173
00:06:48,642 --> 00:06:51,345
这样是为了防止他们
意外触发破坏性的动作


174
00:06:51,745 --> 00:06:54,181
尽量在所有的事情上使用
“规则的”


175
00:06:54,248 --> 00:06:57,251
把“破坏的”留给
破坏性的项目


176
00:06:57,317 --> 00:07:00,687
不要尝试用红色
它的语义非常重要


177
00:07:00,754 --> 00:07:01,622
你要注意这一点


178
00:07:03,223 --> 00:07:04,591
这个API就是
这样


179
00:07:04,791 --> 00:07:05,626
非常简单


180
00:07:05,792 --> 00:07:07,628
这个适用于新的
Force Touch trackpad


181
00:07:07,694 --> 00:07:08,795
也同样适用于我们的


182
00:07:08,862 --> 00:07:11,064
老款trackpads
和Magic Mouse


183
00:07:11,265 --> 00:07:13,300
这样你很容易就能把它们
加到你的应用程序中


184
00:07:13,600 --> 00:07:16,069
你就可以开启新的
奇妙的可能


185
00:07:17,871 --> 00:07:19,740
我们再来看看
取景器中的“弹性加载”


186
00:07:19,806 --> 00:07:23,677
我这里有下载的一张
洛拉的图像


187
00:07:23,744 --> 00:07:25,746
我想把她移动到
“我的文档”文件夹


188
00:07:25,812 --> 00:07:27,114
我要通过
Force clicking


189
00:07:27,181 --> 00:07:28,348
开始拖动它


190
00:07:28,415 --> 00:07:31,051
回到我的历史
我甚至还要改成图标模式


191
00:07:31,118 --> 00:07:32,853
这样我就能更加容易地
找到文档文件夹


192
00:07:33,020 --> 00:07:35,189
最后 把它放进“我的文档”
文件夹


193
00:07:35,923 --> 00:07:38,025
你之前可能已经知道了
弹性加载


194
00:07:38,392 --> 00:07:40,561
你可以悬停在一个文件夹上
超时后


195
00:07:40,627 --> 00:07:43,330
文件夹就会进行
弹性加载


196
00:07:43,664 --> 00:07:45,299
我们向许多地方
和应用程序中添加了


197
00:07:45,365 --> 00:07:47,100
弹性加载
以便把窗口置前


198
00:07:47,501 --> 00:07:49,436
就像你刚才看到的
按钮是弹性加载的


199
00:07:49,670 --> 00:07:52,306
你只要进行Force
click 就可以越过


200
00:07:52,372 --> 00:07:53,473
悬停超时


201
00:07:53,540 --> 00:07:58,078
这样用起来就更直观
更便利


202
00:07:59.346 --> 00:08:02.082 align:middle
要在这项工具栏按钮上


203
00:07:59,346 --> 00:08:02,082
要在这项工具栏按钮上


204
00:08:02,149 --> 00:08:05,652
实现弹性加载
取景器所做的


205
00:08:05,719 --> 00:08:08,255
就是把NSButton的弹
性加载属性设置为“真”


206
00:08:09,189 --> 00:08:10,724
他们就是在IB内校验了下
框


207
00:08:10,791 --> 00:08:11,692
就这么简单


208
00:08:11,758 --> 00:08:13,894
分段控制
你也可以这么做


209
00:08:13,961 --> 00:08:17,631
当我把图标布局
从列表视图改为图标视图


210
00:08:18,031 --> 00:08:19,433
那就是
NSSegmentedControl


211
00:08:19,499 --> 00:08:21,702
再说一遍 它就是个
springLoaded属性


212
00:08:21,768 --> 00:08:23,937
你可以在IB的一个勾选框
上进行设置


213
00:08:24,004 --> 00:08:27,140
在你的按钮 分段控制上
打开弹性加载


214
00:08:27,407 --> 00:08:28,408
就这么简单


215
00:08:28,642 --> 00:08:31,078
你可以勾选使用
但是如果是


216
00:08:31,144 --> 00:08:33,080
在导航中
那么拖放


217
00:08:33,145 --> 00:08:34,948
就很有用
我建议你们去试试


218
00:08:35,015 --> 00:08:35,916
打开它


219
00:08:37,384 --> 00:08:40,354
这是施加力的另一个实例
这是QuickTime


220
00:08:40,419 --> 00:08:42,856
我想让你们注意看这里的
这个快进按钮


221
00:08:44,057 --> 00:08:45,325
我要使用
ForceTouchtrackpad


222
00:08:45,392 --> 00:08:46,660
我要向那个按钮


223
00:08:46,727 --> 00:08:48,095
施加不同的
压力


224
00:08:48,161 --> 00:08:50,497
你可以看到 我可以达到5x
10x 30x


225
00:08:50,764 --> 00:08:51,598
你也可以放慢速度


226
00:08:51,999 --> 00:08:53,734
当你翻看你的
电影文件时


227
00:08:54,067 --> 00:08:55,969
你可以控制前进的
速度


228
00:08:56,036 --> 00:08:58,138
当你接近你要找的区域时
你就可以放慢速度


229
00:08:58.205 --> 00:09:00.040 align:middle
避免
跑过头


230
00:08:58,205 --> 00:09:00,040
避免
跑过头


231
00:09:01,808 --> 00:09:03,410
QuickTime能这样做
是因为


232
00:09:03,477 --> 00:09:04,845
我们有了一种新的按钮类型


233
00:09:04,912 --> 00:09:08,815
因此快进按钮就是带有自定义
图像的NSButtons


234
00:09:08,882 --> 00:09:11,518
它们可以
把按钮的类型设为


235
00:09:11,652 --> 00:09:13,253
Accelerator
Button或者


236
00:09:13,320 --> 00:09:14,855
MultiLevel
AcceleratorButton


237
00:09:15,522 --> 00:09:17,057
对Accelerator
Button来说


238
00:09:17,124 --> 00:09:18,592
你可以在IB这里设置


239
00:09:20,594 --> 00:09:23,096
当trackpad上的力
发生改变时


240
00:09:23,363 --> 00:09:25,432
这个按钮就会持续
发送活动消息


241
00:09:25,532 --> 00:09:27,601
因此当力发生改变时
你就会得到新的活动消息


242
00:09:27,734 --> 00:09:29,736
如果力再次发生改变
你又会收到新的活动消息


243
00:09:30,270 --> 00:09:33,006
当用户点击按钮达到
两次时


244
00:09:33,073 --> 00:09:35,609
doubleValue的域
为1 这是因为


245
00:09:35,676 --> 00:09:38,679
用户达到了
我们在trackpad上


246
00:09:38,745 --> 00:09:41,682
接受的力的按压的最大值


247
00:09:42,850 --> 00:09:45,552
你可以看到
压力在1到2之间变动


248
00:09:45,619 --> 00:09:48,288
你可以
随意


249
00:09:48,355 --> 00:09:49,656
对它
进行调整


250
00:09:49,723 --> 00:09:52,960
QuickTime这个实例
中 它控制的是加速度


251
00:09:54,027 --> 00:09:55,729
你最终得到的值
为零


252
00:09:55,796 --> 00:09:58,065
当用户结束追踪按钮时
你会得到


253
00:09:58.131 --> 00:10:00.334 align:middle
一条值为零的
活动消息


254
00:09:58,131 --> 00:10:00,334
一条值为零的
活动消息


255
00:10:00,634 --> 00:10:01,935
当他们释放
鼠标按钮时


256
00:10:02,402 --> 00:10:04,471
你会得到最后一条
域为零的活动消息


257
00:10:05,506 --> 00:10:07,441
实际上 QuickTime
在这里使用的


258
00:10:07,508 --> 00:10:09,409
就是MultiLevel
AcceleratorButton


259
00:10:09,977 --> 00:10:11,712
你可以在IB这里
进行设置


260
00:10:12,312 --> 00:10:13,981
MultiLevel
AcceleratorButton


261
00:10:14,047 --> 00:10:15,616
是离散的


262
00:10:15,983 --> 00:10:19,753
而AcceleratorB
utton是一个平滑域


263
00:10:19,820 --> 00:10:21,455
一个介于一到二之间的
连续域


264
00:10:21,622 --> 00:10:24,291
AcceleratorBu
tton是整数层


265
00:10:24,358 --> 00:10:25,959
是一个离散整数层
你可以用


266
00:10:26,026 --> 00:10:28,295
max
AcceleratorLevel


267
00:10:28,362 --> 00:10:29,329
对它 进行设置


268
00:10:29,663 --> 00:10:33,166
我们的域是介于一到五
因此你可以设置


269
00:10:33,233 --> 00:10:35,169
在你的加速中
你想要的层数


270
00:10:35,936 --> 00:10:37,704
默认是二


271
00:10:38,205 --> 00:10:39,806
QuickTime把它设置
成了五


272
00:10:40,274 --> 00:10:42,242
你又看到了
doubleValue


273
00:10:42,309 --> 00:10:45,212
域为零到五
当你点击时为一


274
00:10:45,279 --> 00:10:46,713
当用户上升
层级时


275
00:10:46,780 --> 00:10:48,982
它会上升到
你设置的最大层级


276
00:10:49,349 --> 00:10:51,652
当用户停止追踪时
你会得到零的最终


277
00:10:51,718 --> 00:10:53,287
活动消息


278
00:10:53,387 --> 00:10:54,888
QuickTime做的
就是这个


279
00:10:54,955 --> 00:10:55,889
这里你可以看到


280
00:10:55,956 --> 00:10:57,658
QuickTime是
如何映射你的各种速度为


281
00:10:57.724 --> 00:11:00.494 align:middle
一、二、三、四、五


282
00:10:57,724 --> 00:11:00,494
一、二、三、四、五


283
00:11:00,561 --> 00:11:03,463
比如说
三就是10x快进


284
00:11:05,666 --> 00:11:08,769
加速器控制的另一个实例：
这是“地图”


285
00:11:09,436 --> 00:11:11,171
“地图”上有这个
漂亮的缩放按钮


286
00:11:11,972 --> 00:11:13,473
实际上


287
00:11:13,540 --> 00:11:16,143
这些是当做NSSegmented
Controls


288
00:11:16,210 --> 00:11:17,044
实现的


289
00:11:17,144 --> 00:11:18,212
NSSegmentedControls


290
00:11:18,278 --> 00:11:19,179
有一种新的追踪模式


291
00:11:19,246 --> 00:11:21,048
即Momentary
Accelerator


292
00:11:21,114 --> 00:11:24,017
它和加速器
NSButtonType


293
00:11:24,084 --> 00:11:26,653
的工作方式一模一样


294
00:11:27,387 --> 00:11:29,156
在IB中设置这个
同样也非常容易


295
00:11:30,190 --> 00:11:31,692
但是当分段控制活动消息
发出后


296
00:11:31,758 --> 00:11:34,595
你应该请求选定的分段的
doubleValue


297
00:11:34,761 --> 00:11:35,963
而不是
请求


298
00:11:36,029 --> 00:11:37,231
doubleValue


299
00:11:37,698 --> 00:11:40,334
它和我们之前谈到的
域是一样的


300
00:11:40,400 --> 00:11:43,937
当用户结束追踪时
它为一到二


301
00:11:44,004 --> 00:11:45,105
并且最后活动消息值为零


302
00:11:46,440 --> 00:11:49,209
分段控制
没有多层选项


303
00:11:49,443 --> 00:11:51,912
它们仅仅支持
连续模式


304
00:11:55,048 --> 00:11:56,350
这是一个照片的例子


305
00:11:57,184 --> 00:12:02,389
通过施加力 调整力
浏览


306
00:12:03,090 --> 00:12:04,258
“照片”中的照片


307
00:12:04,324 --> 00:12:07,027
我可以控制照片移动的
速度


308
00:12:07,794 --> 00:12:10,898
我们称之为
连续加速控制


309
00:12:11,598 --> 00:12:13,233
如果你在NSButton


310
00:12:13,300 --> 00:12:14,568
或者NSSegmented
Control上


311
00:12:14,635 --> 00:12:16,203
有一项
加速控制设置


312
00:12:16,537 --> 00:12:18,272
你可以在
NSControl节


313
00:12:18,338 --> 00:12:20,140
把连续标志设置为“真”


314
00:12:20,340 --> 00:12:22,042
或者在IB中勾选框


315
00:12:22,776 --> 00:12:26,380
你就可以得到我们所说的
连续加速控制


316
00:12:27,181 --> 00:12:29,116
连续加速控制
是不同的


317
00:12:29,183 --> 00:12:30,884
因为你不太需要关心


318
00:12:30,951 --> 00:12:31,852
它们的
doubleValues


319
00:12:31,919 --> 00:12:33,921
当动作发生时
你只是想尽快移动到


320
00:12:33,987 --> 00:12:34,888
下一个滑动上


321
00:12:34,955 --> 00:12:37,024
doubleValue
无关紧要


322
00:12:37,090 --> 00:12:39,193
它们会像心跳一样
回来


323
00:12:39,359 --> 00:12:41,662
而力会改变
心跳的频率


324
00:12:42,029 --> 00:12:42,996
这就是区别所在


325
00:12:43,263 --> 00:12:46,400
要把问题讲清楚
让我们来对两者进行对比


326
00:12:46,967 --> 00:12:48,068
在加速控制中


327
00:12:48,936 --> 00:12:51,638
只要压力发生变化 我们
就可以获取到你的活动消息


328
00:12:51,705 --> 00:12:53,841
因此
可能会有延迟


329
00:12:54,041 --> 00:12:56,043
它们可能会互相靠近


330
00:12:56,243 --> 00:12:58,378
这样你就改变了
你在电影中


331
00:12:58.445 --> 00:12:59.279 align:middle
的快进速度


332
00:13:00,280 --> 00:13:04,952
如果是连续控制
对连续加速来说


333
00:13:05,018 --> 00:13:06,186
它会参加到心跳中


334
00:13:06,253 --> 00:13:07,754
然后你就可以
完成你的动作


335
00:13:07,921 --> 00:13:09,923
如果用户施加了多次力
频率会很高


336
00:13:09,990 --> 00:13:12,559
它们
可能会


337
00:13:12,626 --> 00:13:13,460
紧密结合起来


338
00:13:13,527 --> 00:13:16,763
像滑动照片
此时动画速度是连续的


339
00:13:16,830 --> 00:13:19,199
它就非常适合
不过你何时应该呈现


340
00:13:19,266 --> 00:13:20,501
下一张照片？


341
00:13:20,734 --> 00:13:22,436
应该在
下次发出活动消息时呈现


342
00:13:22,703 --> 00:13:24,171
它为用户提供了
许多控制


343
00:13:25,472 --> 00:13:27,274
要成为一个“侍从”
你需要了解的就这些


344
00:13:27,341 --> 00:13:28,876
恭喜
你们现在都成了使用


345
00:13:28,942 --> 00:13:30,711
Force Touch
trackpads方面的“侍从”


346
00:13:30,777 --> 00:13:33,514
我们讲了“表格行动作”
一个非常容易实现的API


347
00:13:33,580 --> 00:13:35,949
弹性加载
NSButtons


348
00:13:36,016 --> 00:13:38,452
加速器NS
Buttons 分段控制


349
00:13:38,585 --> 00:13:41,522
打开它们很容易
我们的高层API


350
00:13:41,622 --> 00:13:45,092
使用这些API
在这里真的物有所值


351
00:13:45,392 --> 00:13:47,327
我们希望你们在你们的
应用程序内打开它们


352
00:13:48,428 --> 00:13:49,596
我们接着来看看
怎样成为一名“骑士”


353
00:13:50,531 --> 00:13:51,665
要成为一名“骑士”


354
00:13:51,732 --> 00:13:54,201
那就需要理解力在系统内的
流动方式


355
00:13:54,701 --> 00:13:56,570
我们来讲一下
力的事件流


356
00:13:57,437 --> 00:13:58,438
然后我会讲一下


357
00:13:58.505 --> 00:14:01.074 align:middle
弹性加载
协议


358
00:13:58,505 --> 00:14:01,074
弹性加载
协议


359
00:14:01,141 --> 00:14:04,778
这样你就可以使用和
NSButton相同的API


360
00:14:04,978 --> 00:14:07,381
在你的自定义应用程序内
提供弹性加载


361
00:14:08,015 --> 00:14:11,451
我们最后会谈一些
对齐反馈API


362
00:14:11,518 --> 00:14:15,122
可以帮助你进行对齐
指导以及类似的事情


363
00:14:16,390 --> 00:14:17,391
我们再来谈谈
事件流


364
00:14:18,292 --> 00:14:20,427
我们在OS X已经
有了很多事件


365
00:14:21,228 --> 00:14:23,096
你向上和向下移动鼠标


366
00:14:23,163 --> 00:14:26,233
你的放大 旋转
手势


367
00:14:26,500 --> 00:14:27,901
现在我们再介绍一个：


368
00:14:28,001 --> 00:14:29,303
NSEventType
Pressure


369
00:14:30,103 --> 00:14:32,506
实际上 它是我们在10.1
0.3介绍


370
00:14:32,573 --> 00:14:33,941
新MacBooks时
引入的


371
00:14:34,274 --> 00:14:37,711
你也可以在那里
获得


372
00:14:38,712 --> 00:14:40,080
它们是压力手势


373
00:14:41,114 --> 00:14:42,783
当然了
和新的事件类型


374
00:14:42,850 --> 00:14:46,520
我们有事件掩码：
NSEventMaskPressure


375
00:14:46,854 --> 00:14:49,056
这意味着
在你的跟踪回路中


376
00:14:49,590 --> 00:14:51,158
你可以向你的跟踪回路中
添加


377
00:14:51,225 --> 00:14:52,993
事件掩码压力


378
00:14:53,694 --> 00:14:56,730
当你追踪鼠标时
你也可以让


379
00:14:56,797 --> 00:14:58,432
压力事件
起作用


380
00:14:59.166 --> 00:15:00.200 align:middle
使用真的很方便


381
00:14:59,166 --> 00:15:00,200
使用真的很方便


382
00:15:01,702 --> 00:15:03,504
如果你更喜欢
响应器这种方式 这样你可以


383
00:15:03,570 --> 00:15:06,640
覆盖鼠标向上
鼠标拖动 鼠标向下


384
00:15:06,707 --> 00:15:08,642
我们也还有一种新的
响应器方式


385
00:15:08,709 --> 00:15:10,043
pressureChange
WithEvent


386
00:15:10,110 --> 00:15:11,011
这样如果你喜欢的话


387
00:15:11,078 --> 00:15:11,979
你就可以获取它们


388
00:15:14,348 --> 00:15:17,317
我们再来挖掘下
压力手势的属性


389
00:15:17,651 --> 00:15:20,420
这是一种手势
和鼠标事件序列不同


390
00:15:20,487 --> 00:15:23,190
后者为鼠标上移 鼠标拖动
鼠标下移有个体类型


391
00:15:23,257 --> 00:15:26,593
压力只有
单一类型


392
00:15:26,960 --> 00:15:29,897
它有一个段
会经历开始 改变 结束


393
00:15:30,130 --> 00:15:32,065
这样的一个循环
直到手势结束


394
00:15:33,534 --> 00:15:34,701
我们也有一个阶段


395
00:15:34,835 --> 00:15:35,869
阶段是指我们如何确定


396
00:15:35,936 --> 00:15:37,437
Force click
是否发生了


397
00:15:37,804 --> 00:15:40,707
当你用trackpad
进行鼠标下移


398
00:15:40,774 --> 00:15:43,343
你会得到“开始”段


399
00:15:43,410 --> 00:15:46,346
压力手势
它是阶段一


400
00:15:46,413 --> 00:15:48,882
这是标准
点击层次


401
00:15:48,949 --> 00:15:50,484
用户增加力度


402
00:15:50,551 --> 00:15:51,952
在trackpad上达到了
Force click


403
00:15:52,019 --> 00:15:53,687
层级
就变成了阶段二


404
00:15:53,754 --> 00:15:56,390
这样你就知道用户实现了
Force click


405
00:15:56,790 --> 00:15:59,459
你就可以立即完成你的For
ce click动作


406
00:15:59,526 --> 00:16:01,728iddle
比如说
重命名取景器


407
00:15:59,526 --> 00:16:01,728
比如说
重命名取景器


408
00:16:02,763 --> 00:16:03,964
这样当用户
从trackpad上


409
00:16:04,031 --> 00:16:05,332
释放力的时候


410
00:16:05,799 --> 00:16:08,035
当它到达点击层级时
就会返回阶段一


411
00:16:08,101 --> 00:16:10,504
当手势结束时
最终到了阶段零


412
00:16:10,904 --> 00:16:15,275
因为鼠标按下去后
就不再往下了


413
00:16:15,742 --> 00:16:19,913
这样得到了阶段零
“结束”段的最后事件


414
00:16:21,849 --> 00:16:25,152
现在 当然了
没有真正的压力值


415
00:16:25,219 --> 00:16:26,620
就不会完成任何
压力手势


416
00:16:26,687 --> 00:16:28,322
因此我们也有
压力属性


417
00:16:28,388 --> 00:16:29,723
它的域为
零到一


418
00:16:30,858 --> 00:16:32,159
注意这里


419
00:16:32,226 --> 00:16:34,328
压力属性
就是当前阶段的


420
00:16:34,394 --> 00:16:35,395
压力


421
00:16:35,462 --> 00:16:36,730
正如你在这个图表中看到的


422
00:16:36,797 --> 00:16:39,499
当你进入阶段一
压力开始上升


423
00:16:39,566 --> 00:16:43,003
并且在你进入阶段二时
达到了1


424
00:16:43,070 --> 00:16:45,239
当你越过阶段二
压力立即掉回了零


425
00:16:45,305 --> 00:16:47,574
当你在阶段二增加压力时
压力又重新


426
00:16:47,975 --> 00:16:51,445
开始
上升


427
00:16:51,512 --> 00:16:54,381
压力属于
当前阶段


428
00:16:55,015 --> 00:16:55,849
现在我展示的是


429
00:16:57,217 --> 00:16:59,953
trackpad上的力
和用户在压力事件中的值


430
00:17:00,020 --> 00:17:03,357
这两者
之间的


431
00:17:03,423 --> 00:17:05,459
线性映射
但是


432
00:17:05,526 --> 00:17:06,527
我不希望你们过度曲解


433
00:17:07,160 --> 00:17:10,263
我们喜欢把trackpad
上的每次点击


434
00:17:10,329 --> 00:17:12,999
都当成一次冒险
我们看到了很多


435
00:17:13,066 --> 00:17:15,769
不同的变量
用户使用他们的拇指


436
00:17:15,836 --> 00:17:18,505
他们偏好的
硬度设置


437
00:17:18,972 --> 00:17:20,874
他们如何与trackpad
进行交互


438
00:17:20,941 --> 00:17:23,109
因此我们忙着对这些曲线
进行动态变更


439
00:17:23,176 --> 00:17:25,145
给用户
尽可能好的体验


440
00:17:25,512 --> 00:17:28,281
我们把trackpad的输
入标准化为


441
00:17:28,682 --> 00:17:30,484
零到一的
压力域


442
00:17:30,784 --> 00:17:32,452
你在你的应用程序中
也应该用这个


443
00:17:35,055 --> 00:17:37,157
你可能注意到了
之前我在演示时四处点击


444
00:17:37,224 --> 00:17:39,826
仅仅在TextEdit
四处点击


445
00:17:40,394 --> 00:17:44,965
我并不会看到
动画弹出


446
00:17:45,032 --> 00:17:46,834
直到我离的足够近
施加的压力非常接近


447
00:17:46,900 --> 00:17:47,901
Force click


448
00:17:48,936 --> 00:17:51,371
当用户只是随意点击时
你不会希望有


449
00:17:51,438 --> 00:17:52,673
一大堆的动画
出现


450
00:17:52,739 --> 00:17:54,174
分散
用户的注意


451
00:17:54,341 --> 00:17:57,845
当他们接近转移到
阶段二时


452
00:17:57,911 --> 00:17:59,012
这个动画很有用


453
00:17:59.346 --> 00:18:00.981 align:middle
阶段的
转移属性


454
00:17:59,346 --> 00:18:00,981
阶段的
转移属性


455
00:18:01,048 --> 00:18:02,015
就是用来干这个的


456
00:18:02,149 --> 00:18:04,284
你可以在这里看到
它的域为零到一


457
00:18:04,351 --> 00:18:07,154
但是在零这里
停留了很长时间


458
00:18:07,221 --> 00:18:09,389
直到你开始
接近下一阶段


459
00:18:09,456 --> 00:18:10,490
这个例子中是阶段二


460
00:18:11,058 --> 00:18:13,927
我想让你们接近阶段二
它会暴涨到一


461
00:18:13,994 --> 00:18:17,731
你可以用这个域
控制你的动画


462
00:18:18,031 --> 00:18:19,600
而如果你只是在界面内
随意点击


463
00:18:19,666 --> 00:18:21,168
它就不会妨碍你


464
00:18:21,635 --> 00:18:23,604
你可以得到这个动画
你一接近阶段二


465
00:18:23,670 --> 00:18:26,006
你就可以弹出
结束动画


466
00:18:26,073 --> 00:18:29,510
你可以看到
你一接近阶段二


467
00:18:29,576 --> 00:18:32,346
阶段过渡值就掉回了零
在这个例子中


468
00:18:32,412 --> 00:18:34,982
我们没有阶段三可以过渡
因此剩余的时间


469
00:18:35,048 --> 00:18:36,717
它仍然停在零


470
00:18:38,085 --> 00:18:42,222
我之前提到过
当压力手势存在


471
00:18:42,289 --> 00:18:45,392
鼠标事件
也就同时继续


472
00:18:45,492 --> 00:18:47,761
trackpad还是会
继续模仿鼠标


473
00:18:48,695 --> 00:18:51,632
它也会发出
压力手势


474
00:18:51,698 --> 00:18:54,034
我要看看
这些流是如何在系统中


475
00:18:54,101 --> 00:18:55,335
同时并行


476
00:18:55,669 --> 00:18:56,770
我们接着要讲的
就是这个


477
00:18:56,837 --> 00:19:00,841
这是一个实例 用户向tra
ckpad施加力


478
00:19:01,141 --> 00:19:02,242
进行点击
慢慢接近


479
00:19:02,309 --> 00:19:03,710
Force click
阈值


480
00:19:03,777 --> 00:19:05,245
然后释放了
压力


481
00:19:05,312 --> 00:19:06,180
这就是他们的输入


482
00:19:06,513 --> 00:19:08,949
下面这里
我们要向你演示


483
00:19:09,016 --> 00:19:10,217
进入你的应用程序的事件


484
00:19:11,051 --> 00:19:13,253
一开始
用户施加的是轻微的压力


485
00:19:13,854 --> 00:19:15,789
这些就是全部的鼠标移动


486
00:19:15,856 --> 00:19:18,058
我们还没有到达
点击阈值


487
00:19:18,392 --> 00:19:20,394
我们还没有开始
压力手势


488
00:19:20,494 --> 00:19:21,628
这些只是鼠标移动


489
00:19:21,795 --> 00:19:23,597
还没有
压力手势进来


490
00:19:24,698 --> 00:19:27,034
你达到点击阈值
出现了鼠标下移


491
00:19:27,568 --> 00:19:31,138
你也到了阶段一
得到压力开始事件


492
00:19:31,438 --> 00:19:33,674
此时
压力值要变成零


493
00:19:34,274 --> 00:19:35,142
我们不能保证


494
00:19:35,209 --> 00:19:38,178
是压力开始事件先发生
还是


495
00:19:38,245 --> 00:19:41,114
鼠标向下先发生
它们有时候会交换位置


496
00:19:41,882 --> 00:19:45,252
处理这个最容易的方式
是寻找鼠标向下这个事件


497
00:19:45,319 --> 00:19:47,354
如果你也要压力事件
那么在鼠标向下发生之后


498
00:19:47,421 --> 00:19:49,022
继续寻找
压力事件


499
00:19:50,390 --> 00:19:53,026
当用户开始向trackpa
d施加更多的力


500
00:19:53,093 --> 00:19:54,995
你可以看到 当我们接近
Force click阈值时


501
00:19:55,062 --> 00:19:56,697
压力
朝着一升上去了


502
00:19:57,197 --> 00:19:58,999
如果光标移动
这些将作为鼠标拖动事件


503
00:19:59.066 --> 00:20:00.267 align:middle
体现出来


504
00:19:59,066 --> 00:20:00,267
体现出来


505
00:20:00,334 --> 00:20:01,602
你就有了鼠标拖动事件
以及


506
00:20:01,668 --> 00:20:03,570
压力事件
我们仍然处于阶段一


507
00:20:04,037 --> 00:20:05,739
我们达到了Force
click阈值


508
00:20:06,340 --> 00:20:08,575
现在你在阶段二得到了
压力手势


509
00:20:08,642 --> 00:20:11,278
压力值
一路掉回了零


510
00:20:12,079 --> 00:20:14,515
用户继续向trackpad
施加更大的力


511
00:20:14,815 --> 00:20:17,117
压力再次开始增加 当他们从
trackpad上释放


512
00:20:17,184 --> 00:20:18,986
压力时
它就开始


513
00:20:19,052 --> 00:20:20,420
朝着零回落


514
00:20:20,988 --> 00:20:23,190
现在他们释放回到了Forc
e click阈值


515
00:20:23,257 --> 00:20:24,324
压力为零


516
00:20:25,859 --> 00:20:27,427
此时
我们仍然处于阶段二


517
00:20:28,295 --> 00:20:30,531
用户再多释放
一点压力


518
00:20:30,664 --> 00:20:31,899
我们也仍然处于阶段二


519
00:20:32,533 --> 00:20:34,601
实际上 在这个图表上
我们夸张了一点


520
00:20:35,102 --> 00:20:37,638
不过对于一个人来说
在trackpad上以一个


521
00:20:37,704 --> 00:20:39,706
恒速保持压力
非常困难


522
00:20:39,773 --> 00:20:42,209
如果他们恰好处于Force
click层级 他们就会


523
00:20:42,276 --> 00:20:44,444
超越 然后略微下降
我们并不希望


524
00:20:44,511 --> 00:20:45,979
触发 关闭Force
click


525
00:20:46,046 --> 00:20:47,181
触发 关闭 触发 关闭


526
00:20:47,247 --> 00:20:48,615
这不是用户
想做的


527
00:20:48,916 --> 00:20:52,319
我们要求你往Force
click阈值下


528
00:20:52,386 --> 00:20:55,856
多降一点
直到我们最终脱离阶段二


529
00:20:56,390 --> 00:20:58,992
然后我们给你最终的
阶段一事件


530
00:20:59.493 --> 00:21:00.594 align:middle
在那个小的时间段内


531
00:20:59,493 --> 00:21:00,594
在那个小的时间段内


532
00:21:00,661 --> 00:21:03,964
事件的压力
将为零


533
00:21:04,298 --> 00:21:06,233
很明显 你在Force
click阈值下方


534
00:21:06,300 --> 00:21:07,868
压力将会
开始上升


535
00:21:09,403 --> 00:21:13,140
既然你处于阶段一
用户继续释放


536
00:21:13,340 --> 00:21:16,276
压力上升
再次开始回来


537
00:21:16,343 --> 00:21:18,412
你注意到 它并不是
一路跳回阶段一


538
00:21:18,478 --> 00:21:20,047
因为那是
间隙的一部分


539
00:21:20,647 --> 00:21:23,450
要注意的一点是
这就是为什么你不应该


540
00:21:23,517 --> 00:21:25,519
尝试合并阶段一
和阶段二 获得更大的


541
00:21:25,586 --> 00:21:27,487
动态范围的
原因


542
00:21:27,554 --> 00:21:30,157
但我们到了“大师”阶段时
我们会再


543
00:21:30,224 --> 00:21:32,326
多谈谈


544
00:21:32,659 --> 00:21:33,894
无论何时发生阶段二


545
00:21:33,961 --> 00:21:37,097
我们也会自动提供触觉反馈
因此不要尝试把


546
00:21:37,164 --> 00:21:38,899
压力
合并到两个阶段


547
00:21:39,233 --> 00:21:41,869
要么看着阶段一 使用压力
要么看着阶段二 使用压力


548
00:21:41,969 --> 00:21:43,403
如果你需要在后者
进行你的动画


549
00:21:43,470 --> 00:21:46,273
或者
阶段过渡属性


550
00:21:48,942 --> 00:21:52,212
我们达到了阶段一的
点击阈值点


551
00:21:52,279 --> 00:21:53,514
因此你的压力现在回到了零


552
00:21:53,580 --> 00:21:55,415
就像我们用
Force click阈值


553
00:21:55,482 --> 00:21:57,017
做的那样
实际上 在我们


554
00:21:57,084 --> 00:21:58,685
最终从阶段一释放之前


555
00:21:58,752 --> 00:22:03,490iddle
用户
必须释放更多的力


556
00:21:58,752 --> 00:22:03,490
用户
必须释放更多的力


557
00:22:04,124 --> 00:22:06,693
我们要施加一个力
结束时阶段为零


558
00:22:06,760 --> 00:22:08,495
鼠标上移


559
00:22:08,896 --> 00:22:11,198
还是这样
无法保证是鼠标上移先发生


560
00:22:11,265 --> 00:22:13,634
还是
压力结束事件


561
00:22:14,101 --> 00:22:16,737
先发生
处理这个最容易的方式是：


562
00:22:16,803 --> 00:22:19,439
寻找鼠标上移
同时追踪压力


563
00:22:19,506 --> 00:22:21,108
和鼠标运动
直到


564
00:22:21,175 --> 00:22:22,976
发生了鼠标上移


565
00:22:23,243 --> 00:22:25,612
忽略任何可能在压力事件
之前


566
00:22:25,679 --> 00:22:26,747
之后发生的序列


567
00:22:27,247 --> 00:22:31,885
这个适用于Mice
也同样适用于我们的


568
00:22:31,952 --> 00:22:33,220
老款trackpads


569
00:22:33,287 --> 00:22:34,454
以及新
ForceTouchtrackpads


570
00:22:35,055 --> 00:22:37,457
最后 鼠标上移后
如果用户用非常非常轻微的


571
00:22:37,524 --> 00:22:39,927
压力四处移动
这些鼠标移动


572
00:22:40,093 --> 00:22:42,396
压力手势结束了
我们会再次开始循环


573
00:22:42,462 --> 00:22:44,131
就像
我们一开始做的那样


574
00:22:45,966 --> 00:22:49,102
如果压力会和这个鼠标下移
联系起来


575
00:22:49,169 --> 00:22:50,904
了解鼠标下移


576
00:22:50,971 --> 00:22:53,407
就
非常重要


577
00:22:53,607 --> 00:22:56,610
是否来自一台
模仿鼠标的设备？


578
00:22:56,677 --> 00:22:58,712
是否给出了
压力手势事件？


579
00:22:59,313 --> 00:23:01,815
我们就是通过使用
鼠标下移事件上的


580
00:23:01,882 --> 00:23:04,017
associatedEve
ntMask属性


581
00:23:04,484 --> 00:23:06,153
来帮助你做这个


582
00:23:06,220 --> 00:23:08,222
你在鼠标移动事件上
也可以看到这个


583
00:23:09,089 --> 00:23:09,990
使用真的非常方便


584
00:23:10,991 --> 00:23:12,860
你为associated
EventMask


585
00:23:12,926 --> 00:23:13,861
请求鼠标下移事件


586
00:23:13,927 --> 00:23:16,363
你发现它包括了
EventMaskPressure


587
00:23:16,430 --> 00:23:18,198
如果你正在使用Cocoa


588
00:23:18,265 --> 00:23:20,200
你就用
NSEventMaskPressure


589
00:23:20,267 --> 00:23:21,735
把它结束了


590
00:23:21,802 --> 00:23:23,237
因为你正在校验
位域


591
00:23:24,605 --> 00:23:27,040
如果它确实包括EventM
askPressure


592
00:23:27,107 --> 00:23:29,376
你知道压力事件
就要来了


593
00:23:29,443 --> 00:23:32,746
你就可以把它设置好 这样
你就可以有不同的笔刷宽度


594
00:23:33,013 --> 00:23:34,014
比如说在你绘画时


595
00:23:34,081 --> 00:23:34,915
这很棒


596
00:23:35,415 --> 00:23:37,150
如果它不包括
EventMaskPressure


597
00:23:37,618 --> 00:23:41,221
那么它就来自一个鼠标
或者 比如说


598
00:23:41,288 --> 00:23:43,090
一台老款trackpad
此时你想选择一个默认的


599
00:23:43,156 --> 00:23:45,192
笔刷宽度


600
00:23:45,259 --> 00:23:47,961
通常你在此时选择
最大的笔刷宽度


601
00:23:48,328 --> 00:23:51,532
或者你想要选择
一半的笔刷宽度


602
00:23:51,732 --> 00:23:53,166
你在整个鼠标拖动序列中


603
00:23:53,600 --> 00:23:55,969
都
使用这个定值


604
00:23:57,738 --> 00:24:01,141
这是新EventTypeP
ressure


605
00:24:02,543 --> 00:24:05,179
它有很多新属性
有一个段


606
00:24:05,546 --> 00:24:07,681
因为它是一个手势
当前阶段的压力


607
00:24:07,748 --> 00:24:10,751
位于零到一
的域内


608
00:24:11,051 --> 00:24:12,653
当然你有阶段
你很容易就可以看到


609
00:24:12,719 --> 00:24:14,288
当用户达到
Force click


610
00:24:14,354 --> 00:24:15,556
那些过渡动画的阶段过渡


611
00:24:15,622 --> 00:24:17,257
相连
事件掩码


612
00:24:17,324 --> 00:24:20,194
你知道 当你的鼠标事件
会有压力


613
00:24:20,260 --> 00:24:21,828
与它们
相连时


614
00:24:22,196 --> 00:24:24,031
当然
如果你使用了响应器方式


615
00:24:24,097 --> 00:24:25,332
事件响应器方式


616
00:24:25,532 --> 00:24:26,834
会引起
压力变化


617
00:24:28,335 --> 00:24:29,736
我们再来讲讲
弹性加载


618
00:24:29,803 --> 00:24:31,905
讲一讲NSButton是如
何实现弹性加载的


619
00:24:32,039 --> 00:24:34,641
你可以在你的定制控制器中
使用完全相同的API


620
00:24:34,708 --> 00:24:36,543
向你的应用程序添加
弹性加载


621
00:24:37,911 --> 00:24:38,779
这是一个


622
00:24:38,846 --> 00:24:40,814
NSSpringLoadingDestination
协议


623
00:24:40,881 --> 00:24:42,416
如果你曾经实施过的话


624
00:24:42,482 --> 00:24:43,984
它和
NSDraggingDestination


625
00:24:44,051 --> 00:24:45,018
协议非常类似


626
00:24:46,787 --> 00:24:49,656
在你的目标中
在你的目标视图中


627
00:24:49,723 --> 00:24:51,325
你需要实现
springLoadingEntered


628
00:24:51,391 --> 00:24:52,559
或springLoadingUpdated


629
00:24:53,260 --> 00:24:54,962
这里给你一个实例
看看是如何实现的：


630
00:24:55,195 --> 00:24:56,330
NSButton实现


631
00:24:56,396 --> 00:24:57,631
springLoading
Entered


632
00:24:57,698 --> 00:24:59,099
而不是
springLoadingUpdated


633
00:24:59,299 --> 00:25:01,368
因为一个按钮要么是
激活的 要么是禁止的


634
00:25:01,435 --> 00:25:02,769
因此
你一按住按钮


635
00:25:03,070 --> 00:25:06,139
它就会返回弹性加载选项
然后它就


636
00:25:06,206 --> 00:25:07,341
在生命期内就不变了


637
00:25:07,407 --> 00:25:08,775
拖曳
就发生在按钮中


638
00:25:09,476 --> 00:25:11,245
NSSegmentedControl
另一方面


639
00:25:11,311 --> 00:25:12,846
实现了
springLoadingUpdated


640
00:25:13,313 --> 00:25:15,983
每个段都可能是激活的
或者禁止的 彼此独立


641
00:25:16,049 --> 00:25:17,651
是一个视图


642
00:25:17,718 --> 00:25:19,620
因此有了
springLoadingUpdated


643
00:25:20,153 --> 00:25:23,290
分段控制就可以对拖曳
进行观察 精确找出拖曳


644
00:25:23,357 --> 00:25:24,491
在控制器哪里


645
00:25:24,558 --> 00:25:26,393
如何动态改变
弹性加载选项的


646
00:25:26,894 --> 00:25:28,729
就像我提到过的 你需要...


647
00:25:29,062 --> 00:25:30,430
如果你实现其中的
一个方式


648
00:25:31,164 --> 00:25:32,766
你需要实现
弹性加载选项


649
00:25:33,333 --> 00:25:35,936
如果你愿意
你可以两者都实现


650
00:25:36,003 --> 00:25:37,704
你并不需要仅仅实现
其中一个 但是


651
00:25:37,771 --> 00:25:38,872
你最起码要实现其中一个


652
00:25:39,540 --> 00:25:41,041
对你的弹性加载选项来说
很明显


653
00:25:41,108 --> 00:25:43,577
你返回弹性加载选项应该是
“激活的”还是“禁止的”


654
00:25:43,644 --> 00:25:45,379
非常简单


655
00:25:45,746 --> 00:25:47,548
我们还有其它一些
有趣的选项


656
00:25:47,614 --> 00:25:49,016
持续激活


657
00:25:49,550 --> 00:25:52,452
一般来说
弹性加载动作是离散的


658
00:25:52,519 --> 00:25:53,520
弹性加载产生了


659
00:25:53,754 --> 00:25:56,857
按钮发出了动作
结束了


660
00:25:57,157 --> 00:25:58,659
还有一个持续版本
我们在下面的


661
00:25:58.725 --> 00:26:00.394 align:middle
幻灯片中 会


662
00:25:58,725 --> 00:26:00,394
幻灯片中 会


663
00:26:00,460 --> 00:26:02,129
讲到


664
00:26:02,763 --> 00:26:04,097
我想再讲讲没有悬停的情况


665
00:26:05,499 --> 00:26:07,634
就像我之前提到的
弹性加载可以通过


666
00:26:07,701 --> 00:26:09,303
悬停或者
Force click激活


667
00:26:09,369 --> 00:26:11,071
悬停非常适合


668
00:26:11,138 --> 00:26:12,506
没有Force Touch
trackpads的


669
00:26:12,573 --> 00:26:13,574
人群


670
00:26:14,675 --> 00:26:17,211
举例来说
如果你想在一块很大的画布上


671
00:26:17,277 --> 00:26:18,579
进行
Force click


672
00:26:18,946 --> 00:26:20,214
用户把项目拖拽过画布


673
00:26:20,280 --> 00:26:22,983
他们只是试图
拖到画布另一边


674
00:26:23,150 --> 00:26:24,751
他们抬起手指
回来继续拖拽


675
00:26:24,818 --> 00:26:26,553
或者抬起鼠标
继续拖拽


676
00:26:26,620 --> 00:26:27,788
这个时间可能会很长


677
00:26:28,422 --> 00:26:30,490
光标停住不动
而


678
00:26:30,557 --> 00:26:34,127
弹性加载
一直处于激活状态


679
00:26:35,162 --> 00:26:37,097
这就是一个
假的激活


680
00:26:37,164 --> 00:26:38,732
这不是用户试图
做的


681
00:26:39,399 --> 00:26:41,134
如果因为悬停 你收到了
大量假的激活


682
00:26:41,201 --> 00:26:43,203
如果你遇到了这种情况
你可能想考虑下


683
00:26:43,837 --> 00:26:47,074
无悬停
弹性加载选项


684
00:26:47,274 --> 00:26:48,742
用户就可以用


685
00:26:48,809 --> 00:26:49,943
Force Touch
trackpad进行


686
00:26:50,010 --> 00:26:52,379
Force click
在你的视图的那个位置


687
00:26:52,513 --> 00:26:53,480
得到弹性加载


688
00:26:54,314 --> 00:26:57,484
你要保守地使用
使用之前务必三思


689
00:26:57,551 --> 00:26:59,086
因为我们不想遗漏任何没有
Force Touch trackpad


690
00:26:59.152 --> 00:27:00.687 align:middle
的 用户


691
00:26:59,152 --> 00:27:00,687
的 用户


692
00:27:01,054 --> 00:27:03,824
但是如果你收到了
大量的假的激活


693
00:27:04,024 --> 00:27:05,626
那么偶尔用一个这个选项
就很好


694
00:27:07,661 --> 00:27:08,629
与springLoading
Entered


695
00:27:08,695 --> 00:27:10,130
和“已更新”一起
我们当然还有


696
00:27:10,197 --> 00:27:11,164
springLoadingExited...


697
00:27:11,231 --> 00:27:13,767
当用户退出了你的视图
它就会告诉你


698
00:27:13,967 --> 00:27:15,502
还有draggingEnded


699
00:27:15,569 --> 00:27:17,738
弹性加载是
拖放操作的一部分


700
00:27:17,804 --> 00:27:21,742
因此如果用户
拖过了你的视图


701
00:27:21,942 --> 00:27:24,645
你的弹性加载
目的


702
00:27:24,845 --> 00:27:26,547
你实现了
draggingEnded


703
00:27:26,880 --> 00:27:29,283
当拖拽完成后
当用户释放了鼠标


704
00:27:29,349 --> 00:27:30,684
取消了拖拽


705
00:27:31,385 --> 00:27:33,253
你会拿回
draggingEnded


706
00:27:33,387 --> 00:27:37,057
无论用户是在你的应用程序中
还是在另一个进程中


707
00:27:37,124 --> 00:27:39,059
完成了拖拽
都不重要


708
00:27:39,493 --> 00:27:41,862
任何实现了
draggingUpdated的人


709
00:27:41,929 --> 00:27:43,130
都会得到他们的回调


710
00:27:45,432 --> 00:27:46,834
因为这是拖拽的一部分


711
00:27:47,367 --> 00:27:48,836
NSDraggingDestination


712
00:27:48,902 --> 00:27:52,973
还有一个
draggingEnded函数


713
00:27:53,173 --> 00:27:54,741
它和我们这里的函数
一模一样


714
00:27:54,975 --> 00:27:57,277
如果你同时使用了
弹性加载目的


715
00:27:57,344 --> 00:27:59,546
和NSDragging
Destination


716
00:27:59.947 --> 00:28:00.814 align:middle
那么你只需要


717
00:27:59,947 --> 00:28:00,814
那么你只需要


718
00:28:00,881 --> 00:28:02,583
实现一个
draggingEnded


719
00:28:02,649 --> 00:28:04,918
它会应用于两者之上
因此如果你同时使用了


720
00:28:04,985 --> 00:28:07,287
弹性加载目的
和拖拽目的


721
00:28:07,688 --> 00:28:09,556
你就需要为弹性加载目的
和拖拽目的


722
00:28:09,623 --> 00:28:11,425
完成
清除工作


723
00:28:13,093 --> 00:28:15,596
现在我们来看看
弹性加载真正好玩的地方


724
00:28:15,996 --> 00:28:18,899
因此 要求你实现
springLoadingActivated


725
00:28:18,966 --> 00:28:21,735
我们就是在这里
告诉你的目的


726
00:28:21,802 --> 00:28:23,270
用户进行了弹性加载


727
00:28:24,471 --> 00:28:26,273
我们有一个布尔值
通常这个值为“是”


728
00:28:26,607 --> 00:28:29,109
就像我提到的
弹性加载是一个离散动作


729
00:28:29,176 --> 00:28:32,045
它发生了
NSButton刚刚发生了动作


730
00:28:32,913 --> 00:28:36,183
大家都满意了


731
00:28:36,416 --> 00:28:39,486
但是 如果
你有连续位组


732
00:28:39,553 --> 00:28:40,754
那么只要用户
进行Force click


733
00:28:41,388 --> 00:28:43,123
我们会发送一个
springLoadingActivated“是”


734
00:28:43,190 --> 00:28:45,492
你可以启动一个计时器
你可以继续


735
00:28:45,692 --> 00:28:47,995
往那个计时器添加你的
活动消息


736
00:28:48,061 --> 00:28:51,732
当你从
Force click释放后 它会回复给你


737
00:28:51,999 --> 00:28:54,134
一个springLoading
Activated“否”


738
00:28:54,201 --> 00:28:56,537
你就知道你该关闭
你的计时器了


739
00:28:56,937 --> 00:28:58,472
如果用户使用悬停


740
00:28:58,539 --> 00:29:00,474iddle
当悬停超时时 你会得到


741
00:28:58,539 --> 00:29:00,474
当悬停超时时 你会得到


742
00:29:00,541 --> 00:29:02,042
springLoadingActivated
“是”


743
00:29:02,109 --> 00:29:03,844
当它们从控制器移出时
你就会得到


744
00:29:03,911 --> 00:29:05,379
一个
“否”


745
00:29:06,513 --> 00:29:09,016
要把这个和
正常的离散动作进行对比


746
00:29:09,149 --> 00:29:10,851
通常是在释放
Force click时


747
00:29:10,918 --> 00:29:12,719
来自Force click的
弹性加载


748
00:29:12,786 --> 00:29:14,154
它们会一路进入
Force click


749
00:29:14,221 --> 00:29:15,522
当它们释放Force click


750
00:29:15,589 --> 00:29:17,324
如果你不是连续使用
你就会得到


751
00:29:17,391 --> 00:29:18,892
一个springLoadingActivated
“是”


752
00:29:18,959 --> 00:29:22,095
除非你在弹性加载时
需要连续发出你的活动消息


753
00:29:22,162 --> 00:29:23,297
那么我们通常


754
00:29:23,363 --> 00:29:27,134
会建议你
用它


755
00:29:28,902 --> 00:29:29,903
最后 我们有


756
00:29:29,970 --> 00:29:31,305
springLoading
HighlightChanged


757
00:29:31,638 --> 00:29:33,640
我们希望给用户提供反馈
告诉它们当前的情况


758
00:29:33,707 --> 00:29:35,742
我们有三种高亮形式：不高亮


759
00:29:35,976 --> 00:29:37,244
标准高亮 增强高亮


760
00:29:38,679 --> 00:29:40,414
当你得到一个


761
00:29:40,480 --> 00:29:42,216
springLoading
HighlightChanged


762
00:29:42,282 --> 00:29:44,751
消息 你需要告诉
draggingInfo那个


763
00:29:44,818 --> 00:29:46,520
springLoading
Highlight是为了什么


764
00:29:46,587 --> 00:29:48,188
设置需要展示的视图


765
00:29:48,255 --> 00:29:51,491
然后你就可以更新
在正确的高亮显示


766
00:29:51,558 --> 00:29:52,860
那里绘画


767
00:29:54,228 --> 00:29:56,697
重要的是
不要试图推断


768
00:29:56,763 --> 00:29:59,466
用户的
任何动作


769
00:29:59,900 --> 00:30:02,035
这就是springLoadingActivated
的用途


770
00:30:04,238 --> 00:30:08,075
就像当你从一个菜单中
选择一个项目时


771
00:30:08,141 --> 00:30:10,444
我们会让那个菜单项目闪烁
让用户知道 确认他们已经


772
00:30:10,511 --> 00:30:13,413
选择了那个项目
我们在弹性加载中


773
00:30:13,480 --> 00:30:14,882
也做了类似的事


774
00:30:14,948 --> 00:30:17,317
我们是通过改变高亮
实现的


775
00:30:17,684 --> 00:30:19,586
因此你需要做的
就是用任何需要的


776
00:30:19,653 --> 00:30:21,722
高亮方式绘画
然后你的应用程序的


777
00:30:22,089 --> 00:30:24,791
风格就会和
系统的其它地方


778
00:30:24,858 --> 00:30:25,993
保持一致


779
00:30:26,360 --> 00:30:27,995
使用springLoadingActivated
来知道何时


780
00:30:28,061 --> 00:30:29,463
发出
活动消息


781
00:30:30,898 --> 00:30:32,266
这是弹性加载
目的


782
00:30:33,233 --> 00:30:34,835
我们有对齐反馈 当你在
Interface Builder中


783
00:30:34,902 --> 00:30:37,004
有两个项目在一起时
你可以看到这个


784
00:30:37,070 --> 00:30:39,273
我们把它们对齐了
绘制了这个漂亮的对齐指导


785
00:30:40,107 --> 00:30:42,476
我们有一些新的API
能帮助你实现这一点


786
00:30:42,643 --> 00:30:45,245
绘图由你决定
但是我们的新API能帮助你


787
00:30:45,312 --> 00:30:46,313
决定何时应该对齐


788
00:30:47,080 --> 00:30:50,551
这里给你一个例子
我们来看看这个跟踪回路


789
00:30:50,617 --> 00:30:51,718
一个典型的跟踪回路


790
00:30:51,785 --> 00:30:53,620
我们放大下


791
00:30:53,687 --> 00:30:54,888
你得到了你的鼠标下移事件


792
00:30:54,955 --> 00:30:57,758
你找出你的事件掩码是什么
你想要追踪哪个事件


793
00:30:57,824 --> 00:31:01,662
你请求下个事件
你移动你的项目


794
00:31:01,762 --> 00:31:04,097
更新你的数据模型
设置你的需求显示


795
00:31:04,164 --> 00:31:06,700
鼠标上移了吗？没有
你就继续这个循环


796
00:31:06,867 --> 00:31:10,270
无论drawRect什么时候被调用
你就绘制


797
00:31:10,337 --> 00:31:12,573
你把你的项目拖过屏幕
直到发生了鼠标上移


798
00:31:13,373 --> 00:31:14,208
我们有一个


799
00:31:14,274 --> 00:31:16,410
NSAlignmentFeedbackFilter
对象


800
00:31:16,476 --> 00:31:17,778
能帮到你


801
00:31:18,946 --> 00:31:20,380
你把鼠标上移
你做的第一件事


802
00:31:20,447 --> 00:31:21,915
你从对齐反馈过滤器中


803
00:31:21,982 --> 00:31:23,851
得到
输入事件掩码


804
00:31:24,952 --> 00:31:27,688
对齐反馈过滤器需要知道
这个


805
00:31:27,754 --> 00:31:29,189
当你调用
nextEventMatchingMask时


806
00:31:29,256 --> 00:31:31,425
你只需要或者把它们 或者


807
00:31:31,491 --> 00:31:34,661
把它们的并集 在Swift实例中
和你的事件掩码并运算


808
00:31:35,562 --> 00:31:38,866
你一旦得到下个事件
你要做的第一件事


809
00:31:38,932 --> 00:31:41,201
就是把事件送到
对齐反馈过滤器


810
00:31:41,268 --> 00:31:42,436
它会立即返回


811
00:31:42,503 --> 00:31:44,104
它只是更新一些
内部状态


812
00:31:44,938 --> 00:31:48,675
你移动...不好意思 如果
你使用的是pan手势识别器


813
00:31:48,742 --> 00:31:51,011
你也可以用pan手势识别器
来进行更新


814
00:31:51,078 --> 00:31:52,746
它和跟踪回路工作方式
十分类似


815
00:31:52,980 --> 00:31:56,283
一切都适用
除了这个消息差异


816
00:31:58,252 --> 00:31:59,953
对齐反馈过滤器一旦
处理完输出 返回后


817
00:32:00,020 --> 00:32:03,524
像你平常那样
你把项目移到你的数据模型


818
00:32:03,590 --> 00:32:06,093
然后
你准备对齐


819
00:32:06,627 --> 00:32:09,296
我们来挖掘一下准备对齐
你得使用对齐反馈过滤器


820
00:32:09,363 --> 00:32:11,632
来帮助你
实现这一点


821
00:32:12,199 --> 00:32:14,668
我们之前在数据模型中
有对象


822
00:32:14,735 --> 00:32:17,171
我们得到了事件
我们决定用户移动到这里


823
00:32:17,271 --> 00:32:18,639
如果我们不进行任何对齐


824
00:32:19,072 --> 00:32:20,741
这里就是
默认位置


825
00:32:20,841 --> 00:32:22,476
这是对象
结束的地方


826
00:32:23,243 --> 00:32:26,280
我们想知道：是否应该
在这里对齐 是否应该


827
00:32:26,346 --> 00:32:29,082
向下对齐这条线 或者我们
是否要同时对齐


828
00:32:29,149 --> 00:32:30,384
弄到下面角落里


829
00:32:31,418 --> 00:32:34,188
使用对齐反馈过滤器
对象来帮助你


830
00:32:34,254 --> 00:32:35,088
决定这个


831
00:32:35,155 --> 00:32:36,223
alignmentFeedback
Token


832
00:32:36,290 --> 00:32:37,724
ForHorizontal
MovementInView


833
00:32:37,791 --> 00:32:40,394
previousX
alignedX和defaultX


834
00:32:40,794 --> 00:32:43,030
这些坐标都位于
窗口坐标空格上


835
00:32:43,096 --> 00:32:47,201
因此无论你在视图内
的缩放层级是什么


836
00:32:47,267 --> 00:32:48,502
它都工作的
很好


837
00:32:49,837 --> 00:32:51,972
如果发生对齐
我们就会返回给你一个


838
00:32:52,039 --> 00:32:54,308
对齐反馈
令牌


839
00:32:55,008 --> 00:32:56,577
如果你没有得到
对齐反馈令牌


840
00:32:56,643 --> 00:32:57,644
那就不要进行任何对齐


841
00:32:57,711 --> 00:32:59,079
如果你得到了
对齐反馈令牌


842
00:32:59,413 --> 00:33:01,782
在这个例子中 在你的
数据模型中改变X位置


843
00:33:02,015 --> 00:33:04,484
改变为对齐位置
留住那个


844
00:33:04,551 --> 00:33:05,719
对齐反馈令牌


845
00:33:06,653 --> 00:33:09,256
然后你也可以校验
纵向运动


846
00:33:09,323 --> 00:33:11,525
除了你要发送你的Y值
代替你的X


847
00:33:11,825 --> 00:33:14,394
你还是可能得到 或者得不到
对齐反馈令牌


848
00:33:14,962 --> 00:33:17,064
如果你得到两个
对齐反馈令牌 你就需要


849
00:33:17,130 --> 00:33:19,466
在两个轴线中对齐
这样你的对象就会


850
00:33:19,533 --> 00:33:21,168
到下面角落这里


851
00:33:22,903 --> 00:33:25,138
有时候
这个并不经常发生


852
00:33:25,205 --> 00:33:28,141
但是如果它同时在
X轴和Y轴对齐


853
00:33:28,709 --> 00:33:32,446
你只想对齐到一个位置
它要么对齐


854
00:33:32,713 --> 00:33:35,749
两个轴
要么哪个轴都不对齐


855
00:33:35,983 --> 00:33:39,186
此时我们有运动的
对齐反馈令牌


856
00:33:39,253 --> 00:33:42,122
你越过点
而不是一个个体X坐标


857
00:33:42,189 --> 00:33:44,758
或者Y坐标
两者都可以


858
00:33:44,825 --> 00:33:49,263
你可能得到 也可能得不到
对齐反馈令牌


859
00:33:49,930 --> 00:33:53,867
你对拖拽的各种项目
进行迭代 这样它们


860
00:33:53,934 --> 00:33:56,203
可以对齐
你拿回你的对齐反馈令牌


861
00:33:56,270 --> 00:33:59,139
如果发生对齐
你就改变你的数据模型


862
00:33:59,673 --> 00:34:02,276ddle
现在你有了
一系列令牌


863
00:33:59,673 --> 00:34:02,276
现在你有了
一系列令牌


864
00:34:02,776 --> 00:34:04,344
你想要给使用新
Force Touch trackpad的


865
00:34:04,411 --> 00:34:06,313
用户提供
触觉反馈


866
00:34:07,281 --> 00:34:09,583
我们会使用对齐反馈过滤器
来帮助我们这样做


867
00:34:09,650 --> 00:34:11,418
我们会让对齐反馈过滤器
在执行时间来


868
00:34:11,485 --> 00:34:13,152
执行
反馈


869
00:34:13,620 --> 00:34:15,621
现在执行时间
先使用默认值


870
00:34:15,688 --> 00:34:17,991
我们稍后会
再讲一讲执行时间


871
00:34:18,824 --> 00:34:20,860
然后你给阵列传递
一个反馈令牌


872
00:34:21,027 --> 00:34:23,330
如果没有对齐 你甚至可以
传递一个空的阵列


873
00:34:23,597 --> 00:34:26,166
对齐反馈过滤器
在这方面很健壮


874
00:34:26,233 --> 00:34:27,734
它知道什么都不用做


875
00:34:28,502 --> 00:34:30,103
然后你设置你的视图
为需要显示


876
00:34:30,469 --> 00:34:35,141
无论什么时候要求
你就重新绘制 如果你


877
00:34:35,208 --> 00:34:37,244
有令牌 你就知道你
何时在重新绘制


878
00:34:37,311 --> 00:34:41,215
如果对你的UI合适的话
绘制对齐指导


879
00:34:41,581 --> 00:34:43,784
然后反馈就会同步
和屏幕改变执行


880
00:34:43,851 --> 00:34:46,453
用户就可以
有一个漂亮的


881
00:34:46,520 --> 00:34:49,188
同步
看到对齐指导弹出


882
00:34:49,389 --> 00:34:50,524
他们也同时从trackpad上
感受到


883
00:34:50,591 --> 00:34:53,193
触觉
反馈


884
00:34:53,327 --> 00:34:56,864
如果用户用的不是Force
Touch trackpad 对齐


885
00:34:56,929 --> 00:34:59,032
反馈过滤器也知道
应该如何工作


886
00:34:59,333 --> 00:35:01,668
所以你只需要假设是
Force Touch trackpad


887
00:35:01,735 --> 00:35:02,936
你只需要写就可以了


888
00:35:03,003 --> 00:35:04,938
如果不是
那就没问题


889
00:35:07,441 --> 00:35:09,009
所以 实际上


890
00:35:09,142 --> 00:35:10,811
就是使用对齐
反馈过滤器


891
00:35:11,011 --> 00:35:13,113
它们非常简单的API
添加到你的应用程序


892
00:35:13,180 --> 00:35:15,716
和现有的跟踪回路中
很容易


893
00:35:16,083 --> 00:35:17,551
让整个app提供
一致的风格


894
00:35:17,784 --> 00:35:20,854
比如 我们看看
光标的速度


895
00:35:21,088 --> 00:35:23,624
因此如果用户移动的很快
我们就不对齐


896
00:35:23,690 --> 00:35:25,092
因为我们不想在那个时候


897
00:35:25,158 --> 00:35:26,393
进行
对齐


898
00:35:26,960 --> 00:35:28,562
那不是
用户想要做的


899
00:35:28,996 --> 00:35:30,464
我们来看修改值


900
00:35:30,831 --> 00:35:32,633
这会给所有使用系统宽度
对齐反馈API


901
00:35:32,699 --> 00:35:35,302
的应用程序
提供


902
00:35:35,369 --> 00:35:36,436
一致的风格


903
00:35:36,970 --> 00:35:39,740
你就可以用它
不仅仅是拖拽一个项目


904
00:35:40,107 --> 00:35:42,509
如果你重新调整尺寸
比如说 或者自动调整


905
00:35:42,676 --> 00:35:44,778
那就非常适合用
对齐反馈过滤器


906
00:35:45,179 --> 00:35:47,581
它可以用在
很多不同的地方


907
00:35:49,149 --> 00:35:50,617
要成为一名“骑士”
你需要了解的就这些


908
00:35:50,684 --> 00:35:51,518
恭喜


909
00:35:51,585 --> 00:35:53,020
你们现在都是使用


910
00:35:53,086 --> 00:35:54,488
Force Touch trackpad
的“骑士”了


911
00:35:55,055 --> 00:35:56,990
我们来继续成为
“大师”


912
00:35:57,491 --> 00:35:59,092
都是关于
力的控制


913
00:35:59,560 --> 00:36:01,261
是关于对trackpad
进行配置


914
00:36:01,328 --> 00:36:04,531
这样它就能适用于
你的定制情景


915
00:36:04,731 --> 00:36:06,366
手动提供
触觉反馈


916
00:36:09,770 --> 00:36:11,605
我们再回到
绘图这个例子


917
00:36:12,773 --> 00:36:15,642
你开始绘图 你按压Force
Touch trackpad


918
00:36:15,709 --> 00:36:17,110
你得到了
Force click


919
00:36:17,177 --> 00:36:19,146
但是它并不真的
适用于你的绘图


920
00:36:19,213 --> 00:36:20,814
就像我之前提到的
你不希望尝试合并


921
00:36:20,881 --> 00:36:23,183
阶段一的压力值
和阶段二的压力值


922
00:36:23,250 --> 00:36:25,586
合并 甚至在释放时
也不行


923
00:36:25,652 --> 00:36:27,788
这样
用户就会在绘图过程中


924
00:36:27,855 --> 00:36:29,656
得到触觉反馈
这种经历


925
00:36:29,723 --> 00:36:31,325
可不妙


926
00:36:31,992 --> 00:36:33,393
因此我们想要对trackpad
进行配置


927
00:36:33,460 --> 00:36:37,965
让它在这个例子中不提供一点Forc
e click动作


928
00:36:38,031 --> 00:36:40,400
我们能用压力配置对象
做的 就是这个


929
00:36:40,467 --> 00:36:42,903
我们先用一个
pressureBehavior开始


930
00:36:43,370 --> 00:36:45,706
校验下头部文档
和资料


931
00:36:45,772 --> 00:36:49,042
校验NSEvent.h
头部文档中对每个


932
00:36:49,109 --> 00:36:50,511
都有
大量的描述


933
00:36:50,577 --> 00:36:51,845
我不会每个都讲


934
00:36:51,945 --> 00:36:54,581
默认的是DeepClick
这是系统


935
00:36:54,648 --> 00:36:55,549
发生的


936
00:36:55,616 --> 00:36:57,518
在这个例子中 我们想要
PrimaryGeneric


937
00:36:57,951 --> 00:37:00,454
PrimaryGeneric是个阶
段一手势


938
00:37:00,787 --> 00:37:03,323
因此当用户在绘制时
他们就不会得到


939
00:37:03,390 --> 00:37:04,791
Force click动作


940
00:37:04,858 --> 00:37:08,629
给用户提供了在他们的
trackpad上输入力的


941
00:37:08,695 --> 00:37:11,532
最大的动态范围
把它向你映射回去


942
00:37:11,598 --> 00:37:12,966
映射到零到一的压力


943
00:37:13,267 --> 00:37:15,636
最适合绘图
以及其它多个


944
00:37:15,702 --> 00:37:18,305
情景
校验头部文档


945
00:37:18,372 --> 00:37:21,341
看看其它行为描述
看看


946
00:37:21,408 --> 00:37:22,976
哪个适合
你的情景


947
00:37:24,578 --> 00:37:25,913
一旦你完成压力
配置后


948
00:37:25,979 --> 00:37:26,880
你就可以调用设置


949
00:37:26,947 --> 00:37:29,516
trackpad现在在新的配置中
配置好了


950
00:37:29,883 --> 00:37:32,553
一切都很好
有了一些画布


951
00:37:33,220 --> 00:37:34,788
在鼠标拖拽时 你可以


952
00:37:34,855 --> 00:37:37,791
仅仅把trackpad设置成
一个不同的配置


953
00:37:37,958 --> 00:37:39,993
在鼠标上移中 你对
鼠标的位置进行校验


954
00:37:40,060 --> 00:37:41,328
如果这个特定的


955
00:37:41,395 --> 00:37:42,729
鼠标位置
需要改变


956
00:37:43,530 --> 00:37:45,566
创建一个压力配置
调用设置


957
00:37:45,632 --> 00:37:47,034
trackpad就会
做出改变


958
00:37:47,901 --> 00:37:50,571
你需要意识到
此时你在和用户竞赛


959
00:37:51,305 --> 00:37:55,676
用户可能使用光标
翻过你的视图 立即进行


960
00:37:55,742 --> 00:37:57,311
Force click 释放鼠标
而你甚至


961
00:37:57,377 --> 00:37:58,879
还没有
下移鼠标


962
00:37:58,979 --> 00:38:01,949le
也许你被从虚拟内存中
置入分页


963
00:37:58,979 --> 00:38:01,949
也许你被从虚拟内存中
置入分页


964
00:38:02,015 --> 00:38:03,684
你的app失去响应了


965
00:38:04,318 --> 00:38:07,321
你可以试着设置压力
此时的trackpad配置


966
00:38:07,387 --> 00:38:10,757
但是用户已经
完成了他们的手势


967
00:38:11,024 --> 00:38:12,092
手势不会生效


968
00:38:12,659 --> 00:38:16,029
当你设置trackpad配置时
它会自动重置为


969
00:38:16,830 --> 00:38:19,266
系统默认值
用户也会同时


970
00:38:19,333 --> 00:38:21,468
结束手势
因此你不需要担心


971
00:38:21,535 --> 00:38:22,769
对它复原


972
00:38:23,270 --> 00:38:26,440
但是对多数情况来说
这不够理想 当你需要


973
00:38:26,507 --> 00:38:30,043
根据鼠标位置 在最后一分钟
决定


974
00:38:30,110 --> 00:38:32,346
配置应该是什么时
这很有用


975
00:38:33,013 --> 00:38:37,518
而不是在NSView上设置
压力配置


976
00:38:38,352 --> 00:38:40,220
提前创建一个
压力配置


977
00:38:40,420 --> 00:38:42,022
在NSView上把它设置为
压力配置属性


978
00:38:42,089 --> 00:38:44,291
系统就会在
鼠标下移发生之前


979
00:38:44,358 --> 00:38:46,326
设置好
trackpad


980
00:38:46,393 --> 00:38:48,695
事实上 系统可以给
trackpad配置为这种配置


981
00:38:48,762 --> 00:38:50,697
即使你的app


982
00:38:50,764 --> 00:38:52,566
失去了
响应


983
00:38:53,100 --> 00:38:56,370
现在用户就可以继续
和你的应用程序交互了


984
00:38:56,436 --> 00:38:57,804
你甚至还没有完成
鼠标下移


985
00:38:57,871 --> 00:38:59,039
但是他们没有
感受到Force click


986
00:38:59,106 --> 00:39:01,842
因为它位于
PrimaryGeneric行为


987
00:39:01,909 --> 00:39:04,011
以及你从应用程序中
得到的事件


988
00:39:04,077 --> 00:39:06,547
当你最终得到你的事件
此时从系统中


989
00:39:07,080 --> 00:39:08,415
获得
如果


990
00:39:08,482 --> 00:39:12,019
你失去了响应 不要在它们里面
进行Force click


991
00:39:12,085 --> 00:39:13,754
它们不会到阶段二


992
00:39:13,820 --> 00:39:16,390
我们再来讲讲
触觉反馈


993
00:39:18,192 --> 00:39:20,360
触觉反馈应该
保守使用


994
00:39:20,727 --> 00:39:21,995
它们是用于微妙的交互


995
00:39:22,062 --> 00:39:24,164
我们想让trackpad感觉很奇妙
不是吗？


996
00:39:25,165 --> 00:39:26,633
当用户想要
对齐某些东西时


997
00:39:26,700 --> 00:39:28,535
它们会得到触觉反馈
感觉很棒


998
00:39:28,602 --> 00:39:30,671
但是我们不是想在这里
按摩用户的指头


999
00:39:31,004 --> 00:39:33,040
我们只是想进行
微妙的交互


1000
00:39:33,874 --> 00:39:37,044
事实上 如果用户
用回我们的老款


1001
00:39:37,110 --> 00:39:38,846
trackpads
我们希望他们根本


1002
00:39:38,912 --> 00:39:41,281
意识不到 虽然设备换了
但是却


1003
00:39:41,348 --> 00:39:42,916
基本
感觉不到


1004
00:39:43,383 --> 00:39:47,521
使用触觉反馈的
意义就在这里


1005
00:39:47,754 --> 00:39:49,990
正确使用的话
当用户试图做一些事情


1006
00:39:50,057 --> 00:39:52,259
的时候
给他们一点微妙的反馈


1007
00:39:52,426 --> 00:39:53,827
是的 就这样


1008
00:39:53,894 --> 00:39:55,195
它就应该
一直是这样


1009
00:39:55,262 --> 00:39:56,129
我都不知道


1010
00:39:56,697 --> 00:39:57,598
微妙的交互


1011
00:39:58,065 --> 00:39:59,266
你为defaultPerformer
请求了


1012
00:39:59,333 --> 00:40:00,901
NSHaptic
FeedbackManager


1013
00:40:00,968 --> 00:40:03,003
始终请求
defaultPerformer


1014
00:40:03,070 --> 00:40:05,839
因为它可以根据输入
设备以及用户的偏好


1015
00:40:06,240 --> 00:40:09,510
进行改变


1016
00:40:10,143 --> 00:40:12,079
在某个特定的运行时间
你要求执行反馈模式


1017
00:40:12,145 --> 00:40:14,481
我们
有三个


1018
00:40:14,848 --> 00:40:17,584
模式：“通用”“对齐”
以及“LevelChange”


1019
00:40:17,651 --> 00:40:19,386
对齐可以用于
很多事情


1020
00:40:19,887 --> 00:40:23,824
即使你只是旋转一幅
照片进行水平对齐


1021
00:40:23,891 --> 00:40:26,193
打个比方 你也可以
为它使用对齐


1022
00:40:26,560 --> 00:40:30,163
“LevelChange”就是NS
Button在不同的多次方式中用的


1023
00:40:30,230 --> 00:40:32,599
当层级改变时
它会提供触觉反馈


1024
00:40:33,300 --> 00:40:35,802
如果那两项对你试图
做的事情描述的不够充分


1025
00:40:35,869 --> 00:40:37,905
那就使用
“通用”


1026
00:40:39,072 --> 00:40:42,109
你想让你的触觉反馈
与屏幕上进行的事物


1027
00:40:42,176 --> 00:40:44,178
同步执行
那么默认的


1028
00:40:44,244 --> 00:40:45,746
就是
DrawCompleted


1029
00:40:45,812 --> 00:40:47,614
如果你用Cocoa绘画
或者用核心动画


1030
00:40:47,881 --> 00:40:50,851
你就用DrawCompleted
执行时间


1031
00:40:50,984 --> 00:40:53,987
这个会自动把它们
为你同步起来


1032
00:40:54,054 --> 00:40:57,024
这样在事件进程中 绘画中
你就能确定你的触觉反馈


1033
00:40:57.090 --> 00:40:59.826 align:middle
你就可以仅仅
关注绘画


1034
00:41:00,294 --> 00:41:02,396
如果你直接用Medal
或者OpenGL


1035
00:41:02,663 --> 00:41:05,832
那就可以用“现在”
当事情在屏幕上更新时


1036
00:41:06,133 --> 00:41:09,269
你需要确保你排列了它们
这样


1037
00:41:09,336 --> 00:41:10,971
它们可以同时
发生


1038
00:41:12,139 --> 00:41:13,307
就是这些


1039
00:41:13,373 --> 00:41:14,508
你们现在都是使用


1040
00:41:14,575 --> 00:41:16,276
Force Touch
trackpad的“大师”了


1041
00:41:16,343 --> 00:41:18,312
我迫不及待
想看看你们在你们的


1042
00:41:18,378 --> 00:41:20,914
应用程序中运用这些东西
我们讲了“表格行动作”


1043
00:41:20,981 --> 00:41:24,318
加速按钮 弹性加载
我们讲了力在


1044
00:41:24,518 --> 00:41:26,520
系统中的
流动


1045
00:41:26,753 --> 00:41:29,723
进行对齐反馈
最后是控制trackpad


1046
00:41:29,790 --> 00:41:32,192
为你的特定需求配置
trackpad


1047
00:41:32,626 --> 00:41:34,228
你能做的事情很多


1048
00:41:35,796 --> 00:41:37,631
刚才在我的
演示中的小app


1049
00:41:37,698 --> 00:41:39,032
叫做Force Touch
Catalog


1050
00:41:39,099 --> 00:41:40,601
你可以下载后
看一看


1051
00:41:40,667 --> 00:41:43,237
我们也有对齐指导
样例应用程序


1052
00:41:43,303 --> 00:41:44,805
把它们用起来
也确实有用


1053
00:41:46,773 --> 00:41:49,109
我建议你们看看
“WebKit和Safari中的


1054
00:41:49,176 --> 00:41:50,811
网站开发
有什么新料”


1055
00:41:50,878 --> 00:41:54,615
这样你就可以了解Safari
在网站环境中


1056
00:41:54,681 --> 00:41:58,252
是如何承担压力的


1057
00:41:59,586 --> 00:42:02,723iddle
这之后我们会有个实验室


1058
00:41:59,586 --> 00:42:02,723
这之后我们会有个实验室


1059
00:42:02,789 --> 00:42:04,825
“Cocoa
和Force Touch 手势”


1060
00:42:04,892 --> 00:42:06,226
实验室 我当然也会到场


1061
00:42:06,426 --> 00:42:08,862
我十分乐意倾听
你们就如何在你们的


1062
00:42:08,929 --> 00:42:11,965
应用程序中使用Force
Touch的想法 你们甚至可以给我


1063
00:42:12,032 --> 00:42:14,668
展示下你们已经完成的东西
我会十分乐意观看


1064
00:42:14,735 --> 00:42:15,602
并且和你们讨论


1065
00:42:15,669 --> 00:42:18,038
会议结束后请到
实验室找我


1066
00:42:18,739 --> 00:42:20,774
非常感谢
祝你们剩余的时间过得愉快

