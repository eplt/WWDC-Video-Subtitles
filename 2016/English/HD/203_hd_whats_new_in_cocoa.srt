1
00:00:07,516 --> 00:00:25,926
[ Music ]


2
00:00:26,426 --> 00:00:26,946
>> Good morning.


3
00:00:28,006 --> 00:00:29,016
My name is Ali Ozer.


4
00:00:29,396 --> 00:00:30,506
I and my colleagues [applause].


5
00:00:31,496 --> 00:00:31,786
Thank you.


6
00:00:35,336 --> 00:00:37,926
I and my colleagues Raleigh
Ledet and Taylor Kelly


7
00:00:37,926 --> 00:00:40,206
from the Cocoa Frameworks
team will be talking


8
00:00:40,206 --> 00:00:41,866
about what's new
in Cocoa this year.


9
00:00:42,856 --> 00:00:44,006
Our agenda is pretty simple.


10
00:00:44,006 --> 00:00:47,016
First, API updates
followed by new features


11
00:00:47,016 --> 00:00:48,246
in AppKit and Foundation.


12
00:00:49,776 --> 00:00:54,116
And in the area of API updates,
we have two main categories


13
00:00:54,116 --> 00:00:55,726
of API updates I
want to talk about.


14
00:00:55,726 --> 00:00:59,046
One, the API changes due to
the new Swift API guidelines


15
00:00:59,476 --> 00:01:01,866
and secondly, the general API
refinements we've been doing.


16
00:01:02,296 --> 00:01:03,306
So let's get started.


17
00:01:04,436 --> 00:01:07,746
Now as you heard probably
yesterday or if not,


18
00:01:07,786 --> 00:01:11,636
this morning, we have new API
design guidelines in Swift.


19
00:01:11,636 --> 00:01:13,936
And these guidelines still
embrace Cocoa conventions


20
00:01:13,936 --> 00:01:16,176
and practices and
I'll just remind you


21
00:01:16,176 --> 00:01:17,356
of what some of these are.


22
00:01:18,176 --> 00:01:20,346
Using clear and consistent
naming,


23
00:01:20,936 --> 00:01:24,486
striving for fluent usage, you
know, where a call site reads


24
00:01:24,486 --> 00:01:27,016
as an English phrase,
naming mutating


25
00:01:27,016 --> 00:01:30,406
and non-muting method pairs
consistently, sort and sorted,


26
00:01:30,626 --> 00:01:33,876
append and appending, and
avoiding abbreviations.


27
00:01:33,876 --> 00:01:36,606
These are just of the
main guidelines we've had


28
00:01:36,636 --> 00:01:39,236
for many years and
we've documented these


29
00:01:39,236 --> 00:01:41,296
and we've talked about
them in previous WWDCs,


30
00:01:41,296 --> 00:01:42,796
as you see in this session here.


31
00:01:43,496 --> 00:01:45,566
And now we updated
the guidelines


32
00:01:45,956 --> 00:01:48,956
to utilize Swift features
such as strong typing,


33
00:01:49,216 --> 00:01:51,526
type inference, and overloading,


34
00:01:51,776 --> 00:01:54,756
and to make sure our APIs
shine through in Swift.


35
00:01:54,756 --> 00:01:57,146
And let me talk about some of
the key differences in our APIs


36
00:01:57,146 --> 00:01:58,626
as a result of these changes.


37
00:01:59,096 --> 00:02:02,466
For one thing, we're eliminating
repeated and needless words,


38
00:02:02,666 --> 00:02:05,636
which of course makes
our APIs more swifty,


39
00:02:05,666 --> 00:02:06,906
as you might have
heard yesterday.


40
00:02:06,906 --> 00:02:09,545
You saw an example yesterday in
Chris Lattner's section of state


41
00:02:09,545 --> 00:02:11,256
of the union with an example.


42
00:02:11,256 --> 00:02:14,526
Here's another example,
contacts.arrayByAddingObject.


43
00:02:14,896 --> 00:02:19,056
In a method call like this, both
the words "array" and the words


44
00:02:19,056 --> 00:02:21,426
"object" don't really
add much to that call.


45
00:02:21,766 --> 00:02:25,176
So such a name now comes across
as contacts.adding(person).


46
00:02:26,486 --> 00:02:30,046
Here's another example
on the NSColor class.


47
00:02:30,046 --> 00:02:33,616
NSColor.blueColor, now
we're on the NSColor class.


48
00:02:33,616 --> 00:02:35,076
Blue is already a color,


49
00:02:35,076 --> 00:02:37,516
so the word color really
doesn't add much to this call.


50
00:02:37,876 --> 00:02:39,496
So in the new guidelines,
it actually comes


51
00:02:39,496 --> 00:02:41,056
across as NSColor.blue.


52
00:02:41,836 --> 00:02:44,386
But note that we're still
striving for clarity.


53
00:02:44,576 --> 00:02:47,986
Here's another method from
NSColor, NSColor.textColor.


54
00:02:49,016 --> 00:02:51,756
Text is not inherently
a color and, in fact,


55
00:02:51,756 --> 00:02:55,086
talking about the text of
a color could be confusing.


56
00:02:55,506 --> 00:02:59,006
Is it the text that represents
the color's RGB values or what?


57
00:02:59,516 --> 00:03:01,866
So in a case like this, we've
actually left the method alone


58
00:03:01,866 --> 00:03:04,136
and it comes across
as NSColor.textColor,


59
00:03:04,266 --> 00:03:06,676
like it used to be.


60
00:03:08,506 --> 00:03:13,616
Now some of the other key
changes to making use of types,


61
00:03:13,756 --> 00:03:18,376
here's an example,
document.readFromURL ofType,


62
00:03:18,606 --> 00:03:22,506
now this API comes across
as document.readFrom ofType.


63
00:03:22,856 --> 00:03:26,636
You'll note that we've
dropped the word URL


64
00:03:26,736 --> 00:03:27,886
from our method signature.


65
00:03:28,076 --> 00:03:31,376
It's because the type of
the first argument is URL


66
00:03:31,656 --> 00:03:34,146
and with type inference, Swift
knows enough to handle that.


67
00:03:34,346 --> 00:03:35,496
And by dropping that word,


68
00:03:35,496 --> 00:03:38,246
we actually now have three
read methods on an NSDocument


69
00:03:38,916 --> 00:03:42,256
that are all named exactly the
same thing read from ofType


70
00:03:42,256 --> 00:03:45,626
and it's that first argument,
the type of that first argument,


71
00:03:45,626 --> 00:03:48,036
URL data or FileWrapper


72
00:03:48,036 --> 00:03:50,406
that distinguishes
these from each other.


73
00:03:51,706 --> 00:03:54,576
Now another thing to note
here is making use of label


74
00:03:54,576 --> 00:03:56,556
on the first argument.


75
00:03:57,066 --> 00:04:00,526
From here has now been
pulled into the parens.


76
00:04:00,526 --> 00:04:02,066
We do this in a number of cases.


77
00:04:02,066 --> 00:04:03,896
For instance, when the
first argument performs part


78
00:04:03,896 --> 00:04:05,066
of a prepositional phrase,


79
00:04:05,376 --> 00:04:08,706
we pull that phrase inside the
parens, as you can see here.


80
00:04:08,706 --> 00:04:10,306
And you'll probably
see a lot more examples


81
00:04:10,306 --> 00:04:12,366
of this throughout out APIs.


82
00:04:12,766 --> 00:04:15,616
Now you'll also notice that
second argument ofType.


83
00:04:16,076 --> 00:04:18,305
Here we haven't dropped
the word type from the API


84
00:04:18,856 --> 00:04:20,786
because that argument
is a string


85
00:04:21,065 --> 00:04:22,446
and strings are weakly typed.


86
00:04:22,516 --> 00:04:24,806
So we really need a word
to describe their role


87
00:04:24,806 --> 00:04:26,746
and the role here is
that this is the type


88
00:04:26,746 --> 00:04:27,846
of file we're opening.


89
00:04:28,076 --> 00:04:32,036
So there, we keep the
word type in the API.


90
00:04:35,116 --> 00:04:38,406
Now many framework and standard
library APIs have changed


91
00:04:38,406 --> 00:04:39,936
as a result of these
new guidelines


92
00:04:40,376 --> 00:04:43,756
and the importer whose job
is to map Objective-C APIs


93
00:04:43,756 --> 00:04:46,716
into Swift now does it
using these new guidelines,


94
00:04:47,036 --> 00:04:49,726
but you'll note that some
APIs may need further tuning.


95
00:04:49,996 --> 00:04:53,056
We've done that in our APIs,
such as the API textColor,


96
00:04:53,056 --> 00:04:54,956
which I showed earlier,
which is an exception.


97
00:04:55,146 --> 00:04:57,776
And if you yourself have
Objective-C APIs you're exposing


98
00:04:57,776 --> 00:05:00,726
in Swift, you may need to do
so as well by using something


99
00:05:00,726 --> 00:05:04,526
like NS Swift Name, which lets
you override the default choice


100
00:05:04,526 --> 00:05:05,326
the importer is doing.


101
00:05:06,136 --> 00:05:08,376
You also know that the
migrator converts your --


102
00:05:08,376 --> 00:05:10,696
There's a migrator that converts
your existing Swift 2 code


103
00:05:10,696 --> 00:05:14,666
to Swift 3 and it will help
you with all this new naming


104
00:05:14,666 --> 00:05:16,086
in your existing
code, of course.


105
00:05:16,416 --> 00:05:18,886
And the Swift API
Design Guidelines talk,


106
00:05:18,886 --> 00:05:21,286
which took place just before
this one, you can catch this


107
00:05:21,286 --> 00:05:22,716
on video for a lot more details


108
00:05:22,766 --> 00:05:25,916
on these guidelines
and their impact.


109
00:05:26,046 --> 00:05:29,086
Now we have a number of
general APIs refinements,


110
00:05:29,366 --> 00:05:31,206
that some of which
we've done for a while


111
00:05:31,206 --> 00:05:32,536
and others we're
continuing to do.


112
00:05:32,536 --> 00:05:33,726
Let me quickly go through these.


113
00:05:34,246 --> 00:05:35,816
Nullability is something


114
00:05:35,816 --> 00:05:38,696
that we've already
done much of last year.


115
00:05:38,926 --> 00:05:42,006
It's basically declaring whether
arguments, return values,


116
00:05:42,006 --> 00:05:44,666
properties can be nil or
can be optional or not


117
00:05:45,006 --> 00:05:47,136
and we've continued to
refine this, this year.


118
00:05:47,466 --> 00:05:51,236
For instance, here's a method
which in 10.11 was marked


119
00:05:51,236 --> 00:05:52,766
as returning an optional value.


120
00:05:52,816 --> 00:05:56,736
This is addItem on NSMenu
but in 10.12 it's not marked


121
00:05:56,736 --> 00:05:59,746
as returning a non-optional
value because we determined


122
00:05:59,746 --> 00:06:01,926
that this can never really
return nil and it's better


123
00:06:01,926 --> 00:06:03,756
to reflect that properly
which makes your code,


124
00:06:03,756 --> 00:06:06,476
of course, a little simpler.


125
00:06:06,476 --> 00:06:09,636
We've been doing properties,
converting getter, setter pairs


126
00:06:09,636 --> 00:06:11,426
into formal properties all along


127
00:06:11,836 --> 00:06:14,736
and this year we're also
actually using Swift's ability


128
00:06:14,736 --> 00:06:16,146
to declare properties
on classes.


129
00:06:16,146 --> 00:06:19,326
For instance, here is a
new property on NSWindow.


130
00:06:19,386 --> 00:06:20,896
You'll hear about this
later in the talk,


131
00:06:20,896 --> 00:06:22,576
allowsAutomaticWindowTabbing.


132
00:06:23,216 --> 00:06:26,026
This is reflected as an actual
class property in Swift.


133
00:06:27,236 --> 00:06:28,836
You'll also note that
we have an ability now


134
00:06:28,836 --> 00:06:30,006
to do this in Objective-C.


135
00:06:30,296 --> 00:06:32,446
You can actually declare class
properties in Objective-C


136
00:06:32,446 --> 00:06:34,446
with this syntax
@property class.


137
00:06:34,786 --> 00:06:37,216
So the same feature comes
across in Objective-C


138
00:06:37,216 --> 00:06:38,286
as well, which is pretty cool.


139
00:06:38,736 --> 00:06:42,856
Here's a Core Data example
NSPersistentStoreCoordinator.


140
00:06:43,106 --> 00:06:45,936
It had this method,
registeredStoreTypes in 10.11.


141
00:06:46,176 --> 00:06:48,006
It's now declared
as a class property.


142
00:06:48,006 --> 00:06:49,176
It's a read-only property,


143
00:06:49,176 --> 00:06:51,226
so it only has a get,
as you can see here.


144
00:06:51,526 --> 00:06:53,196
And in Objective-C,
it also comes


145
00:06:53,196 --> 00:06:57,486
across as property
class, as you can see.


146
00:06:58,186 --> 00:07:00,016
Now generics, we've
been applying them


147
00:07:00,016 --> 00:07:02,476
to our collections' classes
but they're really, you know,


148
00:07:02,476 --> 00:07:03,576
not just for collections


149
00:07:03,576 --> 00:07:05,486
but they have many
other uses everywhere,


150
00:07:05,486 --> 00:07:07,036
I'm sure as you're aware.


151
00:07:07,436 --> 00:07:10,326
Here's an example from
Core Data, NSFetchRequest.


152
00:07:11,686 --> 00:07:14,376
Here's the way it's declared
in 10.11, pretty simple.


153
00:07:14,456 --> 00:07:16,606
In 10.12, we just went ahead


154
00:07:16,606 --> 00:07:19,016
and added a parameterized
type ResultType.


155
00:07:19,376 --> 00:07:23,436
We also touched a few other
APIs and we added some,


156
00:07:23,436 --> 00:07:24,786
such as this execute method


157
00:07:24,786 --> 00:07:27,686
which returns an array
of that result type.


158
00:07:28,076 --> 00:07:30,986
As a result of this, the use
case now becomes something


159
00:07:30,986 --> 00:07:31,556
like this.


160
00:07:31,916 --> 00:07:34,906
You have a request which you
get from a managed object,


161
00:07:34,906 --> 00:07:38,016
such as employee, and then when
you go ahead and execute that,


162
00:07:38,236 --> 00:07:40,176
your return now is
automatically inferred


163
00:07:40,176 --> 00:07:42,096
to be an array of employee.


164
00:07:42,716 --> 00:07:45,086
Now this is the case
right now but we're hoping


165
00:07:45,086 --> 00:07:47,816
that in upcoming seeds we'll
actually reflect this a little


166
00:07:47,816 --> 00:07:50,476
cleaner like so, which
is actually pretty cool.


167
00:07:50,476 --> 00:07:53,986
So from those two lines, the
compiler is able to infer


168
00:07:53,986 --> 00:07:56,126
that the return type is an
array of that managed object.


169
00:07:56,616 --> 00:07:59,966
We've been improving
our enumeration names.


170
00:08:00,366 --> 00:08:03,936
An example that we've done this
time around is NSColorPanelMode.


171
00:08:04,366 --> 00:08:07,266
The change -- And here's a
use case for it in Swift.


172
00:08:07,446 --> 00:08:08,966
You'll see that's
not very swifty


173
00:08:09,806 --> 00:08:12,836
because .NSCrayonModeColorPanel
is fairly wordy.


174
00:08:13,646 --> 00:08:17,396
The change we've done is to take
the common suffix and pull it


175
00:08:17,396 --> 00:08:19,306
in as a prefix, which
allows the Swift names


176
00:08:19,306 --> 00:08:20,716
to come across a lot cleaner.


177
00:08:20,786 --> 00:08:22,676
You know, where the
point just comes through,


178
00:08:23,036 --> 00:08:25,026
and the use case is .crayon.


179
00:08:25,076 --> 00:08:27,006
Again, this is what
it looked like before


180
00:08:27,516 --> 00:08:30,786
and this is what it looks
like now, fairly clean.


181
00:08:31,506 --> 00:08:34,895
Now in the enumerations area,
we've also now taking advantage


182
00:08:34,895 --> 00:08:35,895
of string enumerations.


183
00:08:35,895 --> 00:08:37,895
Swift supports string-valued
enumerations


184
00:08:38,206 --> 00:08:41,275
and in many cases Cocoa APIs
expose groups of strings


185
00:08:41,275 --> 00:08:44,526
as opened or closed sets of
APIs that we use in our APIs.


186
00:08:44,526 --> 00:08:47,756
And let's look at an example
using string transforms.


187
00:08:48,946 --> 00:08:51,476
In Swift 2 we had a bunch
of global constants.


188
00:08:52,026 --> 00:08:54,486
NSStringTransformLatinToGreek
and so on.


189
00:08:54,626 --> 00:08:57,066
And then we have an API,
stringByApplyingTransform


190
00:08:57,066 --> 00:08:59,356
that took those strings
as its first argument.


191
00:08:59,876 --> 00:09:02,116
In Swift 3 we've actually
added a new type called


192
00:09:02,116 --> 00:09:05,526
StringTransform and then an
extension we declared various


193
00:09:05,526 --> 00:09:07,766
values for that,
such as LatinToGreek.


194
00:09:08,056 --> 00:09:10,916
And the API that takes
that is applyingTransform,


195
00:09:10,916 --> 00:09:15,456
where the first argument is now
an official StringTransform.


196
00:09:15,586 --> 00:09:19,256
So the string argument has
now become StringTransform,


197
00:09:19,256 --> 00:09:20,586
a little more type safe.


198
00:09:21,126 --> 00:09:24,876
Now note that this is an
open-ended enumeration


199
00:09:25,066 --> 00:09:26,866
in that you can declare
your own values.


200
00:09:27,406 --> 00:09:31,906
Let me show you how you do that.


201
00:09:32,086 --> 00:09:33,406
You can go ahead
and add an extension


202
00:09:33,406 --> 00:09:35,866
to StringTransform yourself
and define your own type.


203
00:09:36,216 --> 00:09:39,896
Now the values here are the
values ICU Library accepts


204
00:09:39,896 --> 00:09:41,266
for doing transforms.


205
00:09:41,266 --> 00:09:44,496
So you can use any valid
ID that ICU provides.


206
00:09:44,856 --> 00:09:47,316
It turns out Any to
Publishing is one ICU has


207
00:09:47,316 --> 00:09:49,456
that we don't expose
on our APIs.


208
00:09:49,456 --> 00:09:52,826
So again, go ahead and define
your own publishing transform


209
00:09:53,106 --> 00:09:55,706
and pass it to the APIs just
as if it's a built-in one.


210
00:09:57,916 --> 00:10:00,686
And string enumerations are
also available in Objective-C


211
00:10:00,686 --> 00:10:03,916
by using of these two macros
for open or close-ended sets.


212
00:10:04,376 --> 00:10:06,796
And here's the way the string
transform declaration was


213
00:10:06,796 --> 00:10:07,456
in fact added.


214
00:10:07,456 --> 00:10:09,046
In 10.11, this is what we had.


215
00:10:09,046 --> 00:10:11,436
And in 10.12, we have a
new type string transform


216
00:10:11,436 --> 00:10:16,096
which is decorated as NS
Extensible String Enum.


217
00:10:17,066 --> 00:10:19,776
And we're also taking
advantage of Swift's ability


218
00:10:19,776 --> 00:10:24,246
to nest declarations related
about a type, into that type.


219
00:10:24,726 --> 00:10:26,996
An example here from NSData.


220
00:10:26,996 --> 00:10:29,756
We had a option set,
NSDataWritingOptions


221
00:10:30,266 --> 00:10:34,396
and class NSData with an API
writeToURL that used that value.


222
00:10:34,896 --> 00:10:37,926
In Swift 3, this comes
across as class NSData


223
00:10:38,266 --> 00:10:40,796
with a nested WritingOptions,
as you can see here.


224
00:10:42,056 --> 00:10:45,346
And the API that uses
it actually just refers


225
00:10:45,346 --> 00:10:46,226
to WritingOptions, which is


226
00:10:46,226 --> 00:10:48,226
of course much more
cleaner, much better scoped.


227
00:10:48,816 --> 00:10:51,056
Now unrelated to
this nesting change,


228
00:10:51,056 --> 00:10:52,196
you'll note a few more things.


229
00:10:53,436 --> 00:10:55,766
So that's the change
in the type.


230
00:10:56,056 --> 00:11:00,426
You'll also you might note that
we now provide default values


231
00:11:00,426 --> 00:11:03,636
of an empty set most cases
where we pass options in,


232
00:11:03,636 --> 00:11:04,716
which means you actually
don't have


233
00:11:04,776 --> 00:11:06,366
to pass the options
argument anymore.


234
00:11:07,116 --> 00:11:10,006
You might've also noticed that
NSURL has become URL here.


235
00:11:10,066 --> 00:11:11,716
You might've already heard
about this but we'll talk


236
00:11:11,716 --> 00:11:13,386
about this more later
in the talk.


237
00:11:15,016 --> 00:11:17,296
Now my last topic
before I escape the stage


238
00:11:17,296 --> 00:11:20,396
for now is noescape.


239
00:11:20,896 --> 00:11:24,136
Okay. So noescape indicates


240
00:11:24,186 --> 00:11:27,496
that a closure's execution will
not escape the function call.


241
00:11:28,006 --> 00:11:28,966
What do I mean by that?


242
00:11:29,076 --> 00:11:29,656
Here's a method


243
00:11:29,656 --> 00:11:31,976
from NSCollection view
performBatchUpdates.


244
00:11:32,186 --> 00:11:33,836
It takes two closure arguments.


245
00:11:34,856 --> 00:11:37,466
You'll note that the first
one is marked with noescape.


246
00:11:37,526 --> 00:11:38,756
This means that the execution


247
00:11:38,756 --> 00:11:42,596
of this closure will
finish before this API


248
00:11:42,796 --> 00:11:44,256
performBatchUpdates returns.


249
00:11:44,566 --> 00:11:46,906
The second argument is
not labeled noescape,


250
00:11:46,936 --> 00:11:50,866
which means that the execution
of this closure might happen


251
00:11:51,166 --> 00:11:52,606
after this function returns.


252
00:11:52,826 --> 00:11:54,626
So it's a good hint to
you and so a good hint


253
00:11:54,626 --> 00:11:55,646
for the compiler as well.


254
00:11:56,006 --> 00:11:58,096
This facility is also
available in Objective-C


255
00:11:58,316 --> 00:12:00,706
where we can decorate
closures with NS NOESCAPE


256
00:12:00,796 --> 00:12:01,686
to get the same effect.


257
00:12:02,616 --> 00:12:05,506
So that's it for our quick
overview of general API changes.


258
00:12:05,826 --> 00:12:07,466
Now note in the seed you have,


259
00:12:07,746 --> 00:12:09,296
we haven't done everything
we want to do yet,


260
00:12:09,296 --> 00:12:11,636
so there will be some
string enumeration changes,


261
00:12:11,636 --> 00:12:14,026
class property changes coming
in other seeds as well.


262
00:12:14,396 --> 00:12:16,646
So we're going to
apply to more APIs.


263
00:12:20,046 --> 00:12:22,026
So with that, let's talk
about AppKit and I'm going


264
00:12:22,026 --> 00:12:24,936
to invite Raleigh Ledet
on stage to kick that off.


265
00:12:25,206 --> 00:12:25,456
Thank you.


266
00:12:26,516 --> 00:12:30,036
[ Applause ]


267
00:12:30,536 --> 00:12:31,046
>> Thank you, Ali.


268
00:12:31,046 --> 00:12:32,226
Good morning, everyone.


269
00:12:33,336 --> 00:12:36,326
As you can see, we've been very
busy this past year in AppKit.


270
00:12:36,826 --> 00:12:40,076
So let's dive right on in and
talk about window snapping.


271
00:12:41,526 --> 00:12:45,116
So when you're dragging
a window in macOS Sierra,


272
00:12:45,266 --> 00:12:47,556
as you bump up against the
edges will stick at the edges


273
00:12:47,746 --> 00:12:49,786
and as you get along the
top edge of another window


274
00:12:49,786 --> 00:12:51,046
and even during resizing.


275
00:12:51,406 --> 00:12:55,046
So it's now much easier for
you to align windows together


276
00:12:55,216 --> 00:12:57,926
and resize them just the
way you really want to do.


277
00:12:58,516 --> 00:13:01,616
And we spent a lot of effort
here in providing heuristics


278
00:13:01,616 --> 00:13:03,906
to make sure that we only
provide the snapping behavior


279
00:13:04,276 --> 00:13:06,006
when that is what
you are trying to do


280
00:13:06,006 --> 00:13:07,366
with your windows
in the first place.


281
00:13:08,366 --> 00:13:10,956
The way you get snapping
behavior in your application is


282
00:13:10,956 --> 00:13:14,036
to just let the system do the
dragging of the window for you.


283
00:13:14,916 --> 00:13:16,746
If you track the mouse yourself


284
00:13:16,746 --> 00:13:19,156
and manually position
the window, you're going


285
00:13:19,156 --> 00:13:21,816
to bypass window snapping and
we will put the window exactly


286
00:13:21,816 --> 00:13:24,596
where you ask us to put it, just
as we have in previous releases.


287
00:13:25,156 --> 00:13:29,416
As you've seen in the keynote,
we now have window tabbing.


288
00:13:29,416 --> 00:13:34,006
This is an example of TextEdit
with three document tabs open.


289
00:13:34,606 --> 00:13:37,366
And the thing about
window tabbing is they are


290
00:13:37,366 --> 00:13:38,296
just windows.


291
00:13:38,876 --> 00:13:42,916
So this example of TextEdit with
three tabs is actually backed


292
00:13:42,976 --> 00:13:44,676
by three different NS windows.


293
00:13:46,146 --> 00:13:50,586
So what we do is every one of
these windows, as long as one


294
00:13:50,586 --> 00:13:52,386
of the tabs is visible,
is considered visible.


295
00:13:52,996 --> 00:13:55,306
So if you check the
NSWindow's .visible property,


296
00:13:55,366 --> 00:13:56,586
it's going to return true.


297
00:13:57,446 --> 00:13:59,906
But only the visible tab
is actually being rendered


298
00:13:59,906 --> 00:14:00,636
to the screen.


299
00:14:00,866 --> 00:14:03,666
We hide all the other windows
at the windows server level


300
00:14:04,056 --> 00:14:05,316
so they aren't rendered
and aren't taking


301
00:14:05,316 --> 00:14:06,216
up resources that way.


302
00:14:06,816 --> 00:14:10,486
And we handle this
all automatically.


303
00:14:11,436 --> 00:14:13,726
So how do you add a
new tab to your window?


304
00:14:14,736 --> 00:14:17,076
You create a new window
and you just order it front


305
00:14:17,076 --> 00:14:19,886
and we will go ahead and create
a tab appropriately for you


306
00:14:20,196 --> 00:14:21,676
and place it in the window.


307
00:14:22,216 --> 00:14:25,546
If you want to remove a tab,
you order your window out


308
00:14:25,876 --> 00:14:27,406
and we'll go ahead
and remove the tab.


309
00:14:27,666 --> 00:14:29,006
This is all done automatically.


310
00:14:29,496 --> 00:14:33,086
Now if the user resizes the
window, we're only going


311
00:14:33,086 --> 00:14:35,126
to resize the window
associated with the active tab.


312
00:14:36,236 --> 00:14:38,046
We don't want to take
the processing time


313
00:14:38,046 --> 00:14:39,666
to manage the other windows


314
00:14:39,666 --> 00:14:41,276
when the users might
not switch to them.


315
00:14:41,596 --> 00:14:43,826
But when the user does switch
to one of the other tabs,


316
00:14:43,876 --> 00:14:45,686
at that point AppKit goes ahead


317
00:14:45,686 --> 00:14:48,616
and resizes the windows
appropriately, re-renders it,


318
00:14:48,836 --> 00:14:50,806
and then changes the
hidden properties


319
00:14:50,806 --> 00:14:51,956
at the window server level,


320
00:14:52,016 --> 00:14:54,566
and so the user gets
the seamless experience


321
00:14:54,566 --> 00:14:57,946
of one window with multiple tabs
even though behind the scenes


322
00:14:57,946 --> 00:14:59,766
we're just dealing
with three windows.


323
00:15:02,286 --> 00:15:05,236
So I want to cover some
areas of what you need to do


324
00:15:05,236 --> 00:15:07,206
in your applications
to adopt tabs


325
00:15:07,486 --> 00:15:09,706
into your applications
depending on what style


326
00:15:09,706 --> 00:15:10,626
of application you have.


327
00:15:11,216 --> 00:15:14,216
If you have for example an
NSDocument based application


328
00:15:14,656 --> 00:15:17,316
or a non-NSDocument
based application.


329
00:15:17,746 --> 00:15:18,646
What you might want to do


330
00:15:18,646 --> 00:15:21,026
if you already have an
existing tab implementation,


331
00:15:21,336 --> 00:15:24,886
and I'll round the section out
with some API that you can use


332
00:15:25,096 --> 00:15:27,276
to customize tabs
in your application.


333
00:15:28,366 --> 00:15:30,406
If you're in an NSDocument
based app,


334
00:15:30,526 --> 00:15:31,466
there's nothing for you to do.


335
00:15:31,516 --> 00:15:34,966
This is fully automatic and,
in fact, in TextEdit here,


336
00:15:34,966 --> 00:15:38,206
we made exactly zero lines
of code changes in TextEdit.


337
00:15:38,446 --> 00:15:41,426
It fully supports tabs and it
just works right out the box.


338
00:15:42,596 --> 00:15:46,106
If you're a non-NSDocument
based app, it's mostly automatic


339
00:15:46,106 --> 00:15:48,366
but what you'll probably
need to do is enable


340
00:15:48,366 --> 00:15:51,776
to New Tab button
in your application.


341
00:15:52,236 --> 00:15:54,816
The New Tab button is
this plus button over here


342
00:15:55,056 --> 00:15:56,216
to the right of all the tabs.


343
00:15:57,546 --> 00:15:59,096
To enable that button, you need


344
00:15:59,096 --> 00:16:02,266
to implement this
newWindowForTab NSResponder


345
00:16:02,266 --> 00:16:05,856
override in your NSWindow
subclass or somewhere higher


346
00:16:05,856 --> 00:16:06,746
up the responder chain.


347
00:16:06,816 --> 00:16:08,786
For example, your
NSWindow delegate


348
00:16:09,136 --> 00:16:12,176
or your NSWindow controller
or your NSWindow document.


349
00:16:12,306 --> 00:16:14,986
If you implement this override
in any one of those places,


350
00:16:14,986 --> 00:16:17,066
AppKit will see it
and will go ahead


351
00:16:17,066 --> 00:16:19,506
and enable the New Tab
button for you automatically.


352
00:16:20,146 --> 00:16:24,756
If you have your own
existing tab implementation,


353
00:16:25,046 --> 00:16:25,736
then you probably want


354
00:16:25,736 --> 00:16:28,746
to disable AppKit's automatic
window tabbing behavior.


355
00:16:29,626 --> 00:16:30,986
There's this class property


356
00:16:30,986 --> 00:16:33,296
on NSWindow
allowsAutomaticWindowTabbing.


357
00:16:34,196 --> 00:16:36,556
This is a class property
early in the bring-up


358
00:16:36,556 --> 00:16:38,106
of your application
called NSWindow.


359
00:16:38,106 --> 00:16:42,026
allowsAutomaticWindowTabbing
equal false


360
00:16:42,196 --> 00:16:44,586
and this will turn off
AppKit's tabbing behavior


361
00:16:44,896 --> 00:16:48,006
and then you can continue using
your own tabbing implementation.


362
00:16:48,416 --> 00:16:50,646
It's important that you call
this early in the bring-up


363
00:16:50,646 --> 00:16:55,116
of your application before you
start ordering windows front.


364
00:16:56,126 --> 00:16:57,576
That's all you really need to do


365
00:16:57,576 --> 00:16:59,666
to adopt tabs in
your application.


366
00:16:59,666 --> 00:17:00,776
It works mostly automatically.


367
00:17:00,776 --> 00:17:03,516
But here's some of the API that
you can use to customize things.


368
00:17:04,146 --> 00:17:07,205
First off, the user can
define some of the behavior


369
00:17:07,205 --> 00:17:10,086
on how they want tabbing
to work on their system


370
00:17:10,215 --> 00:17:11,915
and they can do this in
the System Preferences


371
00:17:11,915 --> 00:17:13,906
and you can find out what
the user preference is


372
00:17:13,935 --> 00:17:17,826
by the class property user
tabbing preferences on NSWindow


373
00:17:17,886 --> 00:17:21,445
and they can set it to manual,
always or to only do tabbing


374
00:17:21,445 --> 00:17:23,165
when they're in full screen.


375
00:17:25,056 --> 00:17:27,146
The rest of these properties
and functions from here


376
00:17:27,146 --> 00:17:29,726
on out I'm going to discuss
are instance properties


377
00:17:29,726 --> 00:17:30,896
and functions on NSWindow.


378
00:17:31,626 --> 00:17:33,836
So once you have an
instance of an NSWindow,


379
00:17:34,066 --> 00:17:35,346
you can set it to tabbing mode.


380
00:17:35,776 --> 00:17:37,666
By default, this tabbing
mode is automatic,


381
00:17:37,666 --> 00:17:38,506
which means we're just going


382
00:17:38,506 --> 00:17:40,546
to follow what the user
tabbing preferences are,


383
00:17:40,546 --> 00:17:43,396
but you can set it to
preferred or disallowed,


384
00:17:43,396 --> 00:17:44,996
depending on your window
type and your needs.


385
00:17:45,876 --> 00:17:50,516
When we group windows together
into a set of tabs, we only want


386
00:17:50,516 --> 00:17:52,796
to group windows that are
similar and the way we do


387
00:17:52,796 --> 00:17:54,676
that is by looking at
the tabbing identifier.


388
00:17:54,956 --> 00:17:57,266
So windows that have the same
tabbing identifier can be


389
00:17:57,266 --> 00:17:58,596
grouped together into tabs.


390
00:17:59,296 --> 00:18:01,926
By default, AppKit will use
a heuristic and try and come


391
00:18:01,926 --> 00:18:03,816
up with a tabbing
identifier on your behalf.


392
00:18:04,106 --> 00:18:07,436
We look at things such as
the windows subclass name,


393
00:18:07,806 --> 00:18:11,046
the properties of the
window, the document,


394
00:18:11,046 --> 00:18:13,336
and various few other
properties to try and come


395
00:18:13,336 --> 00:18:15,906
up with the appropriate
tabbing identifier.


396
00:18:16,516 --> 00:18:17,576
This works really well,


397
00:18:17,986 --> 00:18:20,606
but if it doesn't quite work
well enough for your application


398
00:18:20,606 --> 00:18:23,696
or if you want to have
more control over it,


399
00:18:23,696 --> 00:18:25,596
you can set the tabbing
identifier manually


400
00:18:25,826 --> 00:18:27,346
and AppKit will respect that.


401
00:18:28,556 --> 00:18:31,086
You can find out what are the
windows are grouped together


402
00:18:31,086 --> 00:18:34,386
with some instance of a
window together in tabs


403
00:18:34,386 --> 00:18:35,896
by asking for the tab windows.


404
00:18:36,506 --> 00:18:38,586
Note this returns
an optional array.


405
00:18:38,976 --> 00:18:41,326
It can return nil and
it will return nil


406
00:18:41,326 --> 00:18:42,736
if the tab bar isn't even shown


407
00:18:42,736 --> 00:18:44,946
and there are no tabs
associated at all.


408
00:18:46,106 --> 00:18:50,516
And you can manually add
another tab window together


409
00:18:50,516 --> 00:18:51,116
to the group.


410
00:18:51,236 --> 00:18:53,836
Since these are just windows
that explains the API name


411
00:18:53,836 --> 00:18:56,746
where you add a tab window,
instead of adding a tab itself,


412
00:18:56,746 --> 00:18:58,946
you add the tab window
and you order it using


413
00:18:58,946 --> 00:19:01,456
NSWindowOrderingMode and
that will order the tab


414
00:19:01,916 --> 00:19:03,316
in relation to the other tabs.


415
00:19:05,446 --> 00:19:08,686
AppKit will add a few
new items to your menu.


416
00:19:09,136 --> 00:19:12,306
Namely in the windows menu,
we add some items to go ahead


417
00:19:12,306 --> 00:19:15,016
and help the user
navigate the tabs,


418
00:19:15,196 --> 00:19:17,216
such as selecting the
next or previous tab.


419
00:19:17,696 --> 00:19:20,876
These are just IB actions on
NSWindow and you can wire them


420
00:19:20,876 --> 00:19:23,266
up to your own user
interface items as well.


421
00:19:23,266 --> 00:19:25,396
For example, you might
want to have a button


422
00:19:25,396 --> 00:19:26,576
that toggles the tab bar.


423
00:19:26,876 --> 00:19:28,866
You just wire that
button up to the window,


424
00:19:30,196 --> 00:19:31,986
toggleTabBar IBAction


425
00:19:32,556 --> 00:19:35,766
and NSWindow will handle
toggling the tab bar for you.


426
00:19:36,896 --> 00:19:39,606
So that's everything about
window snapping and tabbing.


427
00:19:40,196 --> 00:19:42,926
Let's move ahead and talk
about right-to-left support.


428
00:19:42,926 --> 00:19:44,656
We've done a lot
of work in AppKit


429
00:19:44,656 --> 00:19:47,156
to enhance our already
existing right-to-left support.


430
00:19:47,766 --> 00:19:50,956
In the screenshot you can
see here's TextEdit running


431
00:19:50,956 --> 00:19:51,516
in Arabic.


432
00:19:51,956 --> 00:19:54,166
The title bar is flipped.


433
00:19:54,386 --> 00:19:56,336
The scrollers are
flipped to the other side.


434
00:19:56,336 --> 00:19:58,156
Even the new tab button is
flipped to the other side.


435
00:19:58,416 --> 00:20:00,016
And all the little attributes


436
00:20:00,016 --> 00:20:02,176
and the various title bar
buttons are all flipped


437
00:20:02,176 --> 00:20:04,586
appropriately as a
right-to-left user would expect.


438
00:20:06,046 --> 00:20:08,146
I want to talk about
right-to-left support


439
00:20:08,146 --> 00:20:09,166
at three different levels.


440
00:20:09,476 --> 00:20:10,926
What's going on at
the system level,


441
00:20:10,926 --> 00:20:13,166
where the user sets
their localization


442
00:20:13,166 --> 00:20:14,286
in the system preference pane,


443
00:20:15,196 --> 00:20:17,266
how that impacts your
application, and what goes


444
00:20:17,266 --> 00:20:18,486
on in your application depending


445
00:20:18,486 --> 00:20:20,306
on the localizations
that you support.


446
00:20:20,836 --> 00:20:22,536
And then finally down
to the content level,


447
00:20:22,536 --> 00:20:23,916
which is at the NSView level


448
00:20:24,256 --> 00:20:26,666
where you can override
things further if needed


449
00:20:26,666 --> 00:20:28,326
with the user interface
layout direction.


450
00:20:28,906 --> 00:20:30,566
And then I'm going
wrap this whole section


451
00:20:30,566 --> 00:20:33,696
up with a really nice
development tip to help you work


452
00:20:34,006 --> 00:20:36,376
on right-to-left support
in your application.


453
00:20:37,576 --> 00:20:39,886
To start off with, let's
talk about the system level.


454
00:20:41,206 --> 00:20:42,916
The key here is consistency.


455
00:20:43,156 --> 00:20:45,356
We want to have a
consistent appearance


456
00:20:45,356 --> 00:20:47,466
to the user who's running
in a right-to-left system.


457
00:20:47,986 --> 00:20:51,056
So regardless of what
localization you may support


458
00:20:51,056 --> 00:20:53,866
in your application,
we want all menu bars


459
00:20:54,136 --> 00:20:57,746
on a right-to-left system
to start off with the apple


460
00:20:57,746 --> 00:21:00,276
over here on the right
side followed with the rest


461
00:21:00,276 --> 00:21:03,716
of the menu items
and this likewise


462
00:21:03,716 --> 00:21:05,076
for the windows title bar.


463
00:21:06,076 --> 00:21:07,556
So the traffic lights
are going to be flipped


464
00:21:07,556 --> 00:21:09,126
over to the other side
and anything that's not


465
00:21:09,126 --> 00:21:10,446
in the content area
is going to be flipped


466
00:21:10,446 --> 00:21:11,336
over to the other side,


467
00:21:11,746 --> 00:21:14,076
regardless of what localization
you have in your application,


468
00:21:14,296 --> 00:21:16,526
providing a consistent
experience to the user.


469
00:21:17,376 --> 00:21:18,896
Now we can't automatically
do this


470
00:21:18,896 --> 00:21:22,166
down into the application
level, because we don't want


471
00:21:22,166 --> 00:21:23,006
to break any assumptions


472
00:21:23,006 --> 00:21:24,356
that your application
might be having.


473
00:21:24,846 --> 00:21:28,616
So it's highly recommended that
you add right-to-left support


474
00:21:28,616 --> 00:21:31,996
in your application, add Hebrew
and Arabic localizations.


475
00:21:32,646 --> 00:21:35,896
And once you have those
localizations in place


476
00:21:36,316 --> 00:21:37,826
at an application level,


477
00:21:37,826 --> 00:21:40,196
all your scroll views will
automatically flip the vertical


478
00:21:40,196 --> 00:21:41,196
scroller and rulers


479
00:21:41,456 --> 00:21:43,736
and NSBrowser will automatically
be flipped as well.


480
00:21:44,096 --> 00:21:47,116
At this level, again we want
consistency so regardless


481
00:21:47,116 --> 00:21:50,816
of what content views user
interface layout direction may


482
00:21:50,816 --> 00:21:53,576
be, we want the scroll
bars to always be


483
00:21:53,576 --> 00:21:55,686
on the same side
for consistency.


484
00:21:55,686 --> 00:21:58,766
Moving down to the
content level,


485
00:21:59,286 --> 00:22:01,366
by default the user interface
layout direction is going


486
00:22:01,366 --> 00:22:04,116
to match what your
application is set to.


487
00:22:05,416 --> 00:22:08,616
This is exactly what you
want for almost all cases


488
00:22:08,616 --> 00:22:10,986
but there are a few exceptions,
namely if you have something


489
00:22:10,986 --> 00:22:15,126
like media controls or spatial
controls or time controls


490
00:22:15,126 --> 00:22:19,696
where it is always laid out
the same way left to right


491
00:22:19,696 --> 00:22:22,396
for both left-to-right users
and right-to-left users.


492
00:22:23,086 --> 00:22:25,836
So you can modify the user
interface layout direction.


493
00:22:26,556 --> 00:22:29,016
And the following controls
in AppKit support that.


494
00:22:29,406 --> 00:22:31,986
So auto layout will
not in this seed


495
00:22:31,986 --> 00:22:37,516
but in the upcoming seed two
we'll start using the parent


496
00:22:37,686 --> 00:22:44,776
container to determine what is
the trailing and leading edges.


497
00:22:46,036 --> 00:22:47,656
And already in the
seed, table view


498
00:22:47,656 --> 00:22:50,246
and outline view will flip
their columns appropriately.


499
00:22:50,246 --> 00:22:54,746
NSPageController switches its
animations and the list goes on.


500
00:22:54,746 --> 00:22:57,996
We have a lot of support in
AppKit for right-to-left.


501
00:22:57,996 --> 00:23:00,016
Let AppKit do the heavy
lifting where you can


502
00:23:00,476 --> 00:23:04,486
and provide your right-to-left
users a great experience.


503
00:23:05,086 --> 00:23:08,596
I promised you a
development tip.


504
00:23:08,596 --> 00:23:10,076
I've been using this
tip all year.


505
00:23:10,156 --> 00:23:11,876
I found it incredibly useful.


506
00:23:12,246 --> 00:23:14,786
In Xcode, you can modify
the scheme of your projects


507
00:23:14,986 --> 00:23:17,606
in the Options section, change
your application language


508
00:23:17,606 --> 00:23:19,046
to right-to-left pseudolanguage.


509
00:23:19,626 --> 00:23:21,526
This allows you to
run your application


510
00:23:21,526 --> 00:23:24,086
in your development language,
and for me that's English,


511
00:23:24,436 --> 00:23:26,216
and so you can see
TextEdit running in English,


512
00:23:26,706 --> 00:23:30,916
but it is all using
right-to-left flipped controls


513
00:23:30,916 --> 00:23:31,116
in it.


514
00:23:31,336 --> 00:23:34,326
So the window title
bar is flipped.


515
00:23:34,576 --> 00:23:36,386
The scroller for the
scroll view is flipped


516
00:23:36,486 --> 00:23:39,386
and you can see all the little
subitems and all the buttons


517
00:23:39,386 --> 00:23:40,356
of the title bar are flipped.


518
00:23:40,536 --> 00:23:44,066
So it's a much easier
way for you to work


519
00:23:44,066 --> 00:23:44,936
on right-to-left support


520
00:23:44,936 --> 00:23:46,646
and make sure everything
is working properly


521
00:23:46,886 --> 00:23:47,856
in your native language.


522
00:23:48,596 --> 00:23:52,076
Now I've just covered what
we're doing in AppKit here.


523
00:23:53,126 --> 00:23:55,966
There's a lot more to
talk about in the What New


524
00:23:55,966 --> 00:23:58,626
in International User Interfaces
talk in Nob Hill on Friday


525
00:23:58,626 --> 00:24:01,326
at 9:00 a.m. They cover
more things on the desktop


526
00:24:01,326 --> 00:24:06,096
such as WebKit, text
layout, asset management,


527
00:24:06,096 --> 00:24:09,056
and they also cover
right-to-left support in iOS.


528
00:24:09,056 --> 00:24:11,176
So I highly recommend that you
check out this talk as well.


529
00:24:14,176 --> 00:24:15,936
Let's now talk about
promise drags.


530
00:24:16,296 --> 00:24:18,336
If you're not familiar,
a promise drag is


531
00:24:18,336 --> 00:24:21,376
when the user is dragging a
file from your application


532
00:24:22,306 --> 00:24:25,826
but you don't have this
file on disc anywhere yet.


533
00:24:26,216 --> 00:24:27,436
But you're just going to promise


534
00:24:27,436 --> 00:24:29,496
that you'll write it wherever
the user wants to drop it.


535
00:24:29,966 --> 00:24:31,086
That's a file promise drag.


536
00:24:31,086 --> 00:24:32,756
We've supported file
promise drags


537
00:24:33,186 --> 00:24:34,616
in OS X since the beginning.


538
00:24:35,876 --> 00:24:38,746
In macOS Sierra, we're
updating our file promise drag


539
00:24:38,806 --> 00:24:41,976
to be more modern with the
new NSFilePromiseProvider


540
00:24:41,976 --> 00:24:44,226
and NSFilePromiseReciever
objects.


541
00:24:45,006 --> 00:24:47,456
Now these objects allow
file promise drags


542
00:24:47,456 --> 00:24:48,826
to support drag flocking.


543
00:24:49,256 --> 00:24:50,596
If you're not familiar
with drag flocking,


544
00:24:50,596 --> 00:24:52,136
it's when you're
dragging number of items


545
00:24:52,386 --> 00:24:54,466
and they can change
their formation mid-drag,


546
00:24:54,466 --> 00:24:56,606
depending on the
destination application


547
00:24:56,606 --> 00:24:57,466
and what's going on there.


548
00:24:59,376 --> 00:25:02,316
So file promise drags with
these two new classes support


549
00:25:02,486 --> 00:25:03,216
drag flocking.


550
00:25:03,286 --> 00:25:04,246
They're UTI based.


551
00:25:04,596 --> 00:25:07,086
They're completely pasteboard
writer and reader compliant,


552
00:25:07,086 --> 00:25:10,916
which means you can use the
item-based API on NSPasteboard


553
00:25:10,916 --> 00:25:12,476
to work with these objects,


554
00:25:13,366 --> 00:25:15,096
and they're file
coordinated when possible.


555
00:25:15,096 --> 00:25:16,976
So you don't need to worry
about file coordination.


556
00:25:16,976 --> 00:25:19,366
We'll automatically wrap
up a file coordinated read


557
00:25:19,366 --> 00:25:21,526
or write on your behalf.


558
00:25:21,776 --> 00:25:23,376
And they're backwards
compatible.


559
00:25:24,226 --> 00:25:25,036
They're backwards compatible


560
00:25:25,036 --> 00:25:27,696
with the non-item
based file promise API.


561
00:25:28,426 --> 00:25:30,846
And what this means is you only
need to worry about one API.


562
00:25:31,276 --> 00:25:33,776
If you implement an
NSFilePromiseProvider,


563
00:25:33,826 --> 00:25:35,376
you can now provide
a file promise


564
00:25:35,646 --> 00:25:38,996
to anybody that's using the
new NSFilePromiseReciever API


565
00:25:39,516 --> 00:25:42,206
or somebody that an existing
application that's using the


566
00:25:42,206 --> 00:25:43,286
non-item-based API.


567
00:25:43,736 --> 00:25:45,686
They will still be able to
accept your promised file


568
00:25:46,106 --> 00:25:49,336
and likewise with
NSFilePromiseReciever.


569
00:25:49,386 --> 00:25:51,356
You will be able to
accept file promises


570
00:25:51,386 --> 00:25:54,396
from anybody using an
NSFilePromiseProvider


571
00:25:54,586 --> 00:25:56,926
or using the non-item-based
API as well.


572
00:25:57,906 --> 00:26:03,646
So you want to provide a
file promise in your drag,


573
00:26:03,646 --> 00:26:06,016
so as the user starts to drag,
you need to create your promises


574
00:26:06,306 --> 00:26:08,246
and you do that by
creating an instance


575
00:26:08,246 --> 00:26:09,746
of NSFilePromiseProvider.


576
00:26:10,096 --> 00:26:13,306
You want to create an instance
for each one of the files


577
00:26:13,306 --> 00:26:15,116
that you are going to
promise and you need


578
00:26:15,116 --> 00:26:17,266
to provide an
NSFilePromiseProvider delegate.


579
00:26:17,706 --> 00:26:19,696
This delegate is what's
going to do the heavy lifting


580
00:26:19,696 --> 00:26:21,226
of writing the files to disc.


581
00:26:22,066 --> 00:26:24,646
At some point the destination
is going to call in this promise


582
00:26:24,776 --> 00:26:26,846
and you'll be asked to
provide the file name


583
00:26:26,846 --> 00:26:27,676
for the destination.


584
00:26:27,676 --> 00:26:29,386
Now you know where the
destination is, you can figure


585
00:26:29,386 --> 00:26:31,836
out the appropriate file name,
but do not write the file


586
00:26:31,836 --> 00:26:33,376
at this point because
it's not wrapped


587
00:26:33,376 --> 00:26:35,736
up with file coordination
yet and we're still figuring


588
00:26:35,736 --> 00:26:37,636
out some of the remaining
items of the drag.


589
00:26:38,316 --> 00:26:39,256
When the drag is completed


590
00:26:39,256 --> 00:26:40,826
and we know all the
information we need to know,


591
00:26:40,826 --> 00:26:43,386
we'll call your delegate back
and ask you to write the promise


592
00:26:43,386 --> 00:26:46,436
to URL and provide a
completion handler.


593
00:26:46,436 --> 00:26:50,606
At this point, it's all wrapped
up with file coordination write.


594
00:26:51,046 --> 00:26:53,526
So just write the file
out to the supplied URL


595
00:26:53,526 --> 00:26:56,056
and call the completion handler
to let file coordination know


596
00:26:56,056 --> 00:26:56,906
that you're finished writing.


597
00:26:58,136 --> 00:27:00,606
If you want to receive
a file promise,


598
00:27:00,916 --> 00:27:02,806
the first thing you need to
do is register with the view


599
00:27:02,806 --> 00:27:04,736
that you want to allow
the job to occur on.


600
00:27:04,736 --> 00:27:07,746
And this is normally done with
view.register forDraggedTypes


601
00:27:08,016 --> 00:27:08,856
and the drag types you need


602
00:27:08,856 --> 00:27:11,366
to add are the
NSFilePromiseReceiver.


603
00:27:11,366 --> 00:27:12,526
readableDrappedTypes.


604
00:27:12,636 --> 00:27:13,996
It's fairly straightforward.


605
00:27:15,156 --> 00:27:17,926
Now once the user is dragging
a file promise over that view,


606
00:27:17,926 --> 00:27:19,786
you'll start getting dragging
messages and you'll want


607
00:27:19,786 --> 00:27:21,376
to get the promise objects.


608
00:27:22,346 --> 00:27:26,186
So you can use the pasteboard
item-based API and just ask it


609
00:27:26,186 --> 00:27:29,626
to read the objects forClasses
NSFilePromiseReceiver.self


610
00:27:29,626 --> 00:27:32,386
and you'll get an array of
NSFilePromiseReceiver objects.


611
00:27:33,436 --> 00:27:35,456
Once you have an
NSFilePromiseReceiver object,


612
00:27:35,806 --> 00:27:37,006
you can call in the promise


613
00:27:37,236 --> 00:27:40,316
by calling receivePromisedFiles
atDestination options


614
00:27:40,406 --> 00:27:41,396
operationQueue reader.


615
00:27:41,396 --> 00:27:44,426
And it will return pretty
quickly from this function


616
00:27:44,626 --> 00:27:46,496
and your reader block will
not have been called yet.


617
00:27:46,496 --> 00:27:47,736
We're going to call
that back later.


618
00:27:48,976 --> 00:27:51,036
Once the source file has
finished writing all the


619
00:27:51,036 --> 00:27:54,466
promises, now we go ahead and
we call your reader block back


620
00:27:54,466 --> 00:27:56,356
on the operation queue
that you specified.


621
00:27:56,986 --> 00:28:01,786
Now it's important that you do
not specify NSMainOperationQueue


622
00:28:01,786 --> 00:28:03,696
for the operation queue
or else you're going


623
00:28:03,696 --> 00:28:07,596
to block your application while
waiting for the source process


624
00:28:07,696 --> 00:28:08,706
to finish writing the files.


625
00:28:08,896 --> 00:28:10,626
And this can take some
time and you don't want


626
00:28:10,626 --> 00:28:12,436
to block your application
during that whole time.


627
00:28:14,916 --> 00:28:18,256
And that's all there is to
do with file promise drags.


628
00:28:18,296 --> 00:28:22,356
It's much simpler API to use
and it works with drag flocking


629
00:28:22,356 --> 00:28:24,776
and supports the item-based
API with pasteboard.


630
00:28:25,556 --> 00:28:27,876
So let's move on and talk
about some improvements we made


631
00:28:27,876 --> 00:28:29,256
to our various container views.


632
00:28:29,576 --> 00:28:30,926
We'll start off with
collection view.


633
00:28:31,896 --> 00:28:34,796
With collection view, previously
when you would scroll,


634
00:28:35,266 --> 00:28:38,526
your contents would scroll
on top of any background view


635
00:28:38,526 --> 00:28:39,346
that you might've had.


636
00:28:39,686 --> 00:28:41,476
Well, now you can tell the
background view to scroll


637
00:28:41,476 --> 00:28:43,276
with your contexts by
setting backgroundViews


638
00:28:43,276 --> 00:28:45,936
ScrollsWithContent to true
and they scroll together.


639
00:28:47,126 --> 00:28:48,056
We also have support


640
00:28:48,056 --> 00:28:50,276
for optional floating
headers and footers.


641
00:28:50,276 --> 00:28:52,796
So you can see the documents
header here becomes floating


642
00:28:52,796 --> 00:28:54,296
and the content scrolls
underneath it.


643
00:28:56,036 --> 00:28:58,826
This is real easy to do with the
NSCollectionView float layout.


644
00:28:59,106 --> 00:29:01,256
Just set the
sectionHeadersPinToVisible true


645
00:29:01,256 --> 00:29:04,206
or the
sectionFootersPinToVisibleBounds


646
00:29:04,206 --> 00:29:05,876
true if you want
the footers to float


647
00:29:06,166 --> 00:29:07,796
and NSCollectionView
will then take care


648
00:29:07,796 --> 00:29:09,996
of doing everything
appropriately on your behalf.


649
00:29:11,236 --> 00:29:13,526
You can also optionally
collapse any section


650
00:29:13,916 --> 00:29:16,176
into a single horizontally
scrollable row,


651
00:29:16,176 --> 00:29:19,106
as you can see here, and you get
this nice little carousel effect


652
00:29:19,106 --> 00:29:20,416
whenever you scroll
horizontally.


653
00:29:21,346 --> 00:29:25,816
This is real easy to do with the
toggleSectionCollapse IBAction


654
00:29:25,906 --> 00:29:27,116
on NSCollectionView.


655
00:29:27,726 --> 00:29:31,976
Now the sender of this message
needs to be a view that is


656
00:29:31,976 --> 00:29:34,206
at your section header
or a descendent


657
00:29:34,206 --> 00:29:35,246
of your section header view


658
00:29:35,516 --> 00:29:38,616
and that is how NSCollectionView
can determine exactly


659
00:29:38,616 --> 00:29:41,226
which section needs to toggle
the collapse state for.


660
00:29:42,556 --> 00:29:47,246
Since you have your button in
your header view or descendent,


661
00:29:47,676 --> 00:29:49,466
you should have your
section header


662
00:29:49,616 --> 00:29:51,056
implement NSCollectionView


663
00:29:51,056 --> 00:29:53,956
SectionHeaderView protocol
and that's just to wire


664
00:29:53,956 --> 00:29:56,646
up your button to the
sectionCollapseButton outlet.


665
00:29:57,206 --> 00:29:59,596
Then NSCollectionView will now
be able to find your button


666
00:29:59,596 --> 00:30:01,056
and automatically
hide and show it,


667
00:30:01,276 --> 00:30:05,206
depending on if there
is enough data inside


668
00:30:05,206 --> 00:30:08,686
that section to collapse.


669
00:30:09,046 --> 00:30:11,786
NSTableView will now
reload full width cells


670
00:30:12,336 --> 00:30:13,976
when the column index
is negative 1.


671
00:30:13,976 --> 00:30:17,326
Negative 1 is our magic
number to say a column


672
00:30:17,746 --> 00:30:22,576
that expands all the way across
your table, across all columns.


673
00:30:22,936 --> 00:30:24,096
So when you call reloadData


674
00:30:24,096 --> 00:30:26,386
and columnIndexes includes
the negative 1 in there,


675
00:30:26,386 --> 00:30:27,786
we will automatically reload


676
00:30:27,786 --> 00:30:29,496
that full width cell
on your behalf.


677
00:30:29,976 --> 00:30:33,666
This only works for 10.12 and
later linked applications.


678
00:30:34,606 --> 00:30:37,186
Likewise on 10.12 linked
applications or later,


679
00:30:37,186 --> 00:30:40,546
NSOutlineView will also
automatically reload its cell


680
00:30:40,546 --> 00:30:44,416
views associated with the item
you pass in to reload item.


681
00:30:44,646 --> 00:30:48,526
Additionally, OutlineView now
strongly references the items


682
00:30:48,526 --> 00:30:50,696
you return to it
via the data source.


683
00:30:51,796 --> 00:30:56,736
This is really useful but if
your application really wants


684
00:30:56,736 --> 00:30:59,996
to maintain the original
assigned behavior


685
00:30:59,996 --> 00:31:03,216
that we had previously, you
can set stronglyReferencesItems


686
00:31:03,216 --> 00:31:07,416
to false and return to
the pre-10.12 behavior.


687
00:31:07,986 --> 00:31:13,896
And with that, I'd like to bring
up Taylor Kelly to go ahead


688
00:31:13,896 --> 00:31:15,726
and talk to you about
grid views.


689
00:31:16,516 --> 00:31:22,126
[ Applause ]


690
00:31:22,626 --> 00:31:23,106
>> Thanks, Raleigh.


691
00:31:24,026 --> 00:31:26,636
So the first thing I'd like to
tell you about is NSGridView.


692
00:31:27,166 --> 00:31:30,246
This is a new container view
class, similar to NSStackView


693
00:31:30,276 --> 00:31:31,396
where we completely create


694
00:31:31,396 --> 00:31:33,906
and manage the constraints
necessary to build your layout.


695
00:31:33,966 --> 00:31:37,446
But where StackView creates
a linear distribution of use,


696
00:31:37,706 --> 00:31:40,576
NSGridView creates these
intersecting rows and columns.


697
00:31:41,116 --> 00:31:42,576
You very commonly
see this in something


698
00:31:42,576 --> 00:31:43,536
like a preference pane UI.


699
00:31:43,536 --> 00:31:46,606
Right, there are these
distinct columns and rows


700
00:31:46,606 --> 00:31:48,916
of aligned content
that are self-sizing


701
00:31:49,136 --> 00:31:50,566
and pretty statically defined.


702
00:31:51,376 --> 00:31:55,616
It supports alignment such as
baseline, leading, and trailing.


703
00:31:55,616 --> 00:31:59,686
It supports spacing of the
GridView as a whole as well


704
00:31:59,686 --> 00:32:02,766
as its padding on an
individual row and column basis.


705
00:32:04,126 --> 00:32:05,496
Similar to a spreadsheet
application,


706
00:32:05,496 --> 00:32:06,646
it supports cell merging.


707
00:32:06,896 --> 00:32:09,116
So a single view can
span multiple rows


708
00:32:09,116 --> 00:32:10,186
or multiple columns.


709
00:32:11,186 --> 00:32:13,786
So for instance these
separators do just that.


710
00:32:15,226 --> 00:32:18,016
It also supports dynamic hiding
and showing of rows and columns


711
00:32:18,126 --> 00:32:19,996
without changing the
GridView's own structure.


712
00:32:20,556 --> 00:32:23,386
So for instance, when we click
on this checkbox, we might want


713
00:32:23,386 --> 00:32:24,926
to hide the Display
Preference button.


714
00:32:25,726 --> 00:32:28,376
And we can do that by getting
the row containing that button


715
00:32:28,376 --> 00:32:30,266
and just setting its
hidden property to true.


716
00:32:30,876 --> 00:32:32,396
GridView will take
care of the rest.


717
00:32:34,066 --> 00:32:35,746
There are several other
improvements we've made


718
00:32:35,746 --> 00:32:36,416
to Auto Layout.


719
00:32:37,126 --> 00:32:40,676
One is a cleanup of overall
AppKit layout cycle meaning


720
00:32:40,676 --> 00:32:42,876
that a view no longer needs
to be using auto layout


721
00:32:42,876 --> 00:32:44,746
or layer backing in
order to participate.


722
00:32:45,496 --> 00:32:47,646
Just by setting needsLayout
to true on that view,


723
00:32:47,936 --> 00:32:50,776
during the next display pass
it'll receive a call to layout.


724
00:32:52,136 --> 00:32:53,086
One implication of this is


725
00:32:53,086 --> 00:32:55,616
that layout is no longer
called twice per display pass


726
00:32:55,616 --> 00:32:59,246
for layer-backed views and we
have less implicit dirtying


727
00:32:59,246 --> 00:33:02,646
of that layout and less
layout passes because of that,


728
00:33:02,926 --> 00:33:04,206
which is great for performance.


729
00:33:04,676 --> 00:33:06,506
But if you notice that
layout isn't getting called


730
00:33:06,506 --> 00:33:07,696
on your view when you expect,


731
00:33:07,976 --> 00:33:10,166
make sure you're explicitly
setting needsLayout.


732
00:33:11,356 --> 00:33:12,586
All of this makes it easier


733
00:33:12,586 --> 00:33:14,246
to do manual layout
of your subviews.


734
00:33:14,246 --> 00:33:17,276
So you can overwrite
layout without calling super


735
00:33:17,576 --> 00:33:19,086
and instead just
calculate the frames


736
00:33:19,086 --> 00:33:21,326
of your subviews,
set them, and return.


737
00:33:22,626 --> 00:33:24,816
You do want to be sure
that you don't dirty


738
00:33:24,816 --> 00:33:26,386
that view's layout
or other views.


739
00:33:26,736 --> 00:33:29,256
This can happen if during a
view's layout it sets its own


740
00:33:29,256 --> 00:33:30,926
frame or the frame
of an ancestor.


741
00:33:31,396 --> 00:33:32,666
This will dirty that
view's layout


742
00:33:32,666 --> 00:33:36,226
and cause an additional
layout pass.


743
00:33:36,616 --> 00:33:39,836
If this continues, this is
what we call a layout loop


744
00:33:40,326 --> 00:33:41,846
and these are pretty
difficult to debug.


745
00:33:42,316 --> 00:33:44,176
So on macOS and iOS,


746
00:33:44,176 --> 00:33:46,356
we've introduced new layout
loop debugging support


747
00:33:46,356 --> 00:33:49,006
so you can better understand
what view is dirtying layout


748
00:33:49,006 --> 00:33:49,686
and why.


749
00:33:51,266 --> 00:33:54,366
There's changes to the layout
constraint API adding anchor


750
00:33:54,366 --> 00:33:55,846
properties so you
know what anchors


751
00:33:55,846 --> 00:33:57,086
that constraint refers to.


752
00:33:57,646 --> 00:34:00,216
These apply even when you're
not using the anchor-based API.


753
00:34:02,536 --> 00:34:04,576
In addition with that first
time it is now nullable,


754
00:34:04,576 --> 00:34:05,756
so if you are reading
that property,


755
00:34:05,806 --> 00:34:07,166
be sure to handle the nil case.


756
00:34:08,186 --> 00:34:10,275
In addition, Interface
Builder has new support


757
00:34:10,275 --> 00:34:12,146
for incremental adoption
of auto layout.


758
00:34:12,505 --> 00:34:14,096
So within a single
document or even


759
00:34:14,096 --> 00:34:16,496
within a single view hierarchy
you can partially adopt


760
00:34:16,496 --> 00:34:19,846
constants, which
is pretty great.


761
00:34:19,846 --> 00:34:22,196
NSGridView, the layout
loop debugging and more,


762
00:34:22,196 --> 00:34:24,686
is talked about in Friday's,
What's New in Auto Layout talk.


763
00:34:25,545 --> 00:34:27,946
At this point I'd like
to talk about colors,


764
00:34:27,946 --> 00:34:30,246
specifically wide gamut colors.


765
00:34:30,886 --> 00:34:33,636
So sRGB is a pretty
popular color space.


766
00:34:33,636 --> 00:34:37,856
Usually it's the implied color
space of otherwise unspecified


767
00:34:38,146 --> 00:34:40,676
and most of our displays
have an sRGB color gamut.


768
00:34:41,585 --> 00:34:44,686
The new 5K iMac and
iPad Pro 9.7 inch,


769
00:34:45,025 --> 00:34:46,806
both contain these
updated displays


770
00:34:46,906 --> 00:34:48,815
that can display
more vivid colors.


771
00:34:49,436 --> 00:34:51,966
Specifically, they're
using the P3 color gamut


772
00:34:52,596 --> 00:34:55,166
and this is what we call a wide
color gamut because compared


773
00:34:55,166 --> 00:34:58,656
to sRGB, it can display much
more vibrant greens and reds.


774
00:34:59,536 --> 00:35:02,726
So your applications can display
photos much more accurately


775
00:35:02,726 --> 00:35:05,866
to their original color and they
can display these more vibrant


776
00:35:05,866 --> 00:35:08,086
colors to make UI
elements really pop.


777
00:35:09,046 --> 00:35:11,856
An example of such a color
would be this emerald green,


778
00:35:11,856 --> 00:35:14,946
which happens to be Pantone's
2013 color of the year.


779
00:35:14,946 --> 00:35:18,166
It's outside of sRGB.


780
00:35:18,166 --> 00:35:19,916
So previous displays
couldn't represent this


781
00:35:19,966 --> 00:35:23,236
but it is fully representable
using P3.


782
00:35:24,136 --> 00:35:27,326
Your photos also contain
these more vibrant colors,


783
00:35:27,326 --> 00:35:29,206
especially these
reds and oranges.


784
00:35:29,786 --> 00:35:33,236
A note of irony here is that
the projector and even the video


785
00:35:33,236 --> 00:35:35,686
at home are not actually going
to reproduce these colors,


786
00:35:35,686 --> 00:35:38,636
so you'll kind of have to take
my word that they're special.


787
00:35:40,646 --> 00:35:41,896
If you want to work
with these colors,


788
00:35:41,896 --> 00:35:44,366
there's a new color
space displayP3,


789
00:35:44,506 --> 00:35:45,376
which lets you work with this.


790
00:35:45,376 --> 00:35:47,766
This joins sRGB and
other color spaces.


791
00:35:48,516 --> 00:35:49,696
There's also a new constructor


792
00:35:49,696 --> 00:35:53,786
on NSColor displayP3 red green
blue alpha which allows you


793
00:35:53,786 --> 00:35:55,516
to create a color
in that color space.


794
00:35:55,896 --> 00:35:58,786
UIColor has the same constructor
with the same semantics.


795
00:35:59,846 --> 00:36:02,486
Another way of working with wide
colors is using something we're


796
00:36:02,486 --> 00:36:05,086
calling extended range sRGB.


797
00:36:06,516 --> 00:36:08,906
And so when working
with a color space,


798
00:36:08,986 --> 00:36:10,016
you're typically constrained


799
00:36:10,016 --> 00:36:11,976
with component values
from 0 to 1.


800
00:36:12,496 --> 00:36:14,446
And you can pick any color
within that color gamut,


801
00:36:14,446 --> 00:36:16,796
such as this blue,
with those values.


802
00:36:17,356 --> 00:36:19,276
But you can't represent
a color that's outside


803
00:36:19,276 --> 00:36:20,076
of that color gamut.


804
00:36:20,286 --> 00:36:22,576
So sRGB cannot represent
this green color.


805
00:36:23,676 --> 00:36:26,526
Well extended range sRGB
uses the same color primaries


806
00:36:26,526 --> 00:36:29,566
and the same white point as
sRGB but allows the components


807
00:36:29,566 --> 00:36:32,156
to take on values less
than 0 or greater than 1.


808
00:36:32,856 --> 00:36:35,466
So it can represent this
green with a negative red


809
00:36:35,466 --> 00:36:38,066
and blue value and a
greater than 1 green value.


810
00:36:39,166 --> 00:36:42,246
It happens to also be the P3
green primary, so you can see


811
00:36:42,246 --> 00:36:45,266
that with extended range sRGB,
you can represent the full range


812
00:36:45,266 --> 00:36:47,296
of colors necessary
for these displays.


813
00:36:48,646 --> 00:36:51,396
This also has a color
space extendedSRGB


814
00:36:51,976 --> 00:36:53,546
and the existing NSColor


815
00:36:53,546 --> 00:36:55,726
and UIColor constructors
you're already using


816
00:36:55,896 --> 00:36:58,036
that previously gave
you colors using sRGB.


817
00:36:58,326 --> 00:37:01,446
Will now accept values less
than 0 or greater than 1


818
00:37:01,446 --> 00:37:04,006
and give you back an
extended range sRGB color,


819
00:37:04,506 --> 00:37:05,326
which is pretty convenient.


820
00:37:07,566 --> 00:37:08,816
One important thing to consider


821
00:37:08,816 --> 00:37:11,376
with these wider color
gamuts is color depth.


822
00:37:12,236 --> 00:37:14,636
So sRGB can theoretically
represent any color


823
00:37:14,636 --> 00:37:17,316
within its gamut, but
with 8 bits per component,


824
00:37:17,316 --> 00:37:20,426
you can only address a finite
number of those, right.


825
00:37:20,566 --> 00:37:23,286
The black space here are simply
un-addressable colors using


826
00:37:23,286 --> 00:37:24,436
those 8 bits per component.


827
00:37:25,826 --> 00:37:28,606
When you widen the color gamut,
right, increase the volume


828
00:37:28,606 --> 00:37:30,756
of that gamut but keep
the same bit depth,


829
00:37:31,246 --> 00:37:33,616
you're addressable
color density goes down.


830
00:37:34,206 --> 00:37:37,436
Your ability to specify
a color loses precision.


831
00:37:37,436 --> 00:37:39,776
So this is why we
recommend when working


832
00:37:39,776 --> 00:37:41,876
with these wider color
spaces, such as P3,


833
00:37:41,876 --> 00:37:45,256
that you use 16 bits
per component instead.


834
00:37:46,326 --> 00:37:48,276
It doubles the amount
of memory and storage


835
00:37:48,276 --> 00:37:50,936
but gives you exponentially
more addressable colors.


836
00:37:50,936 --> 00:37:52,696
So we think that
tradeoff is worth it.


837
00:37:54,466 --> 00:37:56,236
What API do you need
to use in order


838
00:37:56,236 --> 00:37:58,036
to consider these deeper colors?


839
00:37:58,516 --> 00:38:00,796
Well, the great news is that
most of it is automatic.


840
00:38:01,086 --> 00:38:04,236
So NSWindow will automatically
use deeper backing stores


841
00:38:04,356 --> 00:38:07,266
with these higher bit depths
on wide gamut displays,


842
00:38:07,486 --> 00:38:09,186
even as you drag
it across screens.


843
00:38:10,086 --> 00:38:12,126
If there's a reason you need
to explicitly control that,


844
00:38:12,126 --> 00:38:13,566
you can set the depth
limit property


845
00:38:13,656 --> 00:38:15,136
to some value of your choice.


846
00:38:16,096 --> 00:38:19,136
Views and layers within that
window will automatically


847
00:38:19,136 --> 00:38:22,286
inherit that bit depth with the
exception being OpenGL view.


848
00:38:22,726 --> 00:38:24,826
There you should use the
associated pixel format API.


849
00:38:26,616 --> 00:38:30,796
CALayer on both macOS and iOS
has a new contents format API


850
00:38:31,136 --> 00:38:32,856
property that allows you


851
00:38:32,856 --> 00:38:35,446
to again explicitly control
the bit depth it uses.


852
00:38:36,336 --> 00:38:37,756
So this is how you
can take advantage


853
00:38:37,756 --> 00:38:39,116
of wide color in
your application.


854
00:38:39,436 --> 00:38:42,296
We've also enhanced part of the
system to better take advantage


855
00:38:42,296 --> 00:38:43,256
of these wider colors.


856
00:38:43,896 --> 00:38:45,166
One example is the color panel.


857
00:38:45,816 --> 00:38:47,036
So on the iMac on the left here,


858
00:38:47,486 --> 00:38:51,846
the color wheel will
actually display, there we go.


859
00:38:51,846 --> 00:38:53,746
It will actually
display and allow picking


860
00:38:53,746 --> 00:38:58,556
from the full range of
P3 colors beyond the sRGB


861
00:38:58,556 --> 00:38:59,786
that normal color wheels allow.


862
00:39:00,486 --> 00:39:03,706
However, you can also
right click the color wheel


863
00:39:03,836 --> 00:39:06,246
and explicitly choose
the working color space.


864
00:39:06,776 --> 00:39:08,156
So even on these
previous displays


865
00:39:08,156 --> 00:39:09,736
that can't render P3 colors,


866
00:39:09,936 --> 00:39:11,756
you can still allow
picking from them.


867
00:39:14,046 --> 00:39:16,146
The RGB color picker
has always allowed you


868
00:39:16,146 --> 00:39:17,776
to choose the color
space you're working in,


869
00:39:18,036 --> 00:39:20,046
but it also allows you to
change the representation


870
00:39:20,046 --> 00:39:24,136
from 8-bit values from 0
to 255 to floating point.


871
00:39:24,616 --> 00:39:26,566
So again you can get this
higher precision when working


872
00:39:26,566 --> 00:39:28,016
with these wider color spaces.


873
00:39:28,806 --> 00:39:30,826
These color panel changes comes


874
00:39:30,826 --> 00:39:32,826
to all applications
completely for free.


875
00:39:32,826 --> 00:39:34,546
No API is needed for those.


876
00:39:36,396 --> 00:39:38,976
The Working with Wide Color
talk on Thursday covers this


877
00:39:38,976 --> 00:39:41,746
and more, such as asset catalog
support and WebKit support.


878
00:39:41,906 --> 00:39:44,766
I'd recommend checking that out
if this stuff interests you.


879
00:39:45,426 --> 00:39:49,226
So the next topic is
status item enhancements.


880
00:39:49,226 --> 00:39:50,866
So status items are
the things that live


881
00:39:50,866 --> 00:39:52,596
in the upper trailing
corner of the menu bar


882
00:39:52,976 --> 00:39:54,966
and these are things that
previously required the use


883
00:39:54,966 --> 00:39:57,966
of private API to achieve
but now come mostly for free.


884
00:39:59,016 --> 00:40:00,456
First is reordering.


885
00:40:00,536 --> 00:40:03,856
You can now command click and
drag on any item and reorder it


886
00:40:03,856 --> 00:40:05,716
within and beyond
the system items.


887
00:40:06,556 --> 00:40:09,356
You can also use keyboard
focus to navigate to your item


888
00:40:09,546 --> 00:40:11,646
and even activate
menu items within.


889
00:40:12,866 --> 00:40:14,106
The best part of all of this is


890
00:40:14,106 --> 00:40:16,026
that this comes completely
automatically


891
00:40:16,026 --> 00:40:17,896
with no API opt-in
or link check.


892
00:40:18,596 --> 00:40:20,906
So all items are command-click
and drag to reorderable,


893
00:40:21,306 --> 00:40:23,816
and any items with a
menu set will participate


894
00:40:23,816 --> 00:40:24,826
in keyboard navigation.


895
00:40:25,306 --> 00:40:26,666
If they have a custom
target action,


896
00:40:26,666 --> 00:40:27,746
they'll just be skipped over.


897
00:40:28,996 --> 00:40:31,166
The next is hiding and removal.


898
00:40:31,746 --> 00:40:33,326
You can now command-click
and drag an item


899
00:40:33,326 --> 00:40:36,516
out of the status bar, remove
it, get notified of that change,


900
00:40:36,516 --> 00:40:38,136
and even programmatically
restore it.


901
00:40:39,396 --> 00:40:41,806
Unlike reordering, this
does require opt-in.


902
00:40:41,806 --> 00:40:44,426
No status items will be
automatically removable


903
00:40:44,996 --> 00:40:47,446
and you can do that by setting
the behavior of the status item


904
00:40:47,446 --> 00:40:48,686
to include removalAllowed.


905
00:40:49,796 --> 00:40:51,436
You can programmatically
read/set


906
00:40:51,436 --> 00:40:52,866
and even get KVO notified


907
00:40:52,866 --> 00:40:55,046
of this change using
the isVisible property.


908
00:40:55,686 --> 00:40:57,586
And if your application
is a status bar app,


909
00:40:57,656 --> 00:41:00,286
meaning its only representation
is that icon in the status bar,


910
00:41:00,286 --> 00:41:03,766
there's no doc icon or other
way to quit it, you can set it


911
00:41:03,766 --> 00:41:05,556
to automatically quit on removal


912
00:41:05,736 --> 00:41:07,636
by setting the
terminationOnRemoval behavior.


913
00:41:09,456 --> 00:41:11,906
All of this gets autosaved
for you, the location


914
00:41:11,906 --> 00:41:13,966
and the visible state so you
don't have to worry about trying


915
00:41:13,966 --> 00:41:16,306
to preserve that using
the autosave name.


916
00:41:16,966 --> 00:41:19,516
We automatically generate
this based on the item index


917
00:41:19,516 --> 00:41:20,906
that you created in
your application,


918
00:41:21,566 --> 00:41:23,876
but if you create them in
some non-deterministic order


919
00:41:23,876 --> 00:41:25,466
or just want to have
more explicit control,


920
00:41:25,806 --> 00:41:27,046
you can set that autosave name


921
00:41:27,046 --> 00:41:28,886
to some identifier
of your choice.


922
00:41:29,796 --> 00:41:31,716
So that's status
item enhancements.


923
00:41:31,716 --> 00:41:33,796
A lot of it comes for free, and
with a little bit of tweaking,


924
00:41:34,046 --> 00:41:35,916
you can really make them
great in your application.


925
00:41:37,206 --> 00:41:39,216
Next are control constructors.


926
00:41:39,636 --> 00:41:42,796
So these are new constructors
on existing NS Controls


927
00:41:42,796 --> 00:41:45,896
that make it really easy to
get standard look and feels.


928
00:41:46,596 --> 00:41:50,376
Examples are different types
of buttons, segmented controls,


929
00:41:51,036 --> 00:41:55,416
image views, sliders, and
labels, and text fields.


930
00:41:56,226 --> 00:41:57,896
So these are the types of
things you're already working


931
00:41:57,896 --> 00:41:59,696
with in the Interface
Builder object library


932
00:41:59,816 --> 00:42:01,226
and it makes it just as easily


933
00:42:01,226 --> 00:42:03,096
to use these right
out of the box.


934
00:42:03,726 --> 00:42:05,306
They come with the
standard system setup,


935
00:42:05,306 --> 00:42:07,066
the right font size,
and text color,


936
00:42:07,386 --> 00:42:08,836
and they support
different contexts.


937
00:42:09,336 --> 00:42:13,016
So the label here looks
great in aqua, vibrant light


938
00:42:13,016 --> 00:42:15,446
and even a vibrant dark
all right out of the box.


939
00:42:15,566 --> 00:42:16,826
There's no additional
setup needed.


940
00:42:17,576 --> 00:42:19,936
I'd love to show you an example
of what this does to your code.


941
00:42:19,936 --> 00:42:22,686
So this is creating
a checkbox before.


942
00:42:22,766 --> 00:42:24,266
There's quite a few
properties to set


943
00:42:24,266 --> 00:42:26,456
and the unfortunate thing is
we really only care about three


944
00:42:26,456 --> 00:42:28,536
of those; the title,
target, and action.


945
00:42:28,996 --> 00:42:32,426
Well with checkbox, title,
target, action, it's distilled


946
00:42:32,426 --> 00:42:34,436
down to just that,
which is pretty great.


947
00:42:35,716 --> 00:42:39,536
A bit more of a --
Oh [applause].


948
00:42:42,306 --> 00:42:42,896
Just wait.


949
00:42:43,636 --> 00:42:45,756
So this is creating just
a static label, right,


950
00:42:45,756 --> 00:42:47,386
just some text on the screen.


951
00:42:47,536 --> 00:42:50,186
And here, we care about
just the string value.


952
00:42:51,056 --> 00:42:54,026
Well, with labelWithString,
it again is just that.


953
00:42:54,906 --> 00:42:57,056
So, this is pretty great.


954
00:42:57,056 --> 00:42:58,536
It comes out of the box --


955
00:42:59,516 --> 00:43:03,016dle
[ Applause ]


956
00:42:59,516 --> 00:43:03,016
[ Applause ]


957
00:43:03,516 --> 00:43:05,596
It comes out of the box
ready to be used with


958
00:43:05,596 --> 00:43:06,716
or without auto layout.


959
00:43:06,846 --> 00:43:08,866
So if you are going to be
positioning with constraints,


960
00:43:09,056 --> 00:43:11,186
you still need to set
translatesAutoresizingMask


961
00:43:11,186 --> 00:43:14,316
IntoConstaints to false,
like all of your other views.


962
00:43:14,806 --> 00:43:16,826
And so if you already have
categories doing these kinds


963
00:43:16,826 --> 00:43:18,166
of things, we still
recommend moving


964
00:43:18,166 --> 00:43:20,256
over to these new system
ones because you'll ensure


965
00:43:20,466 --> 00:43:21,876
that your controls
have the standard look


966
00:43:21,876 --> 00:43:23,906
and feel both now
and in the future.


967
00:43:24,096 --> 00:43:28,116
The last thing I'd like to
talk about are API refinements.


968
00:43:28,116 --> 00:43:29,906
I only covered a number of
these that applied to all


969
00:43:29,906 --> 00:43:31,946
of our frameworks and these
apply to AppKit as well


970
00:43:31,946 --> 00:43:34,026
but there's two more that I
want to talk about that apply


971
00:43:34,026 --> 00:43:35,046
to AppKit specifically.


972
00:43:36,116 --> 00:43:37,766
The first is weak delegates.


973
00:43:38,436 --> 00:43:40,756
So we've added new zeroing
weak delegate support


974
00:43:40,756 --> 00:43:44,066
for various delegates and data
sources for different classes,


975
00:43:44,806 --> 00:43:47,396
so you no longer need to clear
these properties once the


976
00:43:47,396 --> 00:43:48,466
delegates is deallocated.


977
00:43:49,786 --> 00:43:52,136
It still supports non-weak
referenceable objects


978
00:43:52,326 --> 00:43:54,676
in which case it'll fall
back to the existing assign


979
00:43:54,676 --> 00:43:56,626
or unsafe, unretained semantics.


980
00:43:57,886 --> 00:43:59,456
We've also gone through
and made sure that all


981
00:43:59,456 --> 00:44:01,446
of our classes explicitly
did declare their


982
00:44:01,446 --> 00:44:02,886
designated initializers.


983
00:44:03,466 --> 00:44:05,626
These are the same as what they
effectively were previously


984
00:44:05,786 --> 00:44:07,866
but now are just
declared in the actual API


985
00:44:08,696 --> 00:44:10,386
with the one exception
being NSCursor.


986
00:44:10,756 --> 00:44:12,286
So if you are subclassing
NSCursor,


987
00:44:12,286 --> 00:44:13,266
please see the release notes


988
00:44:13,266 --> 00:44:16,136
for how you should
properly deal with that.


989
00:44:16,416 --> 00:44:18,736
As with all newly declared
designated initializers,


990
00:44:19,156 --> 00:44:21,906
you should make sure that
you're properly dealing


991
00:44:21,906 --> 00:44:23,186
with that in your subclass.


992
00:44:24,286 --> 00:44:25,846
And so if you weren't
previously,


993
00:44:25,846 --> 00:44:27,726
you potentially had these
incorrectness issues


994
00:44:27,726 --> 00:44:29,226
that maybe were subtle bugs.


995
00:44:29,546 --> 00:44:31,676
In Objective-C, you'll now
see build warnings for this.


996
00:44:31,866 --> 00:44:33,676
And in Swift, you're going
to get build failures.


997
00:44:33,676 --> 00:44:35,026
So you want to make sure


998
00:44:35,026 --> 00:44:37,026
that you're properly handling
these different cases.


999
00:44:37,366 --> 00:44:39,386
So that's it for
what's new in AppKit.


1000
00:44:39,386 --> 00:44:41,886
At this point, I'd like to turn
it back over to Ali to tell you


1001
00:44:41,886 --> 00:44:43,056
about what's new in Foundation.


1002
00:44:44,516 --> 00:44:50,076
[ Applause ]


1003
00:44:50,576 --> 00:44:51,196
>> Thank you, Taylor.


1004
00:44:53,946 --> 00:44:56,166
So here are some of the things
that are new in Foundation


1005
00:44:56,636 --> 00:44:58,536
and let me just dive right in.


1006
00:44:59,396 --> 00:45:02,486
Now earlier you saw
NSURL becoming URL


1007
00:45:02,486 --> 00:45:04,706
and I think we also talked
about it a bit yesterday.


1008
00:45:05,026 --> 00:45:10,226
We are dropping NS prefix in
key Foundation types in Swift.


1009
00:45:10,506 --> 00:45:12,316
Now, as you might
know, large subset


1010
00:45:12,316 --> 00:45:16,586
of Foundation actually ships
with the Swift Core Libraries


1011
00:45:16,586 --> 00:45:19,026
as a part of Swift Core
Libraries and is available


1012
00:45:19,026 --> 00:45:20,576
in other platforms,
such as Linux.


1013
00:45:21,436 --> 00:45:25,506
And we want to match the naming
style of this part of Foundation


1014
00:45:25,686 --> 00:45:28,206
with the convention established
by the Swift Standard Library


1015
00:45:28,206 --> 00:45:29,736
which does not use prefixes.


1016
00:45:30,756 --> 00:45:35,126
As a result, a lot of our
types drop their NS prefixes


1017
00:45:35,166 --> 00:45:37,136
in Foundation and
Swift, as you can see.


1018
00:45:37,136 --> 00:45:39,076
NSFormatter becomes
Formatter and so on.


1019
00:45:39,136 --> 00:45:41,906
Now the last two here,
NSData and NSURL are part


1020
00:45:41,906 --> 00:45:45,906
of a special category and I'll
mention these in a little bit.


1021
00:45:46,016 --> 00:45:48,356
Now, this is happening
in Foundation only.


1022
00:45:48,356 --> 00:45:49,516
It's not something
we're applying


1023
00:45:49,516 --> 00:45:52,036
to our other frameworks,
and even in Foundation,


1024
00:45:52,276 --> 00:45:53,676
it's only applying to some APIs.


1025
00:45:53,676 --> 00:45:56,926
We do not apply this
NS dropping to APIs


1026
00:45:56,926 --> 00:45:59,176
that are inherently
tied to Objective-C.


1027
00:45:59,466 --> 00:46:03,206
Examples are NSObject,
NSProxy, NSAutoreleasePool.


1028
00:46:03,546 --> 00:46:06,816
We also do not apply it to
APIs that at platform specific


1029
00:46:06,816 --> 00:46:09,466
and are, in fact, not
available on other platforms


1030
00:46:09,466 --> 00:46:12,976
such as NSUserNotification,
NSXPCConnection.


1031
00:46:14,036 --> 00:46:17,176
And in one other case is classes


1032
00:46:17,176 --> 00:46:18,976
which are also exposed
as value types.


1033
00:46:19,416 --> 00:46:22,386
So here we are exposing
data, URL, et cetera,


1034
00:46:22,386 --> 00:46:26,866
but we're also exposing NSData,
NSURL, and so on and let me talk


1035
00:46:26,866 --> 00:46:27,756
about what I mean there.


1036
00:46:28,216 --> 00:46:30,876
Now first let me explain
a bit about value types.


1037
00:46:32,006 --> 00:46:34,016
You might already be
familiar with value types.


1038
00:46:34,406 --> 00:46:36,526
We've had this concept in
Foundation for a long time.


1039
00:46:36,846 --> 00:46:39,936
These are types where value is
important, not the identity.


1040
00:46:40,586 --> 00:46:44,396
Examples are NSString,
NSData, URL, Array, et cetera.


1041
00:46:45,496 --> 00:46:46,656
Now, since a number


1042
00:46:46,656 --> 00:46:49,786
of Foundation APIs already have
these value type semantics,


1043
00:46:49,826 --> 00:46:52,496
we've gone ahead and added
them as value types in Swift.


1044
00:46:53,056 --> 00:46:55,766
And here is the full set of
APIs where we've done this.


1045
00:46:55,966 --> 00:47:00,066
This is in addition of course
to string, array, dictionary,


1046
00:47:00,066 --> 00:47:02,496
and set which are already
exposed as values types


1047
00:47:02,496 --> 00:47:03,726
in Swift, since they're
available


1048
00:47:03,726 --> 00:47:04,816
in the standard library.


1049
00:47:05,516 --> 00:47:09,536
So now these types here are
exposed as structs in Swift


1050
00:47:09,746 --> 00:47:11,386
and they have value
type semantics,


1051
00:47:11,386 --> 00:47:13,486
meaning they can be
directly mutated,


1052
00:47:13,686 --> 00:47:15,086
if mutability makes
sense for them.


1053
00:47:15,476 --> 00:47:19,096
You can use let or var on these
to distinguished mutability


1054
00:47:19,626 --> 00:47:20,656
at the time you declare them.


1055
00:47:21,206 --> 00:47:24,176
These also conform to the
expected Swift protocols


1056
00:47:24,176 --> 00:47:28,136
as well, as you might expect.


1057
00:47:28,286 --> 00:47:31,136
Now existing class APIs
still remain in cases


1058
00:47:31,136 --> 00:47:32,826
where we've created
these value types


1059
00:47:33,026 --> 00:47:35,666
and let me look at
a case study here.


1060
00:47:36,186 --> 00:47:38,576
An example is data, the
one I already mentioned.


1061
00:47:38,846 --> 00:47:40,806
So now we have the
struct data type.


1062
00:47:40,866 --> 00:47:42,196
This is the value type for data.


1063
00:47:42,536 --> 00:47:44,476
This is the data
type we expect you


1064
00:47:44,476 --> 00:47:48,206
to use most often
in your programming.


1065
00:47:48,236 --> 00:47:52,086
This is the type moving forward;
however, we also have NSData


1066
00:47:52,116 --> 00:47:54,756
which is a subclass of
NSObject and NSMutableData


1067
00:47:54,756 --> 00:47:57,426
which is a subclass
of NSData itself.


1068
00:47:57,846 --> 00:48:00,256
Now NS types remain
because something


1069
00:48:00,256 --> 00:48:03,236
like NSMutableData is not
migratable very easily,


1070
00:48:03,236 --> 00:48:05,146
so the migrator will
not migrate it.


1071
00:48:05,556 --> 00:48:08,306
Another reason we have NS types
is sometimes you actually do


1072
00:48:08,306 --> 00:48:09,606
want to subclass these types.


1073
00:48:09,606 --> 00:48:11,266
You know, you might
be subclassing NSData


1074
00:48:11,266 --> 00:48:14,326
or NSMutableData to provide
some specialized implementation


1075
00:48:14,636 --> 00:48:16,056
and you can do that
with, of course,


1076
00:48:16,056 --> 00:48:18,226
the class types,
as you see here.


1077
00:48:18,226 --> 00:48:20,696
So these are some of the reasons
why the NS types still remain.


1078
00:48:22,186 --> 00:48:24,456
Now, let's look at
some differences here.


1079
00:48:25,256 --> 00:48:29,256
The NSData class has
a length property.


1080
00:48:29,546 --> 00:48:31,916
This has been named count
in the struct version


1081
00:48:31,916 --> 00:48:33,716
because it's more
consistent with the rest


1082
00:48:33,716 --> 00:48:34,986
of the Swift Standard Library.


1083
00:48:35,576 --> 00:48:38,026
Methods such as write
to, range of and many


1084
00:48:38,026 --> 00:48:40,036
of these other methods
remain pretty much intact.


1085
00:48:40,036 --> 00:48:42,346
They come across the same
way except you'll notice


1086
00:48:42,346 --> 00:48:45,796
that the NSRange and NSData
has become range of index


1087
00:48:46,776 --> 00:48:48,956
in the struct data version,
which is more consistent


1088
00:48:48,956 --> 00:48:50,656
with the Swift Library.


1089
00:48:51,036 --> 00:48:54,196
And finally you'll note that a
mutating function, like append,


1090
00:48:54,196 --> 00:48:57,416
is not available on this
value type data directly while


1091
00:48:57,416 --> 00:49:00,336
in the case of NSData, it's
on the NSMutableData class.


1092
00:49:00,736 --> 00:49:02,486
So these are some of the
differences you'll see


1093
00:49:02,486 --> 00:49:04,946
between the value types
and the class types.


1094
00:49:05,516 --> 00:49:08,066
Now I'm not going to say
much more about this.


1095
00:49:08,566 --> 00:49:10,926
There is a talk this afternoon,
What's New in Foundation


1096
00:49:10,926 --> 00:49:12,996
for Swift in the Mission room.


1097
00:49:13,206 --> 00:49:17,696
I encourage you to attend that
and hear more about these.


1098
00:49:17,916 --> 00:49:20,096
Now we have several
new types in Foundation


1099
00:49:20,326 --> 00:49:21,746
to represent measured amounts.


1100
00:49:22,276 --> 00:49:24,406
The main class here
is the unit class.


1101
00:49:24,446 --> 00:49:27,826
This is an abstract type to
represent units, such as miles,


1102
00:49:27,986 --> 00:49:30,406
degrees Celsius, kilometers
per hour, and so on.


1103
00:49:30,596 --> 00:49:32,446
And then we have
a class dimension,


1104
00:49:32,446 --> 00:49:33,606
which is a subclass of unit.


1105
00:49:33,976 --> 00:49:36,046
This represents unit
families such as length,


1106
00:49:36,156 --> 00:49:38,236
temperature, and
speed and so on.


1107
00:49:38,716 --> 00:49:40,146
So here we have the unit class.


1108
00:49:40,446 --> 00:49:43,486
We have the subclass dimension
and then we have subclasses


1109
00:49:44,206 --> 00:49:46,696
such as unit length,
unit temperature,


1110
00:49:46,696 --> 00:49:48,326
unit speed, and a bunch more.


1111
00:49:49,586 --> 00:49:53,036
There's a helper class unit
converter that allows conversion


1112
00:49:53,036 --> 00:49:55,276
between units within
the same unit family


1113
00:49:56,246 --> 00:49:59,576
and there is a struct
measurement, it's a class,


1114
00:49:59,576 --> 00:50:02,596
of course, in Objective-C but
across as a value type in Swift,


1115
00:50:03,036 --> 00:50:05,716
struct measurement which
combines a value such as 10


1116
00:50:06,026 --> 00:50:07,606
with a unit such as miles,


1117
00:50:07,996 --> 00:50:09,776
so this basically is
now a measurement,


1118
00:50:09,986 --> 00:50:11,466
and finally the icing
on the cake,


1119
00:50:11,896 --> 00:50:13,536
we have the measurement
formatter class


1120
00:50:13,776 --> 00:50:16,076
which will take one of these
measurements and show it


1121
00:50:16,076 --> 00:50:17,906
to the user in the
user's locale.


1122
00:50:18,416 --> 00:50:23,246
So it'll show 10 miles to a
user here in the United States


1123
00:50:23,526 --> 00:50:26,496
but will show 16 kilometers, for
instance, to a user in Europe,


1124
00:50:26,726 --> 00:50:27,896
who's using the European system.


1125
00:50:27,896 --> 00:50:29,466
So it will do the
conversions for you


1126
00:50:29,596 --> 00:50:31,076
and show the user
the right thing.


1127
00:50:32,516 --> 00:50:37,186
[ Applause ]


1128
00:50:37,686 --> 00:50:40,506
Now out of the box, we have
plenty of unit families defined.


1129
00:50:40,866 --> 00:50:41,706
Here's the whole set.


1130
00:50:42,236 --> 00:50:45,286
So these are subclasses of
dimension, and within each one


1131
00:50:45,286 --> 00:50:46,406
of these unit families,


1132
00:50:46,406 --> 00:50:49,486
we actually have multiple units
defined out of the box as well.


1133
00:50:49,736 --> 00:50:52,016
Let me take a look at unit
temperature for instance.


1134
00:50:52,446 --> 00:50:54,916
You'll see that unit temperature
has three standards units;


1135
00:50:54,916 --> 00:50:57,276
kelvin, Celsius, and Fahrenheit.


1136
00:50:57,596 --> 00:50:59,596
And these are defined
as class properties


1137
00:50:59,656 --> 00:51:02,646
on the UnitTemperature
class and many


1138
00:51:02,646 --> 00:51:06,126
of the other dimensions also
have a number of units defined


1139
00:51:06,126 --> 00:51:07,836
that know how to convert
between each other.


1140
00:51:08,306 --> 00:51:13,346
And even better news, you can
actually add your own units


1141
00:51:13,386 --> 00:51:15,276
on top of what we
provided and they'll play


1142
00:51:15,276 --> 00:51:16,426
with what's already there


1143
00:51:16,426 --> 00:51:18,896
and you can also add your
own unit families as well.


1144
00:51:19,526 --> 00:51:22,426
So you can hear much more
about this Friday afternoon


1145
00:51:22,426 --> 00:51:25,816
at 4:00 o'clock,
Measurement and Units.


1146
00:51:26,886 --> 00:51:29,166
DateInterval is a new type
we've added to Foundation.


1147
00:51:29,536 --> 00:51:31,906
It represents a date interval.


1148
00:51:32,386 --> 00:51:36,766
It's got three properties;
start, end, and duration.


1149
00:51:36,766 --> 00:51:38,526
Fairly straightforward, so
these are not, of course,


1150
00:51:38,526 --> 00:51:40,026
fully independent
but they're reflected


1151
00:51:40,026 --> 00:51:41,306
as three separate properties.


1152
00:51:41,546 --> 00:51:43,846
In addition to these properties,
DateInterval knows how


1153
00:51:43,846 --> 00:51:46,476
to do things like check if a
date is within a date interval


1154
00:51:46,706 --> 00:51:48,976
or whether two date
intervals overlap and so on.


1155
00:51:49,616 --> 00:51:54,296
Date intervals are of course
also very useful to be formatted


1156
00:51:54,346 --> 00:51:55,836
with the DateIntervalFormatter
class.


1157
00:51:55,836 --> 00:51:58,806
That's something we -- That's an
API we introduced last release.


1158
00:51:59,646 --> 00:52:01,766
We had an API string from to.


1159
00:52:01,916 --> 00:52:03,406
Now we have the string from API


1160
00:52:03,566 --> 00:52:05,176
which simply takes
a date interval,


1161
00:52:05,766 --> 00:52:06,766
so fairly straightforward.


1162
00:52:07,816 --> 00:52:10,696
Now at this point let me
give you a public service


1163
00:52:10,696 --> 00:52:13,396
announcement about
handling dates and times.


1164
00:52:14,716 --> 00:52:16,486
So handling dates can be tricky.


1165
00:52:17,306 --> 00:52:19,296
Now this is not relationship
advice here.


1166
00:52:19,506 --> 00:52:22,236
Okay? I'm not a doctor.


1167
00:52:24,086 --> 00:52:26,406
Let's say you want to
represent a ten second period.


1168
00:52:26,866 --> 00:52:28,996
You might go ahead and create
a DateInterval like this,


1169
00:52:29,096 --> 00:52:31,426
start date and a
ten second period.


1170
00:52:31,836 --> 00:52:35,066
This is likely correct for
whatever you might try to,


1171
00:52:35,066 --> 00:52:37,366
whatever you're trying to
do with a ten second period,


1172
00:52:37,906 --> 00:52:39,636
but let's say you're
trying to represent a day.


1173
00:52:40,326 --> 00:52:42,106
You might go ahead and
write code like this,


1174
00:52:43,276 --> 00:52:46,436
24 times 60 by 60 which is the
number of seconds in a day.


1175
00:52:47,016 --> 00:52:49,326
Well this is the number of
seconds in a 24-hour period


1176
00:52:49,836 --> 00:52:52,986
and it's often not
going to be correct.


1177
00:52:53,346 --> 00:52:55,956
The reason is because days
are not always 24 hours long.


1178
00:52:56,056 --> 00:52:57,836
Months aren't always 31 days.


1179
00:52:57,836 --> 00:53:00,456
Years aren't always
365 days and so on.


1180
00:53:00,456 --> 00:53:02,946
We always keep those in
mind but there are also days


1181
00:53:02,946 --> 00:53:07,786
which are 23 hours or sometimes
24 hours, 25 hours, as you know.


1182
00:53:08,316 --> 00:53:10,016
So depending on what
you want to do


1183
00:53:10,016 --> 00:53:12,476
with a DateInterval representing
a date, are you trying


1184
00:53:12,476 --> 00:53:14,476
to set an alarm exactly
24 hours from now?


1185
00:53:14,746 --> 00:53:17,606
Are you trying to send an alarm
at the same time the next day?


1186
00:53:17,606 --> 00:53:18,896
You have to be careful.


1187
00:53:19,326 --> 00:53:22,746
Typically the correct solutions
here involve using the calendar


1188
00:53:22,746 --> 00:53:25,306
class and you can hear
about these problems


1189
00:53:25,306 --> 00:53:28,696
and also luckily their solutions
in this talk from 2013,


1190
00:53:28,696 --> 00:53:30,666
Solutions to Common Date
and Time Challenges,


1191
00:53:30,666 --> 00:53:33,316
which I encourage you
to go back and watch.


1192
00:53:35,336 --> 00:53:38,906
ISO8601 DateFormatter is
another new API in Foundation.


1193
00:53:38,906 --> 00:53:40,226
It's a formatter for dates.


1194
00:53:40,896 --> 00:53:41,286
Thank you.


1195
00:53:42,516 --> 00:53:45,006
[ Applause ]


1196
00:53:45,506 --> 00:53:47,176
So clearly some of you have had


1197
00:53:47,236 --> 00:53:50,486
to use 8601 before;
8601 is a standard.


1198
00:53:50,486 --> 00:53:52,666
It's an interchange
format for specifying dates


1199
00:53:52,666 --> 00:53:53,956
in an unambiguous manner.


1200
00:53:54,446 --> 00:53:56,786
So this is a separate
class than DateFormatter


1201
00:53:56,786 --> 00:53:58,646
because unlike DateFormatter,
which is meant


1202
00:53:58,646 --> 00:54:02,916
for user-localized dates, 8601
formatting is non-localized.


1203
00:54:03,426 --> 00:54:04,666
It's, you know, interchange
format.


1204
00:54:04,666 --> 00:54:06,236
So it's a separate type.


1205
00:54:06,426 --> 00:54:08,076
We decided to keep
things simple.


1206
00:54:08,546 --> 00:54:09,706
Using it is very simple.


1207
00:54:10,596 --> 00:54:11,786
So create a formatter.


1208
00:54:12,726 --> 00:54:16,486
Get yourself a date, again
not relationship advice.


1209
00:54:18,086 --> 00:54:20,616
And simply ask the formatter
for the string for that date


1210
00:54:20,616 --> 00:54:22,006
and it will return
you the format.


1211
00:54:22,256 --> 00:54:24,276
Now this DateFormatter
can actually go both ways,


1212
00:54:24,836 --> 00:54:26,656
so you can actually -- Oh,
by the way, here's the output


1213
00:54:26,686 --> 00:54:28,416
from that call, and
as you can see,


1214
00:54:28,416 --> 00:54:29,816
it's getting close to lunchtime.


1215
00:54:30,476 --> 00:54:33,266
And here is -- This formatter
also goes the other ways,


1216
00:54:33,586 --> 00:54:34,596
also does parsing.


1217
00:54:34,786 --> 00:54:37,696
So you can get yourself a
formatter and ask for the date


1218
00:54:37,696 --> 00:54:40,116
from a string and it'll
return the date for you.


1219
00:54:40,216 --> 00:54:41,276
So it goes both ways.


1220
00:54:42,626 --> 00:54:46,146
Now by default, this will do
RFC 3339, which is one format;


1221
00:54:46,466 --> 00:54:48,956
however, there are options
that let you specify some


1222
00:54:48,956 --> 00:54:51,926
of the behaviors,
if you need to.


1223
00:54:52,276 --> 00:54:55,096
Now quickly let me cover
some other Foundation updates


1224
00:54:55,096 --> 00:54:56,676
we have.


1225
00:54:56,676 --> 00:55:00,236
URL has a bunch of
new properties,


1226
00:55:00,646 --> 00:55:04,276
such as canonical path of
a file and a bunch more,


1227
00:55:04,276 --> 00:55:06,566
like whether a volume
is encrypted and so on.


1228
00:55:06,566 --> 00:55:08,746
You can read all about
these in the release notes.


1229
00:55:09,046 --> 00:55:11,206
There's a new class
URLSessionTaskMetrics.


1230
00:55:11,606 --> 00:55:15,486
This class helps you gather
network resource loading


1231
00:55:15,486 --> 00:55:18,406
performance information
so you can actually look


1232
00:55:18,406 --> 00:55:20,936
at the network performance
of your applications.


1233
00:55:21,956 --> 00:55:25,456
PersonNameComponentsFormatter
is an API we added last release.


1234
00:55:26,006 --> 00:55:28,866
As you know, it takes a
person's name and it formats it


1235
00:55:28,916 --> 00:55:30,696
in a locale-appropriate manner.


1236
00:55:31,176 --> 00:55:33,456
Well in this release, it
actually can now parse names.


1237
00:55:33,456 --> 00:55:35,216
So you give it a name
and it will return


1238
00:55:35,216 --> 00:55:37,386
to you the first name,
last name, et cetera


1239
00:55:37,626 --> 00:55:38,796
and it does a pretty good job


1240
00:55:38,796 --> 00:55:42,886
since it uses a statistical
model based on real-world data.


1241
00:55:43,506 --> 00:55:47,986
And finally -- But there are
some tricky names out there.


1242
00:55:47,986 --> 00:55:52,126
So don't get your
hopes up fully.


1243
00:55:52,956 --> 00:55:54,966
And DateComponentsFormatter,


1244
00:55:55,296 --> 00:55:58,426
again this is API we
added last release.


1245
00:55:58,656 --> 00:56:01,386
In addition to the full
style and the short style,


1246
00:56:01,386 --> 00:56:03,976
we now have a brief style
of date that you can format.


1247
00:56:04,236 --> 00:56:06,946
And next release, maybe we'll
add the boxer style as well.


1248
00:56:07,646 --> 00:56:09,336
Okay, so that's it
for Foundation.


1249
00:56:11,406 --> 00:56:13,676
Core data, just a quick
mention of core data.


1250
00:56:13,716 --> 00:56:15,736
You already saw some
API improvements


1251
00:56:15,736 --> 00:56:16,996
in core data with generics.


1252
00:56:16,996 --> 00:56:19,876
There's a bunch more
new APIs in core data,


1253
00:56:19,876 --> 00:56:22,456
such as generational querying,
persistent store description,


1254
00:56:22,786 --> 00:56:26,516
the NSFetchedResultsController
class is now available in OS X


1255
00:56:26,516 --> 00:56:28,776
as well, I'm sorry,
macOS as well.


1256
00:56:29,086 --> 00:56:30,706
You can hear all
about this Friday


1257
00:56:30,706 --> 00:56:32,346
at 10:00 a.m. What's
New in Core Data.


1258
00:56:33,116 --> 00:56:35,526
And one more talk I want
to give a shout out to,


1259
00:56:36,516 --> 00:56:40,016
every year we get up here
and tell you about new APIs,


1260
00:56:40,016 --> 00:56:42,676
new technologies were introduced
and you might not always be


1261
00:56:42,676 --> 00:56:44,776
in a position to adopt
these APIs because you're


1262
00:56:44,776 --> 00:56:46,396
in the middle of something else


1263
00:56:46,466 --> 00:56:48,016
or maybe you wait a
release and so on.


1264
00:56:48,426 --> 00:56:49,896
Well, if you want
to get an overview


1265
00:56:49,896 --> 00:56:53,086
of recent APIs we've
added, APIs are important


1266
00:56:53,176 --> 00:56:55,116
to create modern
applications for the Mac.


1267
00:56:55,236 --> 00:56:56,296
This is talk for you.


1268
00:56:56,556 --> 00:56:59,796
It will cover a lot of topics
and they'll have pointers


1269
00:56:59,796 --> 00:57:01,966
to other sessions of
interest, not just in this WWDC


1270
00:57:01,966 --> 00:57:04,096
but also prior WWDCs as well.


1271
00:57:04,476 --> 00:57:06,506
It's also appropriate
for everyone, all ages,


1272
00:57:06,506 --> 00:57:07,676
all experience levels.


1273
00:57:07,986 --> 00:57:09,456
It's also Friday
at 5:00 o'clock.


1274
00:57:09,456 --> 00:57:11,136
So I hope you're here.


1275
00:57:13,146 --> 00:57:16,476
Okay, so and here is
the webpage you can go


1276
00:57:16,476 --> 00:57:17,466
to for more information.


1277
00:57:17,826 --> 00:57:20,596
Please read the AppKit and
Foundation release notes,


1278
00:57:20,596 --> 00:57:22,586
which you can find in
our developer tool site.


1279
00:57:22,586 --> 00:57:24,816
It's there, just raw
information about a lot


1280
00:57:24,816 --> 00:57:25,886
of the stuff I talked about.


1281
00:57:26,256 --> 00:57:27,926
Here are the related
sessions we mentioned.


1282
00:57:27,926 --> 00:57:29,076
There are of course many more.


1283
00:57:29,506 --> 00:57:30,186
Thank you very much.

