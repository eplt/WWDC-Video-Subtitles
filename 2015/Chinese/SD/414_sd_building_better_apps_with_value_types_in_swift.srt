1
00:00:21,255 --> 00:00:23,891
在Swift中 如何使用
数值类型来打造更好的app


2
00:00:24,191 --> 00:00:26,193
大家好 我是道格·格雷戈尔


3
00:00:26,260 --> 00:00:28,362
今天我和我的同事比尔·达德利


4
00:00:28,595 --> 00:00:32,366
我们会讲讲在Swift中 如何使用
数值类型来打造更好的app


5
00:00:36,203 --> 00:00:38,172
首先我们来谈谈


6
00:00:38,238 --> 00:00:39,540
引用语义 


7
00:00:40,474 --> 00:00:44,645
然后我们会深入探讨下不变性 
把它作为引用语义提出的某些问题的


8
00:00:44,711 --> 00:00:46,380
解决方案


9
00:00:48,048 --> 00:00:50,184
深入探讨数值语义、数值类型


10
00:00:50,517 --> 00:00:53,153
尤其是它在Swift的工作原理
数值类型在实践中的应用


11
00:00:53,887 --> 00:00:56,056
然后探讨引用类型和数值类型


12
00:00:56,123 --> 00:01:00,127
在Swift中的混合


13
00:01:01,061 --> 00:01:01,895
让我们开始吧


14
00:01:04,031 --> 00:01:05,065
引用语义


15
00:01:05,666 --> 00:01:10,470
引用语义在
Swift中就是用来定义一个类


16
00:01:11,405 --> 00:01:13,207
这是一个很简单的温度组别


17
00:01:13,807 --> 00:01:16,643
我们以摄氏度来存储我们的温度数值


18
00:01:16,710 --> 00:01:19,713
想得到这个不错的计算华氏温度属性


19
00:01:20,180 --> 00:01:22,583
这样我们可以始终以正确的单位得到它


20
00:01:23,650 --> 00:01:25,686
温度的简单、抽象版本


21
00:01:26,320 --> 00:01:28,055
让我们试着把它用到一些简单的代码上


22
00:01:28,755 --> 00:01:31,892
我们创建一个家庭 
实例再创建一个温度实例


23
00:01:32,226 --> 00:01:35,495
把我们的恒温器设置成
温和的七十五华氏摄氏度


24
00:01:36,897 --> 00:01:39,399
现在我们来决定...
晚餐时间快到了


25
00:01:39,466 --> 00:01:40,901
我想烤一些鲑鱼肉


26
00:01:40,968 --> 00:01:44,304
因此我把烤箱的温度设置成425度
然后点击“烤制”


27
00:01:44,872 --> 00:01:45,873
走开一点


28
00:01:48,242 --> 00:01:50,410
为什么这里这么烫？出了什么事？


29
00:01:51,812 --> 00:01:55,282
你知道发生了什么事
我们实现的就是非有意的共享


30
00:01:55,449 --> 00:01:56,850
想想对象图表


31
00:01:57,951 --> 00:01:58,986
我们有自己的房子


32
00:01:59,052 --> 00:02:01,088
里面有一个恒温器和烤箱


33
00:02:01,154 --> 00:02:03,690
我们还有这个温度指向的温度对象


34
00:02:04,525 --> 00:02:06,260
当我们设置我们的恒温器时


35
00:02:06,326 --> 00:02:08,794
我们把它作为温度连接到相同的对象


36
00:02:09,162 --> 00:02:12,466
事情看起来不错直到我们进行转变


37
00:02:12,799 --> 00:02:15,736
现在这个非有意的或者意想不到的分享


38
00:02:16,336 --> 00:02:18,172
让我们把我们的恒温器设置成了


39
00:02:18,238 --> 00:02:20,207
四百二十五华氏摄氏度


40
00:02:21,508 --> 00:02:23,110
此时已经玩完了


41
00:02:23,177 --> 00:02:26,547
但是为了度量起见
让我们把我们的恒温器连接到烤箱


42
00:02:26,613 --> 00:02:27,714
因为我们已经搞砸了


43
00:02:30,317 --> 00:02:31,585
那么我们做错了什么呢？


44
00:02:32,085 --> 00:02:34,955
在这个有引用语义的世界里


45
00:02:35,656 --> 00:02:38,659
你想要阻止分享 你就要进行复制


46
00:02:40,060 --> 00:02:42,162
知道了吗？让我们来这样试试


47
00:02:44,031 --> 00:02:45,299
好的 把温度设置成七十五


48
00:02:45,365 --> 00:02:47,501
华氏摄氏度


49
00:02:47,801 --> 00:02:52,005
当我设置我的恒温器的温度时
我就会生成一个副本


50
00:02:52,139 --> 00:02:53,841
我就得了一个全新的对象


51
00:02:53,907 --> 00:02:56,376
我的恒温器的温度指向的也就是它


52
00:02:56,710 --> 00:02:58,612
当我改变我的温度变量的温度时


53
00:02:58,679 --> 00:03:01,515
并不会对它产生影响 很好


54
00:03:02,149 --> 00:03:04,084
现在我来设置烤箱的温度


55
00:03:04,151 --> 00:03:05,586
我又生成了一个副本


56
00:03:06,486 --> 00:03:09,723
现在从技术上来讲
我并不需要最后的这个副本


57
00:03:10,224 --> 00:03:15,796
在堆上浪费时间分配内存
创建这个另外的副本效率很低


58
00:03:16,296 --> 00:03:18,932
但是这样更安全
因为上次我错过了一个副本


59
00:03:18,999 --> 00:03:20,200
结果把我烤熟了！


60
00:03:22,169 --> 00:03:24,204
给点力吧 这是周五的会议
让我喘口气吧


61
00:03:30,677 --> 00:03:32,613
我们把这个称之为“保护性拷贝”


62
00:03:33,847 --> 00:03:36,216
我们进行拷贝并不是因为


63
00:03:36,283 --> 00:03:38,585
我们知道我们需要它 而是因为偶尔


64
00:03:38,652 --> 00:03:41,922
或者过一段时间后需要用它


65
00:03:41,989 --> 00:03:43,390
调试这些问题是相当困难的


66
00:03:43,857 --> 00:03:44,825
无论我们什么时候


67
00:03:45,092 --> 00:03:49,897
把一个温度指定到我们的烤箱某处
忘记进行点拷贝太容易了


68
00:03:50,230 --> 00:03:53,333
我要在我自己的烤箱中烤一烤这个行为


69
00:03:55,869 --> 00:03:58,672
好 我完了 我完了 对不起 对不起


70
00:03:59,473 --> 00:04:01,441
通常来说我需要给恒温器做同样的事


71
00:04:01,508 --> 00:04:02,876
不是吗？


72
00:04:02,943 --> 00:04:05,012
有了一大堆样本
我们正在进行复制粘贴


73
00:04:05,078 --> 00:04:07,181
你迟早会来敲我的门问我借


74
00:04:07,247 --> 00:04:09,116
一项语言特征


75
00:04:09,750 --> 00:04:15,722
我们先来谈复制
Cocoa和Objective-C


76
00:04:16,656 --> 00:04:19,892
在Cocoa
有一个NSCopying协议的概念


77
00:04:20,327 --> 00:04:22,863
它对复制的意义进行了编码


78
00:04:23,497 --> 00:04:26,366
你有很多的数据类型
这NSstring NSArray


79
00:04:26,433 --> 00:04:29,002
NSURLRequest 
etcetera


80
00:04:29,069 --> 00:04:31,905
这些都遵从NSCopying
因为你需要安全地对它们


81
00:04:31,972 --> 00:04:33,240
进行复制


82
00:04:35,075 --> 00:04:36,977
我们的系统中需要大量的复制


83
00:04:37,044 --> 00:04:40,647
因此你有足够的理由看到
大量的“保护性拷贝”


84
00:04:40,714 --> 00:04:45,552
NSDictionary会对你放到
字典中的键进行保护性拷贝 为什么？


85
00:04:46,353 --> 00:04:49,957
若要递给NSDictionary
一个键 进行插入


86
00:04:50,324 --> 00:04:54,194
然后又做了变更改变了它的hash值


87
00:04:54,428 --> 00:04:56,296
打断
NSDictionary内部变度


88
00:04:56,363 --> 00:04:58,465
然后埋怨我们让你出了bug


89
00:04:58,866 --> 00:05:00,133
这可不是我们想要的


90
00:05:00,200 --> 00:05:03,504
想要的是在
NSDictionary保护性拷贝


91
00:05:03,570 --> 00:05:07,207
在这个系统中 这是正确的答案
但是不幸的是


92
00:05:08,275 --> 00:05:10,544
进行这些额外的复制会让我们损失性能


93
00:05:11,745 --> 00:05:14,281
我们会把
这些都弄到Objective-C


94
00:05:14,348 --> 00:05:17,150
带有复制属性的语言层面


95
00:05:17,451 --> 00:05:20,220
来对每个单一的赋值进行保护性拷贝


96
00:05:20,287 --> 00:05:23,123
以此来避免这些问题 这确实有用


97
00:05:23,190 --> 00:05:25,092
这个保护性拷贝确实有用


98
00:05:25,192 --> 00:05:26,560
不过还不够好


99
00:05:26,860 --> 00:05:28,228
你仍然会有一堆的bug


100
00:05:29,029 --> 00:05:32,065
因此这些引用语义有问题


101
00:05:32,132 --> 00:05:33,100
出现了变异


102
00:05:34,368 --> 00:05:36,703
也许这里的问题不在于引用语义


103
00:05:36,937 --> 00:05:38,172
而在于变异本身


104
00:05:38,505 --> 00:05:43,277
也许应该移动到带有
引用语义的不可变数据结构


105
00:05:44,011 --> 00:05:46,914
如果你和函数式语言社区某个人谈一谈


106
00:05:46,980 --> 00:05:48,682
他们会说 是的


107
00:05:48,749 --> 00:05:50,250
几十年前我们就开始这么做了


108
00:05:51,251 --> 00:05:52,920
它确实可以提高那里的情况


109
00:05:53,320 --> 00:05:58,258
因此如果没有副效用
你就不会出现非有意的副效用


110
00:05:58,892 --> 00:06:01,662
不可变引用语义是一种在系统中工作的


111
00:06:01,828 --> 00:06:02,763
一致的方法


112
00:06:02,930 --> 00:06:08,435
它没有那些我们在我们的
温度小示例中出现的意外后果


113
00:06:09,303 --> 00:06:13,307
问题在于不变性也有不足


114
00:06:13,740 --> 00:06:15,843
它可能导致不佳的界面


115
00:06:16,310 --> 00:06:19,246
语言工作的方式就是 它的一部分


116
00:06:19,613 --> 00:06:22,449
我们生活在一个我们可以
让事情产生变异的世界中


117
00:06:22,516 --> 00:06:25,319
这也是它的一部分 我们想到状态


118
00:06:25,385 --> 00:06:27,588
变异的状态 因此单纯在一个


119
00:06:27,654 --> 00:06:29,923
不可变的世界中进行思考
有时候对我们来说


120
00:06:29,990 --> 00:06:30,924
是比较怪的


121
00:06:31,825 --> 00:06:33,694
有效映射到机器模型


122
00:06:33,760 --> 00:06:35,028
也是问题


123
00:06:35,829 --> 00:06:37,698
最后你还是不得不着手处理机器码


124
00:06:37,764 --> 00:06:40,434
在一个有状态寄存器、状态缓存、


125
00:06:40,501 --> 00:06:41,368
状态内存、


126
00:06:41,435 --> 00:06:43,337
状态存储的CPU上运行


127
00:06:44,371 --> 00:06:49,810
把一个不可变算法映射到那个层级效率
并不总是那么容易


128
00:06:50,477 --> 00:06:52,112
我们来讲一讲其中的几点


129
00:06:52,179 --> 00:06:54,414
我们把我们的这个温度类拿出来


130
00:06:54,615 --> 00:06:56,583
通过让它成为不可变的增加它的安全性


131
00:06:57,417 --> 00:07:03,257
我们把摄氏度存储属性从一个
var变成一个let 你不能再改了


132
00:07:03,924 --> 00:07:07,094
然后华氏温标计算器属性的
设值函数没有了


133
00:07:07,160 --> 00:07:08,228
因此无论你做什么


134
00:07:08,295 --> 00:07:09,630
你都不能再改变温度状态


135
00:07:09,963 --> 00:07:11,832
为了方便起见
我们添加一些初始化程序


136
00:07:13,367 --> 00:07:15,702
好的 我们来谈谈不优美的...


137
00:07:16,637 --> 00:07:18,071
不优美的不可变界面


138
00:07:18,472 --> 00:07:22,509
要是我说我把我的烤箱温度调整


139
00:07:22,576 --> 00:07:25,279
十华氏温度 这是一个简单的操作


140
00:07:26,280 --> 00:07:28,415
加号就是十度 可以了 好了


141
00:07:29,416 --> 00:07:32,152
如果我们把变化去掉
我们又该怎么做？


142
00:07:32,219 --> 00:07:35,022
我们就必须抓住烤箱的温度对象


143
00:07:35,689 --> 00:07:39,326
创造另外一个有新值的温度对象


144
00:07:40,627 --> 00:07:43,430
对吧？这就有点不太好看了代码更多


145
00:07:43,497 --> 00:07:47,167
也浪费时间在堆上分配另一个对象


146
00:07:47,935 --> 00:07:50,737
我们并没有在这里拥抱不变性


147
00:07:50,804 --> 00:07:54,341
因为我们是做了一个使
烤箱本身发生变化的赋值


148
00:07:55,209 --> 00:07:57,177
如果我们在这里自始至终


149
00:07:57,244 --> 00:07:59,580
拥抱不可变引用的概念


150
00:08:00,113 --> 00:08:02,449
我们就可以创建一个新的温度
放到一个新的烤箱中


151
00:08:02,516 --> 00:08:03,550
然后放到一个新家中


152
00:08:05,719 --> 00:08:12,593
不美观！
让我们再搞点理论知识做一些数学题


153
00:08:13,293 --> 00:08:18,899
埃拉托色尼选筛法是
一种计算质数的古老的算法


154
00:08:19,433 --> 00:08:22,035
它使用了变异 非常适合在地上用棍子


155
00:08:22,102 --> 00:08:24,271
画出事情


156
00:08:24,771 --> 00:08:29,176
这是Swift中变异版本的执行


157
00:08:29,510 --> 00:08:31,378
我们来演示下
以便你明白它背后的想法


158
00:08:31,979 --> 00:08:33,547
你首先要做的是：创建一个阵列


159
00:08:34,681 --> 00:08:36,616
注意var 因为我们要改变这个阵列


160
00:08:37,049 --> 00:08:40,953
注意这个阵列来源于两个、三个质数


161
00:08:41,020 --> 00:08:42,623
是从你计算的数字中求出来的


162
00:08:42,688 --> 00:08:43,524
我们这里是二十


163
00:08:44,825 --> 00:08:47,728
现在每次通过外层循环


164
00:08:47,794 --> 00:08:50,330
我们就会选择阵列中的下一个数字


165
00:08:50,998 --> 00:08:52,533
那个数字是一个质数P


166
00:08:53,800 --> 00:08:58,005
内循环要做的就是走过P的所有倍数


167
00:08:58,272 --> 00:09:03,043
把它们设为零将它们从阵列中抹除


168
00:09:04,178 --> 00:09:05,212
如果是一个质数的倍数


169
00:09:05,279 --> 00:09:06,446
那么你就不是质数


170
00:09:07,514 --> 00:09:08,448
再回到外层循环


171
00:09:08,515 --> 00:09:11,018
我们获取下一个数字 这是一个质数


172
00:09:11,285 --> 00:09:13,687
我们从阵列中把它所有的倍数抹除


173
00:09:13,754 --> 00:09:15,489
这是一个非常简单的算法


174
00:09:15,556 --> 00:09:16,623
想想地上的棍子


175
00:09:16,690 --> 00:09:18,225
你就是在把事情划掉


176
00:09:19,893 --> 00:09:22,296
一旦我们迭代


177
00:09:23,263 --> 00:09:24,398
完毕我们就到这里


178
00:09:24,464 --> 00:09:27,034
进行最后一个简单的操作 也就是说


179
00:09:27,100 --> 00:09:28,936
阵列中所有我们未归零的东西


180
00:09:29,002 --> 00:09:30,170
就是我们的结果的一部分


181
00:09:30,237 --> 00:09:31,572
我们用一个过滤器来处理它


182
00:09:32,906 --> 00:09:35,843
算法非常简单 完全基于变异的


183
00:09:37,444 --> 00:09:38,946
但不是不能在没有变异的


184
00:09:39,046 --> 00:09:40,347
世界里表达它


185
00:09:40,647 --> 00:09:42,182
你当然可以的


186
00:09:42,983 --> 00:09:44,718
为此 我们要使用Haskell


187
00:09:44,785 --> 00:09:46,587
因为它是一个单纯的函数式语言


188
00:09:48,121 --> 00:09:50,724
是的 我知道大家都爱它 好的


189
00:09:51,525 --> 00:09:53,627
这是Haskell的公式化


190
00:09:53,927 --> 00:09:55,996
如果你读过Haskell 它很美


191
00:09:56,797 --> 00:09:58,532
它是函数式的 它一点也不会发生变异


192
00:09:59,199 --> 00:10:01,034
这是个类似执行
它对Swift做了变动


193
00:10:01,101 --> 00:10:03,604
因此也能是函数式的
如果你想让它懒一点


194
00:10:03,670 --> 00:10:05,606
对于读者来说这是一个练习


195
00:10:05,672 --> 00:10:06,807
没有那么难


196
00:10:07,541 --> 00:10:09,710
我们来演示下这个算法的工作原理


197
00:10:09,776 --> 00:10:11,512
因为非常相似


198
00:10:13,180 --> 00:10:16,783
我们的阵列就从二开始 直到二十


199
00:10:18,519 --> 00:10:21,522
在这个简单的例子中 如果没有数字


200
00:10:21,588 --> 00:10:22,556
那里没有质数


201
00:10:22,623 --> 00:10:24,725
那是第一个“If语句”这是小事情


202
00:10:25,926 --> 00:10:28,662
你要做的就是
我们把第一个数字取出来


203
00:10:28,762 --> 00:10:30,197
它就始终是质数


204
00:10:30,898 --> 00:10:32,799
把它和其余的数字分割开来


205
00:10:33,200 --> 00:10:34,801
Haskell通过模式匹配实现它


206
00:10:34,868 --> 00:10:35,802
我们在这里可以分层


207
00:10:36,770 --> 00:10:39,673
我们把那个质数拿出来
在这个阵列其余的元素这里


208
00:10:39,907 --> 00:10:44,311
运行一个过滤器操作


209
00:10:45,179 --> 00:10:46,446
仅仅复制那些不是


210
00:10:46,513 --> 00:10:48,582
那个质数的倍数的东西


211
00:10:49,950 --> 00:10:51,351
现在我们递归 再来一次


212
00:10:52,119 --> 00:10:54,121
把“三”拆分 这是我们的新质数


213
00:10:54,521 --> 00:10:55,689
然后运行这个过滤器


214
00:10:56,890 --> 00:11:00,494
把所有三的倍数消除等等


215
00:11:00,994 --> 00:11:02,362
这里发生的


216
00:11:02,529 --> 00:11:05,933
就是你以构建这个左斜 
实际质数来结束


217
00:11:05,999 --> 00:11:08,669
这样它们就都会连接在一起


218
00:11:10,504 --> 00:11:11,638
理念是相似的


219
00:11:11,705 --> 00:11:12,940
非常相似


220
00:11:13,974 --> 00:11:16,176
但是算法不同


221
00:11:16,243 --> 00:11:20,080
因为它的性能特征不同


222
00:11:21,248 --> 00:11:23,417
这个结果来源于
梅莉莎·欧内尔发表的


223
00:11:23,483 --> 00:11:26,486
一篇绝妙的论文 她称之为
“真实的埃拉托色尼筛选法”


224
00:11:27,154 --> 00:11:29,356
她向Haskell社区展示了
他们挚爱的筛选法


225
00:11:29,423 --> 00:11:32,092
并不是真实的筛选法


226
00:11:32,593 --> 00:11:35,629
因为它并不会作为真实的筛选法来运行


227
00:11:36,363 --> 00:11:41,235
她仔细查看了Haskell
中非常复杂的执行


228
00:11:41,568 --> 00:11:43,937
那又回朔到了性能特征


229
00:11:44,137 --> 00:11:45,739
读一下那篇论文 看一看 非常酷


230
00:11:46,173 --> 00:11:48,475
我想让你们尝试下
为什么会出现这种情况


231
00:11:48,675 --> 00:11:50,644
看看这个Haskell列表推导


232
00:11:50,944 --> 00:11:52,980
或者下面等价的Swift过滤器


233
00:11:55,048 --> 00:11:59,152
在这个不变版本中
这个操作会遍历阵列中的


234
00:11:59,219 --> 00:12:02,055
每个单一元素


235
00:12:02,122 --> 00:12:04,491
然后执行一个除运算
看看下一步中


236
00:12:04,558 --> 00:12:06,727
它是否还应该在那里
看看它是否是P的倍数


237
00:12:07,661 --> 00:12:11,565
在原始的变异算法中
我们只会遍历质数的


238
00:12:11,632 --> 00:12:14,868
倍数以及那些...当然了


239
00:12:14,935 --> 00:12:17,804
随着你得到越来越大的数字
 就会变得越来越稀疏


240
00:12:18,272 --> 00:12:20,874
你访问的元素更少 此外


241
00:12:20,941 --> 00:12:23,410
你只需要在到达下个元素进行一次加法


242
00:12:24,645 --> 00:12:26,413
这样你每个元素所做的工作就更少了


243
00:12:26,713 --> 00:12:27,614
这是有关系的


244
00:12:28,382 --> 00:12:30,517
不变版本不像变异版本的效率那样高


245
00:12:30,584 --> 00:12:32,986
后者无需做很多的功


246
00:12:35,122 --> 00:12:36,690
我们再回到Cocoa


247
00:12:36,823 --> 00:12:41,028
你看到了在Cocoa中使用不变性
Cocoa Touch框架


248
00:12:41,428 --> 00:12:44,431
它们有很多
日期 Ui图片 NSNumber等


249
00:12:44,665 --> 00:12:45,899
它们是不可变类型


250
00:12:46,099 --> 00:12:48,602
有了这些不可变类型
安全性就可以得到提高


251
00:12:48,836 --> 00:12:50,103
这是件好事因为你就无需


252
00:12:50,170 --> 00:12:51,038
担心复制了


253
00:12:51,371 --> 00:12:54,575
你无需担心
你的共享会产生非有意的副效用


254
00:12:55,542 --> 00:12:58,111
但是当你用它工作时你也会看到缺点


255
00:12:58,645 --> 00:13:00,814
在Objective-C
中给自己一个小任务


256
00:13:01,215 --> 00:13:04,952
我想从我的主目录开始
通过添加逐次路径元件


257
00:13:05,018 --> 00:13:07,621
获得某些目录的方式 来创建一个


258
00:13:07,921 --> 00:13:08,956
NSURL


259
00:13:09,823 --> 00:13:11,325
我想在引用语义世界中 无需变异


260
00:13:11,391 --> 00:13:12,659
就可以实现这一点


261
00:13:13,060 --> 00:13:14,761
因此我创建了一个NSURL


262
00:13:15,262 --> 00:13:17,764
每次通过循环时 我就通过附加下一个


263
00:13:17,831 --> 00:13:19,566
路径元件 来创建一个新的URL


264
00:13:20,567 --> 00:13:22,002
这个算法并不是非常好 真的


265
00:13:22,703 --> 00:13:25,572
每通过一次我就创建一个NSURL
另一个对象


266
00:13:25,639 --> 00:13:31,612
旧的对象就会消失
然后NSURL就会在每次通过


267
00:13:31,678 --> 00:13:33,914
循环时 复制所有的
串式数据


268
00:13:34,448 --> 00:13:36,750
那里的效率不是很高


269
00:13:37,084 --> 00:13:39,152
道格 你按错了


270
00:13:39,219 --> 00:13:41,555
你应该把所有的这些元件
收集到一个NSArray


271
00:13:41,622 --> 00:13:45,359
然后使用带路径元件的
文件URL


272
00:13:46,627 --> 00:13:49,530
就这样吧 不过要记住
我们是在这里拥抱不变性


273
00:13:50,564 --> 00:13:53,267
这样当我创建我的阵列时
我会创建一个带有特定


274
00:13:53,634 --> 00:13:55,169
对象的NSArray 好的


275
00:13:55,235 --> 00:13:56,103
这是主目录


276
00:13:56,503 --> 00:13:59,072
每次通过时
我创建一个新的阵列


277
00:13:59,640 --> 00:14:00,874e
多加一个对象


278
00:13:59,640 --> 00:14:00,874
多加一个对象


279
00:14:01,341 --> 00:14:02,442
我仍然是二次的


280
00:14:03,010 --> 00:14:04,311
我仍然是在复制元素


281
00:14:04,378 --> 00:14:05,412
我复制的不是串式数据


282
00:14:05,479 --> 00:14:06,380
这样好一点


283
00:14:06,680 --> 00:14:07,881
我仍然是在复制元素


284
00:14:09,283 --> 00:14:11,652
这就是为什么我们不在
Cocoa世界中完全拥抱


285
00:14:11,718 --> 00:14:13,654
不变性的原因 因为这样说不通


286
00:14:13,720 --> 00:14:15,856
而如果你在更加本地化的


287
00:14:16,089 --> 00:14:18,592
地方使用易变性 就说得通了


288
00:14:19,092 --> 00:14:22,329
把你所有的元件收集到
一个NSMutable阵列


289
00:14:22,930 --> 00:14:26,066
然后使用带路径元件的
文件URL返回到那个


290
00:14:26,533 --> 00:14:28,035
不可变NSURL


291
00:14:29,670 --> 00:14:31,772
因此不变性是件好事


292
00:14:31,839 --> 00:14:34,608
它让引用语义世界的推论更加容易了


293
00:14:35,309 --> 00:14:38,011
但是你又不能完全选择不变性


294
00:14:38,312 --> 00:14:39,479
否则你会疯掉


295
00:14:41,748 --> 00:14:43,250
这样我们就到了数值语义


296
00:14:44,218 --> 00:14:46,086
对于数值语义
我们想采用一个不同的方法


297
00:14:46,553 --> 00:14:47,454
我们喜欢变异


298
00:14:47,888 --> 00:14:51,458
它很有价值 
如果正确使用的话用起来很容易


299
00:14:52,159 --> 00:14:55,495
问题在于正如我们看到的在于共享


300
00:14:57,264 --> 00:14:59,833
你已经知道了数值语义的工作原理
无论你是在


301
00:14:59,900 --> 00:15:02,903
Objective-C中还是在
Swift中你都应该始终用它


302
00:15:03,770 --> 00:15:05,973
道理很简单：如果你有两个变量


303
00:15:06,507 --> 00:15:09,042
从逻辑上来讲
这些变量中的数值是不同的


304
00:15:10,777 --> 00:15:13,914
我有一个整数A
我把它复制到一个整数B


305
00:15:14,147 --> 00:15:16,450
当然了它们是等价的 它是一个副本


306
00:15:17,851 --> 00:15:19,219
我来改变B


307
00:15:19,620 --> 00:15:22,789
如果我告诉你A也会变 你会说我疯了


308
00:15:24,124 --> 00:15:25,025
这些是整数


309
00:15:25,092 --> 00:15:26,093
它们在我们用过的


310
00:15:26,159 --> 00:15:27,528
每种语言中都有数值语义


311
00:15:29,630 --> 00:15:31,164
到CGPoint中举例来说


312
00:15:33,300 --> 00:15:36,503
从A复制到B改变B 对A不会产生


313
00:15:36,570 --> 00:15:37,971
任何影响


314
00:15:38,939 --> 00:15:40,073
你已经习惯这一点了


315
00:15:40,307 --> 00:15:42,543
如果CGPoint的行为不是这样


316
00:15:42,609 --> 00:15:44,378
你肯定会大吃一惊


317
00:15:46,813 --> 00:15:50,217
数值语义的理念就是
把我们已经知道并且理解为


318
00:15:50,284 --> 00:15:53,554
最基本类型的事物
像数字以及包含数字的


319
00:15:53,620 --> 00:15:57,124
小的结构
把它向外扩展


320
00:15:57,991 --> 00:16:00,460
让它能够兼容更多、更丰富的类型


321
00:16:00,527 --> 00:16:02,829
在Swift中字符串属于数值类型


322
00:16:03,530 --> 00:16:07,134
你创建了A从B复制到A
然后对B做出某种改变


323
00:16:07,201 --> 00:16:09,503
这不会对A产生任何影响


324
00:16:10,771 --> 00:16:11,839
因为它是一个数值类型


325
00:16:12,239 --> 00:16:13,740
A和B是不同的变量


326
00:16:13,841 --> 00:16:15,309
因此从逻辑上来说
它们是不同的


327
00:16:18,412 --> 00:16:22,249
知道了吗？那么为什么阵列表现的
方式也是一模一样呢


328
00:16:23,650 --> 00:16:26,153
创建A复制到B 然后改变B


329
00:16:26,220 --> 00:16:27,120
对A没有影响


330
00:16:27,187 --> 00:16:29,890
它们是完全不同的值


331
00:16:31,992 --> 00:16:33,827
最后一点是字典 当然了


332
00:16:33,894 --> 00:16:34,862
它就是一个集合


333
00:16:35,395 --> 00:16:37,030
你把数值语义放进去
然后向你返回的


334
00:16:37,731 --> 00:16:38,899
也是数值语义


335
00:16:39,600 --> 00:16:43,303
这里很棒的一点是
数值类型的构成非常漂亮


336
00:16:43,670 --> 00:16:46,773
因此你就可以在数值语义的
世界中非常容易地构建


337
00:16:46,840 --> 00:16:48,408
非常丰富的抽象物


338
00:16:49,109 --> 00:16:52,412
在Swift中所有的
基本类型整数、两倍数、


339
00:16:52,479 --> 00:16:55,616
字符串、字符等等
它们都是数值类型


340
00:16:55,682 --> 00:16:57,251
它们都有这个基本行为


341
00:16:57,317 --> 00:16:59,052
从逻辑上说 这两个变量它们是不同的


342
00:16:59,820 --> 00:17:01,989
我们在它们顶部构建的全部集合...


343
00:17:02,055 --> 00:17:03,423
阵列、集合、字典...


344
00:17:03,924 --> 00:17:06,260
当给予它们数值类型时
它们都是数值类型


345
00:17:07,861 --> 00:17:09,296
你用来构建自己的类的语言抽象


346
00:17:09,363 --> 00:17:12,566
这里的类包括元组、结构和枚举


347
00:17:12,900 --> 00:17:15,801
当你把数值类型放进去时
你得到的仍然是数值类型


348
00:17:16,170 --> 00:17:19,506
再说一遍 在数值语义世界中构建


349
00:17:20,307 --> 00:17:21,808
丰富的抽象物十分容易


350
00:17:22,843 --> 00:17:25,746
数值类型上还有重要的一点


351
00:17:26,280 --> 00:17:30,017
就是你有一个两个值等价两个数值类型


352
00:17:30,083 --> 00:17:32,519
变量等价的概念


353
00:17:32,619 --> 00:17:33,954
它们保持同样的值


354
00:17:34,821 --> 00:17:37,925
重要的是
那个恒等式并不重要


355
00:17:38,959 --> 00:17:40,160
因为可有任何数字的复制


356
00:17:40,227 --> 00:17:42,629
重要的是存储在那里的实际值


357
00:17:43,330 --> 00:17:44,831
你怎样拿到那个值并不重要


358
00:17:45,232 --> 00:17:47,534
我给你们讲几件非常愚蠢的事


359
00:17:48,368 --> 00:17:50,437
我们这里有A把它设置成五还有B


360
00:17:50,504 --> 00:17:51,805
我们把B设置成二加三


361
00:17:52,639 --> 00:17:54,274
当然了 A和B是等价的


362
00:17:55,375 --> 00:17:56,310
你一直是这么用的


363
00:17:56,376 --> 00:17:58,912
如果整数不是这么用的
你就理解不了了


364
00:17:59,513 --> 00:18:01,715
因此把那个概念扩展一点


365
00:18:02,282 --> 00:18:04,117
当然了
对CGPoints来说也是如此


366
00:18:04,184 --> 00:18:05,953
如果不是这种方式的话 你也理解不了


367
00:18:07,154 --> 00:18:09,790
为什么字符串的行为
方式不是一模一样呢？


368
00:18:10,290 --> 00:18:13,527
我怎样得到“你好 苹果全球
开发者大会”这个串不重要


369
00:18:14,561 --> 00:18:18,432
字符串是数值
相同运算符需要把它表示出来


370
00:18:19,199 --> 00:18:21,668
你可能会让它非常疯狂非常愚蠢


371
00:18:21,735 --> 00:18:24,605
这里我要进行一些排序操作


372
00:18:25,072 --> 00:18:26,540
归根结底我有整数的两个阵列


373
00:18:26,607 --> 00:18:28,809
整数有同样的值


374
00:18:29,209 --> 00:18:30,611
因此这些东西是等价的


375
00:18:31,578 --> 00:18:35,349
当构建一个数值类型 非常重要的点是


376
00:18:35,949 --> 00:18:37,684
要遵从“相等”协议


377
00:18:37,751 --> 00:18:41,088
因为那里的每个数值类型都是相等


378
00:18:41,722 --> 00:18:44,258
这就意味着它有等于操作符


379
00:18:44,324 --> 00:18:46,527
来进行对比 但是操作符的运作方式


380
00:18:46,593 --> 00:18:48,195
必须合乎情理


381
00:18:48,262 --> 00:18:50,998
它需要是反身的、对称的、及物的


382
00:18:51,632 --> 00:18:53,066
为什么这些属性很重要？


383
00:18:53,467 --> 00:18:55,702
除非你拿到你的代码 否则你不理解


384
00:18:56,670 --> 00:18:58,605
如果我从A复制到B 


385
00:18:59,072 --> 00:19:01,642
那么我期待A等于B B等于A


386
00:19:01,909 --> 00:19:03,043
当然了 为什么不相等呢？


387
00:19:03,510 --> 00:19:06,113
如果我之后又从B复制到C
那么C、B、A 


388
00:19:06,180 --> 00:19:08,849
它们都是等价的 我有哪个数字不重要
因为唯一重要的是值


389
00:19:08,916 --> 00:19:11,218
而不是恒等式


390
00:19:12,686 --> 00:19:15,389
幸运的是 实现这些非常容易


391
00:19:16,290 --> 00:19:18,492
让我说就是拿出CGPoints


392
00:19:18,926 --> 00:19:21,662
用“相等”协议扩展实现相同运算符


393
00:19:21,828 --> 00:19:24,131
当你在其它数值类型上构成数值类型时


394
00:19:24,231 --> 00:19:27,067
一般来说你只需要使用


395
00:19:27,534 --> 00:19:29,069
下面的所有数值类型的


396
00:19:29,136 --> 00:19:30,037
等号操作


397
00:19:32,272 --> 00:19:34,541
好的
让我们把它弄回我们的温度类型


398
00:19:35,242 --> 00:19:36,677
我们现在生成一个结构


399
00:19:37,010 --> 00:19:40,380
我们要把摄氏度切换回一个var
我们就可以改变它


400
00:19:41,181 --> 00:19:42,482
它现在就有了数值语义


401
00:19:42,549 --> 00:19:44,284
很明显 我们给了它相同运算符


402
00:19:44,852 --> 00:19:47,654
我们来把它用到我们之前的例子中
很好


403
00:19:47,721 --> 00:19:49,823
创建家庭 创建温度 把温度设为华氏


404
00:19:49,890 --> 00:19:52,659
七十五度 哇！


405
00:19:52,759 --> 00:19:54,661
编译器停在这里了 发生什么了？


406
00:19:55,729 --> 00:19:59,233
我们试着改变温度的一个属性


407
00:19:59,466 --> 00:20:00,767
这项属性的描述是“let”


408
00:20:01,168 --> 00:20:02,336
它是一个常量 不能更改


409
00:20:03,070 --> 00:20:04,238
我们来满足编译器


410
00:20:04,605 --> 00:20:06,106
把它改成var 现在可以改变它了


411
00:20:06,640 --> 00:20:08,342
一切都进展顺利


412
00:20:09,610 --> 00:20:12,846
为什么呢？家庭指向了烤箱内的恒温器


413
00:20:13,113 --> 00:20:16,016
恒温器和烤箱都有了各自的温度数值


414
00:20:16,083 --> 00:20:17,284
实例


415
00:20:17,351 --> 00:20:19,419
它们是完全不同的不会共享


416
00:20:20,087 --> 00:20:21,622
它们在结构中碰巧也是内联的


417
00:20:21,688 --> 00:20:23,657
你的内存使用情况以及性能都更好了


418
00:20:24,858 --> 00:20:28,061
这很棒 数值语义让我们的生活更容易


419
00:20:28,662 --> 00:20:31,331
有了我们的例子让我们继续


420
00:20:31,431 --> 00:20:33,467
把所有的事情都变得有数值语义


421
00:20:34,968 --> 00:20:37,304
房子的结构里面有一个恒温器结构


422
00:20:37,371 --> 00:20:39,907
一个烤箱结构 整个世界都是数值语义


423
00:20:40,140 --> 00:20:45,245
我们需要对我们的代码做的
变更就是 现在家庭是可变化的了


424
00:20:45,546 --> 00:20:48,081
因为我们改变了家庭的恒温器的温度


425
00:20:48,482 --> 00:20:51,652
对 那是家庭、恒温器的
一个变异温度的一个变异


426
00:20:55,722 --> 00:20:57,324
好的 现在就到了一个非常重要的地方


427
00:20:57,591 --> 00:21:00,827
因为Swift的不变性工作模型
数值语义在Swift中


428
00:21:01,228 --> 00:21:04,364
运行的天衣无缝


429
00:21:04,998 --> 00:21:08,535
如果在Swift中有一个“let”
那么它就是数值类型


430
00:21:08,735 --> 00:21:12,472
这意味着当某个东西损坏了
你的进程的内存时


431
00:21:12,539 --> 00:21:14,575
这个值不会很快发生改变


432
00:21:16,643 --> 00:21:18,645
这是一个健壮的语句


433
00:21:19,213 --> 00:21:21,748
它意味着
推论出“let”的事情非常容易


434
00:21:22,349 --> 00:21:24,218
不过我们仍然允许有变异


435
00:21:24,384 --> 00:21:27,387
你可使用var 说这个变量是能变的


436
00:21:27,888 --> 00:21:30,023
对于我们的算法来说 这就非常有用


437
00:21:31,325 --> 00:21:33,293
注意这个变更是非常本地的


438
00:21:33,460 --> 00:21:35,329
我可以变更这个变量但是除非我告诉它


439
00:21:35,395 --> 00:21:38,432
除非我在其它地方做出改变
否则它是不会影响到


440
00:21:38,632 --> 00:21:41,235
我的项目中的其它地方的


441
00:21:41,802 --> 00:21:44,905
这样就有了这个非常漂亮的受控易变性


442
00:21:46,440 --> 00:21:47,774
其它地方有了可靠的保证


443
00:21:49,009 --> 00:21:51,778
这里有趣的一件事是
当你使用数值类型、把它们


444
00:21:51,979 --> 00:21:54,414
传递到线程边界时
你就可以避免这些类型


445
00:21:54,481 --> 00:21:56,683
出现竞态条件


446
00:21:57,150 --> 00:21:58,018
我创建数字


447
00:21:58,085 --> 00:21:59,753
把它们传递给某些会异步处理


448
00:21:59,820 --> 00:22:01,588
事情的进程


449
00:22:02,155 --> 00:22:04,157
我本地改变数字 然后再来一次


450
00:22:04,591 --> 00:22:08,662
有了一个引用语义阵列
这是一个竞态条件


451
00:22:09,062 --> 00:22:10,364
有时候 它会把你吹炸


452
00:22:10,631 --> 00:22:13,233
有了数值语义 你每次都能得到复件


453
00:22:13,800 --> 00:22:14,902
每次都能得到逻辑复件


454
00:22:16,069 --> 00:22:17,738
因此 就没有竞态条件


455
00:22:18,372 --> 00:22:20,040
它们不会同时到达相同的阵列


456
00:22:21,141 --> 00:22:23,911
好的
这个听起来像一个性能问题 不是吗？


457
00:22:24,244 --> 00:22:27,681
每次我们通过一个参数传递数字时
我们就会进行一次拷贝


458
00:22:28,916 --> 00:22:32,853
好的 关于数值语义另外重要的一点是


459
00:22:32,920 --> 00:22:34,388
复制很“廉价”


460
00:22:34,888 --> 00:22:37,457
这里的“廉价”
我的意思是时间常数“廉价”


461
00:22:39,226 --> 00:22:40,827
我们从基础开始构建这个app


462
00:22:40,894 --> 00:22:42,496
当你有基本类型时


463
00:22:42,563 --> 00:22:45,866
那些低层次的东西 
整数、两倍数、浮点数等等


464
00:22:46,099 --> 00:22:48,168
复制它们很“廉价”


465
00:22:48,235 --> 00:22:49,670
你复制的只是几个字节


466
00:22:49,837 --> 00:22:51,638
除非是在处理器中进行复制的


467
00:22:52,973 --> 00:22:57,177
你就可以用两倍数、整数等等构建结构


468
00:22:57,244 --> 00:22:59,680
就像CG点是由两个
CG浮点数构建的一样


469
00:23:00,180 --> 00:23:02,449
任何这种结构 枚举或者元组


470
00:23:02,516 --> 00:23:06,186
它们的字段数量是固定的
在那里复制每个东西


471
00:23:06,253 --> 00:23:08,021
都是时间常数的


472
00:23:08,088 --> 00:23:10,324
因此复制整个东西也是时间常数的


473
00:23:11,992 --> 00:23:13,293
好的


474
00:23:13,360 --> 00:23:14,695
对于定长的东西来说 这很棒


475
00:23:14,761 --> 00:23:17,331
那么对于可扩展的东西来说
字符串、阵列、字典


476
00:23:17,397 --> 00:23:18,532
又是怎样呢？


477
00:23:19,099 --> 00:23:21,802
我们在Swift中处理这些东西的
方式是“写入时复制”


478
00:23:22,836 --> 00:23:24,471
这样就可以让复制很“廉价”


479
00:23:24,671 --> 00:23:27,174
就是一些固定数量的引用计数
操作来对“写入时复制”


480
00:23:27,241 --> 00:23:29,676
值进行复制


481
00:23:30,010 --> 00:23:32,679
当你进行改变时 你有了一个var


482
00:23:32,746 --> 00:23:35,115
然后你就可以变更它
我们也就制作一份副本


483
00:23:35,182 --> 00:23:36,049
并且在其上工作


484
00:23:36,850 --> 00:23:39,319
因此你就是背后分享


485
00:23:40,654 --> 00:23:42,589
但并不是逻辑分享


486
00:23:42,656 --> 00:23:44,992
从逻辑上来说 这些仍然是不同的值


487
00:23:45,225 --> 00:23:47,160
这样你的数值语义的性能特征


488
00:23:47,427 --> 00:23:50,664
就很棒 编程模型也很棒


489
00:23:51,565 --> 00:23:53,600
我们非常喜欢数值语义编程模型


490
00:23:54,268 --> 00:23:57,171
从逻辑上说 不同的变量始终是不同的


491
00:23:58,505 --> 00:24:01,775
你想让它是本地控制时 就有变异概念


492
00:24:01,842 --> 00:24:04,044
一个有效的变异


493
00:24:05,412 --> 00:24:07,147
但是你还有这些严格的“let”保证


494
00:24:07,214 --> 00:24:08,715
意味着它不会在其它地方改变


495
00:24:09,750 --> 00:24:11,952
复件很“廉价”我们就可以一起工作


496
00:24:13,187 --> 00:24:15,656
好的 我想交给我的同事


497
00:24:15,722 --> 00:24:18,659
比尔·达德利
他会谈谈数值类型和实践


498
00:24:26,500 --> 00:24:28,468
谢谢 道格 大家好


499
00:24:28,535 --> 00:24:31,939
刚才道格已经给我们讲了
数值类型的工作原理


500
00:24:32,072 --> 00:24:34,541
它们如何与引用语义进行对比


501
00:24:34,641 --> 00:24:38,879
我们来谈谈使用数值类型
构建一个真实的实例


502
00:24:40,280 --> 00:24:42,583
我们要做的
就是把一个实例组织在一起


503
00:24:42,649 --> 00:24:44,885
然后我们通过几个不同的值、
一个圈和一个多边形


504
00:24:44,952 --> 00:24:48,322
构建一个简单的图表


505
00:24:49,857 --> 00:24:51,859
让我们从圆开始吧


506
00:24:51,925 --> 00:24:54,228
这是圆心 这是半径


507
00:24:54,294 --> 00:24:55,996
都是取自标准库的几个


508
00:24:56,063 --> 00:24:57,231
数值类型


509
00:24:57,865 --> 00:25:00,701
当然了
我们想要实现相同运算符


510
00:25:00,767 --> 00:25:02,035
equals相等操作符


511
00:25:02,102 --> 00:25:04,438
我们只需要对比这些类型就可以实现


512
00:25:04,505 --> 00:25:06,974
同样地
因为它们是内置于标准库的


513
00:25:07,040 --> 00:25:09,676
我们只需要把它们用起来就行
这是因为我们用的是取自库的


514
00:25:09,743 --> 00:25:11,812
简单类型来构建


515
00:25:13,380 --> 00:25:15,015
下一个是多边形


516
00:25:15,082 --> 00:25:17,050
它有一个角落阵列


517
00:25:17,117 --> 00:25:19,753
每个角落都是一个
另一个CG点同样地


518
00:25:19,820 --> 00:25:21,255
这些CG点也是数值类型


519
00:25:21,321 --> 00:25:23,357
因此我们的阵列也是一个数值类型


520
00:25:23,423 --> 00:25:25,659
我们的比较也很直接


521
00:25:25,726 --> 00:25:27,594
只要在那使用equals相等操作符


522
00:25:27,661 --> 00:25:29,963
确保我们实现了“相等”操作符即可


523
00:25:32,499 --> 00:25:36,603
现在我们要做的
就是把这些类型放入我们的图表


524
00:25:36,670 --> 00:25:39,173
把多边形和圆都放进去


525
00:25:40,374 --> 00:25:42,743
制作一个圆的阵列也很直接


526
00:25:43,510 --> 00:25:47,548
制作一个多边形的阵列 同样也很直接


527
00:25:47,614 --> 00:25:49,483
因此我们可以制作任何类型的阵列


528
00:25:49,550 --> 00:25:53,620
我们要做的 就是制作一个
两者都包含的阵列


529
00:25:54,021 --> 00:25:59,927
在Swift中这样做的机制是
使用一项协议


530
00:26:00,093 --> 00:26:02,296
我们会创建一个叫做
Drawable的协议


531
00:26:02,429 --> 00:26:05,365
我们的子类型都会实施


532
00:26:05,432 --> 00:26:07,434
那个协议 然后我们把它们放到


533
00:26:07,501 --> 00:26:09,303
我们的图表中的一个阵列中


534
00:26:10,804 --> 00:26:14,441
“Swift中面向协议编程”
这场会议中有很多信息


535
00:26:14,575 --> 00:26:18,011
今天3:30会再次召开


536
00:26:18,078 --> 00:26:19,046
若你还没有看过的话


537
00:26:19,112 --> 00:26:21,915
我强烈建议你们去看看


538
00:26:21,982 --> 00:26:23,550
或者看看视频


539
00:26:26,153 --> 00:26:27,754
这是我们的Drawable协议


540
00:26:27,821 --> 00:26:31,158
很直接 也很简单
上面有一种方法即“绘制”


541
00:26:32,559 --> 00:26:34,528
当然了 我们想在我们的
两种类型上实施它


542
00:26:34,595 --> 00:26:36,763
我们会创建一个多边形扩展


543
00:26:36,830 --> 00:26:39,099
实施那个绘制方法 然后它会调用


544
00:26:39,166 --> 00:26:41,201
Core Graphics
绘制多边形


545
00:26:42,970 --> 00:26:44,671
圆也是 同样的情况


546
00:26:45,038 --> 00:26:47,608
那么我们要做的
就是调用Core Graphics


547
00:26:47,674 --> 00:26:49,610
构建圆的表示


548
00:26:54,381 --> 00:26:55,549
现在再回到我们的图表


549
00:26:55,616 --> 00:26:58,051
得到了这个可绘制的被调项目阵列


550
00:26:58,886 --> 00:27:00,854
我们需要创建一个方法 添加项目


551
00:27:00,921 --> 00:27:03,690
它被标记为了“变异的”
因为那会改变它自身


552
00:27:05,192 --> 00:27:08,028
我们要实现这个绘制方式
来对那个项目列表进行


553
00:27:08,095 --> 00:27:10,230
简单迭代并且调用列表上的


554
00:27:10,297 --> 00:27:12,332
每个项目的绘制方式


555
00:27:13,166 --> 00:27:15,269
我们来以图解的方式 看看它


556
00:27:15,836 --> 00:27:18,805
我们创建一个图表称之为doc


557
00:27:19,773 --> 00:27:22,142
我们创建一个多边形
然后把它添加到阵列上


558
00:27:23,410 --> 00:27:26,613
我们再创建一个圆也把它添加到阵列上


559
00:27:26,680 --> 00:27:29,016
现在我们的阵列内有了两项可绘制物


560
00:27:29,449 --> 00:27:30,951
注意它们的类型是不同的


561
00:27:33,620 --> 00:27:37,658
当我们再创建
一个文档并且说doc2等于doc


562
00:27:37,724 --> 00:27:40,394
得到了一个逻辑上不同的、全新的实例


563
00:27:40,460 --> 00:27:43,297
从逻辑上说它和第一个实例是分开的


564
00:27:46,867 --> 00:27:50,070
我现在可以返回doc2进行更改 
当我进行更改时


565
00:27:50,137 --> 00:27:52,706
当然了它对doc没有影响


566
00:27:52,773 --> 00:27:54,975
我把那个圆改成一个多边形


567
00:27:55,742 --> 00:27:58,545
阵列有数值语义即使集合是


568
00:27:58,612 --> 00:28:01,181
即使是不纯一的


569
00:28:01,248 --> 00:28:05,919
那么它的内部就有了多边形
那个阵列内的圆


570
00:28:05,986 --> 00:28:07,154
也是一个值


571
00:28:10,090 --> 00:28:15,863
当然了 我们想把我们的
图表的结构做成“相等”的


572
00:28:15,929 --> 00:28:17,431
因此我们把协议实现


573
00:28:17,497 --> 00:28:19,433
我们看到的
这是一个非常直接的


574
00:28:19,499 --> 00:28:20,834
实现


575
00:28:21,168 --> 00:28:23,337
但 如果我们那样做编辑器就会说


576
00:28:23,403 --> 00:28:27,007
“等等方程式两边的两个值 
我没有equals相等操作符”


577
00:28:27,074 --> 00:28:30,110
对于在该方程式的两边这两个值


578
00:28:30,177 --> 00:28:32,980
再说一次 我推荐你们去看
面向协议的编程


579
00:28:33,046 --> 00:28:36,450
我们在那里讲了它的所有的原理细节


580
00:28:36,517 --> 00:28:39,553
我们本次会议专注的是数值语义


581
00:28:41,755 --> 00:28:45,459
可绘制物有个叫做“绘制”的单一方法


582
00:28:45,526 --> 00:28:48,428
图表也有一个叫做“绘制”的方法


583
00:28:48,495 --> 00:28:51,999
把我们的图表变成一个可绘制物


584
00:28:52,232 --> 00:28:54,601
我们只需要把那个声明加到它上面


585
00:28:54,668 --> 00:28:58,605
现在我们的图表像鸭子一样
嘎嘎叫 那它就是一只鸭子了


586
00:29:01,041 --> 00:29:02,743
那么接下来的就非常有趣了


587
00:29:02,809 --> 00:29:08,882
我可以创建一个新的图表
并把它添加到我现有的图表


588
00:29:09,950 --> 00:29:12,186
那里有了三种不同的类型


589
00:29:12,252 --> 00:29:15,322
不过它们都包含在那个阵列中


590
00:29:16,023 --> 00:29:17,791
它是图表的一个新的实例


591
00:29:19,092 --> 00:29:21,195
但是我还可以再进一步


592
00:29:21,261 --> 00:29:23,263
把那个文档加到阵列中


593
00:29:23,630 --> 00:29:25,532
如果这些是引用语义


594
00:29:26,400 --> 00:29:27,334
我们来看看绘制方法


595
00:29:27,401 --> 00:29:29,169
如果这个是引用语义


596
00:29:29,369 --> 00:29:30,737
它就会无限递归


597
00:29:31,338 --> 00:29:35,809
因为当我在我的图表上调用
“绘制”时 它就会遍历


598
00:29:35,876 --> 00:29:37,911
项目列表
并且在列表上找到它自己


599
00:29:37,978 --> 00:29:40,814
然后就会再次调用“绘制”
出现无限递归


600
00:29:41,148 --> 00:29:43,717
不过我们用到是值


601
00:29:43,784 --> 00:29:48,422
因为它是一个值
添加到我的图表的


602
00:29:48,488 --> 00:29:49,790
一个完全分开的、不同的实例


603
00:29:49,857 --> 00:29:53,493
而不是doc


604
00:29:54,328 --> 00:29:56,163
因此不会出现无限递归


605
00:29:56,230 --> 00:29:59,600
我刚刚绘制了两个多边形以及两个圆


606
00:30:02,870 --> 00:30:05,072
既然已经讲过了 纯粹由数值类型构建


607
00:30:05,138 --> 00:30:06,974
一个对象树


608
00:30:07,040 --> 00:30:10,077
我们来讲怎样混淆数值类型和引用类型


609
00:30:10,911 --> 00:30:12,212
在Objective-C中


610
00:30:12,279 --> 00:30:15,516
你已经习惯了始终把原始
数据类型放到你的引用类型中


611
00:30:15,582 --> 00:30:18,352
在Objective-C
中就是这样构建东西的


612
00:30:19,286 --> 00:30:22,422
但是另一方面
这会产生一些有趣的问题


613
00:30:22,489 --> 00:30:24,024
我们必须仔细考虑这些问题


614
00:30:25,225 --> 00:30:27,928
如果我们构建一个数值类型
我们就想要确保


615
00:30:27,995 --> 00:30:31,365
那个数值类型
维持自身的数值语义


616
00:30:31,431 --> 00:30:34,067
哪怕它里面有一个引用


617
00:30:34,368 --> 00:30:35,769
如果我们要那么做


618
00:30:35,836 --> 00:30:37,304
我们就必须仔细考虑那个问题


619
00:30:37,371 --> 00:30:39,373
我们该怎样处理这个事实：


620
00:30:39,439 --> 00:30:43,944
它里面有一个引用 两个不同的值可能


621
00:30:44,011 --> 00:30:45,379
指向了同一件事？


622
00:30:45,579 --> 00:30:47,347
我们就必须解决那个问题


623
00:30:47,414 --> 00:30:48,348
我们要仔细考虑的


624
00:30:48,415 --> 00:30:50,717
另一件事是：
它会对等式产生什么样的影响？


625
00:30:52,019 --> 00:30:53,720
让我们从一个带有不可变类的


626
00:30:53,787 --> 00:30:56,857
简单例子开始 UIImage


627
00:30:57,391 --> 00:31:01,328
创建一个要成为 可绘制物的图片结构


628
00:31:01,395 --> 00:31:03,330
它对UIImage有一个引用


629
00:31:05,132 --> 00:31:06,366
我们用旧金山的这幅美丽的


630
00:31:06,433 --> 00:31:08,869
照片来创建一个实例


631
00:31:10,204 --> 00:31:13,540
如果我们再创建一个“图片2”现在


632
00:31:13,607 --> 00:31:16,710
“图片”和“图片2”
就都指向了同一个对象


633
00:31:17,211 --> 00:31:18,779
如果你看这个
你会想比尔骗我们了


634
00:31:18,846 --> 00:31:20,747
这肯定会出问题 就像那个


635
00:31:20,814 --> 00:31:21,949
温度一样


636
00:31:22,449 --> 00:31:25,652
但是
这不是因为UIImage是不可变的


637
00:31:25,719 --> 00:31:29,756
因此我们不用担心“图片2”
会改变位于它下方的


638
00:31:29,823 --> 00:31:30,724
“图片”


639
00:31:30,791 --> 00:31:33,594
不要担心第一个图片会猝不及防受到


640
00:31:33,660 --> 00:31:34,494
改变的影响


641
00:31:35,729 --> 00:31:38,732
我们想要确保我们实现这个等式


642
00:31:39,600 --> 00:31:41,735
你可能会看到这个然后想“没问题”


643
00:31:41,802 --> 00:31:43,437
我要使用三元组相等操作符


644
00:31:43,504 --> 00:31:46,306
它会对比引用看看


645
00:31:46,373 --> 00:31:47,808
那些引用是否相同


646
00:31:48,342 --> 00:31:51,778
对于这个例子来说
当然没问题 不过我们还必须


647
00:31:51,845 --> 00:31:52,913
认真考虑下 当我们使用


648
00:31:52,980 --> 00:31:57,751
同样的底层位图创建两个UI图片时
会发生什么？


649
00:31:58,519 --> 00:32:02,523
我们想让它们也相等、同等 
在这个例子中


650
00:32:02,589 --> 00:32:04,958
因为我们是在对比引用
 它们就不会相等


651
00:32:05,025 --> 00:32:06,527
因此 说这两个图片


652
00:32:06,593 --> 00:32:08,762
不相同 就错了


653
00:32:09,229 --> 00:32:12,566
想要使用我们从UIImage上的
NSObject继承“是等效方法”


654
00:32:12,900 --> 00:32:16,336
来进行对比


655
00:32:16,403 --> 00:32:19,339
这样
不管是否在相同的对象上


656
00:32:19,540 --> 00:32:25,145
我们都可以确信引用类型
获得正确的回复


657
00:32:25,212 --> 00:32:27,681
我们来谈谈如何使用可变的对象


658
00:32:28,215 --> 00:32:30,450
在这里有一个BezierPath


659
00:32:31,351 --> 00:32:32,953
它也会实现“可绘制物”


660
00:32:33,520 --> 00:32:35,155
但是整个实现是由这个可变的


661
00:32:35,222 --> 00:32:38,525
引用类型
UIBezierPath构成的


662
00:32:39,693 --> 00:32:42,696
在这个读取实例中
当我们进行“Is Empty”时


663
00:32:42,763 --> 00:32:43,664
一起都正常


664
00:32:43,730 --> 00:32:45,832
没有进行任何改变
因为不会和任何其它的


665
00:32:45,899 --> 00:32:48,402
实例混杂到一起


666
00:32:49,069 --> 00:32:52,272
但是下面的这个
我们有这个“向点添加线”方法


667
00:32:52,472 --> 00:32:55,175
如果我们有两个
BezierPaths指向这个方法


668
00:32:55,309 --> 00:32:56,610
它就会造成问题


669
00:32:57,444 --> 00:33:00,714
我们在那里
并没有“改变中”这个关键字


670
00:33:01,415 --> 00:33:04,585
那是一个符号 表明我们知道
我们正在进行改变


671
00:33:04,651 --> 00:33:06,687
“向点添加线”在那里
但是编译器并没有对着


672
00:33:06,753 --> 00:33:09,389
大喊大叫 告诉我们这一点
这是因为路径是一种引用类型


673
00:33:09,823 --> 00:33:11,558
我们很快会再看看它


674
00:33:12,659 --> 00:33:16,697
如果有两个BezierPath实例
并且都通过这个改变


675
00:33:16,763 --> 00:33:18,799
指向了
同一个UIBezierPath实例


676
00:33:18,866 --> 00:33:22,269
如果我做出改变 那么


677
00:33:22,336 --> 00:33:23,971
它就会让另一个实例措手不及


678
00:33:24,037 --> 00:33:25,606
这种情况可不妙


679
00:33:25,672 --> 00:33:27,774
我们就没法维持数值语义


680
00:33:28,041 --> 00:33:29,710
我们需要修复它


681
00:33:30,677 --> 00:33:33,514
我们修复的方式是使用“写入时复制”


682
00:33:33,881 --> 00:33:37,384
我们需要确保
在我们写入那个路径之前


683
00:33:37,451 --> 00:33:39,186
已经制作了它的一个副本


684
00:33:40,988 --> 00:33:42,789
因此
要向我们的BezierPath中


685
00:33:42,856 --> 00:33:44,892
引入一些新事物


686
00:33:44,958 --> 00:33:49,196
首先我们想要让我们的
路径实例是私有的


687
00:33:49,496 --> 00:33:52,900
其次想要实现这个读取计算路径属性


688
00:33:52,966 --> 00:33:56,370
并从那里返回我们的私有实例变量


689
00:33:57,971 --> 00:33:59,339
我们也想为写入计算属性


690
00:33:59,406 --> 00:34:02,776
创建一个路径路径标记为“改变中”


691
00:34:03,110 --> 00:34:04,845
那么它就会 事实上改变状态


692
00:34:04,912 --> 00:34:07,714
我们把它标记为“改变中”
把路径设为与我们现有路径的


693
00:34:07,781 --> 00:34:10,751
新副本等同


694
00:34:11,284 --> 00:34:15,121
现在我们有了一个读取副本
我们还可以获得一个写入副本


695
00:34:16,590 --> 00:34:18,824
那么我们改变我们的实现
来反映这一点


696
00:34:18,891 --> 00:34:21,695
在“Is Empty”方法中
我们会调用我们的读取副本


697
00:34:22,029 --> 00:34:23,764
在下面的改变方法那里


698
00:34:23,830 --> 00:34:25,465
我们会调用写入路径


699
00:34:25,732 --> 00:34:28,402
关于这个 很棒的一点是
编译器会对我们大喊大叫


700
00:34:28,467 --> 00:34:29,969
说：“写入属性路径标记为了


701
00:34:30,370 --> 00:34:33,473
改变中 这个方法没有


702
00:34:33,806 --> 00:34:36,009
标记为改变中 ”


703
00:34:36,076 --> 00:34:39,012
我们就从编译器得到了帮助
在我们搞错时


704
00:34:39,079 --> 00:34:41,081
帮助我们弄明白


705
00:34:43,984 --> 00:34:46,553
在一个图表中浏览下它 浏览下路径


706
00:34:46,987 --> 00:34:49,556
我通过说
“Path To”又创建了一个


707
00:34:49,989 --> 00:34:51,091
当然 我可以读取它


708
00:34:51,158 --> 00:34:54,360
没问题 当我对它写入时


709
00:34:54,995 --> 00:34:58,966
建了另一个BezierPath实例


710
00:34:59,566 --> 00:35:02,736
路径二还是不明白已经发生了一次变异


711
00:35:03,103 --> 00:35:09,009
因此我不会在路径二后面
引入一些意料之外的变异


712
00:35:10,777 --> 00:35:14,681
现在我们来谈谈如何在
实践中使用这些东西


713
00:35:15,649 --> 00:35:19,286
这里我们有我们的
多边形类型 我们要通过


714
00:35:19,353 --> 00:35:21,455
添加一个会返回给我们
对那个多边形进行描述的


715
00:35:21,522 --> 00:35:24,291
BezierPath
的方法对它进行扩展


716
00:35:24,825 --> 00:35:27,327
我们创建BezierPath
通过点进行迭代


717
00:35:27,394 --> 00:35:29,763
向这些点中添加线二


718
00:35:30,797 --> 00:35:33,100
现在缺点就是那个
“添加线到点”方法


719
00:35:33,166 --> 00:35:36,069
会复制每次调用


720
00:35:36,637 --> 00:35:39,439
因此它的表现可能不那么好


721
00:35:40,974 --> 00:35:43,577
因此我们应该创建一个
UIBezierPath实例


722
00:35:43,644 --> 00:35:48,982
然后就地改变那个可变的引用类型


723
00:35:49,316 --> 00:35:52,753
当我们弄完后
用那个BezierPath创建一个


724
00:35:52,819 --> 00:35:55,155
数值类型新的实例
且返回那个BezierPath


725
00:35:55,222 --> 00:35:57,124
这样生成
UIBezierPath副本


726
00:35:57,191 --> 00:36:00,460
或者生成个UIBezierPath
实例而不是生成多个副本、实例


727
00:36:01,962 --> 00:36:04,665
在Swift中 有一个很棒的特性


728
00:36:04,731 --> 00:36:07,367
可以通过它知道对象是否被惟一地引用


729
00:36:07,434 --> 00:36:09,102
这样我们就可以利用它


730
00:36:09,169 --> 00:36:11,572
这个结构和
BezierPath中看到的类似


731
00:36:12,206 --> 00:36:15,609
我们可以利用我们有这个
惟一引用属性这一事实


732
00:36:15,676 --> 00:36:17,644
我们就可以肯定


733
00:36:17,711 --> 00:36:18,946
有些东西是被惟一引用的


734
00:36:19,012 --> 00:36:20,714
如果我们知道那个引用类型是惟一引用


735
00:36:20,981 --> 00:36:23,851
我们就可以避免制作副本


736
00:36:25,252 --> 00:36:27,487
标准库会自始至终使用那个特性


737
00:36:27,554 --> 00:36:30,490
使用那个特性
也可以进行很多很棒的性能优化


738
00:36:32,292 --> 00:36:34,561
这样酒吧数值类型以及引用类型混合了


739
00:36:34,628 --> 00:36:37,497
尽管事实是通过使用“写入时复制”


740
00:36:37,865 --> 00:36:44,071
你在可变类型上有这些引用
你也想要确保你可以维持数值语义


741
00:36:46,206 --> 00:36:48,976
现在我想看一个非常酷的特性  
我们现在能做的


742
00:36:49,042 --> 00:36:52,312
就是把一个模型类型当做一个
值来实现


743
00:36:53,080 --> 00:36:54,715
然后实现一个撤销栈


744
00:36:55,382 --> 00:36:59,052
那么我要创建一个图表
以及一个图表阵列


745
00:36:59,319 --> 00:37:04,892
有了各个变异 我会把我的
doc添加到我的图表阵列中


746
00:37:05,259 --> 00:37:06,760
那么我创建并附加它


747
00:37:07,461 --> 00:37:10,697
我添加了一个多边形
并且把它附加到了撤销栈


748
00:37:11,632 --> 00:37:14,334
我创建了一个圈
并且把它附加到了撤销栈


749
00:37:14,902 --> 00:37:21,008
现在在我的撤销栈里
我有三个不同的图表实例


750
00:37:21,074 --> 00:37:23,677
它们没有引用同一件事情


751
00:37:23,744 --> 00:37:26,146
这些是三个不同的值


752
00:37:26,580 --> 00:37:29,583
因此可用它来实现一些很酷的特性


753
00:37:29,716 --> 00:37:33,754
假设这个位于一个app内
我有一个“历史”按钮


754
00:37:34,054 --> 00:37:37,124
我点击这个“历史”按钮
我得到了返回到


755
00:37:37,191 --> 00:37:40,527
我的撤销栈的
我的图表的全部状态列表


756
00:37:41,094 --> 00:37:43,463
我就可以允许用户点击其它东西


757
00:37:43,630 --> 00:37:45,566
并且及时返回


758
00:37:45,699 --> 00:37:50,137
我就不用在某个阵列中保存
如何撤销添加那个属性


759
00:37:50,204 --> 00:37:51,638
或者撤销添加其它东西


760
00:37:51,705 --> 00:37:53,640
它会直接返回上一个实例


761
00:37:53,707 --> 00:37:55,609
也就是刚刚绘制的那个实例


762
00:37:56,944 --> 00:38:00,247
这是一项超级强大的特性 事实上


763
00:38:00,314 --> 00:38:03,183
Photoshop大量使用这一特性
以便实现他们的各个


764
00:38:03,250 --> 00:38:04,785
与历史相关的东西


765
00:38:05,018 --> 00:38:07,154
当在Photoshop打开一幅图片


766
00:38:07,221 --> 00:38:09,223
幕后发生了什么？


767
00:38:09,323 --> 00:38:11,525
Photoshop会对
那个照片分层、切块


768
00:38:11,592 --> 00:38:14,895
不论照片有多大切分成一堆小的图块


769
00:38:15,128 --> 00:38:18,565
每个这种图块都是数值 含图块的文档


770
00:38:18,632 --> 00:38:21,702
同样也是一个数值


771
00:38:22,102 --> 00:38:24,605
如果我进行改变比如说把这个人的衬衫


772
00:38:24,671 --> 00:38:29,610
从紫色变成绿色
在那个图表的两个实例中唯一


773
00:38:29,676 --> 00:38:33,180
被复制的
就是包含了这个人的衬衫的


774
00:38:33,247 --> 00:38:35,382
图块


775
00:38:35,616 --> 00:38:38,318
这样即使我有两个不同的文档


776
00:38:38,385 --> 00:38:42,523
旧状态和新状态 我唯一需要当成那个


777
00:38:42,589 --> 00:38:44,525
结果来使用的新数据


778
00:38:44,591 --> 00:38:47,828
就是包含了这个人的衬衫的图块


779
00:38:50,097 --> 00:38:52,966
小结一下 我们讲了数值类型


780
00:38:53,033 --> 00:38:55,802
讲了它给你们的
应用程序带来的很棒的特性


781
00:38:55,869 --> 00:38:58,772
把它和引用类型做了对比
向你们演示了数值类似


782
00:38:58,972 --> 00:39:00,374
是如何修复某些问题的


783
00:39:00,908 --> 00:39:03,410
期间我们演示了一个实例
让你们看了一些你们可以


784
00:39:03,477 --> 00:39:05,746
通过使用数值类型
添加到你们的应用程序上的


785
00:39:05,812 --> 00:39:07,281
很酷的特性


786
00:39:07,347 --> 00:39:10,517
我迫不及待想看到这些东西
在你们的app中是如何发挥作用的


787
00:39:11,051 --> 00:39:13,620
有一些相关的会议 你可以观看视频


788
00:39:13,687 --> 00:39:15,389
或者如果你有时间的话 今天3:30


789
00:39:15,455 --> 00:39:17,257
有关于面向协议编程的会议


790
00:39:18,392 --> 00:39:21,428
如果需要更多信息
你总可以给斯蒂芬发邮件


791
00:39:21,495 --> 00:39:25,132
或者访问我们的论坛资料中也有一些


792
00:39:25,199 --> 00:39:26,300
很棒的信息


793
00:39:27,067 --> 00:39:29,536
谢谢 祝你们在苹果全球
开发者大会的剩余部分愉快

