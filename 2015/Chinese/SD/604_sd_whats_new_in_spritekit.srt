1
00:00:20,521 --> 00:00:23,857
SpriteKit 新功能 


2
00:00:29,663 --> 00:00:32,332
大家好欢迎来到“SpriteKit
新功能 ”讲座


3
00:00:32,900 --> 00:00:35,536
今天 我们将要告诉大家一系列很棒的


4
00:00:35,602 --> 00:00:36,470
新功能和改进


5
00:00:37,171 --> 00:00:40,908
我知道在座的各位中有很多人
是第一次来听SpriteKit讲座


6
00:00:40,974 --> 00:00:43,143
首先 我想要花几分钟来


7
00:00:43,544 --> 00:00:45,679
回顾我们所要讲的是什么


8
00:00:48,849 --> 00:00:52,986
SpriteKit是苹果2D游戏
和图形的框架


9
00:00:53,420 --> 00:00:56,290
我们将给你提供集成的物理运动 


10
00:00:56,924 --> 00:00:58,825
离子运动模拟 动作


11
00:00:58,892 --> 00:01:00,727
以及动画 当然 还有计算机子图


12
00:01:01,695 --> 00:01:06,133
我们启动（这个项目）是想要将
SpriteKit做得不仅仅是强大


13
00:01:06,400 --> 00:01:08,769
而且要非常容易上手使用


14
00:01:09,002 --> 00:01:12,472
我们希望一个之前
完全没有做过游戏的人


15
00:01:13,040 --> 00:01:14,641
能够来到我们的平台


16
00:01:14,975 --> 00:01:16,343
开始使用SpriteKit


17
00:01:16,410 --> 00:01:17,911
并且能够花很少的时间得到提高
并熟悉（SpriteKit）


18
00:01:18,679 --> 00:01:20,881
我们非常期望能够传达出一些东西


19
00:01:20,948 --> 00:01:23,217
能够使你专心致志地做你最擅长的事情


20
00:01:23,283 --> 00:01:25,319
那就是做出最棒的游戏


21
00:01:28,021 --> 00:01:29,857
我们将SpriteKit设计成


22
00:01:29,923 --> 00:01:32,559
可以在iPhone、
iPad以及Mac上工作


23
00:01:33,093 --> 00:01:35,863
并且
你也能够通过这个平台将你的app


24
00:01:35,929 --> 00:01:38,599
应用到多个平台上
这也就意味着


25
00:01:38,665 --> 00:01:40,300
你能够
直接在Mac上设计原型


26
00:01:40,367 --> 00:01:42,402
并测试你的SpriteKit游戏


27
00:01:42,669 --> 00:01:44,538
在你将它（游戏）安装到
一个设备上之前


28
00:01:47,574 --> 00:01:50,611
可以说 有了SpriteKit 
游戏构架的开发能够做到事半功倍


29
00:01:51,211 --> 00:01:54,615
在刚开始的时候我们花费了
大量的精力在我们的工具上


30
00:01:54,781 --> 00:01:57,451
在后续的几年里我们
也在持续地进行投资


31
00:01:57,885 --> 00:01:59,186
就是为了能够


32
00:01:59,286 --> 00:02:01,188
让你能够像编辑整个画面
一样编辑粒子效果


33
00:02:01,622 --> 00:02:03,524
直到今年年初也同样


34
00:02:03,590 --> 00:02:06,326
能够对运动和动画进行编辑


35
00:02:06,393 --> 00:02:08,095
只需要在写代码前


36
00:02:08,161 --> 00:02:10,997
加入一段Xcode即可


37
00:02:13,867 --> 00:02:15,969
现在 我们可以开始讲解
这个构架有哪些新功能了


38
00:02:17,037 --> 00:02:19,573
第一点 也是开发人员强烈要求的一点


39
00:02:20,240 --> 00:02:22,609
就是视窗


40
00:02:22,676 --> 00:02:25,279
视窗是指


41
00:02:25,345 --> 00:02:27,981
当我们在讨论你的场景的时候
这部分（场景）是可见的


42
00:02:28,048 --> 00:02:29,850
在任何时候
通过SpriteKit视角


43
00:02:31,351 --> 00:02:34,321
现在的这种工作方式是
如果你想要移动你的镜头


44
00:02:34,821 --> 00:02:38,358
你不得不移动
你游戏中的每一块几何图案


45
00:02:38,425 --> 00:02:40,994
或者
如果你想要跟随你的一个英雄人物


46
00:02:41,061 --> 00:02:42,829
穿越你的整个游戏界面


47
00:02:43,197 --> 00:02:44,765
你就需要做这些计算


48
00:02:45,399 --> 00:02:46,633
现在这样的工作


49
00:02:46,700 --> 00:02:48,368
但是它并不像我们想象中的那样直观


50
00:02:49,303 --> 00:02:51,605
如果你想要对这些游戏实体进行物理模
拟 


51
00:02:51,672 --> 00:02:54,741
当你移动他们的实际位置时


52
00:02:54,808 --> 00:02:57,077
你可以从中看到一些伪影


53
00:02:59,046 --> 00:03:00,914
我们认为我们能够做的更好


54
00:03:01,982 --> 00:03:04,084
接下来我们介绍
SKCameraNode.


55
00:03:05,485 --> 00:03:07,020
通过CameraNode


56
00:03:07,087 --> 00:03:10,524
我们允许你能够简单的指定你看到的部
分


57
00:03:10,591 --> 00:03:13,393
变得可视化 镜头通过


58
00:03:13,460 --> 00:03:14,561
展现你的场景中所包含的


59
00:03:14,628 --> 00:03:16,029
可视化中心来达到这样的效果


60
00:03:16,630 --> 00:03:18,332
这样你就可以在你的画面中任意移动


61
00:03:18,398 --> 00:03:19,800
CameraNode


62
00:03:20,234 --> 00:03:22,035
同样的
你也可以在你的画面中移动其他的


63
00:03:22,102 --> 00:03:23,804
所有的游戏实体


64
00:03:24,705 --> 00:03:26,673
我们在SKScene中
设置了一个属性


65
00:03:26,740 --> 00:03:29,142
这个属性将允许你选择
你想使用的包含这些场景的镜头


66
00:03:29,209 --> 00:03:31,812
在你的场景中你可以选择多个镜头


67
00:03:32,112 --> 00:03:34,581
同样你也可以通过属性选择活动的镜头


68
00:03:35,983 --> 00:03:38,685
如果你不理会属性 即其缺省值为零


69
00:03:39,152 --> 00:03:41,388
我们将会保存所有你今天的使用记录


70
00:03:41,455 --> 00:03:43,390
并且所有的
SpriteKit渲染效果


71
00:03:43,457 --> 00:03:44,625
都和从前一样不会改变


72
00:03:45,792 --> 00:03:48,862
但是SKCameraNode
中最棒的功能是


73
00:03:49,997 --> 00:03:50,898
它作为一个节点存在


74
00:03:51,632 --> 00:03:54,301
这就意味着你能够
使用SpriteKit节点中


75
00:03:54,368 --> 00:03:55,435
所有伟大的功能


76
00:03:55,702 --> 00:03:57,771
你可以访问我们的动作数据库


77
00:03:57,838 --> 00:04:00,073
这样你就能够在
镜头上运行这样的动作（数据）


78
00:04:00,140 --> 00:04:02,009
你也可以使用我们的约束系统


79
00:04:02,075 --> 00:04:03,877
这样你就能够对镜头进行约束


80
00:04:04,244 --> 00:04:06,280
你可以让它与游戏实体相结合


81
00:04:06,346 --> 00:04:08,715
你也可以让它总是保留在


82
00:04:08,782 --> 00:04:10,184
距离你游戏中物体的一定范围内


83
00:04:10,617 --> 00:04:13,587
除了移动镜头之外
你还能够通过这些节点的属性


84
00:04:13,654 --> 00:04:16,055
来控制旋转和尺度


85
00:04:17,291 --> 00:04:18,392
例如


86
00:04:18,458 --> 00:04:20,560
在这样一个游戏中 


87
00:04:20,627 --> 00:04:22,729
我想将镜头放到一
旁


88
00:04:22,796 --> 00:04:24,698
我可能应用一些移动动画


89
00:04:24,765 --> 00:04:26,500
来揭示我的视线中有坏人


90
00:04:26,567 --> 00:04:28,435
在我将我的游戏角色
放在视线中央之前


91
00:04:28,936 --> 00:04:31,104
之后我可以应用一些尺度命令 


92
00:04:31,171 --> 00:04:32,506
来实现镜头的变焦操作


93
00:04:33,440 --> 00:04:35,943
我甚至可以使用我们的跟踪路径运动


94
00:04:36,009 --> 00:04:37,744
如果我想要镜头跟踪一个贝塞尔曲线


95
00:04:38,645 --> 00:04:40,547
如果我真的非常想让我的用户感到恶心


96
00:04:40,614 --> 00:04:41,748
我可以旋转镜头


97
00:04:41,815 --> 00:04:43,450
或者将镜头在场景中到处扔来扔去


98
00:04:43,750 --> 00:04:46,620
所以现在在SpriteKit中
你完全可以控制你的游戏


99
00:04:46,687 --> 00:04:48,822
哪些部分是可见的


100
00:04:49,122 --> 00:04:51,425
我认为这将会是
你的工具中的一件很棒的新品


101
00:04:57,731 --> 00:04:59,266
对镜头的改进


102
00:04:59,333 --> 00:05:01,001
同样的我们也针对音频做了很多工作


103
00:05:01,502 --> 00:05:03,804
我们添加了一个
SKAudioNode


104
00:05:03,871 --> 00:05:05,873
允许你在你的SpriteKit
游戏中


105
00:05:06,039 --> 00:05:07,975
添加位置和环境的背景音


106
00:05:13,113 --> 00:05:16,316
我们借助了我们去年
发布的Apple强大的


107
00:05:16,383 --> 00:05:18,118
AV音频引擎构架


108
00:05:18,519 --> 00:05:19,853
如果你对这个并不熟悉


109
00:05:19,920 --> 00:05:22,322
它允许你指定你的语气音量


110
00:05:22,723 --> 00:05:24,892
并能够作为特定环境中的声音发射器


111
00:05:25,259 --> 00:05:27,828
它可以回放你制定位置


112
00:05:27,895 --> 00:05:29,563
侦听器获得的声音


113
00:05:30,697 --> 00:05:33,600
在SpriteKit中我们将为
你做好所有的画线工作


114
00:05:34,368 --> 00:05:37,571
所有你需要做的工作就是
通过文件名或者URL指定


115
00:05:37,638 --> 00:05:40,707
你想要播放的背景音乐


116
00:05:41,141 --> 00:05:44,444
我们将会使用AudioNodes 


117
00:05:44,511 --> 00:05:46,747
跟随你指定的侦听器的位置
在你的场景中定位


118
00:05:46,813 --> 00:05:50,617
并画出音频曲线 让你能够更容易地


119
00:05:50,884 --> 00:05:53,086
身临其境地在游戏中定位你的音频


120
00:05:53,954 --> 00:05:56,557
如果你想深入一点 亲自动手


121
00:05:56,990 --> 00:06:00,093
你也可以通过
底层AVAudioNode的


122
00:06:00,427 --> 00:06:02,796
一个节点的属性 去掉所有的约束


123
00:06:02,863 --> 00:06:04,264
在那里设置所有的你想要的东西


124
00:06:05,966 --> 00:06:07,668
为了掩饰这种效果


125
00:06:07,734 --> 00:06:09,570
你能够使用


126
00:06:09,670 --> 00:06:12,639
最新的技术将其添加
到你的SpriteKit游戏中


127
00:06:12,840 --> 00:06:14,441
现在我又一个例子


128
00:06:14,775 --> 00:06:16,009
这里是我的制作的一个地精


129
00:06:16,076 --> 00:06:17,911
我打算让他作为我的听众


130
00:06:18,178 --> 00:06:20,047
所以我把我的侦听器位置放在这里


131
00:06:21,081 --> 00:06:23,050
我已经在我的场景中添加了一个火球


132
00:06:23,283 --> 00:06:24,685
这是我的音频资源


133
00:06:24,751 --> 00:06:27,020
在这里我已经将其作为一个
SKAudioNode添加了进来


134
00:06:27,287 --> 00:06:29,389
我重新播放这个音乐的时候


135
00:06:29,456 --> 00:06:31,358
注意听这个音频的效果怎么样


136
00:06:31,425 --> 00:06:33,360
当火球在整个场景中来回运动的时候


137
00:06:33,427 --> 00:06:34,795
你能够注意到


138
00:06:34,862 --> 00:06:37,397
它变得更加饱满 更加集中 声音也更
大了


139
00:06:37,464 --> 00:06:39,166
当它靠近我们的侦听器时


140
00:06:39,233 --> 00:06:41,502
从远到近


141
00:06:41,568 --> 00:06:44,304
直到来到场景这一边
现在我们听一下


142
00:06:59,820 --> 00:07:00,988
很酷 不是吗？


143
00:07:05,726 --> 00:07:07,327
除了这些额外的设置


144
00:07:07,394 --> 00:07:09,630
我不需要做任何事情来处理这些特效


145
00:07:09,696 --> 00:07:11,698
当他们在游戏场景中运动的时候
他们已经和


146
00:07:12,065 --> 00:07:14,001
驱动游戏运行的逻辑联系在了一起


147
00:07:16,403 --> 00:07:20,774
同样的
今年我们也重点关注了引用和实例化


148
00:07:21,208 --> 00:07:25,512
我们知道你花了很多时间
为你的游戏设计


149
00:07:25,746 --> 00:07:29,983
内容和动画 我们也希望你能够在


150
00:07:30,050 --> 00:07:33,320
任何你想用的地方重新使用这些内容


151
00:07:33,387 --> 00:07:36,823
我们将允许你能够为你的节点
和动作创建序列化数据文件


152
00:07:37,257 --> 00:07:39,259
创建序列化数据文件


153
00:07:39,326 --> 00:07:41,862
并将其作为一个引用参数添加进来


154
00:07:41,929 --> 00:07:44,998
而不是简单的加载到你的场景中


155
00:07:45,065 --> 00:07:45,899
这样


156
00:07:45,966 --> 00:07:48,335
你每次对资源文件进行修改之后


157
00:07:48,669 --> 00:07:51,939
将会自动地对你的游戏内容产生影响


158
00:07:54,474 --> 00:07:55,909
我怎么做这个节点呢?


159
00:07:56,743 --> 00:07:59,680
我设计了一部分场景作为节点


160
00:07:59,746 --> 00:08:02,749
可以是一个背景元素
或者是Xcode编辑器中的一些画面


161
00:08:02,816 --> 00:08:07,354
接下来我可以通过
Xcode将这些文件


162
00:08:07,721 --> 00:08:08,856
拖放到主场景中


163
00:08:08,922 --> 00:08:10,624
接下来它会自动地创建一个参数


164
00:08:10,891 --> 00:08:12,025
这些都是为你设置好的


165
00:08:13,093 --> 00:08:15,229
如果你想写代码来完成这些事情
同样可以


166
00:08:15,662 --> 00:08:18,699
你可以手动构建一个
SKReferenceNode


167
00:08:19,066 --> 00:08:23,036
为其分配一个文件名或者URL


168
00:08:23,103 --> 00:08:25,973
当这些内容在
你的游戏中是第一次发布时


169
00:08:26,039 --> 00:08:28,542
我们会将你的包中
这些内容的最新版本的


170
00:08:28,809 --> 00:08:29,977
文件进行上传


171
00:08:31,945 --> 00:08:34,014
我们同样能够这样处理一些动作


172
00:08:34,515 --> 00:08:37,384
通过这些动作作品


173
00:08:37,985 --> 00:08:40,654
能够看出我们的
新动作编辑器是多么的伟大


174
00:08:40,721 --> 00:08:43,323
同时那些你在Xcode中创作的动作
你都 有命名的权利


175
00:08:43,756 --> 00:08:46,059
这些名字将是你在游戏中
使用它们时候的关键字


176
00:08:46,727 --> 00:08:48,996
我们在SKAction中添加了


177
00:08:49,329 --> 00:08:50,631
一个名叫actionNamed
的筛选器


178
00:08:51,031 --> 00:08:51,932
它的作用就像


179
00:08:51,999 --> 00:08:54,935
textureNamed
对于SKTexture一样


180
00:08:55,068 --> 00:08:56,770
你可以输入你想要的动作的名字


181
00:08:57,404 --> 00:09:01,008
我们将自动在你的App包中的


182
00:09:01,708 --> 00:09:04,278
序列化动作文件中 找到


183
00:09:04,344 --> 00:09:06,446
一个最合适的文件


184
00:09:06,513 --> 00:09:07,948
然后将其在应用程序中呈现出来


185
00:09:08,515 --> 00:09:11,218
在你的游戏中请频繁使用这个功能


186
00:09:11,285 --> 00:09:14,955
我们做了所有的关于内存的工作


187
00:09:15,355 --> 00:09:17,724
我们可以保证
你的游戏中所有相同的动作绝对不会


188
00:09:17,791 --> 00:09:21,428
从硬盘中重复地加载多次


189
00:09:21,662 --> 00:09:24,631
有时候你可能会想要
让同一个动作重复多次


190
00:09:24,698 --> 00:09:26,867
但它会播放得时快时慢


191
00:09:27,467 --> 00:09:29,536
我们添加了一个额外的选择器


192
00:09:29,603 --> 00:09:31,338
它将允许你能够覆盖操作的持续时间


193
00:09:32,105 --> 00:09:34,007
这是一个智能时间轴


194
00:09:34,107 --> 00:09:37,277
所以即使你使用的是嵌套组和序列中的
嵌套 动作


195
00:09:37,344 --> 00:09:39,746
它将动态规划新的时间轴


196
00:09:39,813 --> 00:09:43,550
这样 每个时间区间内的动作组件


197
00:09:43,617 --> 00:09:45,285
都将会是一样的大小


198
00:09:46,653 --> 00:09:50,224
这些都是为可重复使用组件设计的工具


199
00:09:50,591 --> 00:09:53,560
这些可重复使用组件你
可以在同一个游戏的同一个场景


200
00:09:53,627 --> 00:09:55,095
或者跨越多个不同的游戏中使用


201
00:09:56,563 --> 00:09:58,966
我们同样在构架中
添加了一系列新的动作


202
00:09:59,032 --> 00:10:01,468
所以现在我们有了这些位置
AudioNodes


203
00:10:01,535 --> 00:10:04,271
就能够通过动作更好的控制回放


204
00:10:04,471 --> 00:10:10,010
我们已经添加了播放,暂停,回放速度


205
00:10:10,110 --> 00:10:12,079
以及操作体积和立体平移等开关


206
00:10:13,881 --> 00:10:17,584
我们也在帧动画中做了一些改动


207
00:10:18,252 --> 00:10:21,421
在SpriteKit中我们一直
都有通过纹理动作运动


208
00:10:21,488 --> 00:10:24,525
做出来的基于帧的动画


209
00:10:25,559 --> 00:10:28,395
但是去年我们在SpriteKit中
引入了lighting


210
00:10:28,462 --> 00:10:29,530
通过lighting


211
00:10:29,596 --> 00:10:31,899
你不仅能够在你的场景中为
Sprites自动生成


212
00:10:32,232 --> 00:10:34,401
也能够自主添加常规的纹理动作


213
00:10:34,468 --> 00:10:37,871
然后我们可以在运行时动态的点亮他们


214
00:10:37,938 --> 00:10:40,207
通过在你的场景中移动光节点


215
00:10:41,608 --> 00:10:43,877
这种做法对于稳定的元素来讲很方便


216
00:10:43,944 --> 00:10:46,914
但是如果我有一个基于帧的动画
例如这个东西


217
00:10:47,681 --> 00:10:49,816
我们想要这些高亮和阴影部分


218
00:10:49,883 --> 00:10:50,751
在当前位置分开


219
00:10:50,817 --> 00:10:53,654
我们不想要腿前面所在的区域高亮


220
00:10:54,655 --> 00:10:56,056
所以 我们添加了一个


221
00:10:56,123 --> 00:10:58,258
正常纹理运动的动画


222
00:10:58,492 --> 00:11:01,228
所以你可以使用这个 在正常的动画


223
00:11:01,728 --> 00:11:04,598
与每一帧之间 进行同步


224
00:11:04,698 --> 00:11:08,836
如果我在我的人物上运行了这种动画
并给场景添加了lighting


225
00:11:09,136 --> 00:11:11,905
你就会看到所有的高亮区域 阴影都能
与每一帧保 持同步


226
00:11:11,972 --> 00:11:15,209
无论我的人物如何跑动


227
00:11:24,918 --> 00:11:27,387
这些就是我们添加到构架中的新功能


228
00:11:27,454 --> 00:11:29,489
我们也做了很多其他的工作
使这些功能能够与


229
00:11:29,823 --> 00:11:32,993
系统的其他部分更好的结合在一起


230
00:11:33,060 --> 00:11:35,229
更好的发挥已经添加到我们平台上的


231
00:11:35,295 --> 00:11:36,797
新硬件和构架的优势


232
00:11:37,898 --> 00:11:40,133
首先我想讲的是Metal


233
00:11:40,767 --> 00:11:43,437
我们正在开发SpriteKit


234
00:11:43,504 --> 00:11:48,041
并且我们正准备将它直接链接到IOS
和 Mac的Metal平台上


235
00:11:48,842 --> 00:11:51,311
将能够在任何
支持Metal的设备上使用


236
00:11:51,378 --> 00:11:53,647
以及那些不会自动降级
到OpenGL的设备上


237
00:11:54,815 --> 00:11:58,285
这意味着你的CPU使用率会降低


238
00:11:58,585 --> 00:12:01,188
这意味着作为一个开发人员
你将会得到更好的绘制调用性能


239
00:12:01,255 --> 00:12:02,823
以及更好的电池使用寿命


240
00:12:02,890 --> 00:12:04,658
因为将能够做到零运动请求


241
00:12:10,531 --> 00:12:12,633
我们将自动升级所有的
SpriteKit程序


242
00:12:12,699 --> 00:12:13,734
你不需要重新编译


243
00:12:13,800 --> 00:12:15,269
或重新提交


244
00:12:15,702 --> 00:12:17,538
只要它支持Metal 你就能够运行


245
00:12:18,505 --> 00:12:21,041
如果你对自定义着色器感兴趣的话


246
00:12:21,108 --> 00:12:22,442
我们也同样顾及到了


247
00:12:23,010 --> 00:12:25,579
如果你的游戏中有自定义着色器


248
00:12:25,646 --> 00:12:28,315
我们几乎支持
所有的Metal变体的升级


249
00:12:28,515 --> 00:12:30,984
同样能够在
支持Metal的设备上很好地运行


250
00:12:36,456 --> 00:12:37,391
接下来是Swift


251
00:12:38,192 --> 00:12:39,960
我们看了整个API的文件


252
00:12:40,127 --> 00:12:42,362
并且我们向其中添加了可空性限定符


253
00:12:42,663 --> 00:12:45,866
我们采用了
Objective-C泛型数组类型


254
00:12:45,933 --> 00:12:47,701
用作参数或者返回类型


255
00:12:48,368 --> 00:12:50,504
这将是你能够很方便的


256
00:12:50,571 --> 00:12:53,373
从Swift中访问
SpriteKit的所有功能


257
00:12:54,408 --> 00:12:56,243
这也能够给你的软件
提供增强版的安全性


258
00:12:56,310 --> 00:12:58,545
增强版的安全性
无论你是使用Swift


259
00:12:59,146 --> 00:13:00,347
还是Objective C


260
00:13:02,049 --> 00:13:03,750
现在我想讲一下SceneKit


261
00:13:03,951 --> 00:13:06,486
或许你并不知道Scenekit


262
00:13:06,553 --> 00:13:09,056 position:10%
我们允许你用SceneKit体现
SpriteKit


263
00:13:09,122 --> 00:13:10,891 position:10%
也可以用SpriteKit
体现SceneKit


264
00:13:11,325 --> 00:13:13,894
今年我们允许你能做到的更多一点


265
00:13:13,961 --> 00:13:16,463
可以直接在
SceneKits游戏中使用


266
00:13:16,530 --> 00:13:18,932
所有你知道和
你喜欢的SpriteKit过渡效果


267
00:13:19,933 --> 00:13:21,935
你甚至都不需要
用SpriteKit去做


268
00:13:22,769 --> 00:13:26,740
你可以像使用门一样使用这个转换器
剪辑


269
00:13:27,040 --> 00:13:29,710
甚至你的SceneKit游戏中
基于转换效果的核心图片


270
00:13:30,177 --> 00:13:33,180
同样能够有很好的效果


271
00:13:34,281 --> 00:13:36,016
这个版本的SceneKit同样支持


272
00:13:36,083 --> 00:13:38,185
Metal背景下的内容


273
00:13:38,886 --> 00:13:41,054
我们可以自动匹配好


274
00:13:41,121 --> 00:13:43,924
如果你有一个支持在Metal上运行
的SceneKit游戏 


275
00:13:44,258 --> 00:13:45,425
我们通过使用Metal


276
00:13:45,492 --> 00:13:47,227
可以使你得到SpriteKit内容


277
00:13:47,294 --> 00:13:49,696
去过你有一个支持GL上运行的
SceneKit游戏


278
00:13:49,763 --> 00:13:52,466
我们可以通过使用OpenGL使你得
到SpriteKit


279
00:13:52,533 --> 00:13:54,735
你永远不会产生额外的开销


280
00:13:54,801 --> 00:13:57,337
在两个API之间进行转换时


281
00:14:00,207 --> 00:14:03,410
今年我们也发布了一个全新的构架


282
00:14:03,610 --> 00:14:04,912
叫做 GameplayKit


283
00:14:05,112 --> 00:14:06,780
这个构架很棒


284
00:14:06,847 --> 00:14:09,750
它将提供给你创建一个游戏逻辑结构所
需的所有基础


285
00:14:09,983 --> 00:14:12,920
就像Entity/
Component系统一样


286
00:14:13,587 --> 00:14:15,088
作为状态机


287
00:14:15,155 --> 00:14:18,258
而且还提供了非常棒的工具


288
00:14:18,392 --> 00:14:21,528
例如AI对手和确定性随机源


289
00:14:22,462 --> 00:14:24,498
有一点我非常喜欢


290
00:14:24,565 --> 00:14:26,967
那就是它能够为你的游戏
提供一个路径寻找的解决方案


291
00:14:27,034 --> 00:14:29,636
我相信很多SpriteKit工程师
会对这个功能感兴趣


292
00:14:30,470 --> 00:14:32,506
GameplayKit中寻路
的工作方式是


293
00:14:32,573 --> 00:14:34,741
你指定一个可穿越的导航图


294
00:14:35,409 --> 00:14:37,644
在你的游戏世界中


295
00:14:38,212 --> 00:14:41,448
之后你将会在这些节点之间连线


296
00:14:41,782 --> 00:14:43,350
并给出一个相关成本


297
00:14:44,618 --> 00:14:46,019
只要你给出了这个地图


298
00:14:46,587 --> 00:14:48,689
GameplayKit 
将计算出地图上


299
00:14:48,822 --> 00:14:50,090
这两个点之间的最优路径


300
00:14:50,991 --> 00:14:52,759
我怎样在游戏中设置呢？


301
00:14:53,994 --> 00:14:56,263
加入我这里
有一个SpriteKit游戏


302
00:14:56,330 --> 00:14:58,165 position:10%
我的英雄在下面的这个角 
我...嗯…


303
00:14:58,632 --> 00:15:01,668
假如我想让他移动到某一个目的地


304
00:15:02,202 --> 00:15:05,806
然后在我的地图上指定几个障碍物


305
00:15:05,873 --> 00:15:07,441
障碍物是不可穿越的地区


306
00:15:07,841 --> 00:15:12,045
将这些数据
给GameplayKit之后


307
00:15:12,112 --> 00:15:14,715
给我的想要穿越地图的角色
周围设置一个缓冲半径


308
00:15:15,048 --> 00:15:17,684
GameplayKit 会将
缓冲半径计算进去


309
00:15:17,751 --> 00:15:20,420
自动扩展所有的障碍物


310
00:15:20,487 --> 00:15:22,556
这样我们不会
进入任何障碍物的缓冲半径中


311
00:15:23,257 --> 00:15:25,359
然后在地图中创建有效的连接图


312
00:15:25,425 --> 00:15:27,694
并且只创建有效的连接


313
00:15:27,861 --> 00:15:29,863
所以我们永远不会穿越这些障碍物


314
00:15:30,430 --> 00:15:33,567
然后你就可以在你的游戏中
使用这些来进行


315
00:15:33,967 --> 00:15:35,035
寻路操作


316
00:15:35,602 --> 00:15:37,704
这个功能并不专属于
 SpriteKit


317
00:15:37,771 --> 00:15:40,707
所以你可以在SceneKit
中使用GameplayKits


318
00:15:40,774 --> 00:15:43,110
SpriteKit, 
OpenGL, Metal


319
00:15:43,177 --> 00:15:44,378
等等任何类型的游戏都可以


320
00:15:45,212 --> 00:15:47,948
如果你使用的是SpriteKit
我们可以使它变得更容易


321
00:15:48,015 --> 00:15:49,249
你甚至都不需要创建障碍物


322
00:15:50,050 --> 00:15:53,687
你可以使用Sprite界限
直接创建障碍物


323
00:15:55,422 --> 00:15:57,691
你可以根据你在Sprite上
设置的物理主体


324
00:15:57,758 --> 00:16:01,261dle
创建障碍物


325
00:15:57,758 --> 00:16:01,261
创建障碍物


326
00:16:01,328 --> 00:16:03,363
甚至从与你游戏中
Sprite相关纹理的


327
00:16:03,597 --> 00:16:05,999 position:10%
Alpha透明度信息中创建障碍物


328
00:16:06,300 --> 00:16:09,203
这给了你一种非常简单的
在SpriteKit软件中利用


329
00:16:09,469 --> 00:16:11,972
GameplayKits寻路的方法


330
00:16:18,345 --> 00:16:19,813
就像我之前说的


331
00:16:20,147 --> 00:16:22,182
构架只是我们工作的一部分


332
00:16:22,649 --> 00:16:25,118
今年我们对我们的工具进行了
大量非常棒的改进


333
00:16:25,185 --> 00:16:27,855
接下来我想将这些交给Norman


334
00:16:27,921 --> 00:16:28,989
来讲解


335
00:16:34,761 --> 00:16:35,963
谢谢你 提姆


336
00:16:37,364 --> 00:16:40,467
开发游戏是一个复杂
并且不断迭代的过程


337
00:16:40,934 --> 00:16:44,271
游戏的各个部分需要
像玩游戏一样不断迭代


338
00:16:44,872 --> 00:16:47,474
以保证一个游戏的趣味性


339
00:16:48,075 --> 00:16:50,244
动画 用来确保一个角色移动的流畅性


340
00:16:50,811 --> 00:16:53,213
艺术性 用来保证屏幕上的像素点


341
00:16:53,280 --> 00:16:56,049
能够流行起来


342
00:16:56,250 --> 00:16:58,685
作为一个游戏工程师
你不仅会遇到迭代问题


343
00:16:58,752 --> 00:17:01,522
你还会遇到可伸缩性问题


344
00:17:01,922 --> 00:17:05,325
我要怎样才能跨越多个等级
复制我的设计呢？


345
00:17:06,292 --> 00:17:09,695
在苹果公司我们当初启动设计
SpriteKit 的工程时


346
00:17:09,762 --> 00:17:13,200
我们不仅想要为你提供
一个高性能


347
00:17:13,267 --> 00:17:15,435
且易用的API


348
00:17:15,502 --> 00:17:18,405
而且要为你提供
一个可伸缩和迭代的工具


349
00:17:18,872 --> 00:17:21,575
这样我们就能专注于
开发游戏


350
00:17:22,542 --> 00:17:25,244
从SpriteKit 构架的
第一个版本发布


351
00:17:25,311 --> 00:17:26,780
我们已经开发并


352
00:17:26,847 --> 00:17:28,582
持续向Xcode中


353
00:17:28,649 --> 00:17:30,584
添加了多个工具


354
00:17:31,051 --> 00:17:34,521
让我来给你们展示一下
作为一个SpriteKit用户


355
00:17:34,688 --> 00:17:36,390
你能够使用哪些工具


356
00:17:37,691 --> 00:17:40,160
第一个要介绍的是纹理地图集


357
00:17:41,161 --> 00:17:43,730
使用texture atlas的
第一个主要好处就是


358
00:17:44,131 --> 00:17:45,866
能够提升性能


359
00:17:46,767 --> 00:17:49,736
SpriteKit通过纹理地图集将
大量的图片调用命令最小化


360
00:17:49,803 --> 00:17:53,106
并发送给GPU以达到优化效率的目的


361
00:17:53,740 --> 00:17:57,811
我们不想强迫我们的用户适应手动


362
00:17:58,145 --> 00:18:01,815
创建这些纹理地图集的过程


363
00:18:02,549 --> 00:18:05,018
每次对资源进行修改的时候


364
00:18:05,118 --> 00:18:07,487
这些手动的过程都必须从头再来一遍


365
00:18:08,188 --> 00:18:10,591
所以我们开发了一个
自动的纹理地图集生成器


366
00:18:10,657 --> 00:18:12,159
在Xcode中


367
00:18:12,793 --> 00:18:15,195
创建一个这种地图集


368
00:18:15,262 --> 00:18:17,798
就像拖拽一个文件夹
到你的工作区中一样简单


369
00:18:18,699 --> 00:18:22,469
同样的我们在开发的时候
也会自动做一些事情


370
00:18:22,536 --> 00:18:25,138
每一张资源图片


371
00:18:25,205 --> 00:18:27,341
都会自动经历一个复杂的后期处理过程


372
00:18:27,741 --> 00:18:31,912
例如我们会为图片
修剪Alpha透明像素


373
00:18:32,479 --> 00:18:34,381
但是这并不会在屏幕上有任何体现


374
00:18:34,915 --> 00:18:38,852
如果旋转90度能够让这些图片更紧凑


375
00:18:39,353 --> 00:18:41,421
或者能得到一个更小的地图集的话 
我们会进行这样的旋转


376
00:18:41,989 --> 00:18:43,690
对于每一个资源图片 


377
00:18:43,757 --> 00:18:47,461
我们都会对其进行其边缘的审查


378
00:18:47,895 --> 00:18:49,596
如果其实完全不透明的


379
00:18:49,663 --> 00:18:51,398
我们将会对其边缘进行压缩


380
00:18:51,465 --> 00:18:53,400
当你在场景中堆叠这些图片时


381
00:18:53,467 --> 00:18:55,736
你不会看到任何接缝


382
00:18:57,237 --> 00:18:59,439
这就是纹理地图集自动生成器


383
00:19:00,440 --> 00:19:02,543
今年我们将它做得更好了


384
00:19:03,277 --> 00:19:05,479
现在你可以生成纹理地图集


385
00:19:05,546 --> 00:19:07,147
来代替资源目录了


386
00:19:07,681 --> 00:19:09,116
使用资源目录生成地图集


387
00:19:09,183 --> 00:19:11,919
有两个主要好处


388
00:19:12,286 --> 00:19:13,153
第一


389
00:19:14,087 --> 00:19:15,923
你可以精确地


390
00:19:15,989 --> 00:19:18,192
为你的目标设备


391
00:19:18,258 --> 00:19:19,860
适配到合适分辨率的图片


392
00:19:20,427 --> 00:19:23,730
你不需要严格
按照你的图片名字的后缀来查找


393
00:19:24,231 --> 00:19:28,502
例如添加2X或者
添加2X到iphone


394
00:19:29,203 --> 00:19:31,538
所有的这些都能在在UI中设计好


395
00:19:32,372 --> 00:19:33,640
第二个


396
00:19:33,707 --> 00:19:36,343
有点就是我们现在支持 ...


397
00:19:36,410 --> 00:19:37,611
在资源目录中


398
00:19:38,245 --> 00:19:41,181
每一组的目标分辨率


399
00:19:41,248 --> 00:19:43,851
将会根据他们设备的独立纹理来生成


400
00:19:44,351 --> 00:19:45,786
当用户打开App Store


401
00:19:45,853 --> 00:19:48,088
并下载下来
你的SpriteKit授权游戏时


402
00:19:48,856 --> 00:19:51,124
只有与他或她的设备


403
00:19:51,191 --> 00:19:53,393
相适配的地图集才会被下载下来


404
00:19:54,061 --> 00:19:56,864
这不仅能够使下载时的带宽最小


405
00:19:57,297 --> 00:20:01,068
同样能够使其安装到
用户手机的时间最短


406
00:20:01,401 --> 00:20:04,872
同样能够最小化应用程序的存储开销


407
00:20:07,241 --> 00:20:10,444
另外 纹理地图集支持基于命令资源


408
00:20:10,911 --> 00:20:13,680 position:10%
基于命令的资源是一个全新的API


409
00:20:13,981 --> 00:20:17,317
它使你能够在游戏运行的情况下


410
00:20:17,384 --> 00:20:19,219
从网上下载艺术资源流


411
00:20:20,053 --> 00:20:22,089
SpriteKit也集成了这种功能


412
00:20:22,489 --> 00:20:24,892
这种资源是通过标签来识别的


413
00:20:25,259 --> 00:20:26,126
例如


414
00:20:26,193 --> 00:20:28,295
这是我的Inspector中的Xc
ode写的背景元素


415
00:20:28,362 --> 00:20:32,432
我可以指定一个与其相关联的标签


416
00:20:33,133 --> 00:20:35,536
我把它叫做一级背景


417
00:20:35,602 --> 00:20:38,505
这些就是标签 你可以通过这些标签


418
00:20:38,572 --> 00:20:40,440
检索这个资源


419
00:20:40,507 --> 00:20:42,242
并且开启背景流媒体


420
00:20:42,476 --> 00:20:44,044
当你的程序调用它的时候


421
00:20:46,813 --> 00:20:48,348
粒子效果


422
00:20:48,415 --> 00:20:50,150
可以有效地帮助你准确的建立起游戏


423
00:20:52,186 --> 00:20:54,555
我们将这个构架中的
SKEmitterNode


424
00:20:54,621 --> 00:20:56,924
作为一个强大且灵活的APIs


425
00:20:56,990 --> 00:20:58,692
提供给你来使用


426
00:20:59,593 --> 00:21:02,196
强大并灵活也有缺点


427
00:21:02,763 --> 00:21:05,832
那就是你需要设置49个属性


428
00:21:07,134 --> 00:21:09,069
你需要对这49个属性


429
00:21:09,136 --> 00:21:11,038
进行排列组合


430
00:21:11,104 --> 00:21:12,739
来达到你想要的视觉和感觉效果


431
00:21:12,806 --> 00:21:15,442
你需要做的就是花费更多的时间


432
00:21:16,109 --> 00:21:18,045
因为我们在Xcode中


433
00:21:18,111 --> 00:21:20,314
开发了一个粒子编辑器


434
00:21:20,747 --> 00:21:23,083
它是使用同一个
SpriteKit呈现驱动


435
00:21:23,417 --> 00:21:25,252
可以让你能够


436
00:21:25,319 --> 00:21:27,120
在你的工作区中直观的看到它


437
00:21:27,754 --> 00:21:31,124
所以你无需编写任何代码


438
00:21:31,491 --> 00:21:33,227
就能够对这49个属性进行调整和改变


439
00:21:33,293 --> 00:21:34,995
也无需重建你的游戏


440
00:21:35,863 --> 00:21:37,865
这些粒子将作为一个
很小的数据文件导出


441
00:21:37,931 --> 00:21:39,800
并能够被序列化


442
00:21:40,133 --> 00:21:44,671
也能够部署在多个等级或者多个项目中


443
00:21:47,841 --> 00:21:50,177
SpriteKit同样支持
Quick Look.


444
00:21:50,377 --> 00:21:53,180
例如 我正在努力学习新的Swift


445
00:21:53,680 --> 00:21:56,617
我创建了一个全新的场景


446
00:21:56,850 --> 00:21:59,987
并努力地在
SpriteKit API中使用


447
00:22:00,053 --> 00:22:01,688
全新的Swift 2.0语言


448
00:22:03,724 --> 00:22:06,593
我正在做的事情就是创建一个坏蛋角色


449
00:22:07,261 --> 00:22:09,162
就叫坏人 这是一个Sprite节点


450
00:22:09,329 --> 00:22:12,232
它是一个叫做车罩的
单独纹理复制出来的


451
00:22:13,200 --> 00:22:15,702
另外 我创建两个子节点 


452
00:22:15,769 --> 00:22:18,839
在这个坏人节点之下


453
00:22:18,906 --> 00:22:21,175
一个有屋顶的纹理


454
00:22:21,675 --> 00:22:23,610
另一个有树干的纹理


455
00:22:24,711 --> 00:22:25,712
这里会发生什么呢？


456
00:22:26,180 --> 00:22:29,249
SpriteKit的部分屏幕中将
会呈现这些看不见的东西


457
00:22:29,316 --> 00:22:31,151
当你努力去


458
00:22:31,218 --> 00:22:32,753
内观一个Sprite节点的时候


459
00:22:33,086 --> 00:22:36,256
它会将结果为你呈现在窗口中


460
00:22:36,323 --> 00:22:39,493
这样 你试着学习一个新的语言或者


461
00:22:39,560 --> 00:22:42,396
更改一个对象的每一步都会呈现出来


462
00:22:42,796 --> 00:22:45,599
你将会在窗口中看到实时的变化


463
00:22:47,534 --> 00:22:49,002
另外SpriteKit中
的Quicklook


464
00:22:49,369 --> 00:22:50,737
同样支持


465
00:22:50,804 --> 00:22:52,539
在你调试程序的时候


466
00:22:52,606 --> 00:22:54,274
无论你是使用Swift


467
00:22:54,842 --> 00:22:56,143
还是Objective-C


468
00:22:56,210 --> 00:22:57,978
无论他们是在IOS设备上运行


469
00:22:58,278 --> 00:22:59,580
还是在Mac OS X上运行


470
00:23:00,447 --> 00:23:03,951
这里我想试着去调试一个我写的程序


471
00:23:05,052 --> 00:23:06,353
我触发了一个断点


472
00:23:06,420 --> 00:23:08,856
目标过程其实停止了 


473
00:23:09,223 --> 00:23:10,591
但是我们仍然能够


474
00:23:10,958 --> 00:23:14,094
隐藏这部分显示
并呈现出目前的纹理


475
00:23:14,695 --> 00:23:15,929
并在调试器中显示出来


476
00:23:16,363 --> 00:23:18,432
所以你能够清楚地知道


477
00:23:18,498 --> 00:23:20,767
这个纹理是我之前调试的


478
00:23:20,834 --> 00:23:23,403
并将它抓取出来分配给了
一个SKSpriteNode


479
00:23:26,440 --> 00:23:29,743
去年 IOS
8中我们发布了一个虚拟场景编辑器


480
00:23:29,810 --> 00:23:32,813
他允许你建立一个完整的场景布局


481
00:23:32,880 --> 00:23:34,114
并不需要编写任何代码


482
00:23:38,018 --> 00:23:41,588
你不仅可以设置场景中每一个


483
00:23:41,655 --> 00:23:43,991
可选节点的位置 旋转和尺度


484
00:23:44,391 --> 00:23:47,761
你同样可以定义其物理属性例如


485
00:23:47,828 --> 00:23:51,498
图片 重力 质量和摩擦


486
00:23:53,166 --> 00:23:55,769
你也可以进行这些物理仿真的


487
00:23:56,203 --> 00:23:59,072
实时模拟


488
00:23:59,139 --> 00:24:01,642
而这些并不需要你登陆游戏
或者重新编译你的程序


489
00:24:03,110 --> 00:24:06,880
SpriteKit也将支持
一些先进的渲染技术


490
00:24:06,947 --> 00:24:08,081
例如自定义着色器等


491
00:24:08,782 --> 00:24:12,853
在这一层上 这个瀑布的背景和


492
00:24:12,920 --> 00:24:15,322
雾的底部实际上我使用了


493
00:24:15,389 --> 00:24:16,256
两个自定义着色器


494
00:24:16,723 --> 00:24:20,060
要添加着色器 


495
00:24:20,561 --> 00:24:22,829
他就像打开帮助编辑器一样简单


496
00:24:22,963 --> 00:24:25,065
它会自动在你的当前场景中显示出来


497
00:24:25,632 --> 00:24:27,601
当然这是渲染过后的


498
00:24:27,668 --> 00:24:30,070
并向你展示附有源代码的


499
00:24:30,137 --> 00:24:31,138
助理编辑器


500
00:24:31,538 --> 00:24:32,606
你在助理编辑器中


501
00:24:32,673 --> 00:24:34,208
所做的任何实时的修改


502
00:24:34,274 --> 00:24:35,909
都会自动进行编译


503
00:24:35,976 --> 00:24:38,011
打开OpenGL或者Metal


504
00:24:38,412 --> 00:24:41,648
会为你提供一个真正实时的视窗


505
00:24:42,015 --> 00:24:44,418
而不是都建整个游戏


506
00:24:44,952 --> 00:24:46,086
跨越整个层


507
00:24:46,587 --> 00:24:48,589
以及特定的节点


508
00:24:48,889 --> 00:24:52,359
触发这个事件来确定我是否真的发送了
一个流给OpenGL或者Metal


509
00:24:52,426 --> 00:24:54,294
无论是否编译成功


510
00:24:54,661 --> 00:24:56,396
这将节省很多迭代的时间


511
00:24:58,398 --> 00:25:00,901
今年我们花了大量的时间来


512
00:25:00,968 --> 00:25:02,569
对虚拟场景编辑器进行改进升级


513
00:25:02,636 --> 00:25:05,239
第一个请求的类型是自定义的


514
00:25:06,273 --> 00:25:09,710
现在 在我的英雄角色所处的这一层


515
00:25:10,344 --> 00:25:12,379
我可以将它指定为一个类


516
00:25:12,446 --> 00:25:14,615
这个类的名字叫做角色类


517
00:25:16,149 --> 00:25:18,652
当场景被反序列化运行时


518
00:25:19,019 --> 00:25:22,489
无论你的程序是用Objective
-C还是用Swift写的


519
00:25:23,957 --> 00:25:26,860
正确的类将会被创建并实例化


520
00:25:27,494 --> 00:25:30,998
并加载到场景中 在场景运行的时候


521
00:25:32,900 --> 00:25:34,434
另外


522
00:25:35,869 --> 00:25:38,505
从SKNodes项目开始的第一天起


523
00:25:38,572 --> 00:25:41,141
我们就一直忙于它的支撑工作


524
00:25:41,575 --> 00:25:44,077
现在你能够使用编辑其中的


525
00:25:44,144 --> 00:25:45,012
镜头节点


526
00:25:45,379 --> 00:25:46,647
音频节点定位 


527
00:25:47,014 --> 00:25:48,549
以及Referenc
eNode


528
00:25:48,615 --> 00:25:50,150
来设计你的场景


529
00:25:50,617 --> 00:25:53,453
能够在编辑器中看到镜头发送


530
00:25:53,520 --> 00:25:55,989
准确的时间轴、缩放因子


531
00:25:56,056 --> 00:25:57,391
以及动作


532
00:25:57,457 --> 00:25:59,092
而并不需要


533
00:25:59,927 --> 00:26:01,528
编译整个游戏是多么酷炫的一件事


534
00:26:02,095 --> 00:26:03,363
你也可以


535
00:26:03,430 --> 00:26:06,200
设置SKAudioNode的位置


536
00:26:06,700 --> 00:26:08,302
并将之移动


537
00:26:08,368 --> 00:26:10,304
来亲自听实时的音效变化


538
00:26:11,104 --> 00:26:14,174
以确定你在场景中
想要的效果是否设置正确


539
00:26:16,710 --> 00:26:20,013
今年 前端工具中最激动人心的功能是


540
00:26:20,080 --> 00:26:21,348
能够设计


541
00:26:21,415 --> 00:26:23,083
复杂的动作


542
00:26:23,951 --> 00:26:26,653
你可以通过基础构建模块


543
00:26:27,054 --> 00:26:28,789
设计出一个非常复杂的动作


544
00:26:28,856 --> 00:26:32,192
我们已经将其作为SpriteKit
的动作部分提供给了大家


545
00:26:33,961 --> 00:26:35,629
它是基于时间线的


546
00:26:36,129 --> 00:26:39,633
和Xcode中的其他编辑器一样


547
00:26:40,133 --> 00:26:42,369
他也支持实时可视化


548
00:26:43,370 --> 00:26:44,905
你不仅可以


549
00:26:44,972 --> 00:26:47,107
用它来开发2D动作


550
00:26:47,808 --> 00:26:50,110
也可以用来为
SceneKit设计3D动画


551
00:26:50,277 --> 00:26:52,713
都是同样的编辑器


552
00:26:53,814 --> 00:26:56,216
你也可以创建电影动画


553
00:26:56,750 --> 00:26:59,553
电影动画可以作为场景动画的一部分


554
00:26:59,620 --> 00:27:02,623
当场景加载的时候
任何包含这种动作的节点


555
00:27:02,689 --> 00:27:05,325
都会自动运行起来


556
00:27:06,627 --> 00:27:09,596
你也可以创建交互式动画


557
00:27:10,063 --> 00:27:11,365
例如循环动画


558
00:27:11,698 --> 00:27:14,535
或者跳转动画
从窗台掉落


559
00:27:15,636 --> 00:27:19,006
通过一行或两行代码出发折叠动画


560
00:27:19,940 --> 00:27:21,375
在不同的游戏场景中


561
00:27:25,546 --> 00:27:27,181
这里有一个场景


562
00:27:27,247 --> 00:27:28,916
我将镜头设计为移动的


563
00:27:28,982 --> 00:27:30,384
现在锁定游戏角色


564
00:27:30,450 --> 00:27:32,052
角色开始运动


565
00:27:32,119 --> 00:27:33,654
运行行走动作循环


566
00:27:33,720 --> 00:27:35,656
穿越整个场景 这就是开场


567
00:27:35,722 --> 00:27:38,625
你也可以在五分钟之完成这些


568
00:27:42,529 --> 00:27:45,432
今年2D和3D的前端工具中


569
00:27:45,499 --> 00:27:48,035
另一个主要关注点就是


570
00:27:48,101 --> 00:27:50,537
能够做引用和实例化


571
00:27:51,438 --> 00:27:53,307
在SpriteKit上


572
00:27:53,373 --> 00:27:56,643
一直是支持对动作或节点的引用


573
00:27:56,944 --> 00:28:00,280
这些都是你场景中的艺术资源


574
00:28:01,381 --> 00:28:03,050
这些都是可重复使用的组件


575
00:28:03,150 --> 00:28:05,385
这些都是数据文件


576
00:28:05,652 --> 00:28:07,621
能够在不同的工程中


577
00:28:07,888 --> 00:28:10,057
不同的人之间 不同的层次上共享


578
00:28:10,924 --> 00:28:12,359
在使用这些引用文件时


579
00:28:12,426 --> 00:28:14,127
你不需要写任何代码


580
00:28:16,930 --> 00:28:19,399
创建引用动画非常简单


581
00:28:19,733 --> 00:28:24,171
我们在Xcode中提供一种
全新的SK动作文件模板


582
00:28:24,238 --> 00:28:27,074
你可以打包一个纯粹的动画文件


583
00:28:27,474 --> 00:28:30,143
设计好所有的复杂的动画


584
00:28:30,210 --> 00:28:31,144
将之命名


585
00:28:31,478 --> 00:28:34,781
使这些动作可以
被SKAction检索


586
00:28:34,848 --> 00:28:36,550
使用actionNamed选择器


587
00:28:37,017 --> 00:28:39,253
创建正确的实例
并将之添加到你的场景中


588
00:28:40,020 --> 00:28:44,224
任何引用的动作
都将会被自动筛选出来


589
00:28:44,291 --> 00:28:46,226
放到一个对象库中


590
00:28:46,360 --> 00:28:48,629
如果你想在不同的场景中


591
00:28:48,695 --> 00:28:50,931
或者不同的层中


592
00:28:50,998 --> 00:28:54,034
再次使用这些动作 这只是一个


593
00:28:54,101 --> 00:28:55,169
从对象库中拖放的问题


594
00:28:56,770 --> 00:28:59,406
创建一个引用节点也很简单


595
00:29:00,807 --> 00:29:04,211
就像在你的工作区中拖一个SKS文件


596
00:29:04,278 --> 00:29:06,680
放到你的场景中一样简单


597
00:29:07,681 --> 00:29:08,882
对于这些引用


598
00:29:08,949 --> 00:29:10,551
我们会自动在编辑器中


599
00:29:10,617 --> 00:29:12,553
生成SKReferenceNode
实例


600
00:29:12,786 --> 00:29:14,621
并为你分配合适的URL


601
00:29:16,223 --> 00:29:19,893
你同样可以使用API创建
一个自定义节点收藏夹


602
00:29:20,394 --> 00:29:22,629
例如 我有一个鸟笼


603
00:29:22,696 --> 00:29:24,231
我打算用它作为一个


604
00:29:24,298 --> 00:29:26,633
不同的层之间的层道具


605
00:29:26,700 --> 00:29:28,802
我可以在多个层之间建立起来


606
00:29:28,869 --> 00:29:31,305
并将其实例化


607
00:29:31,371 --> 00:29:33,941
任何对鸟笼原设计的修改


608
00:29:34,007 --> 00:29:36,443
都会被自动地反映到


609
00:29:36,510 --> 00:29:39,146
每一个引用了这个设计的实例中


610
00:29:42,115 --> 00:29:45,619
这样你就能够在编辑器中手动地


611
00:29:45,686 --> 00:29:48,522
修改和更新引用文件了


612
00:29:50,757 --> 00:29:54,928
接下来
我想邀请泰勒上台来给大家


613
00:29:55,062 --> 00:29:56,964
演示一下Xcode中的这些新功能


614
00:30:03,136 --> 00:30:04,004
谢谢你诺曼


615
00:30:04,071 --> 00:30:04,905
就像你看到的那样


616
00:30:04,972 --> 00:30:07,941
我们为SpriteKit和
Xcode 7增加了很多优秀的功能


617
00:30:08,008 --> 00:30:09,543
我想通过展示一个简单地例子向


618
00:30:09,610 --> 00:30:12,112
你们展示它们是如何
在你的开发流中集成工作的


619
00:30:12,179 --> 00:30:15,249
这个例子展示了创建一个简单的层
添加场景


620
00:30:15,582 --> 00:30:17,351
创建一些互动的游戏等内容


621
00:30:22,189 --> 00:30:25,459
好的
看这里 我刚刚创建了一个游戏工程


622
00:30:25,526 --> 00:30:28,529
我在这个工程中添加了一个层


623
00:30:28,595 --> 00:30:31,565
我们创建了一些平台和一个角色


624
00:30:32,065 --> 00:30:35,669
我想做的第一件事就是在其中创建环境


625
00:30:35,903 --> 00:30:39,072
添加一些背景和前景元素


626
00:30:39,640 --> 00:30:42,409
放在从前
我会直接在场景中做这些事情


627
00:30:42,476 --> 00:30:45,512
然后一个个复制我所需要的实例


628
00:30:45,913 --> 00:30:48,615
如果我需要修改一些东西的话
这很快就会变得非常麻烦


629
00:30:48,682 --> 00:30:51,018
因为我需要对非常多不同的点进行修改


630
00:30:51,318 --> 00:30:52,519
并且很难重复使用


631
00:30:52,586 --> 00:30:54,388
现在我们用
ReferenceNode


632
00:30:54,454 --> 00:30:55,522
解决了这个问题


633
00:30:56,190 --> 00:30:58,659
所以在这里我创建了我的环境中


634
00:30:58,725 --> 00:31:00,861
所需要的所有的元素并
将其放在单独的文件中


635
00:31:01,094 --> 00:31:03,564
这样我就得到了一个有瀑布的背景


636
00:31:03,630 --> 00:31:05,632
和一个有雾气效果的前景


637
00:31:06,400 --> 00:31:08,101
引用这些内容文件所需要进行的操作


638
00:31:08,168 --> 00:31:10,838
就是将其拖放到我的层中


639
00:31:11,238 --> 00:31:13,373
现在 我们自动创建一个


640
00:31:13,574 --> 00:31:16,276
包含所有元素的Reference
Node你会注意到


641
00:31:16,343 --> 00:31:18,745
前景的Z值被保留了下来


642
00:31:18,812 --> 00:31:20,447
当我们将它添加到我的场景中的时候


643
00:31:21,215 --> 00:31:23,684
接下来创建一些复制来填充起来这一层


644
00:31:23,750 --> 00:31:26,653
你会注意到
我复制了ReferenceNode


645
00:31:26,720 --> 00:31:28,322
其本身


646
00:31:28,589 --> 00:31:31,191
而不是我所引用的场景中的


647
00:31:31,325 --> 00:31:33,260
单独的元素


648
00:31:33,894 --> 00:31:37,297
这在我之后的工程中会显得很棒


649
00:31:37,598 --> 00:31:39,900
例如 当我想要跟换背景纹理时


650
00:31:39,967 --> 00:31:41,168
因为它并不是特别合适


651
00:31:41,235 --> 00:31:43,003
我做的这个平台 


652
00:31:43,070 --> 00:31:45,772
我不需要改变我现有的三个实例


653
00:31:46,139 --> 00:31:48,141
我可以打开我单独的资源


654
00:31:48,475 --> 00:31:50,677
只需要做一次修改


655
00:31:51,512 --> 00:31:53,213
改动的地方就会自动送给所有的实例


656
00:31:53,280 --> 00:31:55,249
在这个层中


657
00:32:01,154 --> 00:32:01,989
接下来


658
00:32:02,055 --> 00:32:03,790
我想在我的层中创建一个跳转场景


659
00:32:03,857 --> 00:32:07,060
我会使用我们刚才介绍的


660
00:32:07,261 --> 00:32:08,195
新的动作编辑器来做


661
00:32:08,562 --> 00:32:10,764
放在从前 你只能在代码中创建动作


662
00:32:10,831 --> 00:32:13,467
这非常不容易看到


663
00:32:13,534 --> 00:32:16,637
所以我们想要开发一中编辑器
能够很容易的创建复杂的动作


664
00:32:16,703 --> 00:32:19,072
并给你实时的


665
00:32:19,139 --> 00:32:20,140
你正在创建的图像信息


666
00:32:20,774 --> 00:32:22,309
访问动作编辑器


667
00:32:22,376 --> 00:32:23,944
你可以点击左下角的按钮


668
00:32:24,011 --> 00:32:26,246
你会看到显示出来


669
00:32:26,313 --> 00:32:29,082
你的场景中的所有节点以及时间轴


670
00:32:29,149 --> 00:32:30,884
其中包含所有的动作


671
00:32:31,251 --> 00:32:33,353
我们能够看到我们的角色
已经有了一个动作


672
00:32:33,420 --> 00:32:35,122
这是一个由纹理动作组成的动画


673
00:32:35,656 --> 00:32:37,357
我们将它放在一个空闲的帧内


674
00:32:37,491 --> 00:32:38,759
现在点击播放


675
00:32:39,026 --> 00:32:41,862
我们可以看到我们的角色
在我们的场景中


676
00:32:42,162 --> 00:32:42,996
动了起来


677
00:32:43,964 --> 00:32:46,300
接下来
在我们的层中创建一个跳转场景


678
00:32:46,366 --> 00:32:49,269
我们准备让角色穿过这一层


679
00:32:50,103 --> 00:32:51,939
要做到这些


680
00:32:52,005 --> 00:32:54,174
我们需要过滤出来
我们的玩家互动编辑器和


681
00:32:54,975 --> 00:32:57,511
我们的对象库中的动作


682
00:32:57,711 --> 00:33:01,215
我们为你提供了一组动作构件


683
00:33:01,281 --> 00:33:02,983
可以用来创建更加复杂的动作


684
00:33:03,050 --> 00:33:04,651
这正是我接下来要做到的事情


685
00:33:05,052 --> 00:33:07,054
我们首先添加一个移动的动作


686
00:33:07,120 --> 00:33:08,155
到我们的跳转场景中


687
00:33:08,222 --> 00:33:10,958
我需要做的所有事情就是拖放
从对象库拖放到时间轴中


688
00:33:11,992 --> 00:33:13,260
现在对于这个运动


689
00:33:13,327 --> 00:33:16,196
我们可以看到在X方向上有850个单
位组成


690
00:33:16,263 --> 00:33:18,165
我们想要将这个动作做得更缓慢更自然


691
00:33:18,565 --> 00:33:20,033
现在点击这个播放


692
00:33:20,100 --> 00:33:22,236
我们可以看到我们的角色是这样跑的


693
00:33:22,569 --> 00:33:24,605
这有点快
所以我们需要修改持续的时间


694
00:33:24,671 --> 00:33:27,441
将这个动作拖长大概2秒


695
00:33:27,741 --> 00:33:29,276
我想要调整一下时间轴


696
00:33:29,843 --> 00:33:30,777
所以现在运行一下


697
00:33:30,844 --> 00:33:32,513
这时的运动就有了一个更合理的速率


698
00:33:33,780 --> 00:33:37,251
现在我想让角色
在穿越屏幕的时候跑起来


699
00:33:37,317 --> 00:33:39,520
所以我要添加一个带有纹理动作的动画


700
00:33:40,320 --> 00:33:42,823
要定义我们准备使用的动画


701
00:33:42,990 --> 00:33:45,359
我可以打开媒体库


702
00:33:45,425 --> 00:33:46,760
过滤下来我们的奔跑的框架


703
00:33:47,327 --> 00:33:49,897
我可以选择之后将其简单地
拖动到我们的运动中


704
00:33:50,397 --> 00:33:51,298
现在我们运行一下


705
00:33:52,332 --> 00:33:55,002
可以看到角色将会做这个动作


706
00:33:55,402 --> 00:33:58,005
当然 如果我们只使用一次的话


707
00:33:58,071 --> 00:34:00,407
我们可以添加一个循环


708
00:34:00,474 --> 00:34:01,475
这样就能在其移动的整个
时间段中持续下来


709
00:34:01,542 --> 00:34:03,844
我可以点击角落里的
这个循环按钮创建一个循环


710
00:34:03,911 --> 00:34:05,212
我能够看到


711
00:34:05,279 --> 00:34:06,647
循环的所有控制参数


712
00:34:06,947 --> 00:34:10,350
我可以增加迭代的次数 


713
00:34:10,417 --> 00:34:11,784
也可以减少 也可以自定义循环


714
00:34:12,186 --> 00:34:14,454
在这个例子中我想要让它循环两次


715
00:34:14,521 --> 00:34:16,822
接下来我将调整一下持续时间
来适应我们的运动过程


716
00:34:17,024 --> 00:34:19,426
现在我们就得到了我们的角色
跑着穿越整个场景的动画


717
00:34:20,360 --> 00:34:22,862
接下来 我们在层中添加两个沟


718
00:34:22,929 --> 00:34:24,565
让这个角色跳过它们


719
00:34:24,630 --> 00:34:30,003
在动作编辑器中我们可以
定向清除我们动作中的时间点


720
00:34:30,070 --> 00:34:33,806
在刚刚到达沟的旁边的时候
我可以清除掉


721
00:34:33,940 --> 00:34:35,876
然后添加一个其他的动作


722
00:34:36,342 --> 00:34:38,045
我们可以正好对齐我们刚才擦除的地方


723
00:34:39,913 --> 00:34:43,350
对于这个移动
我们会在Y轴方向移动100个单位


724
00:34:43,417 --> 00:34:44,885
我将其设置成缓慢输出


725
00:34:45,351 --> 00:34:47,688
这样在到达我们跳跃的顶部的时候
角色的动作会变慢


726
00:34:48,422 --> 00:34:51,225
在到达沟的中间的时候
我会再做一次擦除


727
00:34:51,291 --> 00:34:53,360
调整一下持续时间 使角色能够在


728
00:34:53,427 --> 00:34:56,063
达到最高点的时候刚好到达沟的中间


729
00:34:56,797 --> 00:35:00,734
然后复制我们动作的第一部分
然后翻转


730
00:35:00,901 --> 00:35:02,903
得到一个完整的跳跃运动


731
00:35:03,871 --> 00:35:05,405
跳跃的最后一步


732
00:35:05,472 --> 00:35:07,741
我准备再创建一个动画


733
00:35:07,808 --> 00:35:11,011
包含跳跃的构架


734
00:35:11,078 --> 00:35:14,081
同样的方法
打开媒体库 过滤下来我们的跳跃构架


735
00:35:14,147 --> 00:35:15,282
添加到动作中


736
00:35:16,316 --> 00:35:18,919
现在我们的角色就能够
从第一个沟上面跳过去


737
00:35:20,354 --> 00:35:23,257
当然 我们还有一个沟


738
00:35:23,323 --> 00:35:25,826
我需要做的就是复制我刚刚添加的动作


739
00:35:25,893 --> 00:35:28,629
然后替换
但是接下来我们会碰到同样的问题


740
00:35:28,695 --> 00:35:31,031
那就是在地图上的哪里进行修改


741
00:35:31,098 --> 00:35:33,767
我将要对每一个复制的实例进行修改


742
00:35:34,101 --> 00:35:37,037
很可能我会在不同的层中


743
00:35:37,104 --> 00:35:38,005
重复使用这些动作


744
00:35:38,071 --> 00:35:39,740
甚至可能在不同的工程中


745
00:35:40,374 --> 00:35:41,875
我们用同样的方式解决了这个问题


746
00:35:41,942 --> 00:35:44,077
就是允许你引用运动


747
00:35:44,411 --> 00:35:46,647
我们在Xcode中引入一个新文件


748
00:35:46,813 --> 00:35:48,615
这是一个
SpriteKit动作文件夹


749
00:35:49,416 --> 00:35:51,251
这个文件夹中放了一些动作文件


750
00:35:51,318 --> 00:35:53,086
这些动作文件的名字


751
00:35:53,153 --> 00:35:55,822
你可以在场景、工程或者代码中
全局引用


752
00:35:56,290 --> 00:35:57,824
接下来 选定动作文件  


753
00:35:58,225 --> 00:36:00,594
创建一个这样的文件夹


754
00:36:00,661 --> 00:36:01,762
并将其转换成引用的形式


755
00:36:02,162 --> 00:36:04,798
我准备给它命名 将其命名为跳跃


756
00:36:05,232 --> 00:36:07,367
我们可以选择一个动作文件夹放进去


757
00:36:07,434 --> 00:36:09,336
在这个例子中
我会新建一个新的文件夹


758
00:36:10,871 --> 00:36:13,674
我给这个文件夹命名为角色动作


759
00:36:13,740 --> 00:36:16,376
因为我打算将所有的跟角色有关的动作
都放进这个文件夹


760
00:36:17,911 --> 00:36:19,479
将这个文件添加到我们的工程


761
00:36:19,546 --> 00:36:21,982
现在你会看到我们创建的这些动作


762
00:36:22,049 --> 00:36:24,418
例如跳跃已经在跳跃文件夹的下面了


763
00:36:24,818 --> 00:36:25,919
并且在我们的场景中


764
00:36:26,620 --> 00:36:28,622
我们可以引用
这些动作


765
00:36:29,690 --> 00:36:31,225
现在你放到这个文件夹中的动作


766
00:36:31,291 --> 00:36:33,360
已经完全从所有的场景
或者工程中独立了出来


767
00:36:33,427 --> 00:36:35,195
但是在一些场景中某些背景下


768
00:36:35,262 --> 00:36:36,897
你经常会想要修改他们


769
00:36:37,431 --> 00:36:39,533
我们允许你设置一个预览窗口


770
00:36:39,600 --> 00:36:42,469
你可以分配你文件夹中的任何动作
在你的场景中的任何节点


771
00:36:42,536 --> 00:36:45,372
例如我可以在这个场景中的任何节点预
览我 的跳跃动作


772
00:36:45,572 --> 00:36:46,874
或者打开一个自己的场景


773
00:36:46,940 --> 00:36:48,709
在角色的不同角度


774
00:36:48,976 --> 00:36:51,979
例如 我可以预览角色左边或者


775
00:36:52,045 --> 00:36:55,115
右边跳跃动作是怎样的


776
00:36:56,984 --> 00:36:59,119
所以现在 在这里 我们继续 


777
00:36:59,186 --> 00:37:02,623
回到擦除第二个沟的地方 在对象库中


778
00:37:02,689 --> 00:37:04,391
我们可以用可以引用的动作


779
00:37:04,458 --> 00:37:05,792
自动填充进去


780
00:37:05,893 --> 00:37:08,929
因为我刚才创建的跳跃动作


781
00:37:08,996 --> 00:37:11,565
已经自动放在了对象库中
我就能够将它拖放进去


782
00:37:11,899 --> 00:37:14,101
现在我们就完成了我们的跳转场景
让我们欣赏一下


783
00:37:16,937 --> 00:37:17,838
看起来很棒


784
00:37:18,372 --> 00:37:20,607
现在我想向你展示一下
怎样在代码中使用


785
00:37:20,674 --> 00:37:23,143
而不仅仅是一个跳转场景


786
00:37:23,844 --> 00:37:26,446
我想要做的就是在每一个角色
可能存在的地图中


787
00:37:26,513 --> 00:37:29,983
都创建一个动作 然后通过代码引用它


788
00:37:31,051 --> 00:37:33,654
我要创建一个引用


789
00:37:33,720 --> 00:37:35,355
这个可引用的动作叫跑


790
00:37:35,489 --> 00:37:36,523
其中包含我们动画


791
00:37:37,090 --> 00:37:38,992
我也同样对对空文件这么处理


792
00:37:41,061 --> 00:37:42,129
现在开始 删除这些


793
00:37:42,196 --> 00:37:44,364
因为现在我们要把这些做成交互式的


794
00:37:44,698 --> 00:37:45,933
现在你可以看到


795
00:37:45,999 --> 00:37:48,101
我们的动作文件夹中


796
00:37:48,168 --> 00:37:50,270
包含了三个地图


797
00:37:50,671 --> 00:37:52,573
现在通过代码使用这些动作


798
00:37:52,639 --> 00:37:54,641
你所要做的就是使用
我们刚才介绍的新选择器


799
00:37:54,975 --> 00:37:57,010
动作名称选择器 


800
00:37:57,077 --> 00:37:58,946
给它们提供我们刚刚创建的动作的名称


801
00:37:59,279 --> 00:38:00,981
空 跑 和跳跃


802
00:38:01,682 --> 00:38:04,451
现在当我运行我们的游戏时


803
00:38:04,518 --> 00:38:07,354
你能够看到我刚才创建的动作
现在正在游戏中使用着


804
00:38:08,188 --> 00:38:09,022
交互式的


805
00:38:09,857 --> 00:38:11,792
这一点最强大的地方在于


806
00:38:11,859 --> 00:38:12,960
当你想要修改你的动作时


807
00:38:13,026 --> 00:38:14,928
我可以直接打开动作文件夹


808
00:38:14,995 --> 00:38:18,065
例如 让角色在跳跃的时候翻个筋斗


809
00:38:18,131 --> 00:38:22,636
我可以打开这里
然后添加一个旋转的动作到跳跃上


810
00:38:23,337 --> 00:38:26,406
给它赋值负360 缓进缓出


811
00:38:27,007 --> 00:38:30,143
现在我们不编译就运行我们的游戏


812
00:38:30,544 --> 00:38:32,212
我们可以看到发生了改变


813
00:38:32,279 --> 00:38:33,981
我刚做的修改已经提交给了角色


814
00:38:41,154 --> 00:38:42,723
现在这一层看起来已经很棒了


815
00:38:42,789 --> 00:38:45,225
所以最后要做的事情就是
创建一个漂亮的电影动画开场


816
00:38:45,325 --> 00:38:47,060
将角色引入到这一层


817
00:38:47,494 --> 00:38:51,698
我可以通过创建一个SKCamera
Node到场景中的方式实现


818
00:38:52,199 --> 00:38:54,968
让我们在镜头节点中
定义一个Viewport


819
00:38:55,135 --> 00:38:57,104
我们可以开始使用我刚添加的镜头


820
00:38:57,304 --> 00:38:59,306
来分配我们的场景


821
00:39:00,174 --> 00:39:02,643
作为电影动画开场
我想用从这个角落开始


822
00:39:02,709 --> 00:39:05,512
使用镜头放大


823
00:39:10,450 --> 00:39:12,252
我准备放大这里的雾气


824
00:39:12,719 --> 00:39:15,389
最棒的是
因为这只是一个SKNode 


825
00:39:15,455 --> 00:39:16,590
我可以向镜头中添加动作


826
00:39:17,191 --> 00:39:19,159
过滤下来适应我们的镜头


827
00:39:20,260 --> 00:39:21,929
之后添加一个有两个动作的移动


828
00:39:22,262 --> 00:39:24,698
我准备要做的电影动画开场


829
00:39:24,765 --> 00:39:26,433
就是讲镜头平移到这一层的中心


830
00:39:26,600 --> 00:39:28,001
同时缩放


831
00:39:28,535 --> 00:39:30,571
第二步我将要把X轴的值


832
00:39:30,637 --> 00:39:33,841
设置为507
作为中 心


833
00:39:35,042 --> 00:39:37,177
同时将Y轴的值设置为
384个单位并作为中心


834
00:39:37,244 --> 00:39:39,513
并将这些设置为


835
00:39:39,580 --> 00:39:40,881
缓进缓出


836
00:39:41,782 --> 00:39:44,184
我打算在我们打开我们的场景半秒钟后


837
00:39:44,251 --> 00:39:46,019
开始移动我们的动画


838
00:39:46,086 --> 00:39:48,455
并耗时3秒将其平移过去


839
00:39:48,922 --> 00:39:52,893
同样我添加了第二个动作
并给其半秒钟从我们的动画中抵消


840
00:39:52,960 --> 00:39:57,631
在动画结束后同时结束


841
00:39:58,031 --> 00:39:59,333
现在 在短短时间内


842
00:39:59,399 --> 00:40:01,001
我们创建了一个电影动画式的开场


843
00:40:01,134 --> 00:40:02,236
我们也已经结束了这一层


844
00:40:02,402 --> 00:40:04,004
接下来让我们看一下它现在什么样子


845
00:40:11,879 --> 00:40:14,481
这就是你现在可以使用
SpriteKit和Xcode 7


846
00:40:14,581 --> 00:40:16,917
做的事情了


847
00:40:23,657 --> 00:40:25,292
与此同时 我想将话题重新交给提姆


848
00:40:25,392 --> 00:40:27,961
让它来为你们总结一下


849
00:40:29,396 --> 00:40:30,564
谢谢泰勒


850
00:40:30,664 --> 00:40:32,266
这真的是一个非常棒的工作


851
00:40:32,666 --> 00:40:35,335
我相信大家有目共睹


852
00:40:35,402 --> 00:40:37,237
这对于SpriteKit工程师来讲


853
00:40:37,304 --> 00:40:38,472
将会是超级棒的一年


854
00:40:38,772 --> 00:40:41,675
我们新增了AudioNode,
也新增了CameraNode


855
00:40:41,742 --> 00:40:43,243
我们也有了可以引用的动作和节点


856
00:40:43,510 --> 00:40:45,345
也有了一个全新的


857
00:40:45,412 --> 00:40:47,548
基于运动编辑器的
集成在Xcode中的时间轴


858
00:40:47,781 --> 00:40:50,851
我们整合了纹理地图集和资源目录


859
00:40:50,918 --> 00:40:52,619
并给你提供了新的功能


860
00:40:52,853 --> 00:40:55,088
例如基于命令的资源库
和更加简洁的App


861
00:40:55,656 --> 00:40:59,059
同时也使SpriteKit适配
所有的支持Metal的设备


862
00:40:59,126 --> 00:41:01,962
让你能够更容易地访问


863
00:41:02,095 --> 00:41:03,830
全新的GamePlayKit构架


864
00:41:06,300 --> 00:41:08,101
如果你需要更多的信息


865
00:41:08,168 --> 00:41:09,837
请访问我们的开发者网站


866
00:41:09,903 --> 00:41:11,138
或者拨打咨询电话


867
00:41:11,271 --> 00:41:13,774
联系我们的图形专家Allan
Schaffer 


868
00:41:15,342 --> 00:41:16,543
还有几个与之相关的会议


869
00:41:16,610 --> 00:41:18,212
如果你想对GamePlayKit


870
00:41:18,278 --> 00:41:19,880
或者SceneKit了解更多的话


871
00:41:21,014 --> 00:41:22,749
我们也有一些实验室


872
00:41:22,850 --> 00:41:24,585
第一个就是SpriteKit实验室


873
00:41:24,651 --> 00:41:25,786
现在马上就会启动


874
00:41:26,053 --> 00:41:28,689
大家放松 跟我们一起下楼


875
00:41:28,755 --> 00:41:30,390
我们将很乐意回答你们的所有问题


876
00:41:31,091 --> 00:41:32,960
非常感谢
请享受您的会议

