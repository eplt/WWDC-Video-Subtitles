1
00:00:06,516 --> 00:00:17,500
[ Music ]


2
00:00:24,456 --> 00:00:24,976
>> Good morning.


3
00:00:25,516 --> 00:00:29,356
[ Applause ]


4
00:00:29,856 --> 00:00:33,356
Welcome to What's New in Swift.


5
00:00:33,356 --> 00:00:35,626
Let's start out by
talking about the goals


6
00:00:35,626 --> 00:00:37,206
for the Swift 3 release.


7
00:00:37,366 --> 00:00:41,456
Swift was released as an open
source project just six months


8
00:00:41,456 --> 00:00:44,826
ago, and a big part of doing
that was not just to shove


9
00:00:44,826 --> 00:00:46,526
out a bunch of sources
to GitHub,


10
00:00:46,526 --> 00:00:49,766
but to create a fully
open community


11
00:00:50,316 --> 00:00:53,286
that drives the evolution
of Swift going forward.


12
00:00:54,126 --> 00:00:58,136
Swift 3 is the first major
update to Swift that is intended


13
00:00:58,136 --> 00:01:02,006
to be a product of that
community, and so we'll talk


14
00:01:02,006 --> 00:01:05,016
about how that community has
evolved and the language,


15
00:01:05,096 --> 00:01:06,476
the evolution process


16
00:01:06,806 --> 00:01:09,416
that crafts the language going
forward, and Chris will talk


17
00:01:09,416 --> 00:01:14,556
about what that community
has produced for Swift 3.


18
00:01:14,766 --> 00:01:18,686
Another big aspect for this
release was bringing Swift


19
00:01:18,686 --> 00:01:19,696
to more people.


20
00:01:20,526 --> 00:01:23,556
Today's software
ecosystems are really diverse


21
00:01:23,596 --> 00:01:25,576
and people are doing a
lot of different things


22
00:01:25,996 --> 00:01:28,086
in different contexts,
whether they are building it


23
00:01:28,086 --> 00:01:31,086
for the server, they are
building apps, and others.


24
00:01:31,136 --> 00:01:34,436
We want Swift to be available
for everybody, and so we'll talk


25
00:01:34,436 --> 00:01:38,526
about some great things that
have happened on the Linux side.


26
00:01:38,526 --> 00:01:41,446
And this is really the
first major update to Swift


27
00:01:41,626 --> 00:01:43,626
since Swift was ported to Linux.


28
00:01:44,776 --> 00:01:49,346
Now, looking inward at the
release, Swift has been going


29
00:01:49,346 --> 00:01:51,466
through some iterate
refinement and sculpting


30
00:01:51,606 --> 00:01:55,156
over the last two releases,
based a lot from feedback


31
00:01:55,156 --> 00:01:58,926
from developers who are using
it, and also, as you'll see


32
00:01:58,926 --> 00:02:01,486
from the Swift community
since it was open sourced.


33
00:02:02,186 --> 00:02:04,226
A big thing about Swift
3 is we really want


34
00:02:04,226 --> 00:02:07,396
to get those core fundamentals
into shape, all right,


35
00:02:07,396 --> 00:02:10,205
so we can really build on
top of them going forward.


36
00:02:11,416 --> 00:02:15,176
And last, and probably the most
broadest goal, is we really want


37
00:02:15,176 --> 00:02:17,796
to awesomize Swift
for awesomeness.


38
00:02:17,796 --> 00:02:18,246
All right?


39
00:02:19,156 --> 00:02:22,566
Swift is really intended to
be a powerful tool in the hand


40
00:02:22,596 --> 00:02:25,816
of developers, and in their
hands they can do really


41
00:02:25,816 --> 00:02:26,756
amazing things.


42
00:02:27,296 --> 00:02:28,536
That's what we intended
it to be.


43
00:02:29,496 --> 00:02:31,796
Now, this is a really
kind of broad goal,


44
00:02:32,066 --> 00:02:35,306
and the way we've been directing
our efforts here is listening


45
00:02:35,306 --> 00:02:38,096
to feedback from those
using Swift, app developers,


46
00:02:38,636 --> 00:02:41,456
but also how we're
using it within Apple.


47
00:02:42,186 --> 00:02:43,416
And so I want to
talk a few minutes


48
00:02:43,416 --> 00:02:45,196
about how we've been
using Swift, particularly


49
00:02:45,276 --> 00:02:48,556
in the last year in our
OS releases and the tools.


50
00:02:49,856 --> 00:02:52,506
Now, the big thing here is it's
not just increased adoption


51
00:02:52,506 --> 00:02:54,936
at Apple; it's just we're
using Swift in a variety


52
00:02:54,936 --> 00:02:57,886
of different ways, whether
it's in writing apps,


53
00:02:57,996 --> 00:03:00,386
we have internal frameworks
that are now using Swift,


54
00:03:00,386 --> 00:03:02,146
Agents and Daemons,
things that just kind


55
00:03:02,146 --> 00:03:04,516
of power the underlying
experiences


56
00:03:04,846 --> 00:03:06,156
in the operating system.


57
00:03:06,756 --> 00:03:09,986
And so if you can look, you
know, to Sierra, iOS 10,


58
00:03:09,986 --> 00:03:13,796
you can see things like the New
Music app using a significant


59
00:03:13,796 --> 00:03:14,996
amount of Swift.


60
00:03:14,996 --> 00:03:18,676
The Console app in Sierra
which is very much tied


61
00:03:18,676 --> 00:03:25,396
to the new logging initiatives,
also has a lot of use of Swift.


62
00:03:25,396 --> 00:03:27,156
Also with the Agents and
Daemons, the new picture


63
00:03:27,156 --> 00:03:31,616
in picture feature in Sierra is
100 percent written in Swift.


64
00:03:32,666 --> 00:03:35,826
Now, looking to the Tools,
Xcode, if you look inside,


65
00:03:36,066 --> 00:03:37,336
it's using Swift as well.


66
00:03:37,496 --> 00:03:39,496
For example, the new
documentation viewer


67
00:03:39,496 --> 00:03:41,936
in Xcode 8 is 100
percent written in Swift.


68
00:03:42,526 --> 00:03:45,406
And the new beautiful
Swift Playgrounds for iOS,


69
00:03:45,896 --> 00:03:47,766
that's 100 percent
written in Swift as well.


70
00:03:48,636 --> 00:03:52,286
So we are really using Swift
in many different ways.


71
00:03:52,346 --> 00:03:56,306
And this is really focusing our
efforts to solve different kinds


72
00:03:56,306 --> 00:03:58,266
of problems, whether
it's performance issues,


73
00:03:58,266 --> 00:04:01,886
such as memory usage, getting
the calling conventions right,


74
00:04:02,066 --> 00:04:03,356
and so forth, and
just making sure


75
00:04:03,356 --> 00:04:06,726
that Swift is the right
tool in different contexts.


76
00:04:07,046 --> 00:04:09,806
I want to talk about a
particular case study,


77
00:04:09,926 --> 00:04:11,376
and that's the Dock.


78
00:04:12,326 --> 00:04:15,056
And the Dock is interesting
for two reasons.


79
00:04:16,406 --> 00:04:19,296
The first reason is it's a
lot more than people think.


80
00:04:19,296 --> 00:04:23,086
It's not just the bar at
the bottom of your desktop.


81
00:04:23,526 --> 00:04:26,746
It's actually a large amount
of the macOS Windows, you know,


82
00:04:26,746 --> 00:04:27,966
management experience.


83
00:04:28,456 --> 00:04:31,976
So things like Mission
Control, LaunchPad, Spaces,


84
00:04:31,976 --> 00:04:34,816
this is all what we
consider part of the Dock.


85
00:04:36,166 --> 00:04:38,906
The second reason why Dock is
interesting is it's actually


86
00:04:38,906 --> 00:04:40,556
been a Swift adopter
for two releases.


87
00:04:40,556 --> 00:04:43,176
It started adopting
Swift in El Capitan.


88
00:04:43,176 --> 00:04:45,586
So we have two releases
to look at and to compare


89
00:04:45,586 --> 00:04:46,696
in how it was using Swift.


90
00:04:47,606 --> 00:04:51,396
So a lot of changes happened
to the Dock in Sierra.


91
00:04:52,506 --> 00:04:56,576
First, almost all of Mission
Control was rewritten in Swift,


92
00:04:56,576 --> 00:04:58,956
and the accessibility engine
was rewritten in Swift.


93
00:04:59,516 --> 00:05:00,306
Why did we do this?


94
00:05:00,306 --> 00:05:03,186
We just didn't rewrite code just
for the sake of rewriting code.


95
00:05:03,756 --> 00:05:06,206
The code had kind of grown
organically over time


96
00:05:06,206 --> 00:05:09,146
as features had been added and
it was time to refactor it.


97
00:05:09,616 --> 00:05:12,256
But also some new functionality
needed to be implemented,


98
00:05:12,256 --> 00:05:15,606
and so it was the
appropriate time to make this,


99
00:05:15,606 --> 00:05:16,836
you know, to do this rewrite.


100
00:05:18,116 --> 00:05:20,626
Now, what does this look
like at the project level?


101
00:05:21,486 --> 00:05:25,296
So to give you an idea, Dock
is about 200,000 lines of code


102
00:05:26,186 --> 00:05:29,966
with tens of thousands of
lines written in Swift.


103
00:05:29,966 --> 00:05:34,676
And between El Capitan and
Sierra, the amount of Swift code


104
00:05:34,676 --> 00:05:36,286
in the project more
than doubled.


105
00:05:37,596 --> 00:05:39,616
And this actually, because
this is part of a rewrite,


106
00:05:40,176 --> 00:05:42,236
this replaced a significant
amount


107
00:05:42,236 --> 00:05:43,716
of C and Objective-C code.


108
00:05:45,456 --> 00:05:47,726
And the effects here
are somewhat non-linear,


109
00:05:48,146 --> 00:05:49,346
because there's some refactoring


110
00:05:49,346 --> 00:05:52,036
and some new features being
added, but we saw there was


111
00:05:52,036 --> 00:05:55,166
about 15 percent less code
to replace the existing C


112
00:05:55,166 --> 00:05:57,766
and Objective-C code in Swift,


113
00:05:57,766 --> 00:06:00,786
and this is with new features
being added at the same time.


114
00:06:01,686 --> 00:06:05,286
And the net result is this
project is actually slightly


115
00:06:05,286 --> 00:06:08,786
smaller in Sierra than
it was in El Capitan.


116
00:06:10,136 --> 00:06:13,186
Now, there's a lot you
can read into statistics.


117
00:06:13,646 --> 00:06:16,526
I think the most important thing
here is the engineers working


118
00:06:16,526 --> 00:06:18,826
on the Dock love using Swift.


119
00:06:19,416 --> 00:06:20,796
They are not mandated to use it.


120
00:06:21,166 --> 00:06:21,866
They volunteered.


121
00:06:22,106 --> 00:06:25,506
They really just
wanted to use Swift.


122
00:06:25,506 --> 00:06:27,656
And their experience
is that they feel


123
00:06:28,066 --> 00:06:30,036
that they can more
easily articulate the code


124
00:06:30,036 --> 00:06:32,576
that they want to write and
they love the safety features


125
00:06:32,576 --> 00:06:34,366
from Swift that gives
them more assurance


126
00:06:34,366 --> 00:06:35,806
that the code they
write is great.


127
00:06:36,406 --> 00:06:39,786
Let's move on to
Swift Open Source.


128
00:06:40,356 --> 00:06:42,426
If you haven't already,
the place to go


129
00:06:42,426 --> 00:06:44,466
on the web is swift.org.


130
00:06:45,196 --> 00:06:48,106
And there you can find a variety
of ways that you can contribute


131
00:06:48,106 --> 00:06:50,056
to the project, such
as if you want


132
00:06:50,056 --> 00:06:52,016
to do the most awesome
profession in the world


133
00:06:52,016 --> 00:06:54,656
and be a compiler hacker, you
can check out the source code


134
00:06:54,656 --> 00:06:56,186
and find ways to contribute.


135
00:06:56,486 --> 00:06:58,676
And there's other ways.


136
00:06:58,976 --> 00:07:01,026
You know, you can contribute
ideas, where do we want


137
00:07:01,026 --> 00:07:02,516
to take the Swift language?


138
00:07:04,476 --> 00:07:07,716
Now, how we run the
project is really important.


139
00:07:08,426 --> 00:07:10,536
It's meant to be
very egalitarian.


140
00:07:11,116 --> 00:07:14,916
We want it to be a very
open process and transparent


141
00:07:15,106 --> 00:07:18,786
and free, and everyone
can really participate


142
00:07:19,066 --> 00:07:20,376
in driving the language forward.


143
00:07:20,626 --> 00:07:23,686
And they can see the rationale
of why changes were made.


144
00:07:24,286 --> 00:07:25,236
This is really important.


145
00:07:25,646 --> 00:07:28,196
And so all changes to language,
whether you are somebody


146
00:07:28,196 --> 00:07:31,096
who works at Apple or
you're someone out there


147
00:07:31,096 --> 00:07:33,706
who is writing apps and you have
an idea of how to contribute


148
00:07:33,816 --> 00:07:36,316
to change Swift, it works
exactly the same way.


149
00:07:36,316 --> 00:07:38,586
And I think this is
really, really important.


150
00:07:39,116 --> 00:07:43,026
And it also means that non-Apple
engineers do have direct access,


151
00:07:43,026 --> 00:07:45,036
you know, to commit
to the compiler


152
00:07:45,036 --> 00:07:46,346
and all those repositories.


153
00:07:46,716 --> 00:07:48,996
And so we really wanted
to empower the community


154
00:07:49,336 --> 00:07:50,426
to drive Swift forward.


155
00:07:50,906 --> 00:07:53,506
Third, and I think this
is just as important,


156
00:07:53,886 --> 00:07:56,186
we have a very strong code
of conduct for the project,


157
00:07:56,466 --> 00:07:59,576
and we think it's very important
that everyone can contribute


158
00:07:59,576 --> 00:08:02,546
without feeling that they are
discriminated against or treated


159
00:08:02,546 --> 00:08:05,626
in an unprofessional manner, and
we enforce this very strongly.


160
00:08:06,956 --> 00:08:11,836
And last, the project is under a
Permissive Open Source License.


161
00:08:12,326 --> 00:08:14,286
This is really important,
because we want Swift to be used


162
00:08:14,286 --> 00:08:17,066
in ways that Apple
didn't conceive.


163
00:08:17,296 --> 00:08:20,166
This is one of the goals
of open sourcing Swift.


164
00:08:20,166 --> 00:08:23,886
We really want everyone to be
able to use it in a lot of ways.


165
00:08:24,456 --> 00:08:26,466
And there's strong
patent protection


166
00:08:26,636 --> 00:08:27,896
for the community as well.


167
00:08:28,146 --> 00:08:29,726
So that's why we
chose this license.


168
00:08:31,196 --> 00:08:35,126
Now, you can follow along
with top of, you know,


169
00:08:35,686 --> 00:08:37,666
Trunk Development for
Swift in a variety of ways.


170
00:08:37,666 --> 00:08:38,706
You can check out the sources.


171
00:08:38,706 --> 00:08:39,606
You can build the compiler.


172
00:08:40,635 --> 00:08:43,206
We also provide downloadable
snapshots regularly,


173
00:08:43,206 --> 00:08:46,186
that you can download from
Swift or you can use directly


174
00:08:46,186 --> 00:08:48,476
in Xcode, or you can
use them on Linux.


175
00:08:48,476 --> 00:08:50,386
And as other platforms
are supported,


176
00:08:50,386 --> 00:08:52,786
we will provide those
snapshots as well.


177
00:08:53,686 --> 00:08:54,476
What's really awesome


178
00:08:54,476 --> 00:08:57,076
in an Xcode 8 is we now have
full support for Playgrounds


179
00:08:57,076 --> 00:08:58,836
with these downloadable
snapshots,


180
00:08:59,186 --> 00:09:01,656
which is a really
awesome way to experiment


181
00:09:01,656 --> 00:09:03,356
with the language as it evolves.


182
00:09:03,726 --> 00:09:06,066
Also, you no longer have to
restart Xcode if you want


183
00:09:06,066 --> 00:09:07,226
to use one of these tool chains,


184
00:09:07,226 --> 00:09:10,976
so this really creates a really
clean experience with trying


185
00:09:10,976 --> 00:09:12,886
out the latest version of Swift.


186
00:09:13,436 --> 00:09:17,266
Now, all the development
is happening now on GitHub,


187
00:09:17,916 --> 00:09:20,036
and it's not just one project.


188
00:09:20,036 --> 00:09:22,616
It's actually a family
of repositories,


189
00:09:22,616 --> 00:09:25,176
and you can find a description
of all of them on swift.org,


190
00:09:25,176 --> 00:09:27,816
but they can roughly
be categorized


191
00:09:27,816 --> 00:09:31,816
into these three
sections, the Language


192
00:09:31,816 --> 00:09:34,956
and its evolution
process, a Package Manager,


193
00:09:35,496 --> 00:09:36,786
and a set of Core Libraries.


194
00:09:37,116 --> 00:09:38,216
Let me talk about each.


195
00:09:39,816 --> 00:09:41,966
Now, the Package
Manager was announced


196
00:09:42,126 --> 00:09:43,716
when Swift went Open Source.


197
00:09:44,356 --> 00:09:47,286
It's still very early but
active in development.


198
00:09:47,286 --> 00:09:50,906
There's over 1,000
repositories on GitHub


199
00:09:51,156 --> 00:09:52,626
that use the Package Manager.


200
00:09:52,966 --> 00:09:54,406
So what is this?


201
00:09:55,446 --> 00:09:58,836
It's a cross-platform, Package
Manager, for building, you know,


202
00:09:58,836 --> 00:10:00,846
packages for Linux, for 0S 10.


203
00:10:01,216 --> 00:10:04,436
The idea is that we want to
build, enable the community


204
00:10:04,436 --> 00:10:07,216
to build, a software
ecosystem for Swift.


205
00:10:07,216 --> 00:10:09,196
And we think this is really
vital for bringing Swift


206
00:10:09,196 --> 00:10:11,656
to other contexts, like
Swift on the server.


207
00:10:13,526 --> 00:10:15,866
It's designed for very
frictionless development.


208
00:10:15,866 --> 00:10:19,216
It's like easy to get
started, minimal configuration,


209
00:10:19,626 --> 00:10:21,436
easy to articulate
your dependencies.


210
00:10:21,606 --> 00:10:24,196
It's just -- the idea is
just write your code and go.


211
00:10:24,246 --> 00:10:30,276
And we think the Package Manager
is so fundamental to Swift


212
00:10:30,326 --> 00:10:33,166
and its long-term success
that we are committed


213
00:10:33,166 --> 00:10:34,916
to delivering fantastic
integration


214
00:10:34,916 --> 00:10:37,646
of the Package Manager
in Xcode as it matures.


215
00:10:38,186 --> 00:10:43,286
Let's talk about
the Core Libraries.


216
00:10:43,606 --> 00:10:44,236
So what are these?


217
00:10:45,666 --> 00:10:48,656
There's a lot of
great APIs in iOS,


218
00:10:48,656 --> 00:10:51,646
in macOS, TD OS, and WatchOS.


219
00:10:52,236 --> 00:10:55,336
A lot of these are like part
of the base substrate of APIs


220
00:10:55,336 --> 00:10:56,576
that we think should
be available


221
00:10:56,576 --> 00:10:58,356
for everyone to get work done.


222
00:10:59,226 --> 00:11:02,076
And so the Core Libraries
represent alternate


223
00:11:02,196 --> 00:11:05,236
implementations that aren't
tied to the Objective-C run time


224
00:11:05,706 --> 00:11:09,546
of some of these core APIs on
Linux, and also other platforms


225
00:11:09,546 --> 00:11:13,836
that Swift will be ported to, so
notable examples include things


226
00:11:13,836 --> 00:11:16,406
like XE tests, so you
can write unit tests,


227
00:11:17,076 --> 00:11:20,236
a subset of foundation that
really is quite portable


228
00:11:20,236 --> 00:11:23,756
and not really tied to Cocoa,
and a work in progress port


229
00:11:23,756 --> 00:11:26,766
of libdispatch so you can use
all those concurrency APIs.


230
00:11:27,206 --> 00:11:29,896
Now, the work here is
still fairly early.


231
00:11:29,896 --> 00:11:31,216
It launched with
Swift Open Source,


232
00:11:31,366 --> 00:11:32,666
but there's a lot
there right now.


233
00:11:33,016 --> 00:11:36,456
So for foundation on Linux,
it supports a lot a great APIs


234
00:11:36,456 --> 00:11:41,736
like manipulating URLs, dates,
there's data, UID, and so forth.


235
00:11:41,956 --> 00:11:45,936
And we expect this to mature
and possibly grow in the future


236
00:11:45,936 --> 00:11:49,686
over time as the community
wants more functionality.


237
00:11:50,266 --> 00:11:55,036
Now, let's talk about
the Language.


238
00:11:55,886 --> 00:11:56,756
Now, Chris will talk a lot


239
00:11:56,756 --> 00:11:58,496
about specific changes
in the language.


240
00:11:58,796 --> 00:12:00,486
I want to talk about
the evolution process


241
00:12:00,716 --> 00:12:01,976
that creates those changes.


242
00:12:02,616 --> 00:12:05,376
This happens out on the
Swift-evolution repository.


243
00:12:06,396 --> 00:12:10,156
So let's say you have an idea
of how you want to change Swift.


244
00:12:10,156 --> 00:12:11,996
Like you think there's
something in there that sucks


245
00:12:11,996 --> 00:12:14,896
and some problem there
that really gets in the way


246
00:12:15,256 --> 00:12:16,186
of doing core development.


247
00:12:16,186 --> 00:12:18,346
Maybe it was a good design
decision two years ago,


248
00:12:18,346 --> 00:12:19,846
but it should be revisited.


249
00:12:20,406 --> 00:12:23,876
Or maybe there's something
great that we should add


250
00:12:24,256 --> 00:12:25,996
that would enable
a whole new set


251
00:12:25,996 --> 00:12:27,876
of opportunities for developers.


252
00:12:28,246 --> 00:12:28,826
Doesn't matter.


253
00:12:29,326 --> 00:12:31,356
You start the idea
by socializing it


254
00:12:31,456 --> 00:12:34,626
on a mailing list, kicking it
around with other developers


255
00:12:34,676 --> 00:12:37,096
who have similar
interests, and see,


256
00:12:37,126 --> 00:12:38,846
you know, is this a good idea?


257
00:12:39,286 --> 00:12:40,736
What are the pros and cons here?


258
00:12:41,006 --> 00:12:43,436
And once there's
enough critical mass,


259
00:12:44,256 --> 00:12:46,096
it gets turned into a proposal.


260
00:12:46,726 --> 00:12:48,626
This is just essentially
like a white paper,


261
00:12:49,116 --> 00:12:52,356
written in markdown, which
can be viewed, you know,


262
00:12:52,356 --> 00:12:54,196
right in a web browser
on GitHub.


263
00:12:54,896 --> 00:12:57,896
And here's an example of
actually one of the proposals,


264
00:12:58,786 --> 00:13:01,926
and it gets submitted for
review via pull request.


265
00:13:02,776 --> 00:13:05,626
Now, you notice in the bottom
left corner here this badge


266
00:13:05,626 --> 00:13:07,766
number, it says SE0046.


267
00:13:08,766 --> 00:13:11,496
Each proposal is numbered,
and this is how we refer to,


268
00:13:11,496 --> 00:13:13,376
you know, the actual
specific proposals


269
00:13:13,376 --> 00:13:15,456
that created change in Swift.


270
00:13:15,826 --> 00:13:19,086
Chris will refer to these
proposals throughout his part


271
00:13:19,086 --> 00:13:21,316
of the talk when he talks about
the changes to the language.


272
00:13:22,356 --> 00:13:26,896
And these proposals are the way
that everybody proposes changes


273
00:13:26,896 --> 00:13:29,146
to the language,
proposes the rationale


274
00:13:29,146 --> 00:13:31,746
of why we're doing
the change, you know,


275
00:13:32,836 --> 00:13:36,656
what the specific change
would be, the pros and cons,


276
00:13:37,056 --> 00:13:38,816
and once the proposal
is accepted,


277
00:13:39,006 --> 00:13:40,826
the rationale for accepting it.


278
00:13:41,916 --> 00:13:45,356
So a formal review for
a proposal starts just


279
00:13:45,356 --> 00:13:47,556
by accepting it into
the repository,


280
00:13:47,856 --> 00:13:51,356
and the review is really just
-- it's open discussion again.


281
00:13:51,356 --> 00:13:53,686
It's on the mailing list,
but this time it's focused


282
00:13:53,976 --> 00:13:55,476
to the specific proposal
as written,


283
00:13:55,476 --> 00:13:56,886
not just some abstract idea.


284
00:13:56,966 --> 00:14:01,126
And after some period of
time, the Swift core team,


285
00:14:01,126 --> 00:14:03,186
which is a small set of
individuals, whose role is just


286
00:14:03,186 --> 00:14:05,546
to shepherd the project going
forward, looks at the feedback


287
00:14:05,546 --> 00:14:08,926
of the community, sees, you
know, the pros and the cons,


288
00:14:09,376 --> 00:14:13,456
and arbitrates a decision based
on what the community wants.


289
00:14:13,836 --> 00:14:15,016
And they look at a
variety of things.


290
00:14:15,016 --> 00:14:17,926
How does the current
proposal fit into Swift?


291
00:14:18,346 --> 00:14:19,136
So does it make sense?


292
00:14:19,136 --> 00:14:21,166
So sometimes proposals are
sent back, hey, you know,


293
00:14:21,166 --> 00:14:24,376
the way it currently is, this
just doesn't work, you know,


294
00:14:24,376 --> 00:14:27,246
so go back and consider
some refinements here.


295
00:14:27,606 --> 00:14:29,426
Or this will just never
fit in Swift at all.


296
00:14:29,426 --> 00:14:32,916
But also the proposals
are often accepted,


297
00:14:33,406 --> 00:14:34,616
sometimes with refinements.


298
00:14:34,896 --> 00:14:37,046
And any time it's
sent back or accepted,


299
00:14:37,806 --> 00:14:39,156
a rationale is documented.


300
00:14:39,156 --> 00:14:41,036
So everyone can look
back at the history


301
00:14:41,276 --> 00:14:44,076
of the language evolution and
understand what was proposed


302
00:14:44,076 --> 00:14:47,796
and why it was proposed and why
it was accepted or rejected.


303
00:14:47,796 --> 00:14:52,186
And you can go and see all
the proposals just by going


304
00:14:52,186 --> 00:14:54,336
to the Swift-evolution
repository.


305
00:14:54,646 --> 00:14:57,116
And this is the process
that created Swift 3,


306
00:14:57,116 --> 00:14:59,446
a process driven by everyone.


307
00:14:59,896 --> 00:15:02,316
And to talk more about
what that has produced,


308
00:15:02,316 --> 00:15:03,976
I'm going to hand
it over to Chris.


309
00:15:04,516 --> 00:15:09,556
[ Applause ]


310
00:15:10,056 --> 00:15:12,276
>> Thank you, Ted.


311
00:15:12,276 --> 00:15:13,836
Well, with everything
else going on,


312
00:15:13,836 --> 00:15:15,286
unfortunately I didn't have time


313
00:15:15,286 --> 00:15:17,166
to prepare notes
and slides for you.


314
00:15:17,166 --> 00:15:19,086
But I printed out
all the proposals


315
00:15:19,086 --> 00:15:20,166
and I thought I'd
read them to you now.


316
00:15:20,916 --> 00:15:21,506
Sound good?


317
00:15:23,466 --> 00:15:23,956
[Laughter] Maybe not.


318
00:15:25,406 --> 00:15:26,556
So what are we trying
to do here?


319
00:15:27,476 --> 00:15:29,026
We said before that we want


320
00:15:29,026 --> 00:15:30,526
to make the core
experience of Swift great.


321
00:15:30,526 --> 00:15:32,246
And that isn't just
about the language.


322
00:15:32,366 --> 00:15:34,946
That's also the standard
library, the experience


323
00:15:34,946 --> 00:15:37,066
of working with major
APIs like Cocoa,


324
00:15:37,446 --> 00:15:39,096
and also working with our tools.


325
00:15:39,096 --> 00:15:41,156
And so we'll go through and talk
about each of these in turn.


326
00:15:42,216 --> 00:15:44,936
Now, our number one goal for
Swift 3 is source compatibility.


327
00:15:45,216 --> 00:15:46,646
And that's a big goal.


328
00:15:46,706 --> 00:15:49,496
That means we want to look at
what kind of code you write


329
00:15:49,496 --> 00:15:51,396
in your applications
and make sure


330
00:15:51,396 --> 00:15:52,866
that when Swift 3 comes out,


331
00:15:52,866 --> 00:15:54,906
that's the right
way going forward.


332
00:15:55,466 --> 00:15:57,616
And this is actually
a really hard problem,


333
00:15:57,616 --> 00:16:01,296
because this isn't just a
matter of do we use commas


334
00:16:01,296 --> 00:16:03,796
or do we use colons,
that kind of stuff.


335
00:16:04,106 --> 00:16:07,276
It's also about real key APIs
and doing everything possible


336
00:16:07,276 --> 00:16:09,416
to get Swift 3 into that
shape so that we can live


337
00:16:09,416 --> 00:16:11,356
with it forever and
get the churn


338
00:16:11,356 --> 00:16:12,606
out from underneath
you over with.


339
00:16:13,666 --> 00:16:16,246
Now, there's a number of
different aspects of this,


340
00:16:16,246 --> 00:16:17,746
one of which is that we're
going to incorporate this


341
00:16:17,746 --> 00:16:19,506
into the Swift-evolution
proposal process


342
00:16:19,506 --> 00:16:22,146
that Ted discussed before, so
that any proposals that come


343
00:16:22,146 --> 00:16:25,876
in after Swift 3 really think
about source compatibility.


344
00:16:26,856 --> 00:16:30,236
Now, I think the biggest aspect,
the biggest change in Swift 3


345
00:16:30,236 --> 00:16:31,536
that affects the
code that we write


346
00:16:31,536 --> 00:16:33,386
on a daily basis is the APIs.


347
00:16:33,386 --> 00:16:36,316
And so let's dive
into API naming


348
00:16:36,316 --> 00:16:38,066
and just get a quick
taste of what's going on.


349
00:16:39,166 --> 00:16:43,386
So APIs are an essential
part of how Apple thinks


350
00:16:43,386 --> 00:16:46,916
about building its platform in
building out the key components


351
00:16:46,916 --> 00:16:48,526
that you all work
with and you build


352
00:16:48,526 --> 00:16:49,936
on to make great applications.


353
00:16:50,476 --> 00:16:53,146
And the naming rules, and
the design approaches that go


354
00:16:53,146 --> 00:16:55,596
into that shape them in
a really fundamental way.


355
00:16:56,446 --> 00:16:57,826
And so with Swift 3, we looked


356
00:16:57,826 --> 00:17:00,676
at what is the best way
to write these APIs?


357
00:17:00,866 --> 00:17:02,736
Do we want full verbosity?


358
00:17:02,826 --> 00:17:06,146
Do we want full terseness and
like the smallest code possible?


359
00:17:06,756 --> 00:17:08,506
And what we found
is that the thing


360
00:17:08,506 --> 00:17:10,226
that really matters is clarity.


361
00:17:10,396 --> 00:17:11,955
And clarity at the point of use.


362
00:17:12,286 --> 00:17:13,695
And so we've really optimized


363
00:17:13,695 --> 00:17:15,996
for capturing the essential
important information


364
00:17:16,175 --> 00:17:18,616
without encoding lots of
boilerplate into APIs.


365
00:17:19,406 --> 00:17:22,276
Now, let's dive into a couple of
examples, and I'll show you some


366
00:17:22,276 --> 00:17:23,806
of the thought process
and rationale


367
00:17:23,806 --> 00:17:25,236
for what this means in practice.


368
00:17:26,026 --> 00:17:28,656
So here are a couple
of APIs in Swift 2.


369
00:17:29,576 --> 00:17:31,956
We will start with array
and append contents of.


370
00:17:32,406 --> 00:17:34,746
With Swift 3, this
gets chopped in half.


371
00:17:35,406 --> 00:17:38,896
The verb append, the
operation is now the operation.


372
00:17:39,386 --> 00:17:42,126
Contents of is something
that describes the role


373
00:17:42,126 --> 00:17:43,286
of the parameter you pass in.


374
00:17:43,536 --> 00:17:45,706
Now it's an argument
label that gets passed


375
00:17:46,086 --> 00:17:47,756
or gets used at the call site.


376
00:17:48,066 --> 00:17:49,626
This makes it a lot more
clear what's happening.


377
00:17:50,506 --> 00:17:54,016
Inserted index, this was
already in the proper verb form,


378
00:17:54,276 --> 00:17:57,706
but that index didn't add
any extra information.


379
00:17:57,896 --> 00:17:59,806
It was just repeating
type information


380
00:17:59,806 --> 00:18:01,126
that would be better
to be left off.


381
00:18:02,276 --> 00:18:05,266
In foundation, let's
look at NSURL.


382
00:18:05,646 --> 00:18:09,236
It has a file URL method or
property, and just from looking


383
00:18:09,236 --> 00:18:11,056
at it, it's not clear
that it returns e-Bullion


384
00:18:11,296 --> 00:18:13,946
and so now it starts with
is making it really clear.


385
00:18:14,726 --> 00:18:17,886
Another simple example is URL
by pending path component,


386
00:18:18,366 --> 00:18:20,736
it just drops the
redundantly encoded return type


387
00:18:21,046 --> 00:18:22,066
because it's not necessary.


388
00:18:22,796 --> 00:18:24,956
And so there's a ton of
different improvements like this


389
00:18:25,436 --> 00:18:27,456
that all kind of
add up together,


390
00:18:27,786 --> 00:18:29,616
and there's a lot more
detail and talk coming


391
00:18:29,616 --> 00:18:31,056
up right after this at 10:00.


392
00:18:31,946 --> 00:18:35,136
Now, let's talk about
Objective-C and CAPIs


393
00:18:35,136 --> 00:18:36,566
and how they work in Swift.


394
00:18:36,566 --> 00:18:40,416
Because again, that's a key
piece of how the APIs you work


395
00:18:40,416 --> 00:18:42,646
with look and how you
experience them in Swift.


396
00:18:43,576 --> 00:18:45,106
We've done a number of
great improvements here,


397
00:18:45,106 --> 00:18:46,946
so one we call import is member.


398
00:18:47,576 --> 00:18:49,926
Here's a typical core
graphics API written in C.


399
00:18:50,796 --> 00:18:53,156
In Swift 2 it would come in as
this global function, right?


400
00:18:53,996 --> 00:18:57,026
Well, this works, but this isn't
the kind of API we want to work


401
00:18:57,026 --> 00:18:59,796
with as Swift developers, and so
we've introduced a new feature


402
00:18:59,796 --> 00:19:04,136
that allows the API author to
tag their API with this macro


403
00:19:04,136 --> 00:19:06,506
that wraps an attribute
and now gets imported


404
00:19:06,506 --> 00:19:08,836
as a method providing the
beautiful object-oriented APIs


405
00:19:08,836 --> 00:19:10,856
that you have seen in core
graphics and dispatch.


406
00:19:11,326 --> 00:19:13,276
This is something you
can use in your code too.


407
00:19:15,026 --> 00:19:17,046
Another is generics.


408
00:19:17,136 --> 00:19:19,616
We introduced lightweight
generics last year with Swift 2,


409
00:19:19,616 --> 00:19:23,046
and we used them to import
typed collections into Swift.


410
00:19:23,216 --> 00:19:25,086
But a number of frameworks


411
00:19:25,086 --> 00:19:27,436
at Apple adopted lightweight
generics in other ways;


412
00:19:27,436 --> 00:19:29,636
for example, auto
layout and core data.


413
00:19:29,756 --> 00:19:31,996
With Swift 3 we are now able


414
00:19:31,996 --> 00:19:37,126
to import the fully general
generics right into Swift 3


415
00:19:37,126 --> 00:19:40,166
as generic types, which
means that a lot of cast


416
00:19:40,166 --> 00:19:42,766
and redundant coding of that
type information now can just


417
00:19:42,766 --> 00:19:43,166
go away.


418
00:19:44,376 --> 00:19:45,316
Let's talk --


419
00:19:46,516 --> 00:19:51,616
[ Applause ]


420
00:19:52,116 --> 00:19:53,286
Let's talk about constants.


421
00:19:53,796 --> 00:19:55,236
A common pattern
that we see in a lot


422
00:19:55,236 --> 00:19:58,706
of Cocoa APIs are
using strings as enums.


423
00:19:59,276 --> 00:20:02,226
And we do this because
that's in C the best way


424
00:20:02,226 --> 00:20:06,456
that we could find to encode an
openly extensible enum concept,


425
00:20:06,456 --> 00:20:07,956
but there are a lot of
disadvantages with this.


426
00:20:08,836 --> 00:20:12,126
These "enums," in quotes,
become these global constants


427
00:20:12,556 --> 00:20:14,936
which then get imported
directly into Swift as globals


428
00:20:15,166 --> 00:20:16,826
and they get used with
these big long names.


429
00:20:17,156 --> 00:20:18,906
This is really unfortunate
for a lot of reasons,


430
00:20:18,906 --> 00:20:21,456
one of which is it's
completely not type safe


431
00:20:21,556 --> 00:20:23,086
because you can pass
an arbitrary string


432
00:20:23,086 --> 00:20:23,846
and it won't work.


433
00:20:23,936 --> 00:20:27,426
It's also not great because
it pollutes code completion


434
00:20:27,426 --> 00:20:31,126
and it just doesn't feel
like a very Swift API,


435
00:20:31,396 --> 00:20:34,186
very good direction
for Swift APIs.


436
00:20:35,026 --> 00:20:36,636
With Swift 3 we solved this.


437
00:20:37,016 --> 00:20:40,196
So now an API author can
add a simple attribute


438
00:20:40,276 --> 00:20:42,786
to their type def and now
all of the different uses


439
00:20:42,786 --> 00:20:44,746
of this become strongly
typed in Swift.


440
00:20:45,116 --> 00:20:46,906
So you'll find with
NS notification names,


441
00:20:46,906 --> 00:20:50,706
a commonly used one, that these
now become scoped underneath


442
00:20:50,966 --> 00:20:53,826
user defaults in this
case, and now they get used


443
00:20:53,826 --> 00:20:55,146
with proper dot syntax.


444
00:20:56,086 --> 00:20:58,786
And the great thing about this
is it's actually type checked.


445
00:20:59,516 --> 00:21:04,586ddle
[ Applause ]


446
00:20:59,516 --> 00:21:04,586
[ Applause ]


447
00:21:05,086 --> 00:21:05,586
So there are a ton


448
00:21:05,586 --> 00:21:07,816
of improvements throughout
the SDK adopting these


449
00:21:07,816 --> 00:21:09,836
and other features that you
can learn about all week long.


450
00:21:10,156 --> 00:21:11,786
There are a number of
great talks this week.


451
00:21:12,766 --> 00:21:14,756
Let's dive into the
core language.


452
00:21:15,996 --> 00:21:19,496
So with these changes
as context, we went back


453
00:21:19,496 --> 00:21:20,836
and looked at parameter labels.


454
00:21:20,986 --> 00:21:24,246
And as a quick refresher, if you
had this function in Swift 2,


455
00:21:24,666 --> 00:21:27,496
you'd call it and
you'd use labels on two


456
00:21:27,496 --> 00:21:28,956
out of the three parameters.


457
00:21:28,956 --> 00:21:29,546
Why is that?


458
00:21:30,186 --> 00:21:34,176
Well, the answer is that we were
following the Objective-C naming


459
00:21:34,176 --> 00:21:36,656
and design patterns and
we wanted to be consistent


460
00:21:36,656 --> 00:21:38,666
with Cocoa and the Cocoa
experience in Swift.


461
00:21:39,236 --> 00:21:41,666
But of course we've just
radically changed how Cocoa


462
00:21:41,666 --> 00:21:44,786
works in Swift, and so now we're
able to bring argument labels


463
00:21:44,786 --> 00:21:45,686
to all the parameters,


464
00:21:46,016 --> 00:21:48,626
which makes the language a lot
more consistent and predictable.


465
00:21:49,516 --> 00:21:54,266
[ Applause ]


466
00:21:54,766 --> 00:21:55,896
Let's talk about generics.


467
00:21:56,306 --> 00:21:58,656
So the Swift generic
syntax, I think,


468
00:21:58,656 --> 00:22:00,086
is really beautiful
and expressive.


469
00:22:00,086 --> 00:22:04,086
It allows you to capture the key
essence of what a function does


470
00:22:04,366 --> 00:22:06,366
in a very concise
and very nice way.


471
00:22:07,506 --> 00:22:08,736
Unfortunately, though,
when you get


472
00:22:08,736 --> 00:22:10,286
into more advanced use cases,


473
00:22:10,286 --> 00:22:11,866
you start adding
generic constraints,


474
00:22:12,206 --> 00:22:14,926
and the generic constraints are
almost secondary to the behavior


475
00:22:14,926 --> 00:22:17,616
of the function in this
case, but they push


476
00:22:17,616 --> 00:22:20,676
down the primary signature
way down into the code


477
00:22:20,676 --> 00:22:22,066
and it makes it a lot
more difficult to read.


478
00:22:22,636 --> 00:22:25,116
With Swift 3, we've extended
the syntax and improved this,


479
00:22:25,446 --> 00:22:27,646
so now your signature is
right up front where you want


480
00:22:27,646 --> 00:22:29,976
to see it and the constraints
are now secondary to that.


481
00:22:30,516 --> 00:22:34,586
[ Applause ]


482
00:22:35,086 --> 00:22:36,406
Let's talk about unused results.


483
00:22:36,986 --> 00:22:38,056
So here's a simple function.


484
00:22:38,056 --> 00:22:39,716
It just adds one to a
number and returns it.


485
00:22:40,346 --> 00:22:42,136
With Swift 2, you
wouldn't get a warning


486
00:22:42,136 --> 00:22:44,376
about this code even though
it's almost certainly a bug.


487
00:22:44,866 --> 00:22:46,636
Maybe you forgot to
assign it to a variable.


488
00:22:46,636 --> 00:22:48,936
Maybe you're just calling it
the completely wrong function.


489
00:22:49,346 --> 00:22:53,746
Right? So with Swift 3 you
get a warning by default.


490
00:22:53,746 --> 00:22:54,326
It's safe.


491
00:22:54,366 --> 00:22:54,896
This is great.


492
00:22:55,676 --> 00:22:59,226
And this is also really good
because it composes well


493
00:22:59,226 --> 00:23:00,896
for more complicated
cases as well.


494
00:23:01,486 --> 00:23:03,476
So not all functions
are pure like this


495
00:23:03,476 --> 00:23:04,476
in the functional sense.


496
00:23:04,516 --> 00:23:06,326
Some of them actually
do have side effects.


497
00:23:06,326 --> 00:23:07,306
We live in the real world.


498
00:23:08,186 --> 00:23:10,816
And so you may be wondering,
well, if I have a side effect,


499
00:23:10,816 --> 00:23:12,946
maybe I'm calling this
just for that side effect.


500
00:23:13,736 --> 00:23:16,416
Well, that's okay, because you
can assign to the underbar,


501
00:23:16,826 --> 00:23:19,946
which tells the compiler
and humans who have


502
00:23:19,946 --> 00:23:22,556
to maintain your code that
you thought about the fact


503
00:23:22,556 --> 00:23:23,686
that this returned something


504
00:23:23,896 --> 00:23:26,856
and you explicitly don't
care about it, right?


505
00:23:27,296 --> 00:23:30,076
Now, not all functions
have this property.


506
00:23:30,076 --> 00:23:32,186
Some functions, which are
kind of the exceptions,


507
00:23:32,696 --> 00:23:35,156
have a side effect as
their primary behavior,


508
00:23:35,296 --> 00:23:37,276
and so the return value
is a secondary thing


509
00:23:37,276 --> 00:23:38,566
that often you don't care about.


510
00:23:38,826 --> 00:23:40,236
And so in those exceptional
cases,


511
00:23:40,236 --> 00:23:42,226
you can actually use an
attribute to say, hey,


512
00:23:42,576 --> 00:23:44,686
I know that this return
value is a secondary thing,


513
00:23:44,806 --> 00:23:47,216
never produce a warning
if it goes unused,


514
00:23:47,516 --> 00:23:48,456
which is a nice system.


515
00:23:49,546 --> 00:23:55,586
So let's talk about the most
exciting piece of Swift 3,


516
00:23:56,046 --> 00:23:57,416
features that go away.


517
00:23:57,416 --> 00:23:59,996
And you may be saying why
would you do this, right?


518
00:24:00,556 --> 00:24:03,026
But we really want Swift
3 to be great, right?


519
00:24:03,376 --> 00:24:06,256
And Swift 3 is the sum
of all of its pieces,


520
00:24:06,256 --> 00:24:07,796
and many of the pieces were put


521
00:24:08,156 --> 00:24:11,196
into Swift before we really knew
what the language would build


522
00:24:11,196 --> 00:24:13,126
into and where we
wanted it to go.


523
00:24:13,426 --> 00:24:16,036
And so what we did was we went
back and thought about all


524
00:24:16,036 --> 00:24:17,086
of the features in the language,


525
00:24:17,086 --> 00:24:18,286
no matter when they
were introduced,


526
00:24:18,286 --> 00:24:19,566
and asked a basic question.


527
00:24:20,526 --> 00:24:24,186
If this feature were not already
in Swift, would we add it now?


528
00:24:25,626 --> 00:24:27,136
And for some features,
the answer was no,


529
00:24:27,246 --> 00:24:28,276
and so we're taking them away.


530
00:24:29,016 --> 00:24:31,266
And this is a great way,
this is a great thing to do,


531
00:24:31,266 --> 00:24:33,116
because it simplifies the
language for everybody.


532
00:24:34,006 --> 00:24:38,776
Now, some of these I realize may
be polarizing or controversial.


533
00:24:39,676 --> 00:24:41,656
The great thing about
Swift-evolution is


534
00:24:41,656 --> 00:24:43,216
that we debated these
all as a community.


535
00:24:43,636 --> 00:24:47,226
Each of these has a proposal
with extensive rationale,


536
00:24:47,576 --> 00:24:49,906
and if you really want to go
back and read the hundreds


537
00:24:49,906 --> 00:24:52,186
of emails on each of these,
you can totally go back


538
00:24:52,226 --> 00:24:54,386
to the mailing list archive
and see what happened.


539
00:24:54,896 --> 00:24:56,686
I think that pretty
much every side


540
00:24:56,686 --> 00:24:58,836
of every perspective was
very well represented


541
00:24:58,836 --> 00:24:59,946
on these issues.


542
00:25:01,106 --> 00:25:04,076
So now there are a bunch
of other small enhancements


543
00:25:04,076 --> 00:25:06,266
to language as well, and I
don't have time to go into all


544
00:25:06,266 --> 00:25:08,516
of them, but we have things
like generic type aliases.


545
00:25:08,826 --> 00:25:12,726
We have type safe selector
and key path references.


546
00:25:13,126 --> 00:25:15,426
We have new build
configurations, improvements


547
00:25:15,426 --> 00:25:17,256
to power matching, a
ton of great stuff,


548
00:25:17,446 --> 00:25:19,306
and you can read them about
them either in the proposals


549
00:25:19,306 --> 00:25:21,686
or in the extra release notes.


550
00:25:22,036 --> 00:25:24,676
Now another aspect of the
core language is talking


551
00:25:24,676 --> 00:25:26,726
about syntax, right?


552
00:25:27,196 --> 00:25:30,386
And I think we all love,
and I hope you love,


553
00:25:30,386 --> 00:25:33,186
the basic syntactic
structure of Swift.


554
00:25:33,316 --> 00:25:35,276
I think it's one of the things
that draws a lot of people in,


555
00:25:35,276 --> 00:25:37,896
because it feels familiar and
it works really well together.


556
00:25:38,526 --> 00:25:40,146
But unfortunately,
not all of the pieces


557
00:25:40,146 --> 00:25:45,766
in Swift were considered
with the care of the hot path


558
00:25:45,766 --> 00:25:47,826
of the syntactic
structures we use every day,


559
00:25:48,426 --> 00:25:49,176
and so we went back,


560
00:25:49,176 --> 00:25:51,586
and repainted everything
a nice consistent shade


561
00:25:51,586 --> 00:25:55,506
of your favorite color
here, and we looked at a lot


562
00:25:55,506 --> 00:25:58,626
of the weird corner cases,
because those corner cases,


563
00:25:58,626 --> 00:26:01,116
if they are inconsistent with
the rest of the language,


564
00:26:01,116 --> 00:26:04,466
it makes them even harder to
use, and these are included


565
00:26:04,466 --> 00:26:06,036
in the Swift because
they are important.


566
00:26:06,566 --> 00:26:09,076
And so we went back and
standardized everything,


567
00:26:09,076 --> 00:26:10,486
and we really want
to get it right,


568
00:26:10,486 --> 00:26:11,686
so it's right for the long time.


569
00:26:12,666 --> 00:26:15,176
So that's a brief overview
of the core language.


570
00:26:15,176 --> 00:26:16,646
I want to dive a little
bit deeper now and talk


571
00:26:16,646 --> 00:26:17,546
about the type system.


572
00:26:18,676 --> 00:26:20,556
First of all, what
is the type system?


573
00:26:21,126 --> 00:26:23,926
The type system in Swift works
together with the type checker


574
00:26:24,526 --> 00:26:27,116
to define how types work,
and the type checker


575
00:26:27,116 --> 00:26:28,886
and the compiler
uses the type system


576
00:26:28,886 --> 00:26:33,416
to prove your code is correct
or validate that it's correct,


577
00:26:33,676 --> 00:26:36,336
as well as infer things that
you leave out of your code


578
00:26:36,336 --> 00:26:37,606
because it's supposed
to be implicit.


579
00:26:37,666 --> 00:26:40,586
For example, what
is a type of A?


580
00:26:40,586 --> 00:26:42,706
Swift 3, we wanted to
simplify the type system,


581
00:26:42,706 --> 00:26:44,626
make it more consistent,
and we also wanted


582
00:26:44,626 --> 00:26:47,636
to define away common types
of problems that people run


583
00:26:47,636 --> 00:26:49,646
into that were surprising
and led to bugs.


584
00:26:50,276 --> 00:26:53,126
So let's talk about a
few examples of this.


585
00:26:53,126 --> 00:26:54,986
First is unsafe pointer, right?


586
00:26:56,096 --> 00:26:58,936
So I don't know if you realize
this but you can actually


587
00:26:59,116 --> 00:27:01,836
in Swift 2 assign nil
to an unsafe pointer.


588
00:27:02,026 --> 00:27:03,946
You can test it directly
for nil,


589
00:27:04,206 --> 00:27:06,006
and you can actually
use unsafe pointers


590
00:27:06,006 --> 00:27:08,316
without having any idea
whether they hold a nil or not.


591
00:27:08,966 --> 00:27:11,416
This is really inconsistent
with the rest of the language


592
00:27:11,416 --> 00:27:13,886
and it makes unsafe
pointers even more unsafe.


593
00:27:13,886 --> 00:27:17,726
Well, with Swift 3, now
unsafe pointers cannot be nil,


594
00:27:17,726 --> 00:27:20,416
so you use optionals, just like
everything else in the language.


595
00:27:20,816 --> 00:27:24,206
You get to use if let to safely
test them and unwrap them,


596
00:27:24,526 --> 00:27:27,566
and you even get all the
syntactic affordances we provide


597
00:27:27,566 --> 00:27:30,636
optionals, which makes
everything just work a lot


598
00:27:31,796 --> 00:27:33,486
more predictably.


599
00:27:33,486 --> 00:27:35,576
Speaking of optionals,
another interesting part


600
00:27:35,576 --> 00:27:37,966
of the language is
implicitly unwrapped optionals.


601
00:27:38,966 --> 00:27:41,066
Implicitly unwrapped optionals
are a really important part


602
00:27:41,066 --> 00:27:42,926
of the language, particularly
when you are working


603
00:27:42,926 --> 00:27:45,236
with two-phase initialization
or you are calling an API


604
00:27:45,236 --> 00:27:47,206
that hasn't been
audited for nullability.


605
00:27:47,716 --> 00:27:50,196
Now, here's an overly simplified
example where I have an int,


606
00:27:50,356 --> 00:27:52,406
implicitly unwrapped
optional that I'm getting in,


607
00:27:52,726 --> 00:27:54,286
but this applies more
generally to lots


608
00:27:54,286 --> 00:27:55,276
of different types of things.


609
00:27:56,176 --> 00:27:57,246
Now, the basic way


610
00:27:57,246 --> 00:27:59,186
that implicitly unwrapped
optionals worked in Swift 2,


611
00:27:59,186 --> 00:28:01,306
I think, was understandable
for most people.


612
00:28:02,166 --> 00:28:06,026
In the case of X, for
example, well, the compiler has


613
00:28:06,026 --> 00:28:08,646
to force unwrap that implicitly
unwrapped optional in order


614
00:28:08,646 --> 00:28:10,016
to do the addition,
and so it does.


615
00:28:10,516 --> 00:28:12,716
In the case of Y, well,
it didn't have to,


616
00:28:12,716 --> 00:28:14,106
and so if just kind
of propagated it


617
00:28:14,106 --> 00:28:14,976
down through the code.


618
00:28:15,616 --> 00:28:17,996
Well, this propagation was
surprising for a lot of reasons.


619
00:28:18,636 --> 00:28:22,996
It also was surprising because
more complicated cases often led


620
00:28:22,996 --> 00:28:25,466
us to scratch our heads about
what the code actually does.


621
00:28:25,836 --> 00:28:28,136
Because you don't even know you
have an implicitly unwrapped


622
00:28:28,136 --> 00:28:29,286
optional in many cases.


623
00:28:30,086 --> 00:28:33,296
So here, I have an int and an
implicitly unwrapped optional.


624
00:28:33,386 --> 00:28:35,426
Does that implicitly
unwrapped optional get forced?


625
00:28:35,926 --> 00:28:36,836
Do I get an array of any?


626
00:28:36,836 --> 00:28:37,786
Do I get an array of optional?


627
00:28:37,786 --> 00:28:38,626
What is going on?


628
00:28:38,626 --> 00:28:40,496
Well, you never really
know until you go


629
00:28:40,496 --> 00:28:42,576
to compile your code and you
get some weird compiler error,


630
00:28:42,926 --> 00:28:45,496
and this is not the effect
that we're going for.


631
00:28:46,846 --> 00:28:49,696
So implicitly unwrapped
optional is really important


632
00:28:49,846 --> 00:28:54,196
as a concept, so we kept it,
but we changed how it works,


633
00:28:54,196 --> 00:28:55,896
to have a new, simpler model.


634
00:28:56,756 --> 00:28:58,196
The model is now very local.


635
00:28:58,336 --> 00:29:00,976
For any use of an
implicitly unwrapped optional,


636
00:29:01,756 --> 00:29:04,766
if the value can be used
as an optional, it is.


637
00:29:05,176 --> 00:29:06,176
That's the safe thing.


638
00:29:06,176 --> 00:29:08,016
We don't want to be
unwrapping values


639
00:29:08,346 --> 00:29:09,276
where you don't expect it.


640
00:29:10,006 --> 00:29:12,486
However, if the compiler
is required to unwrap it


641
00:29:12,556 --> 00:29:14,386
for type checking
to succeed, it does.


642
00:29:15,206 --> 00:29:17,126
So let's go through
some examples again.


643
00:29:17,826 --> 00:29:20,486
Here, we have X, the
compiler has to unwrap it


644
00:29:20,486 --> 00:29:22,036
to do the addition,
and so it does.


645
00:29:22,036 --> 00:29:24,406
This is the key aspect of what
makes implicitly unwrapped


646
00:29:24,406 --> 00:29:26,176
optionals different
than strong ones.


647
00:29:27,396 --> 00:29:30,856
Why? Well, here the compiler
can type check the expression


648
00:29:31,746 --> 00:29:33,936
as an optional, and
so now instead


649
00:29:33,936 --> 00:29:35,986
of propagating the
implicitly unwrapped optional,


650
00:29:35,986 --> 00:29:38,966
maybe deep down through your
code and many different levels,


651
00:29:39,356 --> 00:29:41,606
it turns into a strong optional,
which allows you to think


652
00:29:41,606 --> 00:29:44,876
about it and know
that that's there.


653
00:29:45,066 --> 00:29:46,326
This also leads to more
predictable behavior


654
00:29:46,326 --> 00:29:48,786
with the array, because now, of
course, this can be type checked


655
00:29:48,786 --> 00:29:50,826
as a strong optional,
and so it does.


656
00:29:50,936 --> 00:29:54,006
And if you actually
want it to be unwrapped,


657
00:29:54,206 --> 00:29:55,096
well, that's okay too.


658
00:29:55,096 --> 00:29:56,906
You can explicitly
wrap this in your code


659
00:29:56,906 --> 00:30:00,126
with the exclamation mark, and
now people who read it can know


660
00:30:00,126 --> 00:30:02,526
about that, and your
code is a lot better.


661
00:30:03,516 --> 00:30:07,196
So that's my quick tour of some
of the interesting things going


662
00:30:07,196 --> 00:30:07,966
on with the type system.


663
00:30:08,216 --> 00:30:09,836
Let's talk about the
standard library.


664
00:30:11,046 --> 00:30:13,756
The big news in the standard
library is a whole new


665
00:30:13,756 --> 00:30:15,026
collection indexing model.


666
00:30:16,206 --> 00:30:17,076
And what does that mean?


667
00:30:17,196 --> 00:30:18,766
Well, maybe you've
worked with indexes.


668
00:30:18,766 --> 00:30:19,376
Maybe not.


669
00:30:19,576 --> 00:30:21,356
There are a lot of great
ways to get indexes.


670
00:30:21,796 --> 00:30:23,416
The difference here
is in how they move.


671
00:30:24,106 --> 00:30:26,746
And previously in Swift 2, you'd
call them method on the index,


672
00:30:26,856 --> 00:30:28,386
like Successor, to
move it forward.


673
00:30:29,156 --> 00:30:32,196
In Swift 3, the model is
basically the same except now


674
00:30:32,196 --> 00:30:34,256
instead of the index
moving itself,


675
00:30:34,656 --> 00:30:38,136
the collection moves
the index with itself.


676
00:30:39,226 --> 00:30:40,546
And why would we do this?


677
00:30:40,746 --> 00:30:42,666
Well, there's a number of
great things at the Springs.


678
00:30:42,666 --> 00:30:44,566
First of all, we get to
simplify the standard library.


679
00:30:44,566 --> 00:30:46,546
A bunch of types just
go away, which is great.


680
00:30:47,116 --> 00:30:50,886
Even better, common kinds of
problems get defined away.


681
00:30:51,356 --> 00:30:52,906
You can now have an
inclusive range all the way


682
00:30:52,906 --> 00:30:56,136
up to the maximum element, which
previously would trigger a trap


683
00:30:56,136 --> 00:30:57,536
which nobody expected.


684
00:30:58,096 --> 00:30:59,916
We also think this is going
to bring better performance,


685
00:30:59,916 --> 00:31:01,666
because we can get rid
of our tandem releases


686
00:31:01,666 --> 00:31:02,866
with many common collections.


687
00:31:02,866 --> 00:31:04,526
So we are pretty
excited about this.


688
00:31:05,456 --> 00:31:07,466
Let's talk about numerics.


689
00:31:07,996 --> 00:31:10,776
We have a new floating point
protocol or family of protocols


690
00:31:10,776 --> 00:31:13,096
which help define
operations to allow you


691
00:31:13,096 --> 00:31:15,326
to write generic algorithms
across a broad range


692
00:31:15,326 --> 00:31:16,356
of FloatingPoint types.


693
00:31:17,266 --> 00:31:20,566
Even better, if you are a
numerical analysis type person


694
00:31:20,696 --> 00:31:23,356
and you understand IEEE
FloatingPoint, which is not me


695
00:31:23,756 --> 00:31:26,866
and not most people,
but it has a lot


696
00:31:26,866 --> 00:31:30,096
of great low level operations,
like getting the number of ULPS


697
00:31:30,096 --> 00:31:33,546
out of the whatever, some really
important smart stuff here.


698
00:31:35,566 --> 00:31:37,116
[Laughter] So I don't really
understand all that stuff.


699
00:31:37,116 --> 00:31:38,346
I think it's really
important, though,


700
00:31:38,346 --> 00:31:40,156
and people who do
really value it.


701
00:31:40,576 --> 00:31:44,226
I do understand things like
Pi, because everybody loves Pi.


702
00:31:44,966 --> 00:31:48,126
And in Swift 2 we always
got stuck using MPi,


703
00:31:48,126 --> 00:31:49,826
and it really irritated me


704
00:31:49,826 --> 00:31:51,906
because it was always the
wrong type, and you also had


705
00:31:51,906 --> 00:31:54,526
to cast it, and it always
led to huge frustration.


706
00:31:55,196 --> 00:31:58,236
Well, now, despite all
that IEEE stuff, you know,


707
00:31:58,236 --> 00:32:00,496
in addition to all that IEEE
stuff, we even get great things


708
00:32:00,496 --> 00:32:02,616
like Pi on all the
FloatingPoint types.


709
00:32:03,436 --> 00:32:05,376
And Swift often has
types available.


710
00:32:05,596 --> 00:32:07,426
And the other great
thing about this is


711
00:32:08,206 --> 00:32:11,176
that if you have typed
context, for example,


712
00:32:11,176 --> 00:32:14,566
here we're returning a CGFloat,
instead of doing a cast,


713
00:32:14,566 --> 00:32:17,836
you can use CGFloat.Pi, but
even better you can allow the


714
00:32:17,836 --> 00:32:20,196
compiler to infer that
completely for you.


715
00:32:20,566 --> 00:32:21,826
It leads to a really
nice result.


716
00:32:22,516 --> 00:32:27,166
[ Applause ]


717
00:32:27,666 --> 00:32:29,156
So as with the language,
there's a ton


718
00:32:29,156 --> 00:32:30,986
of great improvements
throughout the standard library.


719
00:32:31,376 --> 00:32:33,196
Some of these can really effect


720
00:32:33,196 --> 00:32:35,336
and really improve the
code you write in Swift,


721
00:32:35,336 --> 00:32:39,246
so I highly recommend sticking
around for the other Swift talks


722
00:32:39,246 --> 00:32:40,576
which will dive into
more information.


723
00:32:40,576 --> 00:32:44,316
So this was a quick tour of the
language, the standard library,


724
00:32:44,316 --> 00:32:48,436
how Cocoa works in Swift, but
the next big piece is how Swift


725
00:32:48,596 --> 00:32:49,916
and the tools work together.


726
00:32:50,186 --> 00:32:53,846
So to talk about that, I'd
like to invite up Ewa Matejska.


727
00:32:54,636 --> 00:32:54,846
Ewa?


728
00:32:55,516 --> 00:32:57,806
[ Applause ]


729
00:32:58,306 --> 00:32:59,026
>> Thank you, Chris.


730
00:33:01,556 --> 00:33:02,686
Good morning, everybody.


731
00:33:03,556 --> 00:33:06,896
Let's talk about Tools, and
what better place to start


732
00:33:06,896 --> 00:33:09,356
than what the tools can
do for your performance.


733
00:33:09,956 --> 00:33:12,856
As you can see, we've been
really busy this year,


734
00:33:13,606 --> 00:33:15,776
but let's talk about
a couple of these.


735
00:33:17,536 --> 00:33:20,646
We revamped the dictionary
implementation,


736
00:33:21,166 --> 00:33:22,756
and we also really focused


737
00:33:22,756 --> 00:33:27,256
on optimizing the string hashing
algorithms for ASCII strings,


738
00:33:27,756 --> 00:33:30,006
and we see some really
nice improvements


739
00:33:30,626 --> 00:33:33,216
in our micro benchmarks
for dictionaries


740
00:33:33,216 --> 00:33:35,326
that use strings
since last year.


741
00:33:36,736 --> 00:33:38,676
We also added stack promotion


742
00:33:39,236 --> 00:33:42,966
for class instances array
literals, where we promote


743
00:33:42,966 --> 00:33:46,676
from the heap, which is really
expensive, to the stack,


744
00:33:47,246 --> 00:33:49,016
and we see some really
nice improvements


745
00:33:49,016 --> 00:33:52,126
when our tests take
advantage of that.


746
00:33:53,416 --> 00:33:55,986
Also, as I already
described, we really focused


747
00:33:55,986 --> 00:33:59,246
on our string hashing
algorithms, and we see this


748
00:33:59,246 --> 00:34:04,176
in a dramatic way in our tests
that compared the prefixes


749
00:34:04,176 --> 00:34:08,446
and suffixes of strings, like
we get 86 times improvement.


750
00:34:10,295 --> 00:34:14,266
Next, I want to talk to you
about whole module optimization.


751
00:34:14,716 --> 00:34:17,025
This is a feature we
introduced last year,


752
00:34:17,166 --> 00:34:20,996
but I want to just remind you
a little bit about what it is.


753
00:34:21,556 --> 00:34:23,076
When you look at this diagram,


754
00:34:23,596 --> 00:34:26,585
you can see a really
parallel compilation flow,


755
00:34:27,295 --> 00:34:29,726
one file in, one file out.


756
00:34:30,366 --> 00:34:34,565
With whole module optimization,
we expand the scope


757
00:34:34,565 --> 00:34:37,795
of compilation from one
file to multiple files.


758
00:34:38,386 --> 00:34:41,456
And this is really great because
the compiler has a lot more


759
00:34:41,456 --> 00:34:45,416
information to write new,
innovative optimizations


760
00:34:45,766 --> 00:34:47,696
and to make your
code run faster.


761
00:34:48,716 --> 00:34:50,636
So we think this
has so much promise


762
00:34:50,835 --> 00:34:54,926
from our internal benchmarking,
that this year we are turning it


763
00:34:54,926 --> 00:34:57,696
on by default for
all new projects.


764
00:34:58,326 --> 00:35:02,826
And existing projects will get
a modernization suggestion and,


765
00:35:03,306 --> 00:35:07,426
as it suggests, we think you
should modernize and adopt it.


766
00:35:08,336 --> 00:35:11,376
There's a big caveat,
which is compilation time.


767
00:35:12,226 --> 00:35:14,776
As you look in this
diagram, you probably noticed


768
00:35:14,946 --> 00:35:17,686
that the compiler is
a bit of a bottleneck.


769
00:35:18,346 --> 00:35:22,066
And as you would expect, your
compilation time increases.


770
00:35:22,846 --> 00:35:26,766
To offset this cost, we have
made the compiler a lot smarter


771
00:35:27,126 --> 00:35:29,536
and it's caching
as much as it can


772
00:35:30,216 --> 00:35:33,236
to avoid reoptimization
and recompilation.


773
00:35:34,116 --> 00:35:35,756
So the result of all this is


774
00:35:35,806 --> 00:35:39,376
that although the first time
you compile, it will be --


775
00:35:39,586 --> 00:35:41,986
it will take a longer
time, follow-up,


776
00:35:41,986 --> 00:35:44,646
incremental compilations
should be faster.


777
00:35:46,906 --> 00:35:51,866
Moving on to code size,
this is an area that got --


778
00:35:51,866 --> 00:35:55,666
we did a lot of work
in since Swift 2.2,


779
00:35:56,106 --> 00:35:57,846
and we have some nice results.


780
00:35:58,536 --> 00:36:02,446
DemoBots is a sample app that
you can download from Developer


781
00:36:02,446 --> 00:36:05,646
at Apple.com, and
it saw a decrease


782
00:36:05,646 --> 00:36:09,186
in its application binary
size of almost 25 percent


783
00:36:09,926 --> 00:36:14,456
since Swift 2.2, so that's
some really nice ones here.


784
00:36:15,756 --> 00:36:17,906
Well, that's all I have
to say about performance,


785
00:36:18,716 --> 00:36:21,496
but there's lots more
to talk about in Xcode.


786
00:36:23,326 --> 00:36:26,966
So my favorite feature in
Xcode this year is the improved


787
00:36:27,486 --> 00:36:31,726
navigation of Swift code because
it really makes a difference


788
00:36:31,726 --> 00:36:33,506
every day in development.


789
00:36:34,166 --> 00:36:36,206
Let's take a look at an example.


790
00:36:36,916 --> 00:36:41,486
So here's an example where we
create an array of integers


791
00:36:41,486 --> 00:36:43,216
and then just go Sort.


792
00:36:43,736 --> 00:36:46,756
What do you think happens
when you right click on Sort


793
00:36:47,296 --> 00:36:49,276
and jump to a declaration?


794
00:36:49,856 --> 00:36:54,106
In Xcode 7.1, you take


795
00:36:54,106 --> 00:36:56,406
in a synthesized header
that looks like this.


796
00:36:57,056 --> 00:36:58,376
Like what is this?


797
00:36:58,516 --> 00:37:02,206
It's an extension to
mutable collection type,


798
00:37:02,426 --> 00:37:05,126
the sort here return self
that generated that element,


799
00:37:05,126 --> 00:37:08,936
and the only reference
to array is in a comment.


800
00:37:09,606 --> 00:37:13,276
So it doesn't make very much
sense and it's not very logical.


801
00:37:13,936 --> 00:37:16,436
So in Xcode 8, we're
doing a lot better,


802
00:37:17,026 --> 00:37:20,196
and now you see there's
an extension to an array


803
00:37:20,446 --> 00:37:25,376
like you would expect and
sorted, because sort was renamed


804
00:37:25,376 --> 00:37:30,136
to sorted in Xcode 8, now
returns an array of elements.


805
00:37:30,896 --> 00:37:35,336
So this really improves how
you can navigate the code


806
00:37:35,336 --> 00:37:37,716
in Xcode and its readability.


807
00:37:37,716 --> 00:37:38,836
It's much more logical.


808
00:37:40,426 --> 00:37:42,606
Also, in the standard library,


809
00:37:43,116 --> 00:37:45,526
we added groupings
by logical areas.


810
00:37:46,026 --> 00:37:49,846
For example, array is
grouped under collection.


811
00:37:50,756 --> 00:37:54,636
And speaking of the standard
library, we have all kinds


812
00:37:54,636 --> 00:37:56,256
of new documentation for you.


813
00:37:56,986 --> 00:38:02,146
And again, the protocols
are locked into the APIs,


814
00:38:02,276 --> 00:38:06,146
so you can logically
navigate like you would


815
00:38:06,146 --> 00:38:07,716
in the synthesized interfaces.


816
00:38:08,016 --> 00:38:09,306
[ Applause ]


817
00:38:09,306 --> 00:38:09,736
Thank you.


818
00:38:10,516 --> 00:38:13,016
[ Applause ]


819
00:38:13,516 --> 00:38:15,616
I think you're going to
really love this part.


820
00:38:15,916 --> 00:38:20,276
Yeah. So how many people
have Swift 2.2 code?


821
00:38:20,876 --> 00:38:21,936
Probably lots of people.


822
00:38:22,496 --> 00:38:25,556
So, of course, we have the
migrator for you like always,


823
00:38:26,276 --> 00:38:28,626
but this year you get to choose.


824
00:38:28,626 --> 00:38:33,626
You get to choose
Swift 2.3 or Swift 3.


825
00:38:34,516 --> 00:38:36,916
[ Applause ]


826
00:38:37,416 --> 00:38:40,206
If you're not quite
ready to jump to Swift 3,


827
00:38:41,126 --> 00:38:46,506
Swift 2.3 is just Swift 2.2 that
works with the new SDKs, okay,


828
00:38:47,076 --> 00:38:50,346
and we will be accepting
submissions to the app store,


829
00:38:50,716 --> 00:38:55,116
both with Swift 3 and 2.3,
but you should be aware


830
00:38:55,116 --> 00:38:57,846
that there are some very key
features in Xcode that depend


831
00:38:57,846 --> 00:39:00,976
on Swift 3, like
Playgrounds and Documentation


832
00:39:01,646 --> 00:39:04,136
and the new features as
well, like Thread Sanitizer.


833
00:39:05,246 --> 00:39:08,726
Swift 2.3 is a really
an interim solution


834
00:39:09,156 --> 00:39:10,586
to allow you the flexibility


835
00:39:10,586 --> 00:39:13,026
to schedule time to
update to Swift 3.


836
00:39:13,476 --> 00:39:14,786
So please schedule it today.


837
00:39:16,026 --> 00:39:20,956
Yeah. If you are
using Swift 2.3,


838
00:39:21,146 --> 00:39:22,516
I have a little tip for you.


839
00:39:23,306 --> 00:39:24,566
Here is a sample.


840
00:39:24,566 --> 00:39:28,966
It's a little code snippet from
the lister sample that's in 2.2.


841
00:39:29,696 --> 00:39:33,826
And when you run the
Swift migrator to 2.3,


842
00:39:33,826 --> 00:39:37,376
it will suggest you add an
exclamation mark after frame,


843
00:39:37,706 --> 00:39:41,106
because the core
graphics API have improved


844
00:39:41,276 --> 00:39:43,626
with additional ability editing.


845
00:39:44,906 --> 00:39:50,016
Now this code compiles both
with Swift 2.2 and Swift 2.3,


846
00:39:50,016 --> 00:39:52,736
but if you have a little
more complicated scenario,


847
00:39:53,116 --> 00:39:55,086
you could conditionally
compile your code


848
00:39:55,476 --> 00:39:58,786
with a pound FL statement here.


849
00:39:59,166 --> 00:40:01,046
So that's just a little tip.


850
00:40:02,146 --> 00:40:05,626
And when you are ready, when you
are ready to upgrade to Swift 3,


851
00:40:06,736 --> 00:40:08,426
the migrator is there for you.


852
00:40:08,866 --> 00:40:12,256
Just go to Edit, Convert
to Current Swift Syntax,


853
00:40:12,666 --> 00:40:15,296
and you are taken through the
migration experience again.


854
00:40:16,376 --> 00:40:17,836
So it's easy.


855
00:40:18,006 --> 00:40:19,976
Convert to Swift 3
and schedule it today.


856
00:40:21,026 --> 00:40:23,596
So that's all I have
to say about tools.


857
00:40:24,706 --> 00:40:29,286
And just to recap,
recap, Chris talked


858
00:40:29,286 --> 00:40:32,256
about how Swift 3
really focuses on nailing


859
00:40:32,256 --> 00:40:33,276
down the fundamentals.


860
00:40:33,956 --> 00:40:37,156
And we're doing all this
in the open on Swift.org,


861
00:40:37,246 --> 00:40:40,776
as Ted described, and you can
just go there and get involved


862
00:40:40,776 --> 00:40:41,926
in the evolution process.


863
00:40:42,376 --> 00:40:45,436
And you can see we've got
awesome Xcode integration


864
00:40:45,436 --> 00:40:45,846
as well.


865
00:40:46,906 --> 00:40:49,396
So there's lots more
information this week.


866
00:40:49,396 --> 00:40:50,476
There is just the beginning.


867
00:40:50,886 --> 00:40:52,646
And we have lots of
sessions throughout the week.


868
00:40:53,386 --> 00:40:54,636
I want to highlight one,


869
00:40:55,196 --> 00:40:57,606
which is the Swift
API Design Guidelines.


870
00:40:58,006 --> 00:41:00,016
It's in this room right
after this session.


871
00:41:00,476 --> 00:41:01,626
And have an awesome
week with us.


872
00:41:01,626 --> 00:41:01,976
Thank you.


873
00:41:02,516 --> 00:41:13,160
[ Applause ]

