1
00:00:21,288 --> 00:00:28,295
UIKitDynamics
和视觉效果的最新进展


2
00:00:31,365 --> 00:00:33,834
欢迎参加WWDC
和"UIKitDynamics


3
00:00:34,601 --> 00:00:37,070
和视觉效果的最新进展"
的最后一天的活动


4
00:00:37,304 --> 00:00:38,405
我是麦克·特纳


5
00:00:38,672 --> 00:00:40,440
我将和我的同事大卫·杜汉
一起为大家进行介绍


6
00:00:40,507 --> 00:00:42,643
我们两个都是Apple在这里的
UIKit开发组成员


7
00:00:43,644 --> 00:00:45,179
所以 在我们开始今天的介绍之前


8
00:00:45,646 --> 00:00:47,314
我要向各位推荐几场
非常好的讲座


9
00:00:47,381 --> 00:00:48,882
我只是简要介绍一下


10
00:00:48,949 --> 00:00:50,651
在过去几年里我们
进行过几场非常好的


11
00:00:50,717 --> 00:00:53,287
围绕UIKitDynamics动态
和视觉效果的讲座


12
00:00:53,620 --> 00:00:56,557
所以我们今天就从
简要概述


13
00:00:56,623 --> 00:00:58,358
动态动画模拟系统开始


14
00:00:58,425 --> 00:01:00,160
我们会进行 基本示范 然后


15
00:01:00,327 --> 00:01:03,664
我们直接切入今年
UIKit Dynamics的新进展


16
00:01:04,197 --> 00:01:08,068
然后大卫会过来
与我们讨论视觉效果


17
00:01:09,937 --> 00:01:12,206
以及你怎样在你的应用程序中
运用那些效果


18
00:01:12,706 --> 00:01:14,374
最后 我们会稍稍涉及


19
00:01:14,441 --> 00:01:17,077
一些应用UIKit
Dynamics的最佳操作范例


20
00:01:17,144 --> 00:01:18,779
和你的应用程序里的自动布局


21
00:01:20,681 --> 00:01:22,683
所以我们谈论UIKit Dynamics时


22
00:01:22,749 --> 00:01:25,085
我们说的是一个二维的
基于物理启发的


23
00:01:25,152 --> 00:01:26,553
动画交互系统


24
00:01:27,387 --> 00:01:30,023
它有一个非常易于组合的
说明式的API


25
00:01:30,357 --> 00:01:32,993
可以显示你的应用程序
里的高水平动画


26
00:01:33,727 --> 00:01:37,798
我们所说的并非核心动画或用户界面视
图UIView动画的


27
00:01:38,031 --> 00:01:39,199
替代程序 而是另一个


28
00:01:39,266 --> 00:01:41,702
能够帮助你在你的应用程序
创建定制的效果的工具


29
00:01:42,436 --> 00:01:43,537
让我们来看一个示例


30
00:01:44,238 --> 00:01:46,807
这里有一个基础的滑动视图


31
00:01:47,774 --> 00:01:50,477
用户可以平移视图
但是如果你放开它


32
00:01:50,544 --> 00:01:53,413
它就像受到重力
影响一样落下来


33
00:01:53,780 --> 00:01:55,883
现在 它并不会直接
从电话底部消失


34
00:01:56,083 --> 00:01:57,851
相反 它先在底部边缘停止


35
00:01:57,985 --> 00:01:59,686
再稍稍向上反弹 然后停在那里


36
00:02:00,287 --> 00:02:02,823
现在 让我们看一看如何
创建这个基本示例


37
00:02:03,457 --> 00:02:06,059
首先你需要先选定一个很好
的参考视图


38
00:02:06,326 --> 00:02:08,228
在这里 我们选择
视图控制器的视图


39
00:02:08,294 --> 00:02:09,596
其中包含我们的滑动视图


40
00:02:11,131 --> 00:02:12,766
选择引用视图后 我们要


41
00:02:12,833 --> 00:02:15,602
创建一个动态动画并
将它与引用视图关联


42
00:02:16,136 --> 00:02:18,639
这段动态动画
为我们的动画


43
00:02:18,705 --> 00:02:21,775
保持整体背景 它的
主要作用是跟踪


44
00:02:21,842 --> 00:02:23,544
行为和动态项目


45
00:02:24,711 --> 00:02:27,281
对于滑动的例子
我们有一个滑动行为


46
00:02:27,714 --> 00:02:30,050
UI动态行为的
伟大之处之一


47
00:02:30,450 --> 00:02:32,286
是更高层次的行为
可以由相对原始


48
00:02:32,352 --> 00:02:33,220
的行为组成


49
00:02:34,087 --> 00:02:36,456
所以我们的滑动
行为只不过是


50
00:02:36,523 --> 00:02:38,792
重力 碰撞 附件
的组合作品


51
00:02:39,760 --> 00:02:41,195
稍后 我们将向大家展示


52
00:02:41,261 --> 00:02:44,531
我们如何使用UIAttachmen
Behavior和增加的新组件


53
00:02:44,598 --> 00:02:45,899
让滑动
比过去更简单


54
00:02:47,534 --> 00:02:48,936
所以一旦我们
有滑动的行为


55
00:02:49,036 --> 00:02:50,504
我们就需要一个动态的项目


56
00:02:50,971 --> 00:02:53,574
这里我们选择了
滑动视图


57
00:02:53,941 --> 00:02:56,276
它只是一个自动符合动态项
协议的UIView


58
00:02:56,410 --> 00:02:57,511
所以这是一个很好的选择


59
00:02:57,845 --> 00:02:59,913
然后我们选择
动态项 将它与


60
00:02:59,980 --> 00:03:01,281le
滑动行为关联 将滑动行为


61
00:02:59,980 --> 00:03:01,281
滑动行为关联 将滑动行为


62
00:03:01,348 --> 00:03:02,816
和animator组件关联


63
00:03:03,450 --> 00:03:05,886
现在animator组件
将自动确定


64
00:03:05,953 --> 00:03:08,555
系统静止或运动的时间
这是要创建这个


65
00:03:08,622 --> 00:03:10,057
伟大的效果你所需要的全部条件


66
00:03:12,025 --> 00:03:13,527
现在我们已经看过了一个基本示范


67
00:03:14,494 --> 00:03:16,730
这就是今年UIKit
dynamics的新变化


68
00:03:17,431 --> 00:03:18,265
我们支持


69
00:03:18,332 --> 00:03:21,034
UIDynamicItem的
非矩形碰撞结合


70
00:03:21,802 --> 00:03:24,238
我们有一个全新的
UIDynamicItemGroup


71
00:03:24,304 --> 00:03:26,907
允许多个项目
就像引擎中的一个部件


72
00:03:28,141 --> 00:03:29,543
一样运转 我们
还有一个全新的


73
00:03:29,776 --> 00:03:31,178
模拟向量力场的行为


74
00:03:32,746 --> 00:03:35,983
我们对UIDynamicItemBehavior
以及UISnapBehavior进行了


75
00:03:36,049 --> 00:03:37,484
一些基础性的优化处理


76
00:03:38,018 --> 00:03:40,687
我们会看到UIAttachmentBehavior
新增了一些很好的功能


77
00:03:41,355 --> 00:03:43,991
我们最后还将介绍
一些新的方法 你们可以


78
00:03:44,057 --> 00:03:46,093
用这些方法调试动画


79
00:03:49,263 --> 00:03:52,499
所以 在iOS 9里 我们
增加了UIDynamicItem


80
00:03:52,566 --> 00:03:55,569
碰撞边界类型
可以提供三个新方法


81
00:03:55,903 --> 00:03:58,405
为动态项指定碰撞边界


82
00:03:59,506 --> 00:04:02,309
在默认情况下你的碰撞
边界是矩形


83
00:04:02,509 --> 00:04:04,811
与边界数据访问器
返回的动态项目协议


84
00:04:05,078 --> 00:04:06,246
匹配


85
00:04:07,381 --> 00:04:10,417
现在你可以指定一个
椭圆类型 它来自


86
00:04:10,484 --> 00:04:12,920
协议中的边界
宽度和高度


87
00:04:13,820 --> 00:04:17,024
最后 你可以指定
一个UI BezierPath用于


88
00:04:17,089 --> 00:04:18,524
动态项的碰撞边界


89
00:04:20,761 --> 00:04:23,597
现在 为了实现这一点 我们采用了
现有的动态项目协议


90
00:04:23,664 --> 00:04:27,067
并已经延长两个可选属性


91
00:04:27,401 --> 00:04:28,435
如果你不
应用这两个


92
00:04:28,502 --> 00:04:30,871
可选属性中的任何一个
你将像过去一样


93
00:04:30,938 --> 00:04:32,372
遭遇到矩形碰撞边界


94
00:04:33,273 --> 00:04:35,409
如果你执行第一个
碰撞边界类型


95
00:04:35,542 --> 00:04:37,411
并返回椭圆
就将得到一个


96
00:04:37,511 --> 00:04:39,279
基于边界的宽度
和高度的椭圆


97
00:04:39,980 --> 00:04:42,082
如果你执行
第一碰撞边界类型并返回一个路径


98
00:04:42,149 --> 00:04:43,884
我们会将你调回
执行第二个类型


99
00:04:44,218 --> 00:04:46,820
此时您将需要提供
一个UI BezierPath


100
00:04:46,887 --> 00:04:47,754
用于碰撞边界


101
00:04:48,822 --> 00:04:51,458
所以如果我们要模拟
项目之间的


102
00:04:51,525 --> 00:04:53,894
边界不同的碰撞
为保险起见


103
00:04:53,961 --> 00:04:56,129
我们要多做几次
情况可能看起来像这样


104
00:04:56,630 --> 00:04:58,932
这次碰撞看起来
比过去所有项目


105
00:04:58.999 --> 00:05:00.033 align:middle
都有矩形碰撞边界


106
00:04:58,999 --> 00:05:00,033
都有矩形碰撞边界


107
00:05:00,100 --> 00:05:02,436
的情况下更现实


108
00:05:04,872 --> 00:05:07,875
现在 为碰撞边界
设定路径时有


109
00:05:07,941 --> 00:05:09,943
一些限制
特别是


110
00:05:10,010 --> 00:05:13,180
BezierPath要求必须是凸起
的逆时针模绕


111
00:05:13,580 --> 00:05:14,815
并且非自相交


112
00:05:15,415 --> 00:05:17,985
这些都是非常基本的
如果你仔细想想


113
00:05:18,785 --> 00:05:19,987
也没有什么太花哨的东西


114
00:05:20,454 --> 00:05:23,457
我们还需要记住
当项目在屏幕上时


115
00:05:23,524 --> 00:05:26,960
BezierPath的
00点将代表


116
00:05:27,461 --> 00:05:28,462
动态项的中心点


117
00:05:30,230 --> 00:05:33,333
这就是碰撞边界的更新内容
让我们来谈谈动态项目组


118
00:05:33,567 --> 00:05:35,936
这是进行
多个项目


119
00:05:36,170 --> 00:05:38,405
并使他们作为一项
在底层引擎运行的基本方式


120
00:05:39,106 --> 00:05:41,842
这个项目组
保留每个项目


121
00:05:42,042 --> 00:05:45,245
的位置和各自的
碰撞边界


122
00:05:45,479 --> 00:05:49,550
所以因为这个原因 你应该
把这些项目与一组


123
00:05:49,850 --> 00:05:51,218
而不是单独的行为
关联起来


124
00:05:51,285 --> 00:05:52,586
与其将它们与组
进行关联


125
00:05:52,986 --> 00:05:54,288
将组与
任何行为进行关联


126
00:05:54,354 --> 00:05:56,223
你更倾向于
与animator组件关联


127
00:05:56,290 --> 00:05:57,891
总的来说 这会
把那些行为


128
00:05:57,958 --> 00:05:58,992
强加在项目上


129
00:05:59,860 --> 00:06:02,462
而一个组却不能被
添加到其他组中


130
00:06:02,529 --> 00:06:03,897
这是一个一级抽象


131
00:06:04,598 --> 00:06:07,668
所以要创建凹形或其他


132
00:06:07,734 --> 00:06:10,737
复杂的不能用动
态项目边界路径创建的几何结构


133
00:06:11,338 --> 00:06:13,941
而且总体来说行为能够有此影响


134
00:06:14,341 --> 00:06:15,809
要做
到这些 这是一个很好的方式


135
00:06:17,077 --> 00:06:19,313
那么 让我们暂时
回到滑动示例


136
00:06:21,481 --> 00:06:24,418
我们希望实现更丰富的滑动效果
而不仅仅是简单的平移和回落


137
00:06:24,484 --> 00:06:27,154
比如我们让屏幕
在用户触碰时轻微跳动


138
00:06:27,221 --> 00:06:28,522
显示可以平移


139
00:06:29,289 --> 00:06:31,124
要做到这些 我们只需要


140
00:06:31,191 --> 00:06:33,293
给滑动视图添加一个简短的力


141
00:06:33,894 --> 00:06:34,995
这就是那力


142
00:06:37,130 --> 00:06:40,067
所以我们可以在项目
的中心把这个力


143
00:06:40,334 --> 00:06:44,471
作为一个向量进行模拟在项目的中心
向量的长度对应的这个力


144
00:06:44,538 --> 00:06:47,374
的长度 向量指向上方以说明


145
00:06:47,441 --> 00:06:49,743
这个力的方向 在本例中我们要


146
00:06:49,810 --> 00:06:51,578
向上移动视图 所以这个力指向上方


147
00:06:52,379 --> 00:06:55,382
为了应用这个力我们就要使用
UIPushBehavior


148
00:06:56,083 --> 00:06:58,118
你还记得的话
UIPushBehavior


149
00:06:58,185 --> 00:06:59,486
有两种截然不同的模式


150
00:06:59,887 --> 00:07:02,990
它有一个连续模式
代表了一种跨越时间的力


151
00:07:03,056 --> 00:07:05,492
另一个模式是瞬时模式


152
00:07:05,993 --> 00:07:08,395
代表一个简短的瞬间的力


153
00:07:08,529 --> 00:07:09,730
或者称为一个脉冲


154
00:07:10,597 --> 00:07:13,667
对于这种交互 我们
只需要一个简短的力 它会反弹回来


155
00:07:13,734 --> 00:07:15,135
然后静止
所以我们要


156
00:07:15,202 --> 00:07:16,136
使用瞬时模式


157
00:07:16,537 --> 00:07:18,272
我们这样做就
得到一个简短的力


158
00:07:18,338 --> 00:07:20,407
但是什么使视图回来？


159
00:07:20,474 --> 00:07:22,476
我们给它一个力
使它向上移动


160
00:07:22,543 --> 00:07:24,011
但它却回落下来


161
00:07:24,778 --> 00:07:28,382
这是我们的复合行为
是由重力


162
00:07:28,448 --> 00:07:29,750
碰撞和附件构成的


163
00:07:30,083 --> 00:07:31,818
所以是重力
使其移动下来


164
00:07:31,885 --> 00:07:33,487
然后它再以
碰撞行为反弹


165
00:07:34,121 --> 00:07:35,856
但让我们来
多了解一些重力


166
00:07:35,923 --> 00:07:37,324
以及它如何影响
我们的项目


167
00:07:38,091 --> 00:07:39,993
我们从开始
施加脉冲力的瞬间


168
00:07:40,661 --> 00:07:42,963
来看滑动视图


169
00:07:43,030 --> 00:07:44,498
的垂直运动


170
00:07:44,932 --> 00:07:47,401
你会发现
这个力是作用于一个点


171
00:07:47,601 --> 00:07:50,070
然后项目向上移动
再以弧形回落


172
00:07:50,804 --> 00:07:53,073
这是因为在我们的
图表中重力


173
00:07:53,140 --> 00:07:54,575
无时无地
不在影响它


174
00:07:54,875 --> 00:07:57,578
如果我们把这些力与重力相加
情况看起来


175
00:07:57,644 --> 00:08:01,815
可能像这样
这个力是应用于


176
00:08:01,882 --> 00:08:03,417
所有位置和时间的


177
00:08:03,617 --> 00:08:04,985
所以不容易模拟


178
00:08:05,419 --> 00:08:07,354
也许我们可以试着
使用UI来推动行为


179
00:08:07,454 --> 00:08:09,289
但是这会非常
复杂的 而且很快


180
00:08:09,990 --> 00:08:12,492
所以我们需要更多地
把重力当作一个场加以思考


181
00:08:13,360 --> 00:08:15,495
场非常简单
它只是一个函数


182
00:08:15,729 --> 00:08:18,832
在指定的定义域内
给每一个点分配一个向量


183
00:08:18,999 --> 00:08:20,701
在这个例子中
我们的定义域


184
00:08:20,767 --> 00:08:21,935
是整个参考视图


185
00:08:22,236 --> 00:08:24,605
所以我们希望重力
在整个参考视图里


186
00:08:24,938 --> 00:08:26,006
影响滑动视图


187
00:08:26,840 --> 00:08:27,674
特别简单


188
00:08:27,875 --> 00:08:30,677
所以我们采用了这个场
的想法 并加以扩展


189
00:08:31,011 --> 00:08:33,780
在iOS 9中 我们引入了
UIFieldBehavior


190
00:08:34,780 --> 00:08:36,283
UIFieldBehavior


191
00:08:36,350 --> 00:08:38,150
是一个
可以添加到参考视图的


192
00:08:38,217 --> 00:08:42,222
一个区域中的方法
场在参考视图之内的


193
00:08:42,289 --> 00:08:43,222
每一个点都被赋值


194
00:08:43,289 --> 00:08:46,393
任何产生的力量


195
00:08:46,460 --> 00:08:48,195
自动被动态animator组件应用


196
00:08:48,262 --> 00:08:49,530
到已经与场关联的
项目中


197
00:08:51,164 --> 00:08:54,134
如果你在想
我们现有的UIGravityBehavior


198
00:08:54,535 --> 00:08:56,203
被作为一个场实施


199
00:08:57,504 --> 00:08:58,805
重要的是还要记住


200
00:08:58,872 --> 00:09:00,073ddle
这是简化的物理


201
00:08:58,872 --> 00:09:00,073
这是简化的物理


202
00:09:00,140 --> 00:09:01,642
为适应这个展示进行了调整


203
00:09:02,009 --> 00:09:03,744
我不会用它来建造


204
00:09:03,810 --> 00:09:05,312
星际空间站
或类似的东西


205
00:09:06,747 --> 00:09:09,283
让我们看一看内置场的类型


206
00:09:09,483 --> 00:09:10,684
这里种类非常丰富


207
00:09:10,784 --> 00:09:12,686
有线性和放射重力场、


208
00:09:12,753 --> 00:09:14,254
速度和阻力场、


209
00:09:14,321 --> 00:09:17,191
涡流场以及依据胡克定律的弹簧场


210
00:09:17,257 --> 00:09:18,525
还有电场


211
00:09:18,592 --> 00:09:20,460
和磁场


212
00:09:21,328 --> 00:09:23,096
如果还不能满足你的需要


213
00:09:23,163 --> 00:09:24,998
我们也提供自定义力鉴别器


214
00:09:25,065 --> 00:09:26,033
此话题我们稍后再叙


215
00:09:26,466 --> 00:09:28,335
我们先从线性重力开始


216
00:09:29,369 --> 00:09:31,371
我们首先会注意到它处于一个区域内


217
00:09:31,638 --> 00:09:33,440
就像我们之前讲的那样


218
00:09:33,907 --> 00:09:36,476
而且它有场强
我们使用默认值1


219
00:09:36,810 --> 00:09:38,412
它也是一个方向作用力


220
00:09:38,478 --> 00:09:41,548
我们使用熟悉的重力方向


221
00:09:42,082 --> 00:09:43,317
举例


222
00:09:43,550 --> 00:09:46,119
但它实际可以指向任何方向


223
00:09:46,720 --> 00:09:50,324
让我们看一看放射重力和
线性重力的区别


224
00:09:51,058 --> 00:09:55,729
除存在于一个区域并且有场强外


225
00:09:55,796 --> 00:09:59,900
这儿有一个位置作为一个质点
用放射重力可以模拟


226
00:10:00,467 --> 00:10:02,503
如你所知


227
00:10:02,569 --> 00:10:04,838
两个物体之间重力


228
00:10:04,905 --> 00:10:09,076
与距离的平方成反比


229
00:10:09,343 --> 00:10:11,945
这儿是物体之间距离的平方


230
00:10:12,012 --> 00:10:14,781
这个指数是场的衰减值


231
00:10:15,148 --> 00:10:17,351
距离场的位置越远


232
00:10:17,851 --> 00:10:21,255
场产生的作用力就会减小


233
00:10:21,822 --> 00:10:23,824
这儿也有最小半径


234
00:10:24,324 --> 00:10:29,296
这一方法可以确定
一个物体距离位置点多远


235
00:10:29,363 --> 00:10:31,832
才可以感受到场的作用力


236
00:10:33,333 --> 00:10:35,002
我们还有一个噪声场


237
00:10:35,502 --> 00:10:37,404
在这方面我们注意到的第一个问题是


238
00:10:37,471 --> 00:10:40,874
它随着时间变化 你可以使用动画速度


239
00:10:40,941 --> 00:10:42,476
来调节 默认值为1


240
00:10:42,809 --> 00:10:44,311
0表示静态场


241
00:10:45,012 --> 00:10:46,914
你也可以使用平滑参数


242
00:10:46,980 --> 00:10:48,448
调节噪声程度


243
00:10:50,717 --> 00:10:52,486
让我们看一看自定义场鉴别器


244
00:10:53,287 --> 00:10:54,721
使用起来非常简单


245
00:10:54,788 --> 00:10:59,026
先使用场鉴别框创建一个
UIFieldBehavior并初始化


246
00:10:59,693 --> 00:11:02,996
然后就可以调用该框
使用几个场取样包含相关取样位置


247
00:11:03,163 --> 00:11:05,999
速度、质量、负载以及时间


248
00:11:06,066 --> 00:11:08,368
下来你就可以使用它来


249
00:11:08,435 --> 00:11:10,537
判断任何作用力


250
00:11:11,004 --> 00:11:13,574
这里我们需要做的是选择位置 x位置


251
00:11:13,941 --> 00:11:15,075
然后绘成正弦波


252
00:11:15,676 --> 00:11:16,510
一个很酷的结果


253
00:11:17,878 --> 00:11:20,380
这是一些基本的内置场


254
00:11:20,447 --> 00:11:22,382
和UIFieldBehavior
的概述


255
00:11:22,616 --> 00:11:25,018
我想邀请大卫


256
00:11:25,252 --> 00:11:26,086
举例展示


257
00:11:33,227 --> 00:11:34,995
大家好 我们将


258
00:11:35,062 --> 00:11:36,597
带你体验一个


259
00:11:36,663 --> 00:11:38,632
我相信你们以前都见过的一个例子


260
00:11:40,534 --> 00:11:43,470
我确信你们某个时候
都使用过FaceTime


261
00:11:43,537 --> 00:11:45,572
所以这儿的例子是


262
00:11:45,672 --> 00:11:47,207
创建一个相似的UI


263
00:11:47,274 --> 00:11:49,977
管理屏幕中的脸孔


264
00:11:51,044 --> 00:11:52,813
正如你所看到的 在我滑过这儿时


265
00:11:53,313 --> 00:11:55,716
方框移动顺畅


266
00:11:55,782 --> 00:11:58,952
如果我从角上拉开一点 它会弹回


267
00:11:59,019 --> 00:12:01,021
如果我再拉 它会有


268
00:12:01,088 --> 00:12:02,756
漂亮的渐入曲线


269
00:12:02,823 --> 00:12:05,425
如果向下抛 它就会


270
00:12:05,492 --> 00:12:07,628
沿着四周边沿弹开


271
00:12:08,061 --> 00:12:10,297
你会注意到在我向下抛时 它并没有


272
00:12:10,364 --> 00:12:12,432
直接到它应到的地方


273
00:12:12,666 --> 00:12:14,735
实际上有一个物理过程 它会弹离


274
00:12:14,801 --> 00:12:16,503
屏幕边沿并回到原位


275
00:12:17,704 --> 00:12:22,042
现在 我可以产生一个调试视图


276
00:12:22,109 --> 00:12:23,977
看看这些作用力场的样子


277
00:12:24,578 --> 00:12:25,712
这样 你可以看到


278
00:12:31,685 --> 00:12:33,954
这儿
你可以看到我们有四个弹簧场在运行


279
00:12:34,021 --> 00:12:38,158
我们可以很容易地解释所发生的事情


280
00:12:38,225 --> 00:12:40,227
如果我们把这个放在边沿


281
00:12:40,294 --> 00:12:41,562
我们知道它会弹回


282
00:12:42,462 --> 00:12:44,865
如果我们跨越两者 那么根据


283
00:12:44,932 --> 00:12:47,000
我们跨越的位置
它会选择一边或另一边


284
00:12:47,801 --> 00:12:49,336
穿过中间


285
00:12:49,703 --> 00:12:50,971
它会选择最近的一边


286
00:12:51,538 --> 00:12:52,940
让我们看看怎样设置


287
00:12:53,006 --> 00:12:55,909
怎样在实际中独立完成


288
00:12:58,145 --> 00:13:00,848
第一就是建立Sticky
Corners 行为


289
00:13:01,281 --> 00:13:03,750
根据麦克的说法
它是由其它行为构成的


290
00:13:03,817 --> 00:13:06,320
这种复杂的行为可以做完成我们的一切
想法


291
00:13:06,720 --> 00:13:08,288
在这种情况下 它会产生冲突行为


292
00:13:08,355 --> 00:13:09,456
因为我们不想让你的面孔


293
00:13:09,523 --> 00:13:11,091
急速离开屏幕边沿


294
00:13:11,825 --> 00:13:14,161
我们有一个动态的项目行为


295
00:13:14,228 --> 00:13:16,296
可以影响面孔的属性


296
00:13:16,630 --> 00:13:18,165
这样 我们可以减小密度


297
00:13:18,232 --> 00:13:19,900
使引擎具光感


298
00:13:20,334 --> 00:13:22,870
但需要增加其对运动的耐受性 这样


299
00:13:22,936 --> 00:13:25,272
它位于某一地点时
就不会绕着那个位置


300
00:13:25,339 --> 00:13:26,373
不断旋转


301
00:13:27,140 --> 00:13:28,809
最后我们禁用旋转


302
00:13:28,876 --> 00:13:29,910
因为这样做没有意义


303
00:13:29,977 --> 00:13:31,011
你并不想让自己的面孔


304
00:13:31,078 --> 00:13:32,145
在屏幕中旋转


305
00:13:33,947 --> 00:13:35,749
最后我们有个这些场行为


306
00:13:35,816 --> 00:13:38,852
四个弹簧场标出了四个角


307
00:13:38,952 --> 00:13:40,587
我们也把它们增添到行为中


308
00:13:40,988 --> 00:13:44,525
现在无论什么时候人们增添这种
StickyCorners 行为


309
00:13:44,625 --> 00:13:46,260
都会免费得到这种行为


310
00:13:48,629 --> 00:13:50,397
接下来 看看视图控制器


311
00:13:50,964 --> 00:13:53,634
我们去看一看建立视图层级需要的一切


312
00:13:54,368 --> 00:13:56,336
但还需增添一个拖动手势识别器


313
00:13:56,403 --> 00:13:58,605
这样 用户可以选择面孔


314
00:13:58,672 --> 00:13:59,773
并在屏幕移动


315
00:14:00,974 --> 00:14:03,410
长按手势识别器则会使我们


316
00:14:03,477 --> 00:14:05,312
开关调试界面


317
00:14:05,913 --> 00:14:07,281
我们创建动态仿真器


318
00:14:07,447 --> 00:14:09,783
并增添StickyCorners行
为


319
00:14:10,184 --> 00:14:12,252
手势识别器是如何工作的？


320
00:14:12,753 --> 00:14:15,289
像往常一样
手势识别在状态之间进行


321
00:14:15,355 --> 00:14:19,993
它从begin开始
开始后 我们做一些记账


322
00:14:20,060 --> 00:14:23,263
这样我们可以跟踪进展但我们也需要禁
用sticky behavior


323
00:14:23,330 --> 00:14:24,698
我马上会演示我们是怎样做的


324
00:14:25,365 --> 00:14:27,835
同样 当它变化时 我们向四周移动


325
00:14:28,502 --> 00:14:30,137
当它取消或结束时


326
00:14:30,504 --> 00:14:32,072
这是比较特殊的地方


327
00:14:32,573 --> 00:14:35,442
当用户停止互动时


328
00:14:35,509 --> 00:14:37,377
我们检查拖动手势识别器的速度


329
00:14:37,911 --> 00:14:40,247
并使用它把速度增添到


330
00:14:40,314 --> 00:14:41,715
动态体系中


331
00:14:41,782 --> 00:14:44,551
这样 当用户离开视图时


332
00:14:44,718 --> 00:14:47,521
它会继续随用户的动作而移动


333
00:14:47,754 --> 00:14:49,623
而不是突然停止并


334
00:14:49,690 --> 00:14:51,058
由场完全接管


335
00:14:51,725 --> 00:14:53,026
禁用和启用


336
00:14:53,093 --> 00:14:54,494
都是由于相同的理由


337
00:14:54,828 --> 00:14:56,196
在用户在活动中时


338
00:14:56,263 --> 00:14:57,965
我们不想让这些场处于活跃状态


339
00:14:58,031 --> 00:14:58,899
否则它会从我们的


340
00:14:58,966 --> 00:15:00,100
指尖下溜走


341
00:15:01,668 --> 00:15:02,970
所以我们再回过来看一下


342
00:15:03,036 --> 00:15:05,239
看看是怎样启用的


343
00:15:05,806 --> 00:15:07,541
的确非常简单


344
00:15:07,941 --> 00:15:10,544
在启用时 我们把所有项目增添到


345
00:15:10,611 --> 00:15:13,080
这些行为中 当禁用时
我们再取出来


346
00:15:13,380 --> 00:15:16,316
创建这样一个系统非常简单


347
00:15:16,383 --> 00:15:18,519
你可以在自己的程序中


348
00:15:18,719 --> 00:15:20,220
建立类似
FaceTime的行为


349
00:15:20,287 --> 00:15:22,990
所以 为了告诉你们如何将调试UI


350
00:15:23,190 --> 00:15:24,258
置入你自己的应用程序


351
00:15:24,324 --> 00:15:25,726
我要让麦克上来帮我一下


352
00:15:32,733 --> 00:15:33,567
谢谢 大卫


353
00:15:34,101 --> 00:15:37,004
真的非常好 在大卫的例子中


354
00:15:37,070 --> 00:15:38,772
为了能够一探究竟


355
00:15:38,972 --> 00:15:41,508
将这些场线可视化了


356
00:15:41,909 --> 00:15:43,810
在他打开它之前 这显得很神秘


357
00:15:44,611 --> 00:15:47,948
所以 在你的动画设计参照视图中


358
00:15:48,315 --> 00:15:50,150
这些线基本是用来显示这个场的叠加图


359
00:15:51,151 --> 00:15:53,820
特别是 这个叠加图能够帮助你将


360
00:15:54,154 --> 00:15:56,924
各个场、碰撞边界、附件 以及


361
00:15:56,990 --> 00:15:59,092
某特定组件是运动还是静止可视化


362
00:16:00,661 --> 00:16:02,930
现在 你可能奇怪 这不会是API


363
00:16:03,864 --> 00:16:06,767
但是它在LLDB中可以存取
而我们也正在把它


364
00:16:06,834 --> 00:16:09,736
作为UIDynamicAnimator上的
一个有效的调试功能加以推广


365
00:16:09,903 --> 00:16:11,071
而且它用起来确实很简单


366
00:16:11,271 --> 00:16:12,606
暂停调试程序


367
00:16:12,673 --> 00:16:14,208
为你的动态动画设计找一个参照


368
00:16:14,641 --> 00:16:16,076
激活调试功能 设定在true


369
00:16:16,376 --> 00:16:18,979
然后你将得到这个漂亮的叠加图
它能够给出所有的物理属性


370
00:16:24,051 --> 00:16:27,287
现在 除了激活和灭活调试功能之外


371
00:16:27,354 --> 00:16:28,956
我们还要给出调试间隔


372
00:16:29,056 --> 00:16:30,457
这样你就可以调整


373
00:16:30,524 --> 00:16:33,160
调试叠加图更新的时间间隔了


374
00:16:33,460 --> 00:16:35,229
所以 默认情况下


375
00:16:35,295 --> 00:16:37,030
每个动画帧都会更新
但是如果你有许多


376
00:16:37,097 --> 00:16:39,867
复杂的物理属性 那么可能


377
00:16:39,933 --> 00:16:41,034
例如 最好把间隔改为5


378
00:16:41,101 --> 00:16:43,237
即只是每到第5帧才更新


379
00:16:44,238 --> 00:16:47,274
同时 我们还允许你调节


380
00:16:47,341 --> 00:16:48,442
动态动画设计的动画速度


381
00:16:48,909 --> 00:16:51,078
此时放慢速度可能有利于


382
00:16:51,211 --> 00:16:52,746
观察真实的过程


383
00:16:53,046 --> 00:16:55,582
之后 重要的是要记住 在使用时


384
00:16:56,116 --> 00:16:57,951
如果放慢速度


385
00:16:58,252 --> 00:16:59,219
可能会影响模拟效果


386
00:16:59,286 --> 00:17:00,854
所以一定要确保以1x修正


387
00:17:03,490 --> 00:17:06,693
那么接下来让我们谈谈
UIDynamicItemBehavior


388
00:17:06,827 --> 00:17:08,127
现在 如果你再次调用


389
00:17:08,194 --> 00:17:11,498
可改变你的视图或动态道具的物理属性


390
00:17:12,031 --> 00:17:14,535
这适用于一个或多个动态道具


391
00:17:15,035 --> 00:17:16,403
在大卫的例子中


392
00:17:16,470 --> 00:17:18,505
他为FaceTime方块选用了低密
度


393
00:17:18,571 --> 00:17:20,641
及高阻力


394
00:17:20,941 --> 00:17:22,776
使其牢牢固定于场的角点


395
00:17:23,510 --> 00:17:26,012
就现有特性 在此多举几个例子


396
00:17:26,079 --> 00:17:29,883
我们有弹性、摩擦力
我们看到了密度和阻力


397
00:17:29,950 --> 00:17:32,052
我们有角阻力 这些都可调节


398
00:17:32,386 --> 00:17:34,821
你的道具在动画引擎中的状态


399
00:17:35,522 --> 00:17:38,792
在iOS 9中
我们增加了两个性能


400
00:17:38,959 --> 00:17:41,995
这影响你的道具


401
00:17:42,062 --> 00:17:44,131
在我们新型电场和磁场中的参与度；


402
00:17:44,464 --> 00:17:46,466
我们还增加了anchored属性


403
00:17:47,034 --> 00:17:48,001
这个略有不同


404
00:17:48,502 --> 00:17:51,038
但是它能让你的道具


405
00:17:51,104 --> 00:17:54,474
参与动态系统 参与碰撞


406
00:17:54,541 --> 00:17:56,677
不过没有自己的速度


407
00:17:56,743 --> 00:17:59,112
所以更像是碰撞边界


408
00:18:00,280 --> 00:18:01,181
那么接下来


409
00:18:01,248 --> 00:18:03,650
我要谈谈UIAttachmentB
ehavior


410
00:18:03,917 --> 00:18:06,386
这让你能够约束两个动态道具


411
00:18:06,453 --> 00:18:09,156
从而让它们彼此
保持特定的距离


412
00:18:09,690 --> 00:18:13,060
你可以利用阻尼和频率进行配置


413
00:18:13,360 --> 00:18:16,129
让它更像一个弹簧 而不是连杆


414
00:18:16,763 --> 00:18:18,098
这是一个很好的附件


415
00:18:18,165 --> 00:18:20,901
你知道 它很有用 但是你也确实


416
00:18:20,968 --> 00:18:23,203
只有一个办法来约束两个道具


417
00:18:24,438 --> 00:18:27,474
所以 在iOS
9中 我们增加了更多附件类型


418
00:18:28,308 --> 00:18:29,877
第一个是限制附件


419
00:18:30,477 --> 00:18:32,446
这与刚讲到的距离附件很像


420
00:18:32,513 --> 00:18:35,415
但不是我们能想到的


421
00:18:35,482 --> 00:18:37,751
像一个连杆或弹簧一样受约束


422
00:18:38,252 --> 00:18:40,821
而是更像两个道具间的一根绳子


423
00:18:40,921 --> 00:18:43,624
唯一约束是彼此间的
最大距离


424
00:18:44,658 --> 00:18:46,827
你对它的配置类似于距离附件


425
00:18:47,127 --> 00:18:49,863
规定从每个道具中心偏移出的两个点


426
00:18:50,631 --> 00:18:51,465
很简单


427
00:18:51,965 --> 00:18:53,500
接下来是一个固定的附件


428
00:18:54,468 --> 00:18:57,104
这与限制附件或距离附件
略有不同


429
00:18:57,704 --> 00:19:01,041
在你创建这种类型的附件时
首先规定一个锚点


430
00:19:01,375 --> 00:19:04,178
就每个道具中心而言 这个锚点


431
00:19:05,012 --> 00:19:07,181
位于你的参照视图坐标空间


432
00:19:08,148 --> 00:19:12,319
而这类附件无论如何不会
在两个道具之间运动


433
00:19:12,653 --> 00:19:18,725
相对于允许道具端部旋转的连杆
它更像是两道具间的焊接杆


434
00:19:20,360 --> 00:19:22,462
我们还增加了一种锁销附件


435
00:19:23,363 --> 00:19:25,399
这个类似于固定附件


436
00:19:25,465 --> 00:19:29,036
即你可以
先在两个道具间规定一个锚点


437
00:19:30,070 --> 00:19:34,441
但是这种类型附件允许两个道具
围绕这个锚点在彼此之间旋转


438
00:19:35,008 --> 00:19:39,379
这样你可以规定一个旋转范围
默认状态下无界


439
00:19:39,680 --> 00:19:42,482
但是我们可以给出界限
如缩小范围


440
00:19:43,417 --> 00:19:46,186
最后我们增加了一个滑动附件


441
00:19:46,787 --> 00:19:49,489
这个滑动附件有点复杂


442
00:19:49,556 --> 00:19:51,058
我们等一下看一个例子


443
00:19:51,558 --> 00:19:53,627
和固定附件及锁销附件一样


444
00:19:53,694 --> 00:19:56,063
我们先在参照视图坐标空间


445
00:19:56,129 --> 00:19:57,631
规定附件锚点


446
00:19:58,866 --> 00:20:00,334
但是与这两个类型不同 我们还要


447
00:20:00,400 --> 00:20:02,436
规定一个平移轴


448
00:20:02,903 --> 00:20:04,805
这里 两个道具之间


449
00:20:04,872 --> 00:20:07,574
相对运动都将沿着这个平移轴


450
00:20:08,342 --> 00:20:11,245
这个类型的附件可阻止两个道具
所有的相对旋转


451
00:20:11,311 --> 00:20:13,614
所以 两个道具不能再旋转


452
00:20:13,680 --> 00:20:16,550
只能沿着这个平移轴
运动


453
00:20:17,818 --> 00:20:18,852
但像锁销附件一样


454
00:20:19,186 --> 00:20:21,121
你可以限制平移范围


455
00:20:21,288 --> 00:20:23,090
这样 如果你规定了一个平移范围


456
00:20:23,423 --> 00:20:25,559
就要把附件锚点


457
00:20:26,093 --> 00:20:27,494
放在确定为范围零点的


458
00:20:27,561 --> 00:20:29,162
锚点位置


459
00:20:29,897 --> 00:20:32,132
所以
如果我们以这种类型附件建立该系统


460
00:20:32,799 --> 00:20:33,967
我们就能够得到


461
00:20:34,034 --> 00:20:35,569
两个道具间直线运动
就是这样


462
00:20:36,470 --> 00:20:37,437
所以 相当复杂


463
00:20:37,504 --> 00:20:38,906
让我们看一个基本示例


464
00:20:39,940 --> 00:20:41,308
为此 我想


465
00:20:41,375 --> 00:20:43,243
再次回到滑动的例子


466
00:20:44,478 --> 00:20:46,647
是说过在过去 如果我们


467
00:20:46,713 --> 00:20:49,583
使其可滑动 将必须


468
00:20:49,650 --> 00:20:51,985
在底部
每一侧以及顶部离开屏面的某处


469
00:20:52,052 --> 00:20:53,887
增加一个碰撞


470
00:20:54,188 --> 00:20:55,222
以限制滑动视图


471
00:20:55,455 --> 00:20:57,424
沿着垂直轴的运动


472
00:20:58,025 --> 00:21:00,294
那么
有了UI附件 我们再无需如此


473
00:21:00,360 --> 00:21:02,763
我们用滑动附件就能做到


474
00:21:03,030 --> 00:21:04,798
所以 我们把系统控制在一次碰撞


475
00:21:05,165 --> 00:21:06,166
使其表现更佳


476
00:21:06,433 --> 00:21:08,135
而代码确实更易读


477
00:21:08,902 --> 00:21:10,537
所以 如果我们在此激活调试视图


478
00:21:10,971 --> 00:21:13,307
你就能够看到


479
00:21:13,373 --> 00:21:15,375
通过沿垂直轴的直线描画的滑动附件


480
00:21:15,442 --> 00:21:18,412
它随我们滑动视图而缩放


481
00:21:18,879 --> 00:21:20,480
但是同时还有一个附件


482
00:21:20,848 --> 00:21:23,717
即距离附件 我们用它


483
00:21:23,784 --> 00:21:25,586
通过一个平移手势识别器


484
00:21:25,652 --> 00:21:26,820
附于一个操控锚点


485
00:21:27,321 --> 00:21:29,556
所以 不同于大卫的演示


486
00:21:29,623 --> 00:21:30,624
这个完全在动态系统内


487
00:21:30,691 --> 00:21:32,659
我们不做任何禁用或启动


488
00:21:32,826 --> 00:21:33,760
我们只是保持动态


489
00:21:34,361 --> 00:21:35,195
好极了


490
00:21:35,829 --> 00:21:36,897
所以最后


491
00:21:36,964 --> 00:21:39,733
让我在UISnapBehav
ior上为你做一个快速更新


492
00:21:39,800 --> 00:21:42,503
如果再次你调用UISnapBeha
vior 它能做的更多


493
00:21:42,803 --> 00:21:46,139
它可以被用来将一个视图从一个位置
移动到另一个位置


494
00:21:46,206 --> 00:21:47,107
并有一种快动效果


495
00:21:47,941 --> 00:21:50,244
通过SnapBehavior
你可以定制快拍阻尼


496
00:21:50,310 --> 00:21:53,113
这样确实可以调节


497
00:21:53,180 --> 00:21:54,815
感觉上的快慢


498
00:21:55,616 --> 00:21:58,018
在iOS 9中 我们也新增了


499
00:21:58,085 --> 00:22:00,220
初始化后定制捕捉点的功能


500
00:22:00,287 --> 00:22:01,822
同样相当不错


501
00:22:02,089 --> 00:22:03,357
这里让我看一个简单的例子


502
00:22:03,991 --> 00:22:08,262
所以 如果我们试着平移视图
那么打开调试功能


503
00:22:08,629 --> 00:22:11,598
就会回到如最初捕捉点的屏面


504
00:22:12,032 --> 00:22:14,601
如果我们轻敲另一个位置
就会对齐到新点


505
00:22:14,701 --> 00:22:16,203
即在现有动态特性基础上


506
00:22:16,503 --> 00:22:18,105
调节捕捉点


507
00:22:18,472 --> 00:22:19,306
相当不错


508
00:22:19,640 --> 00:22:22,976
你还会注意到 有了调试叠加图


509
00:22:23,544 --> 00:22:25,646
这些实际上都是自行合成


510
00:22:25,712 --> 00:22:29,082
这里4个附件 配置如弹簧


511
00:22:29,516 --> 00:22:31,885
把视图对齐到新位置


512
00:22:31,952 --> 00:22:32,786
确实非常棒


513
00:22:33,554 --> 00:22:34,388
所以 这就是


514
00:22:34,454 --> 00:22:36,857
UIKit Dynamics
和iOS 9中新增的内容


515
00:22:37,391 --> 00:22:38,759
我要把它交给大卫


516
00:22:38,825 --> 00:22:39,927
让他谈谈视觉效果


517
00:22:46,500 --> 00:22:47,334
各位早上好


518
00:22:47,734 --> 00:22:49,870
那么我们接下来要谈谈利用视觉效果


519
00:22:49,937 --> 00:22:51,471
为你的应用增加新模式


520
00:22:52,272 --> 00:22:56,009
那么我们用一个简单的图像浏览器应用
示例来形象地加以说明


521
00:22:56,343 --> 00:23:00,180
这里 我们要
向用户额外介绍一下


522
00:23:00,247 --> 00:23:01,748
他们目前正在看的图片


523
00:23:02,316 --> 00:23:05,519
看右边 图像上面


524
00:23:05,586 --> 00:23:06,553
有点叠加部分


525
00:23:06,620 --> 00:23:09,122
是我们图像的文件名


526
00:23:09,690 --> 00:23:11,892
所以我们要看看如何创建


527
00:23:13,160 --> 00:23:15,229
那么 第一步是你要


528
00:23:15,295 --> 00:23:16,330
形成一种模糊效果


529
00:23:16,864 --> 00:23:19,199
我们有3种模式 超亮、


530
00:23:19,299 --> 00:23:20,467
明亮及阴暗模式


531
00:23:22,302 --> 00:23:25,172
你通过这些模式形成一种模糊效果


532
00:23:25,572 --> 00:23:27,341
就是那样


533
00:23:27,908 --> 00:23:30,444
最后 你用模糊模式形成


534
00:23:30,611 --> 00:23:31,712
你的视觉效果图


535
00:23:32,312 --> 00:23:34,248
之后只要添加你需要的布局


536
00:23:34,548 --> 00:23:36,350
你就能够得到屏面上你看到的模糊效果


537
00:23:38,085 --> 00:23:39,820
下一步 我们要添加振动效果


538
00:23:39,887 --> 00:23:42,523
振动的作用是 使某物在模糊模式


539
00:23:42,589 --> 00:23:44,958
突然弹出


540
00:23:46,159 --> 00:23:47,928
所以接下来 我们要


541
00:23:47,995 --> 00:23:49,763
通过模糊效果形成振动效果


542
00:23:49,930 --> 00:23:51,698
如上面提到的 确实要要模糊叠加


543
00:23:51,765 --> 00:23:54,234
所以我们从模糊效果开始


544
00:23:54,301 --> 00:23:55,536
形成振动效果


545
00:23:56,603 --> 00:23:57,905
我们形成振动效果


546
00:23:57,971 --> 00:23:59,173
正如我们之前形成模糊效果


547
00:24:00,174 --> 00:24:01,742
此时 我们要


548
00:24:01,808 --> 00:24:04,278
在模糊视图中添加内容视图


549
00:24:04,344 --> 00:24:07,147
现在 不必直接加到模糊视图上


550
00:24:07,214 --> 00:24:10,384
而应是在视觉效果图后


551
00:24:10,450 --> 00:24:11,351
有一个模糊视图


552
00:24:12,419 --> 00:24:14,288
最后 我们


553
00:24:14,354 --> 00:24:16,223
在振动视图的内容视图上加标签


554
00:24:16,823 --> 00:24:19,326
视觉效果图的内容视图上


555
00:24:19,393 --> 00:24:21,295
加这些东西是要确保


556
00:24:21,361 --> 00:24:23,797
你给出的所有内容


557
00:24:23,864 --> 00:24:24,698
效果无误


558
00:24:26,166 --> 00:24:27,434
所以 当你完成这些之后


559
00:24:27,901 --> 00:24:30,304
模糊视图顶部就有了可爱的标签


560
00:24:30,404 --> 00:24:31,638
正如你在屏面上看到的那样


561
00:24:32,406 --> 00:24:33,907
那么iOS 9有什么新东西呢


562
00:24:34,541 --> 00:24:37,077
首先我们使得


563
00:24:37,144 --> 00:24:40,380
你的视图边界有清新的动画效果


564
00:24:40,848 --> 00:24:42,783
在模糊视图中你可以向用户显示更多信
息


565
00:24:42,850 --> 00:24:45,919
而无需做任何复杂的工作


566
00:24:46,887 --> 00:24:48,689
但是 除此之外 我们让你能够


567
00:24:48,755 --> 00:24:50,057
让模糊视图生动有趣


568
00:24:52,125 --> 00:24:54,728
那么现在 比如
如果你的app有夜间加载模式


569
00:24:54,795 --> 00:24:56,930
你在你的应用中可以日夜都采用非常清
新的动画


570
00:24:56,997 --> 00:24:58,966
并推动用户


571
00:25:00,267 --> 00:25:02,102
接下来我们要简要介绍


572
00:25:02,169 --> 00:25:04,972
我们如何切实地把这些效果搬上屏面


573
00:25:05,072 --> 00:25:08,008
它做什么用 以及你为什么需要知道


574
00:25:08,075 --> 00:25:09,843
这很重要 因为所有这些都会影响


575
00:25:09,910 --> 00:25:11,345
性能和修正


576
00:25:12,145 --> 00:25:13,881
这里 小婴儿Sophia带我们看


577
00:25:13,947 --> 00:25:18,318
如何向她的小UI加一点叠加内容


578
00:25:19,253 --> 00:25:20,854
那么先想想


579
00:25:20,921 --> 00:25:21,822
我们要捕捉哪里


580
00:25:22,489 --> 00:25:23,957
我们只要看到一个视觉效果


581
00:25:24,024 --> 00:25:26,426
就知道我们需要捕捉的内容


582
00:25:26,860 --> 00:25:27,895
我们将它从屏面移开


583
00:25:28,729 --> 00:25:30,330
这样我们就把这个小东西拷贝了出来


584
00:25:30,964 --> 00:25:33,233
现在
它从屏面上下来了 我们可以用它了


585
00:25:33,300 --> 00:25:34,701
但是我们为什么将它从屏面取下


586
00:25:35,102 --> 00:25:37,304
好 有一个原因是我们需要确保


587
00:25:37,371 --> 00:25:39,139
我们获得正确的效果
而且在这种情况下


588
00:25:39,206 --> 00:25:41,275
我们捕获了我们需要用于模糊的所有一
切内容


589
00:25:41,341 --> 00:25:42,376
为了达到那种模糊效果


590
00:25:42,709 --> 00:25:44,077
而且我们经常离屏做这些事情


591
00:25:44,144 --> 00:25:46,580
这样
我们就不会弄乱屏幕上已经做好的内容


592
00:25:46,647 --> 00:25:48,549
当我们正在离屏做出这样效果的时候


593
00:25:49,783 --> 00:25:51,518
于是我们将这个模糊效果应用在它这里


594
00:25:52,419 --> 00:25:54,354
最后 我们把它复制回原来的位置


595
00:25:54,421 --> 00:25:55,856
即效果视图对它所要求的位置


596
00:25:56,823 --> 00:25:58,825
而所有这些给了我们一个定义


597
00:25:58,892 --> 00:26:01,929
它定义的是你以前可能已经听说过的一
个东西 即所谓“离屏通过”


598
00:26:01,995 --> 00:26:05,465
就是无论什么时候我们获得一个内容
我们将它复制到屏幕以外


599
00:26:05,866 --> 00:26:07,835
做好后 再把它返回到屏幕上


600
00:26:09,336 --> 00:26:11,805
那么有什么其他方法
我们可以得到“离屏通过”？


601
00:26:12,873 --> 00:26:14,007
好
正如你所看到的


602
00:26:14,074 --> 00:26:15,275
我们已经有了Alpha


603
00:26:15,542 --> 00:26:17,311
而且你可以看到你做那种效果的方法


604
00:26:17,377 --> 00:26:18,946
因为如何你有一个复杂的视图层次


605
00:26:19,179 --> 00:26:20,581
其中需要Alpha


606
00:26:20,647 --> 00:26:23,217
那么我们就不能只把Alpha适用于
单个视图


607
00:26:23,283 --> 00:26:24,551
因为你将得不到正确的效果


608
00:26:25,152 --> 00:26:28,155
相反
我们需要获得整个复杂的视图层次


609
00:26:28,222 --> 00:26:31,391
通过离屏获得它渲染它
然后将Alpha应用到整个事情


610
00:26:32,025 --> 00:26:34,294
遮罩在它的背后有一个非常相似的推理


611
00:26:34,361 --> 00:26:36,263
在那个推理中我们需要将所有像素用于
遮罩


612
00:26:39,166 --> 00:26:42,336
正如我们刚才提到的
模糊和虚化也是通过离屏完成的


613
00:26:43,303 --> 00:26:44,872
但快照不是 为什么是这样呢？


614
00:26:44,938 --> 00:26:45,806
你可能会问自己


615
00:26:46,573 --> 00:26:48,208
嗯 首先 什么是快照？


616
00:26:48,509 --> 00:26:51,345
我们已经有了这两种UIView方法
一种是在屏幕更新后


617
00:26:51,411 --> 00:26:53,614
获得屏幕快照
然后以矩形绘制出视图层次


618
00:26:54,181 --> 00:26:57,150
一种是UIScreen方法
即在屏幕更新后获得快照视图


619
00:26:57,651 --> 00:27:00,621
而且所有这些都会把快照上的内容返回
给你


620
00:27:01,321 --> 00:27:03,857
那么 快照基本上是做同样的事情


621
00:27:03,924 --> 00:27:06,960
即如“离屏通过”做的一样
但让你能够控制最后一个步骤


622
00:27:07,027 --> 00:27:08,195
从而将内容复制回屏幕


623
00:27:09,263 --> 00:27:11,832
我们获得了所有你要求我们进行快照的
内容


624
00:27:11,965 --> 00:27:14,268
对它进行离屏渲染
然后返给你一个视图


625
00:27:14,334 --> 00:27:17,271
或者代表那个图像的像素内容


626
00:27:18,672 --> 00:27:20,974
但是 再一次想问的是 这与确保


627
00:27:21,041 --> 00:27:22,509
你的效果必须正确无误有关吗？


628
00:27:22,843 --> 00:27:23,677
好


629
00:27:23,744 --> 00:27:27,114
不幸的是如果你得到的视觉效果陷入了


630
00:27:27,181 --> 00:27:28,448
这一点
正如你可以看到的


631
00:27:28,515 --> 00:27:29,983
索̨菲亚已经
失去了她的模糊度


632
00:27:30,050 --> 00:27:32,886
而这就是你在视觉效果完成后将在屏幕
上所看到的内容


633
00:27:33,120 --> 00:27:34,755
视学效果是你离屏时所得到的


634
00:27:34,821 --> 00:27:36,223
它是你事先没有想到会遇到的


635
00:27:38,592 --> 00:27:40,527
好
重新回到这里


636
00:27:40,928 --> 00:27:43,130
我敢肯定你们今年都已经
参加过多任务会议


637
00:27:43,197 --> 00:27:45,199
如果没有
你可以下课后看看它们的视频


638
00:27:45,632 --> 00:27:48,101
但在所有事情当中
即你需要启动一个非常好的App


639
00:27:48,168 --> 00:27:49,503
以参与多任务处理


640
00:27:49,570 --> 00:27:51,305
其中关键的一点是屏幕上要有好的表现


641
00:27:51,371 --> 00:27:54,441
因为现在你的App的表现
也会影响到其他正在运行的App


642
00:27:55,042 --> 00:27:57,811
所以 既然我们在这个特殊的例子中
没有出现任何滚动


643
00:27:57,878 --> 00:28:01,048
那么我们就可以决定
让我们不要一直保持对模糊进行渲染


644
00:28:01,114 --> 00:28:02,649
让我们只是为它照一个快照好了


645
00:28:02,816 --> 00:28:06,320
因此我们决定为那个特殊的视觉效果图
照一个快照


646
00:28:07,521 --> 00:28:11,658
但随后发生的事情是捕捉区域
是离屏完成的


647
00:28:12,092 --> 00:28:14,561
而且由于你只快照了视觉效果图


648
00:28:15,495 --> 00:28:17,331
因此在捕捉区域上什么也没有


649
00:28:17,898 --> 00:28:21,068
这样一来捕捉区域什么也没带给你
而且模糊功能也没有可以模糊的


650
00:28:21,134 --> 00:28:23,003
你得到的是你之前看到的被破坏的效果


651
00:28:24,037 --> 00:28:25,305
所以 既然我们已经看到


652
00:28:25,639 --> 00:28:28,742
你是如何破坏了你的效果
那我们能做些什么来解决这个问题呢？


653
00:28:29,243 --> 00:28:31,111
好了 第一件事就是


654
00:28:31,178 --> 00:28:33,747
我们有了这个简便的方法
即用于视觉效果图上的方法


655
00:28:34,014 --> 00:28:35,449
所谓的“这个效果怎么了？”


656
00:28:43,357 --> 00:28:46,860
就像使用动态调试标志


657
00:28:46,927 --> 00:28:50,063
在SDK中不是这样的 但你可以


658
00:28:50,130 --> 00:28:51,765
从调试器中调用它 就像这个一样


659
00:28:52,432 --> 00:28:55,736
你会得到一个字符串
看起来和这个有点像


660
00:28:56,270 --> 00:28:58,872
在这种情况下
我们发现在层次结构上的某个地方


661
00:28:58,939 --> 00:29:01,642
有一个遮罩视图 它造成的视觉效果


662
00:29:01,708 --> 00:29:04,511
需要在屏幕外来完成
因此无法捕获尽可能多的


663
00:29:04,578 --> 00:29:06,280
它所需要的内容
以便进行正确的渲染


664
00:29:07,848 --> 00:29:09,082
那么如何解决这一问题呢？


665
00:29:10,751 --> 00:29:12,953
第一种方式
如果你使用的是Alpha


666
00:29:13,020 --> 00:29:15,489
或者遮罩这项工作实际上是重新排列你
的视图层次


667
00:29:15,622 --> 00:29:18,792
我们在这里所拥有的只是一些容器
或许窗口


668
00:29:19,026 --> 00:29:19,960
和一个容器视图


669
00:29:20,027 --> 00:29:22,162
包含一个模糊和更多的内容


670
00:29:22,563 --> 00:29:24,631
那么
在这种情况下 模糊实际上并不需要


671
00:29:24,698 --> 00:29:26,733
加入我们所拥有的Alpha或者遮罩


672
00:29:27,501 --> 00:29:30,637
所以我们只是重新安排
以便将模糊作为第一个子视图


673
00:29:30,771 --> 00:29:33,273
将容器作为第二个子视图
这样一来容器


674
00:29:33,340 --> 00:29:35,609
和它里面的一切都将渲染于模糊的顶部


675
00:29:35,909 --> 00:29:38,378
而且我们可以将Alpha或
遮罩适用于这个容器视图


676
00:29:38,445 --> 00:29:39,479
却不会搞乱我们的模糊


677
00:29:40,948 --> 00:29:42,883
我们能为遮罩做的第二件事是


678
00:29:43,383 --> 00:29:45,686
不是将容器视图进行遮罩


679
00:29:46,620 --> 00:29:47,855
而且我们可以将那个遮罩


680
00:29:48,021 --> 00:29:51,091
向下移动到我们实际上需要遮罩的内容
上


681
00:29:51,959 --> 00:29:53,260
现在 正如我们前面所提到的


682
00:29:53,327 --> 00:29:54,995
遮罩往往会采取“离屏通过”


683
00:29:55,195 --> 00:29:56,697
所以你在做这样的转换时


684
00:29:56,763 --> 00:29:58,131
应该非常地小心谨慎


685
00:30:00,667 --> 00:30:02,736
最后
通过快照 正如我们前面提到的


686
00:30:02,803 --> 00:30:05,072
快照只会捕获你告诉它需要做的


687
00:30:05,672 --> 00:30:06,773
所以
在这种情况下


688
00:30:06,840 --> 00:30:09,910
我们要求快照的内容视
图中 有一定的透明度


689
00:30:09,977 --> 00:30:11,678
这样
我们就可以看到它背后的东西


690
00:30:11,745 --> 00:30:14,715
但是如果我们只快照了那个视图
那么我们在模糊中将得不到透明度


691
00:30:14,781 --> 00:30:16,116
它会看起来有点滑稽


692
00:30:16,550 --> 00:30:18,352
因此 当我们一直向上移动快照时


693
00:30:18,418 --> 00:30:20,621
窗口通常是最容易做的事情


694
00:30:21,221 --> 00:30:23,357
但有时你可能需要
一直将它向上移动到屏幕上


695
00:30:23,924 --> 00:30:25,993
所以
如果你要快照模糊 你应该确保


696
00:30:26,059 --> 00:30:28,428
你在快照时尽量远离模糊内容


697
00:30:28,495 --> 00:30:30,998
以确保你得到你所需要的
一切


698
00:30:32,666 --> 00:30:35,936
然后有了这些
让我们转到有关动态和自动布局的


699
00:30:36,003 --> 00:30:37,371
一些最佳做法


700
00:30:41,341 --> 00:30:42,776
所以
你可能要做的第一件事是


701
00:30:42,843 --> 00:30:44,745
你可能需要
使相当复杂的


702
00:30:44,811 --> 00:30:46,847
视图层次在动态系统内发生作用


703
00:30:47,915 --> 00:30:50,150
而你想要的是使外部视图加入


704
00:30:50,217 --> 00:30:52,686
动态系统而不是内部视图


705
00:30:52,753 --> 00:30:53,787
它们的布局将正如


706
00:30:53,854 --> 00:30:55,822
你用其他内容所做的布局的一样


707
00:30:56,056 --> 00:30:59,760
所以 你可以将UIKit
Dynamics用于外部视图


708
00:30:59,960 --> 00:31:02,462
这只需要将
“自动调整遮罩大小转变为约束”


709
00:31:02,529 --> 00:31:03,931
变为“真”即可


710
00:31:04,097 --> 00:31:06,300
是的在WWDC中唯一的幻灯片里
讲的是“真”


711
00:31:09,169 --> 00:31:10,737
然后你就可以使用“自动布局”


712
00:31:10,804 --> 00:31:12,506
将所有其他的东西正好放置于视图里面


713
00:31:12,573 --> 00:31:14,675
就像你经常做的一样
或者使用新的句法


714
00:31:14,741 --> 00:31:15,976
即如幻灯片上所显示的一样


715
00:31:17,411 --> 00:31:20,247
你可以做的另一件事是
你在动态系统里经常会有


716
00:31:20,314 --> 00:31:23,483
各种项目
但你可能对它们作了标记


717
00:31:23,550 --> 00:31:25,819
它们不应该参与 但需要跟随


718
00:31:26,253 --> 00:31:28,522
所以在这里Lola有她的小标签


719
00:31:28,856 --> 00:31:31,458
上面写了文件名是什么
而我们只有这个锚点


720
00:31:31,525 --> 00:31:33,427
它代表了我们的自动布局约束


721
00:31:33,794 --> 00:31:36,830
然后当动态图起作用并准备四处移动L
ola时


722
00:31:37,030 --> 00:31:39,533
标签也跟着一起动 但标签最终不会


723
00:31:39,600 --> 00:31:41,001
与动态图有互动


724
00:31:43,036 --> 00:31:45,472
最后你可以使用动态图来操作


725
00:31:45,539 --> 00:31:47,307
其方法是创建一个自定义动态项目


726
00:31:47,441 --> 00:31:48,675
正如麦克前面所提到的


727
00:31:49,843 --> 00:31:51,545
你只需要将
NSObject划入子类


728
00:31:51,612 --> 00:31:53,580
或者其他适当的对象类


729
00:31:55,048 --> 00:31:57,084
只要符合UI动态项目协议


730
00:31:58,151 --> 00:31:59,753
并提供了所需要的方法


731
00:32:00,654 --> 00:32:02,222
对于Bounds 有的尺寸...


732
00:32:02,289 --> 00:32:04,791
它不能是“00”
或者动态系统准备


733
00:32:06,193 --> 00:32:08,262
抛出一个异常...
然后你执行居中和转换


734
00:32:08,362 --> 00:32:10,764
并按顺序使用这些数值


735
00:32:10,831 --> 00:32:12,999
以构建自动布局约束


736
00:32:13,233 --> 00:32:15,335
或者改变你系统外部的一些东西


737
00:32:16,470 --> 00:32:19,373
然后关闭 我们将给你一个演示
你也可以做到这样


738
00:32:25,812 --> 00:32:27,247
所以我们这里得到的是什么？


739
00:32:28,248 --> 00:32:30,017
对 同刚才一样
是一个简单的应用程序


740
00:32:30,250 --> 00:32:31,585
它刚刚显示了一张照片


741
00:32:31,652 --> 00:32:34,054
但是
我们希望能够以某种风格向用户展示


742
00:32:34,121 --> 00:32:35,789
照片里人的面部


743
00:32:36,056 --> 00:32:37,324
所以
当我们点击


744
00:32:37,391 --> 00:32:39,993
我们的动态项目时系统就
会伸出


745
00:32:40,060 --> 00:32:41,395
并且在那个模糊中出现动画


746
00:32:42,129 --> 00:32:43,830
如果你再次点击 当然 它的移动


747
00:32:43,897 --> 00:32:45,432
会出现更好一点的效果


748
00:32:46,433 --> 00:32:49,036
但是如果你继续点击 你就可以看到


749
00:32:49,102 --> 00:32:51,638
它在动态系统上的反应非常流畅


750
00:32:52,306 --> 00:32:54,741
并且不具有非常固定的、僵硬的路径


751
00:32:55,475 --> 00:32:58,879
所以它对于用户正在做的动作做出恰好
的反应


752
00:32:59,713 --> 00:33:01,148
那么 我们是如何做到这个的？


753
00:33:02,449 --> 00:33:03,884
所以
我们做的第一件事是


754
00:33:03,951 --> 00:33:05,485
我们使这个面部
执行布局向导


755
00:33:06,019 --> 00:33:07,988
这正好是UI布局向导的一个子类


756
00:33:08,288 --> 00:33:11,391
而在它的内部是一点点的动态


757
00:33:11,825 --> 00:33:14,561
我们将这个面部布局向导执行动态项目
也就是再一次


758
00:33:14,628 --> 00:33:17,431
将NSObject划入子类
并符合UI动态项目


759
00:33:18,265 --> 00:33:19,900
并且它将管理一个约束


760
00:33:20,300 --> 00:33:24,037
然后通过将该约束的常数
设置为中心点的x值


761
00:33:24,104 --> 00:33:27,407
或y值 不管该约束是如何变化的


762
00:33:30,043 --> 00:33:33,680
在这里 当你设置布局向导时


763
00:33:34,014 --> 00:33:35,582
它就会得到一个中心位置


764
00:33:35,849 --> 00:33:38,385
并且创建了四个额外的动态项目


765
00:33:38,652 --> 00:33:40,354
在系统中表示上、左、下


766
00:33:40,420 --> 00:33:41,955
和右


767
00:33:43,156 --> 00:33:45,259
我们将它分配到约束
而约束刚好从动态项目的


768
00:33:45,325 --> 00:33:47,861
左上角发生作用


769
00:33:48,495 --> 00:33:50,597
以及从动态项目参考视图


770
00:33:51,565 --> 00:33:54,067
而我们使用滑块附件以限制


771
00:33:54,134 --> 00:33:56,103
这四个动态项目相对于该位置


772
00:33:56,170 --> 00:33:57,237
可以去的范围大小


773
00:33:57,638 --> 00:33:59,973
这可保证它避免飞到系统外


774
00:34:00,040 --> 00:34:01,909
或者折叠到一个过小的位置


775
00:34:03,911 --> 00:34:05,045
现在 在视图控制器里


776
00:34:05,112 --> 00:34:08,014
我们得到这种行为的方式
是我们有一个


777
00:34:08,081 --> 00:34:09,416
沿着面部布局向导的重力行为


778
00:34:09,483 --> 00:34:10,817
然后在彼此的顶部将它们居中


779
00:34:10,884 --> 00:34:12,351
因此当重力发生变化时


780
00:34:12,418 --> 00:34:13,954
布局向导将会适当地移动


781
00:34:15,188 --> 00:34:17,090
我们从故事板中得到模糊效果


782
00:34:17,157 --> 00:34:18,792
这样我们不必不断地摆弄它


783
00:34:18,859 --> 00:34:21,195
如果我们决定要改变我们使用的风格


784
00:34:22,829 --> 00:34:26,099
我们使用约束将那个模糊视图


785
00:34:26,366 --> 00:34:27,568
附加到面部布局向导上


786
00:34:27,900 --> 00:34:29,803
因此 当此向导改变了尺寸


787
00:34:29,870 --> 00:34:31,538
模糊视图也会随之改变


788
00:34:33,005 --> 00:34:35,842
现在
为了使它看起来像是模糊视图切割了


789
00:34:35,909 --> 00:34:38,411
除面部以外的所有东西
对此我们确实有一个小窍门


790
00:34:38,679 --> 00:34:40,813
我们做了一个原始图像的顶替图像


791
00:34:40,981 --> 00:34:44,284
刚好切出我们需要的图像
给它们一个遮罩


792
00:34:44,618 --> 00:34:47,754
并创造更多的UI图像视图放置于


793
00:34:47,821 --> 00:34:48,956
已经在那里的视图的顶部


794
00:34:49,456 --> 00:34:52,125
所以它看起来好像模糊刚好遮挡着面部


795
00:34:52,192 --> 00:34:54,194
但实际发生的事情是
你所看到的视图


796
00:34:54,261 --> 00:34:56,830
被放置在顶部
而面部从它们上面切除


797
00:34:58,465 --> 00:35:01,368
最后 我们对这个视图
点击我们设置的手势识别器


798
00:35:01,435 --> 00:35:04,438
得到的正好是
使我们的动态系统发生改变的东西


799
00:35:06,206 --> 00:35:08,141
当我们要暴露面部时


800
00:35:08,475 --> 00:35:09,743
我们只需要改变重力就可以


801
00:35:09,810 --> 00:35:13,046
所以重力通常是造成一切被拉向
中心的原因


802
00:35:13,347 --> 00:35:16,650
但当我们打开它时
它像一个反重力一样想推开一切东西


803
00:35:18,385 --> 00:35:19,653
然后我们利用以下这个事实


804
00:35:19,720 --> 00:35:21,822
即我们通常在这个过程中
始终布局子视图


805
00:35:22,189 --> 00:35:24,758
以实际地触发模糊动画进入或退出


806
00:35:25,792 --> 00:35:29,162
而所有这些都是为了建设
这个非常好的效果


807
00:35:29,363 --> 00:35:33,300
我们所依靠的是自动布局
和动态都可以很容易地提供给你


808
00:35:33,967 --> 00:35:35,736
至此我们将回到幻灯片来做一个结束


809
00:35:39,373 --> 00:35:40,674
总而言之


810
00:35:41,675 --> 00:35:45,279
我们希望你能够使用这些技术
以真正地改善用户体验


811
00:35:45,746 --> 00:35:47,915
所以 当你添加一个模糊
你添加了它


812
00:35:47,981 --> 00:35:51,985
这样你就可以通过其他的信息
来弥补你的内容


813
00:35:52,319 --> 00:35:53,453
当你使用动态


814
00:35:53,520 --> 00:35:56,990
你可以有一个反应刚刚好的用户界面


815
00:35:57,057 --> 00:35:59,226
并且正如用户对他们输入内容
的期待一样


816
00:35:59,993 --> 00:36:02,629
但是你也需要考虑到表现
当你在做这些事情时


817
00:36:02,996 --> 00:36:05,432
因为如果你有很多在屏幕上的动态项目


818
00:36:05,499 --> 00:36:07,501
它们能够使用户界面真正陷入困境


819
00:36:07,835 --> 00:36:10,204
而且你不会得到你所期待的的物理现象


820
00:36:10,537 --> 00:36:11,872
所以请谨慎地使用


821
00:36:13,040 --> 00:36:15,576
而且对于视觉效果
如果你有很多这样的效果


822
00:36:15,642 --> 00:36:17,544
你最终将有很多“离屏通过”


823
00:36:17,711 --> 00:36:19,446
并且这也会招致相当高的成本


824
00:36:21,748 --> 00:36:24,284
这些都是与课程相关的内容
这是我们今天为你准备的


825
00:36:24,518 --> 00:36:26,954
不幸的是其中大部分都在之前发生过


826
00:36:27,187 --> 00:36:29,523
仅有一个没有发生
而且是与我们一起出现的


827
00:36:29,590 --> 00:36:31,892
即所谓
“通过GCD建立响应和效率的App”


828
00:36:33,060 --> 00:36:35,562
而且我们在此之后将在实验室里回答
你的所有问题


829
00:36:35,629 --> 00:36:38,632
并帮助你避免出现
你这一年遇到的大部分情况


830
00:36:40,801 --> 00:36:42,503
我们已经有了各种文档


831
00:36:42,769 --> 00:36:46,139
以及你以前在演示中看到的
用于StickyCorners样本的组装代码


832
00:36:46,206 --> 00:36:47,341
将会提供给你


833
00:36:47,908 --> 00:36:50,677
而且 当然 寇特·罗斯特
将通过电子邮件回答大家的提问


834
00:36:51,979 --> 00:36:53,780
我很高兴你们在周五
坚持与我们一起学习


835
00:36:53,847 --> 00:36:56,550
我希望你拥有一个伟大的WWDC
并祝大家一路平安

