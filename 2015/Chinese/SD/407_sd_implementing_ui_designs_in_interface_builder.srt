1
00:00:20,621 --> 00:00:23,090
在Interface Builder中执行用户界面设计


2
00:00:26,360 --> 00:00:27,261
谢谢


3
00:00:30,364 --> 00:00:32,466
下午好 欢迎大家吃完午餐后回来


4
00:00:32,633 --> 00:00:34,768
我猜大家是吃了午餐看视频的


5
00:00:35,035 --> 00:00:36,136
我还正在吃我的早餐呢


6
00:00:36,703 --> 00:00:39,239
不管您吃了什么餐 或者您来自哪里


7
00:00:39,373 --> 00:00:42,776
欢迎探讨Core Data线程问题


8
00:00:43,677 --> 00:00:44,545
我只是开了个玩笑


9
00:00:45,179 --> 00:00:46,647
我们来聊聊
Interface Builder


10
00:00:46,713 --> 00:00:48,182
我的名字叫凯文凯文· 凱希


11
00:00:48,248 --> 00:00:50,150
我是一位界面编程工程师


12
00:00:50,217 --> 00:00:51,885
我们今天来做一些不同的事情


13
00:00:52,452 --> 00:00:54,655
介绍Interface 
Builder两个新特性


14
00:00:54,855 --> 00:00:56,456
但是我先想做另外两件事情


15
00:00:56,590 --> 00:01:00,160
第一件我们要给你们一些
更高级的内容提示和技巧最好实例


16
00:01:00,227 --> 00:01:02,296
Interface 
Builder在后台运行的


17
00:01:02,896 --> 00:01:04,397
然后我们要来看一下


18
00:01:04,464 --> 00:01:06,400
Interface Builder
如何帮


19
00:01:06,466 --> 00:01:09,036
在开发自己的应用过程中的每一步的


20
00:01:09,670 --> 00:01:11,004
让我解释得更清楚些


21
00:01:11,772 --> 00:01:12,739
您在这里


22
00:01:12,806 --> 00:01:14,508
您有一个非常棒的点子


23
00:01:15,042 --> 00:01:17,077
现在 可喜的是有其他一些同伴


24
00:01:17,144 --> 00:01:19,313
也觉得您的点子非常棒


25
00:01:19,746 --> 00:01:20,681
可是问题来了


26
00:01:20,747 --> 00:01:22,115
他们生活在世界各地


27
00:01:22,182 --> 00:01:24,451
并且他们使用不同的苹果产品


28
00:01:25,385 --> 00:01:26,220
那您要怎么办呢


29
00:01:26,587 --> 00:01:28,355
首先您要想想您的应用


30
00:01:28,689 --> 00:01:30,123
它会具有一些什么样的特点呢


31
00:01:30,524 --> 00:01:34,695
哪些将成为您会面对的
不同的共享功能块呢


32
00:01:35,028 --> 00:01:38,065
在您思考这些功能块的时候
您将会观察每个独立的场景


33
00:01:38,332 --> 00:01:40,167
并且在每个场景中 继续下去


34
00:01:40,234 --> 00:01:42,002
实际上都会慢慢深入到界面层


35
00:01:42,636 --> 00:01:44,171
好 让我们回到第二步


36
00:01:44,738 --> 00:01:48,876
针对不同的产品
并且是不同的语言来开发界面


37
00:01:48,942 --> 00:01:50,277
那将会是非常大的工作量


38
00:01:50,611 --> 00:01:53,413
Interface Builder
为您节省大量工作


39
00:01:53,647 --> 00:01:55,282
会在任何一个步骤中


40
00:01:56,383 --> 00:02:00,554
我们可将整个过程调制成三个主要步骤


41
00:02:00,721 --> 00:02:03,323
这些步骤将为我们的议题
提供完美的解决方案


42
00:02:03,790 --> 00:02:04,925
我们将开始讨论


43
00:02:04,992 --> 00:02:07,027
设计时用Interface 
Builder


44
00:02:07,094 --> 00:02:09,329
我将提供给大家一些最好的实例


45
00:02:10,030 --> 00:02:11,698
然后我们将稍微揭开一些内幕


46
00:02:11,832 --> 00:02:13,901
Interface 
Builder是怎么工作的


47
00:02:14,368 --> 00:02:17,938
然后
我们将在此次演示中花上大量时间


48
00:02:18,005 --> 00:02:20,240
来讨论运行中的
Interface Builder


49
00:02:20,307 --> 00:02:23,644
不仅讨论在运行时您怎么与它交互


50
00:02:23,944 --> 00:02:25,679
而且讨论您可以怎么样利用不同运行时


51
00:02:25,746 --> 00:02:27,814
操作系统特性的好处


52
00:02:27,881 --> 00:02:29,850
来增强您应用的可适用性


53
00:02:30,751 --> 00:02:33,387
深入讨论设计时刻的
Interface Builder


54
00:02:33,654 --> 00:02:34,922
最好的方法莫过于直接展示


55
00:02:34,988 --> 00:02:37,257
设计时刻的
Interface Builder


56
00:02:38,759 --> 00:02:40,294
在我在讲示例之前 我要告诉大家


57
00:02:40,761 --> 00:02:44,064
在这个示例程序中
我会带给大家5个提示和技巧


58
00:02:44,131 --> 00:02:45,966
5个最好的实例


59
00:02:46,266 --> 00:02:49,369
我们将在
我们正在开发的一个驾车旅行的应用中


60
00:02:49,436 --> 00:02:51,271
增加一些新的功能


61
00:02:51,338 --> 00:02:53,540
我们将增加一个新的标签


62
00:02:53,607 --> 00:02:55,709
让我们可以关注那些正在自驾游的朋友


63
00:03:00,047 --> 00:03:02,015
所以 在这个应用中


64
00:03:02,082 --> 00:03:06,486
我将实现来自一位设计人员的要求
我非常乐于效劳


65
00:03:06,553 --> 00:03:09,590
原因有两个 第一
如果您正在和一个设计师一起工作


66
00:03:09,656 --> 00:03:13,527
他/她在和您一起工作的时候
会跟您说一些行话


67
00:03:14,027 --> 00:03:16,296
第二如果您并没有和一个设计师工作


68
00:03:16,363 --> 00:03:19,533
为了告诉您这些
信息设计应用以及最好设计方法


69
00:03:19,733 --> 00:03:21,535
不一定需要设计师帮助就能完成


70
00:03:23,370 --> 00:03:25,706
我们用静态的模拟性演示


71
00:03:25,772 --> 00:03:30,210
就像您在屏幕上看到的一样
会有两块数据是您需要从这个应用抓取


72
00:03:30,344 --> 00:03:32,713
第一 信息展示的布局 它存放的地方


73
00:03:32,980 --> 00:03:36,216
第二 外观 它长成什么样子


74
00:03:36,750 --> 00:03:38,452
首先我们将从应用布局开始


75
00:03:38,519 --> 00:03:39,853
它将给我们演示


76
00:03:39,920 --> 00:03:43,390
最佳实例一 引用自动布局


77
00:03:43,724 --> 00:03:46,059
特别是引用栈视图


78
00:03:46,960 --> 00:03:49,563
引用自动布局意味着处理视图间的关系


79
00:03:49,630 --> 00:03:53,400
协同抵抗那些对象约束


80
00:03:53,901 --> 00:03:56,837
对于那些过去已经
使用过自动布局的朋友


81
00:03:57,137 --> 00:04:01,008
您就知道和
对象约束一起工作非常灵活和强大


82
00:04:01,475 --> 00:04:02,643
还有一些其他的东西


83
00:04:03,477 --> 00:04:07,681
例如 您需要不停地去定义一套约束


84
00:04:08,182 --> 00:04:09,850
在这里 栈视图就要派上用场了


85
00:04:10,417 --> 00:04:11,885
如果约束只是把


86
00:04:11,952 --> 00:04:16,990
旧有的位置尺寸信息抽象成关系的话


87
00:04:17,156 --> 00:04:18,992
栈视图将走得更远


88
00:04:19,493 --> 00:04:22,529
它将会把这些关系抽象成行为


89
00:04:22,896 --> 00:04:25,599
让我们来进一步应用栈视图
到我们的应用中


90
00:04:26,200 --> 00:04:27,634
切换到Xcode


91
00:04:28,402 --> 00:04:31,205
这里就是我们强大的新功能


92
00:04:31,572 --> 00:04:35,209
直接在Interface
Builder中应用栈视图


93
00:04:35,275 --> 00:04:36,877
我并不认为还有比这更简单的了


94
00:04:36,944 --> 00:04:40,581
我只是简单地选择视图放入栈视图


95
00:04:41,148 --> 00:04:46,453
然后使用画布下方的栈按钮
直接点击


96
00:04:46,520 --> 00:04:47,855
现在 我们就拥有了一个栈视图


97
00:04:48,722 --> 00:04:50,257
一旦我们拥有了栈视图


98
00:04:50,324 --> 00:04:53,694
我们可以就调校栈视图不同的属性


99
00:04:53,861 --> 00:04:55,662
现在 在明天的自动布局课程


100
00:04:55,729 --> 00:04:57,865
他们将深入栈视图所有不同的属性


101
00:04:58,065 --> 00:04:59,266
但是我们将聚焦在一点


102
00:04:59,333 --> 00:05:00,634
那就是对齐


103
00:05:01,468 --> 00:05:03,237
如果我们切换回我的模型


104
00:05:04,538 --> 00:05:06,673
您会看到我的设计师要求


105
00:05:06,740 --> 00:05:09,676
基线与这些标签对齐


106
00:05:10,811 --> 00:05:12,312
什么是基线对齐


107
00:05:13,347 --> 00:05:15,482
基线对齐大致上可以允许您将


108
00:05:15,549 --> 00:05:19,152
不同大小的文字对齐 看起来舒适


109
00:05:19,219 --> 00:05:22,322
如果您有文本性对象像按钮 标签


110
00:05:22,389 --> 00:05:23,624
和分断控制按钮


111
00:05:23,690 --> 00:05:29,997
您想要基线对齐它们
而不是使用居上居中或居下


112
00:05:31,265 --> 00:05:33,834
让我们回到Interface 
Builder我们可以


113
00:05:34,368 --> 00:05:37,371
如果进入属性检测器 我可以做什么


114
00:05:38,639 --> 00:05:43,477
我可改变栈视图的对齐方式为基线对齐


115
00:05:43,544 --> 00:05:44,778
这是第一年也是最后一年


116
00:05:44,845 --> 00:05:46,647
如果您有多行文本的话


117
00:05:46,713 --> 00:05:48,415
您可以根据第一行


118
00:05:48,482 --> 00:05:49,550
或者最后一行文本


119
00:05:49,616 --> 00:05:52,319
在这个例子中 总共就只有一行
也就无关紧要了


120
00:05:53,487 --> 00:05:55,489
看起来真棒 我们选择第一行


121
00:05:56,356 --> 00:05:58,258
让我们继续应用栈视图


122
00:05:58,325 --> 00:06:00,661
我可以将这个标签中的栈放入栈视图


123
00:06:01,228 --> 00:06:02,329
我可以增加图片视图


124
00:06:02,396 --> 00:06:05,132
我把它嵌入到栈视图


125
00:06:05,199 --> 00:06:07,601
Interface Builder
就会自动推理


126
00:06:07,668 --> 00:06:11,071
对齐方向等不同的属性


127
00:06:11,939 --> 00:06:13,841
现在 我们有了这个外部栈视图


128
00:06:13,907 --> 00:06:16,109
我们需要将它放入表单元格


129
00:06:16,210 --> 00:06:17,444
表单元格本身不是栈视图


130
00:06:17,511 --> 00:06:19,880
为了做到这点 我们要使用原始约束


131
00:06:21,281 --> 00:06:25,385
我要去把我的TIE 战斗机


132
00:06:25,886 --> 00:06:30,123
打开来加一些约束 
我要在这个跳出界面上澄清两件事情


133
00:06:30,190 --> 00:06:31,525
第一件


134
00:06:31,592 --> 00:06:33,026
什么是布局边缘


135
00:06:33,093 --> 00:06:34,094
具体指哪些东西


136
00:06:34,895 --> 00:06:37,331
布局边缘就是一个视图上
边缘内侧的空白部分


137
00:06:37,631 --> 00:06:40,467
系统提供了一些默认值


138
00:06:40,534 --> 00:06:43,437
如果您使用布局边缘


139
00:06:43,637 --> 00:06:48,575
它们将根据不同的上下文自动适应
例如不同的设备或者视图层次等级结构


140
00:06:49,443 --> 00:06:54,114
一般地如果您有按钮 标签


141
00:06:54,181 --> 00:06:56,517
这些用户将交互或者看到的内容


142
00:06:56,783 --> 00:06:58,886
如果不是约束到另一个表视图的话


143
00:06:58,952 --> 00:07:00,587
您希望约束它们到边缘


144
00:07:01,221 --> 00:07:02,723
如果您有一些像图片视图


145
00:07:02,789 --> 00:07:05,659
它们待在您整个表视图单元格后面


146
00:07:05,926 --> 00:07:07,661
那把它们约束到边界相比就比较合理


147
00:07:07,728 --> 00:07:09,129
甚至这些边缘会改变


148
00:07:09,196 --> 00:07:11,665
您的图片还是仍然


149
00:07:11,899 --> 00:07:12,833
留在后台


150
00:07:13,567 --> 00:07:16,136
如果我取消选中约束


151
00:07:16,203 --> 00:07:18,539
约束和边缘
您可以在这里看到更大的数据


152
00:07:18,605 --> 00:07:20,807
Interface Builder
默认调整到边缘


153
00:07:20,874 --> 00:07:22,543
非常有帮助
因为这正是我们想要的


154
00:07:23,410 --> 00:07:26,880
第二件我想去澄清的是这里这个
我将要使用的更新框


155
00:07:27,181 --> 00:07:28,448
更新框促成


156
00:07:28,515 --> 00:07:31,752
Interface Builder
移动您在IB画布中的视图


157
00:07:31,818 --> 00:07:33,954
使得它们符合运行时的约束条件


158
00:07:34,421 --> 00:07:36,123
当我增加约束


159
00:07:36,190 --> 00:07:37,658
我有一系列选择去实现


160
00:07:38,425 --> 00:07:40,494
如果我说所有容器内的框架


161
00:07:40,561 --> 00:07:42,963
它指所有在
表视图单元格中的子视图运行时


162
00:07:43,030 --> 00:07:44,498
移动它们到


163
00:07:44,565 --> 00:07:46,266
约束指示的地方


164
00:07:47,367 --> 00:07:51,572
然而 如果我有一个大视图
而其中又有非常多的子视图


165
00:07:52,139 --> 00:07:54,174
也许我只是想移动当前实例


166
00:07:54,241 --> 00:07:56,109
我正在工作的那些东西


167
00:07:56,176 --> 00:07:58,412
这里 我们可以使用折中方案


168
00:07:58,478 --> 00:08:01,715
它只会移动我增加的新约束中的


169
00:08:01,782 --> 00:08:02,950
那些条目


170
00:08:03,784 --> 00:08:05,552
现在 我只剩下一件事情 并不重要了


171
00:08:06,019 --> 00:08:08,989
我们需要给所有框架增加约束


172
00:08:10,257 --> 00:08:11,592
我们正在做着呢


173
00:08:12,192 --> 00:08:14,962
好 下一件事情 我需要更改栈视图中


174
00:08:15,028 --> 00:08:17,030
每一个条目的对齐方式


175
00:08:17,431 --> 00:08:19,099
另一个这么操作的例子


176
00:08:19,166 --> 00:08:21,768
我需要改变它为填充 可是现在


177
00:08:21,902 --> 00:08:24,338
那的确不是我需要寻找的 对吗


178
00:08:25,506 --> 00:08:28,408
栈视图建立在自动布局上


179
00:08:28,475 --> 00:08:30,310
意味着它可以使用约束


180
00:08:30,377 --> 00:08:32,446
去非常好地调校您的布局


181
00:08:33,212 --> 00:08:37,183
所以 如果我想要使这个图片
拥有1比1的比例 甚至是在栈视图中


182
00:08:37,251 --> 00:08:40,354
我仍然可以增加一个约束来增加
一个比例值


183
00:08:41,255 --> 00:08:44,958
然后改变乘数到1比1


184
00:08:47,828 --> 00:08:50,597
接下来我要在图片视图和右手边内容间


185
00:08:50,664 --> 00:08:52,933
增加一些空间


186
00:08:53,901 --> 00:08:56,370
因为我的设计师希望在那里
会有一些间距


187
00:08:57,371 --> 00:08:59,806
现在我需要改变间距的栈视图


188
00:08:59,873 --> 00:09:04,811
完全被标签以及其他栈视图封闭了吗
那我要怎么得到它


189
00:09:05,279 --> 00:09:08,081
Interface Builder
得到封闭视图的几种方法是


190
00:09:08,148 --> 00:09:10,350
我可以使用跳跃条或者使用轮廓视图


191
00:09:10,551 --> 00:09:12,119
但是我要展示我最喜欢的方式


192
00:09:12,186 --> 00:09:14,221
Xcode高级提示一


193
00:09:14,588 --> 00:09:15,656
也是目前最快的选择


194
00:09:16,290 --> 00:09:19,092
如果我按住shift右击或者
control左击


195
00:09:19,159 --> 00:09:21,128
我会在鼠标指示处看到一个全面的列表


196
00:09:21,195 --> 00:09:24,164
那么我就可以简单地选择我需要的


197
00:09:26,200 --> 00:09:28,702
我选好后可以改变间距


198
00:09:29,803 --> 00:09:31,605
到我想要的那样 就是这样


199
00:09:33,006 --> 00:09:35,309
最后一件我想要
演示给你们的关于栈视图的是


200
00:09:35,375 --> 00:09:38,178
您如何同时使用多个栈视图


201
00:09:38,245 --> 00:09:41,181
去获取您想要的布局


202
00:09:41,748 --> 00:09:43,650
如果让我们来看看需求说明


203
00:09:44,985 --> 00:09:48,789
您就能看到这一套标签设计师想要它们


204
00:09:48,856 --> 00:09:51,692
表现得像一个整体并且


205
00:09:51,758 --> 00:09:53,126
垂直居中于表格视图单元格


206
00:09:54,494 --> 00:09:56,563
我们可以把右手边的这些内容


207
00:09:56,630 --> 00:09:58,632
放在另外一个栈视图中并且调整对齐


208
00:09:59,199 --> 00:10:00,133
让我来演示一下


209
00:10:01,101 --> 00:10:04,371
我会使用我的最快选择来到栈视图


210
00:10:05,372 --> 00:10:07,207
我要在另外一个栈视图中嵌入它


211
00:10:08,408 --> 00:10:10,944
您会看到这个蓝色稍有变深


212
00:10:11,478 --> 00:10:14,248
意思是现在可以改变居中对齐了


213
00:10:15,482 --> 00:10:18,118
现在对齐方式影响到了非堆栈方向


214
00:10:18,185 --> 00:10:20,487
因为这是一个垂直栈视图


215
00:10:20,554 --> 00:10:22,556
它将水平对齐


216
00:10:22,623 --> 00:10:24,224
可是我要改变的是垂直对齐方式


217
00:10:24,658 --> 00:10:26,793
所以我要改变通道为水平对齐


218
00:10:28,428 --> 00:10:31,064
您可以看到运用非常小的约束


219
00:10:31,131 --> 00:10:33,734
通过栈视图 
我就能精确得到想要的布局


220
00:10:35,769 --> 00:10:37,838
在应用自动布局时 我们的建议是


221
00:10:37,905 --> 00:10:40,974
使用栈视图并且优先使用它


222
00:10:41,041 --> 00:10:43,777
然后您只需要使用最原始的约束即可


223
00:10:44,178 --> 00:10:45,546
我们认为您可以使用栈视图


224
00:10:45,612 --> 00:10:47,114
来开发大部分UI


225
00:10:47,181 --> 00:10:48,315
这使它变得简单


226
00:10:48,382 --> 00:10:50,284
这使不同布局测试变得简便


227
00:10:50,551 --> 00:10:54,087
不再需要调整一堆约束


228
00:10:54,354 --> 00:10:55,889
维护也变得简单


229
00:10:55,956 --> 00:10:57,224
以后回头只需要


230
00:10:57,291 --> 00:10:59,026
编辑一个您的文件了


231
00:11:00,827 --> 00:11:02,229
好的 这就是


232
00:11:03,463 --> 00:11:06,533
接下来 让我们来看下


233
00:11:06,600 --> 00:11:08,502
我们的应用外观


234
00:11:08,769 --> 00:11:12,673
第一件事情
我需要准备设计时刻的画布


235
00:11:14,708 --> 00:11:16,810
我需要通过编辑画布菜单来做到这点


236
00:11:16,877 --> 00:11:19,012
Interface 
Builder有很多选项


237
00:11:19,079 --> 00:11:20,948
来自定义画在画布上的内容


238
00:11:21,415 --> 00:11:24,084
例如这些栈视图为我创建的蓝色背景


239
00:11:24,151 --> 00:11:26,353
在布局的时候就非常有用


240
00:11:26,420 --> 00:11:29,223
我可以看到栈视图具体多大


241
00:11:29,456 --> 00:11:31,425
可是在设计的时候 我想要看到


242
00:11:31,491 --> 00:11:34,328
它跑起来具体长什么样


243
00:11:34,995 --> 00:11:36,597
所以我就直接关掉这些


244
00:11:38,265 --> 00:11:41,435
好 在示例讲演外观的章节


245
00:11:41,502 --> 00:11:45,072
我们要看下使用Interface 
Builder的3个最佳示例


246
00:11:45,939 --> 00:11:47,274
我们回到我们的需求说明


247
00:11:47,341 --> 00:11:48,842
我们看第一个


248
00:11:49,910 --> 00:11:52,980
我们的设计师定义了页头和页身


249
00:11:53,046 --> 00:11:57,184
而不是外在的字体或者字体大小


250
00:11:57,251 --> 00:11:58,652
这些是什么


251
00:11:58,719 --> 00:12:01,088
这些叫做动态类型风格


252
00:12:01,154 --> 00:12:03,657
它们由系统定义 当您使用它们的时候


253
00:12:03,757 --> 00:12:04,758
它允许系统


254
00:12:04,825 --> 00:12:08,462
自动调整有效的大小和字体


255
00:12:08,529 --> 00:12:12,266
适应在运行时候根据用户偏好的
一系列要求


256
00:12:12,499 --> 00:12:15,669
例如用户可以自行更改为


257
00:12:15,736 --> 00:12:16,970
更大的字体


258
00:12:17,404 --> 00:12:19,373
当您的应用使用了动态类型


259
00:12:19,439 --> 00:12:23,544
它会自动适应那些字体改变
当您使用了自动布局


260
00:12:23,610 --> 00:12:25,245
视图会围绕它而自动调整


261
00:12:26,213 --> 00:12:29,049
在InterfaceBuilder
我们可以非常简单地应用它


262
00:12:30,150 --> 00:12:32,819
我只要选择
我想要使用的自动类型的标签


263
00:12:33,220 --> 00:12:34,254
然后进入视察器


264
00:12:36,557 --> 00:12:41,094
选出一个字体类型而不是外加的字体


265
00:12:41,228 --> 00:12:43,664
在这个例子里我会选择页头


266
00:12:44,264 --> 00:12:45,899
我已经在剩下的标签上应用了它


267
00:12:45,966 --> 00:12:48,335
所以我们动态类型也讲完了


268
00:12:50,804 --> 00:12:52,840
接下来我们要带上


269
00:12:52,906 --> 00:12:55,242
图片视图 我们要使用


270
00:12:55,309 --> 00:12:57,044
两种最好的示例来演示


271
00:12:57,277 --> 00:13:00,080
一个是可设计性 另一个是可视察性


272
00:13:00,747 --> 00:13:04,184
可设计性让在Interface 
Builder画布中可实现


273
00:13:04,251 --> 00:13:05,552
看到我们自定义绘画的代码


274
00:13:06,320 --> 00:13:07,721
让我们来看看一些这样的代码


275
00:13:08,722 --> 00:13:12,359
我要来打开工程导航


276
00:13:12,459 --> 00:13:13,994
增加一些文件


277
00:13:14,361 --> 00:13:16,330
托尼刚上线


278
00:13:16,396 --> 00:13:18,098
远程传送给我这个代码


279
00:13:18,632 --> 00:13:20,467
让我们把它加入我们的工程


280
00:13:21,235 --> 00:13:24,505
然后打开它 打开的时候


281
00:13:24,571 --> 00:13:27,407
我要给大家演示Xcode高级提示三


282
00:13:27,474 --> 00:13:29,076
高级导航


283
00:13:29,810 --> 00:13:34,248
如果option加shift点击这
个文件 我得到一个小显示器


284
00:13:35,749 --> 00:13:39,186
这个显示器允许我更改具体
我想要打开文件的目标


285
00:13:39,520 --> 00:13:42,990
所以我们选择一个新标签
选择一个新分区


286
00:13:43,123 --> 00:13:44,258
如果我有多个标签


287
00:13:44,324 --> 00:13:47,661
我甚至可以选择特定的分区
里面甚至有没有被打开的标签


288
00:13:48,195 --> 00:13:51,465
如果我使用command键
我甚至可以在一个新窗口中打开


289
00:13:52,499 --> 00:13:54,535
在这个示例我只是使用助手编辑器


290
00:13:58,071 --> 00:14:01,608
应用可设计性实际上只需要简单的两步


291
00:14:02,242 --> 00:14:04,745
您所需要做的是用IB可设计性


292
00:14:04,811 --> 00:14:06,346
标记一个UI子视图


293
00:14:06,713 --> 00:14:09,283
然后用它设置一个自定义类


294
00:14:10,751 --> 00:14:13,353
所以我们选择我们的图片视图


295
00:14:13,420 --> 00:14:16,290
或者将要成为我们的图片视图
改变身份检查器


296
00:14:16,356 --> 00:14:20,027
加入我们自定义的子类


297
00:14:20,527 --> 00:14:22,829
Interface Builder
会创建我们的项目


298
00:14:22,896 --> 00:14:26,900
启动一个进程来渲染我们的代码


299
00:14:26,967 --> 00:14:29,236
并在画布中演示出来


300
00:14:30,537 --> 00:14:34,474
如果我们改变代码


301
00:14:34,541 --> 00:14:38,679
它将自动演示这些改变创建它们


302
00:14:39,012 --> 00:14:42,015
并会在Interface 
Builder中应用它们


303
00:14:45,152 --> 00:14:47,721
接下来我们想要采用可视察性


304
00:14:48,088 --> 00:14:51,058
您可以看到在这里我把一些不同的属性
标记为增加IB可视察性


305
00:14:51,124 --> 00:14:53,794
当您标记一个属性为IB可视察性时


306
00:14:53,861 --> 00:14:56,730
Interface Builder
可为您创建一个视察器


307
00:14:57,865 --> 00:15:01,301
如果我选择图片视图来到属性视察器


308
00:15:02,169 --> 00:15:03,770
您可以看到我标记的三个属性


309
00:15:03,837 --> 00:15:06,006
为可视察性 显示在视察器中


310
00:15:06,974 --> 00:15:08,408
我们可以快速采用这些属性


311
00:15:09,142 --> 00:15:13,113
所以我可以说
我要增加那个小图片在那里


312
00:15:13,180 --> 00:15:17,150
我们要使用我们的画笔
如果我回忆正确 说明里说到两点


313
00:15:18,352 --> 00:15:21,321
我们也可以给它一个不错的边缘


314
00:15:22,589 --> 00:15:24,124
现在 这里我们的可设计性


315
00:15:24,191 --> 00:15:25,659
和可视察性在同时工作


316
00:15:25,726 --> 00:15:28,529
来帮助您快速地在您的设计上重复书写


317
00:15:28,695 --> 00:15:32,032
我并没有编译和运行过
但是我可以精确地看到


318
00:15:32,099 --> 00:15:33,767
在运行时候的样子


319
00:15:33,834 --> 00:15:35,402
这都归功于可设计性和可视察性


320
00:15:38,105 --> 00:15:41,341
这就是我们关于运用


321
00:15:41,408 --> 00:15:43,243
动态类型可设计性和可视察性


322
00:15:43,310 --> 00:15:45,179
来调整我们应用外观的章节


323
00:15:47,147 --> 00:15:51,451
现在 我们知道我们的应用


324
00:15:51,518 --> 00:15:53,220
不是都由一个场景组成 


325
00:15:53,854 --> 00:15:57,624
除非您写幻灯片应用大部分情况下


326
00:15:57,691 --> 00:15:59,660
您会有多个场景


327
00:15:59,726 --> 00:16:04,398
如果我放大Storyboard
我可以看到有许多场景


328
00:16:05,332 --> 00:16:08,702
您可以使用Segue
将一个场景加入到您应用的流中


329
00:16:09,403 --> 00:16:12,239
创建一个Segue我可以
control拖拽一个视图控制器


330
00:16:12,306 --> 00:16:15,175
或者一个对象 它将初始化
一个Segue 然后选择


331
00:16:15,242 --> 00:16:17,277
我想要的Segue的类型


332
00:16:17,344 --> 00:16:19,279
在这个例子中我将增加一个关系


333
00:16:19,346 --> 00:16:22,583
来增加另外一个
标签到我们的标签栏控制器


334
00:16:24,318 --> 00:16:26,420
现在我们一旦创建Segue
我意识到我似乎


335
00:16:26,486 --> 00:16:30,123
想要在这个表格视图控制器中实现导航


336
00:16:30,190 --> 00:16:32,226
所以
我将在一个导航控制器中嵌入这个


337
00:16:33,060 --> 00:16:34,294
我将要选择编辑器菜单插入


338
00:16:34,361 --> 00:16:37,831
在一个导航控制器中插入这个


339
00:16:39,166 --> 00:16:42,169
这些是Interface 
Builder会帮到我们的地方


340
00:16:42,236 --> 00:16:43,837
这是另一个Xcode高级提示


341
00:16:44,471 --> 00:16:47,875
Interface 
Builder针对这个特定的场景 


342
00:16:47,941 --> 00:16:49,576
展示了导航条和标签条


343
00:16:49,910 --> 00:16:51,612
这些对象并没有被添加到我们的场景里


344
00:16:51,678 --> 00:16:54,281
Interface Builder
并没有添加这些到场景


345
00:16:54,348 --> 00:16:57,384
它只是让您看到当您给出一些上下文后


346
00:16:57,451 --> 00:17:00,087
您的应用具体看起来会怎么样


347
00:17:00,220 --> 00:17:02,823
这就不需要编译和运行


348
00:17:02,956 --> 00:17:05,492
就能针对不同的上下文进行设计


349
00:17:06,560 --> 00:17:08,762
选择您的视图控制器
您可以看到您的模拟矩阵


350
00:17:08,829 --> 00:17:11,865
这些是属性的名字


351
00:17:12,999 --> 00:17:14,367
然后来到属性视察器


352
00:17:15,368 --> 00:17:17,137
您可以看到我的模拟矩阵


353
00:17:17,570 --> 00:17:19,373
它们都说是被推理的


354
00:17:19,439 --> 00:17:21,775
被推理的
基本上是使用围绕我的上下文


355
00:17:21,974 --> 00:17:25,679
我们知道我们在一个标签控制器里面
我们知道我们在一个导航控制器里面


356
00:17:25,746 --> 00:17:28,448
Interface Builder
就会知道去显示哪个条


357
00:17:28,549 --> 00:17:30,984
我可以覆盖任何这些我想要的


358
00:17:31,652 --> 00:17:34,154
我可以说实际上我想要


359
00:17:34,221 --> 00:17:35,656
它看起来像一个提示框


360
00:17:35,722 --> 00:17:36,857
如果我有内容在这个框里


361
00:17:36,924 --> 00:17:38,792
如果顶部这条是黑色的会怎样


362
00:17:39,860 --> 00:17:41,161
我会把它设置成被推理的


363
00:17:42,362 --> 00:17:46,700
所有这些矩阵数据不会影响


364
00:17:46,767 --> 00:17:49,136
您实际运行时的应用 除了一个例外


365
00:17:49,203 --> 00:17:51,004
那就是尺寸模拟矩阵


366
00:17:51,505 --> 00:17:53,841
尺寸模拟矩阵
实际上会改变视图控制器的尺寸


367
00:17:53,907 --> 00:17:55,876
但是一般情况下


368
00:17:55,943 --> 00:17:58,312
把它放入自动
调整大小的视图控制层次结构


369
00:17:58,812 --> 00:18:01,748
如果您不适用视图控制器
它也是非常有帮助的


370
00:18:01,815 --> 00:18:03,984
例如您想要设置您自己应用的大小


371
00:18:04,852 --> 00:18:08,455
甚至当您的应用运行在不同设备上


372
00:18:08,522 --> 00:18:10,023
您想要设计一个您脑中特定的尺寸


373
00:18:10,090 --> 00:18:12,626
它也将会是有帮助的


374
00:18:12,693 --> 00:18:17,297
我的说明是针对iPhone 6 
Plus的 所以我可以改变


375
00:18:17,364 --> 00:18:20,534
屏幕尺寸为5.5英寸


376
00:18:21,268 --> 00:18:24,771
可以在如此规格尺寸的视图控制器上
进行编辑设计


377
00:18:25,706 --> 00:18:28,275
Interface 
Builder其他属性今天不讨论


378
00:18:28,342 --> 00:18:31,912
它们能够允许您使用预览助手
观察到您的应用在不同的设备上


379
00:18:31,979 --> 00:18:34,381
看起来会怎么样


380
00:18:34,815 --> 00:18:36,984
但是当您脑中有个特定的上下文的时候


381
00:18:37,351 --> 00:18:39,119
这真的会非常有用 好吧


382
00:18:41,421 --> 00:18:42,723
让我们回到推理


383
00:18:42,823 --> 00:18:44,324
让我们完成我们的视图控制器


384
00:18:45,526 --> 00:18:47,861
给它一个标题 朋友


385
00:18:48,896 --> 00:18:50,898
让我们增加一些标签按钮项


386
00:18:52,833 --> 00:18:57,604
我们已经增加
一项这使得我们可以邀请新朋友


387
00:18:58,138 --> 00:19:00,641
使用Xcode 7
我可以增加多个条目项


388
00:19:00,707 --> 00:19:01,942
到我的导航项


389
00:19:10,217 --> 00:19:11,885
这些都是些小功能啊 对吧


390
00:19:14,154 --> 00:19:17,324
让我们使用一个Segue来完成它


391
00:19:17,391 --> 00:19:20,227
使它看起来符合情景


392
00:19:20,294 --> 00:19:24,031
如果您放大看 我们有一个不错的开始


393
00:19:25,632 --> 00:19:28,101
就像我会根据功能或者重用


394
00:19:28,168 --> 00:19:31,572
重构我的代码


395
00:19:31,638 --> 00:19:32,873
到几个不同的文件


396
00:19:32,940 --> 00:19:35,375
我现在使用Interface
可以实现相同的事情了


397
00:19:36,710 --> 00:19:40,013
如果我只是选择我想要的视图控制器


398
00:19:40,080 --> 00:19:43,016
来到编辑器菜单
我可选择重构到Storyboard


399
00:19:44,051 --> 00:19:45,485
您可以写入一个名字 我叫它跟随


400
00:19:45,552 --> 00:19:47,154
因为这是我们的跟随标签


401
00:19:47,387 --> 00:19:50,090
Interface Builder
会创建一个新Storyboard 


402
00:19:50,157 --> 00:19:52,926
把这些
视图控制器移入Storyboard


403
00:19:53,093 --> 00:19:56,530
放置一个关联到我们旧的
Storyboard中的场景


404
00:19:57,097 --> 00:20:00,067
现在我们使用Storyboard
就显得真简单了


405
00:20:10,377 --> 00:20:13,013
让我们回到幻灯片


406
00:20:13,080 --> 00:20:15,015
我们看到相当数量不同的东西


407
00:20:15,082 --> 00:20:16,950
所以让我们简单概述下


408
00:20:19,620 --> 00:20:22,322
我已经给了您5个最好的实例


409
00:20:22,389 --> 00:20:24,992
我们采用了栈视图和动态类型


410
00:20:25,058 --> 00:20:27,294
来增强你们应用的可适应性


411
00:20:27,361 --> 00:20:30,030
我们已经采用可设计性和可视察性


412
00:20:30,097 --> 00:20:32,933
使得在不需要编译和运行的情况下
可以快速显示您的设计


413
00:20:33,300 --> 00:20:35,636
最后
我们使用Storyboard关联


414
00:20:35,702 --> 00:20:38,539
来确保像处理我们的代码那样


415
00:20:38,605 --> 00:20:39,740
模块化我们的界面


416
00:20:41,141 --> 00:20:42,176
我也给了你们一个提示


417
00:20:42,242 --> 00:20:43,710
我希望你们会觉得有帮助


418
00:20:43,777 --> 00:20:47,247
当你们使用Interface 
Builder的时就像可以选择东西


419
00:20:47,314 --> 00:20:48,782
可以自定义画布


420
00:20:48,849 --> 00:20:51,752
使用多个条目项打开正是您想要的文件


421
00:20:51,818 --> 00:20:55,022
当然也可以使用模拟矩阵的好处


422
00:20:55,122 --> 00:20:58,525
在设计的时刻
就能看到您应用的具体情况


423
00:21:00,460 --> 00:21:01,995
可是如果我点击编译会怎样


424
00:21:02,663 --> 00:21:05,632
让我们来讲讲踏它
在编译的时候的一些情况吧


425
00:21:07,167 --> 00:21:09,036
现在 去做到这点 我们需要退后一步


426
00:21:09,102 --> 00:21:11,038
看看设计时刻的情况


427
00:21:11,104 --> 00:21:13,040
在运行的时候 我们会走向哪里


428
00:21:13,607 --> 00:21:16,410
在设计的时候 你们工作于XML文件


429
00:21:16,810 --> 00:21:20,781
在编译的时候
一个叫做IB的进程


430
00:21:20,914 --> 00:21:23,851
把这些文件编译成nib文件


431
00:21:24,184 --> 00:21:27,688
Nib文件是
非常小特别优化了的二进制文件


432
00:21:27,754 --> 00:21:30,891
它使用一个
叫做键值压缩的进程来创建这些


433
00:21:32,559 --> 00:21:34,695
我有一些例子来看下它们是怎么样的


434
00:21:35,362 --> 00:21:37,231
Interface Builder
编译Storyboard


435
00:21:37,297 --> 00:21:38,365
它首先会做两件事情


436
00:21:38,699 --> 00:21:41,969
第一它尝试最优化您应用的性能


437
00:21:42,536 --> 00:21:44,505
第二它会尽可能少地


438
00:21:44,571 --> 00:21:45,973
创建nib文件


439
00:21:46,807 --> 00:21:50,978
如果我有一个视图控制器
它有一个视图和一些子视图


440
00:21:52,312 --> 00:21:55,816
Interface Builder
编译时为此视图控制器创建nib文件


441
00:21:55,883 --> 00:21:57,918
-并且创建一个nib文件给这个视图


442
00:21:59,219 --> 00:22:00,921
为什么是两个nib文件呢


443
00:22:01,488 --> 00:22:04,625
为视图控制器和视图建两个nib文件


444
00:22:04,825 --> 00:22:07,394
意味着视图层次结构可以按照要求加载


445
00:22:08,662 --> 00:22:10,764
来看下这里的另一个示例
它有一个表视图控制器


446
00:22:10,831 --> 00:22:14,067
和一个导航控制器 
看起来甚至更有趣了


447
00:22:14,801 --> 00:22:18,038
它又一次根据Segue
关系创建尽可能少的nib文件 


448
00:22:18,472 --> 00:22:22,176
我们知道那两个视图控制器在一起


449
00:22:22,242 --> 00:22:24,311
所以我们会把它们放入相同的nib中


450
00:22:25,279 --> 00:22:28,749
接下来我们会
给您一个表视图的nib文件


451
00:22:28,982 --> 00:22:31,852
也会为单元格创建一个nib文件


452
00:22:33,387 --> 00:22:35,289
所以在运行的时候这些会怎么样呢


453
00:22:36,623 --> 00:22:40,327
UI Storyboard API
时候分配一个Storyboard


454
00:22:40,460 --> 00:22:44,331
起初您所有分配的内存是分配给


455
00:22:44,398 --> 00:22:46,300
UI Storyboard实例本身


456
00:22:46,533 --> 00:22:48,402
不是视图控制器也不是视图


457
00:22:49,403 --> 00:22:51,371
当您初始化视图控制器时


458
00:22:51,438 --> 00:22:54,541
它将为视图控制器载入nib文件


459
00:22:54,608 --> 00:22:58,111
直到有人要求 
实际并没有视图层次结构被加载


460
00:22:59,713 --> 00:23:02,316
同样的 我给予导航控制器


461
00:23:02,382 --> 00:23:04,885
和表视图控制器一个标示
这样我就可以使用


462
00:23:04,952 --> 00:23:07,588
初始化API来得到


463
00:23:07,654 --> 00:23:09,556
那个视图控制器实例了


464
00:23:09,623 --> 00:23:11,291
但是再一次 直到有人要求它


465
00:23:11,358 --> 00:23:12,893
视图并没有被加载到内存


466
00:23:14,828 --> 00:23:16,897
那这些表视图单元格呢
这里就比较有趣了


467
00:23:17,497 --> 00:23:22,503
Interface Builder
自动地将表视图单元格nib文件同


468
00:23:22,569 --> 00:23:25,272
在您设置的
重用标示器下的表视图注册到一起


469
00:23:25,339 --> 00:23:27,274
那个表视图单元


470
00:23:27,941 --> 00:23:30,043
现在那就意味着这些单元格


471
00:23:30,110 --> 00:23:33,480
在有人使用标示器
实际DQ这个单元格之前


472
00:23:33,547 --> 00:23:34,615
并不会被加载


473
00:23:35,249 --> 00:23:39,119
现在这也意味着
在运行的时候nib文件


474
00:23:39,186 --> 00:23:42,789
如果被加载进内存
它可以快速初始化它


475
00:23:45,292 --> 00:23:46,793
谈到编译时的
Interface Builder


476
00:23:46,860 --> 00:23:48,996
就有一些可以来谈一谈了


477
00:23:49,463 --> 00:23:50,931
第一个就是性能


478
00:23:51,164 --> 00:23:53,600
Interface Builder
代替您


479
00:23:53,800 --> 00:23:56,270
把您的应用性能调到尽可能的好


480
00:23:57,504 --> 00:23:59,706
nib文件只是在需要时被加载


481
00:24:00,040 --> 00:24:03,010
而且nib文件本身也非常小且优化的


482
00:24:04,178 --> 00:24:08,315
Interface Builder
重用了不同的nib文件


483
00:24:08,382 --> 00:24:10,751
例如在这个我们能看到的表视图单元格


484
00:24:11,051 --> 00:24:13,520
一旦运行时拥有nib文件 它就能够


485
00:24:13,587 --> 00:24:17,357
重新快速初始化 因为需要新的单元格


486
00:24:18,592 --> 00:24:21,361
最终您终于看到在编译时刻和运行时刻


487
00:24:21,562 --> 00:24:24,064
所有事物的生命周期


488
00:24:24,264 --> 00:24:26,600
您也懂得了与不同的对象怎么交互


489
00:24:26,800 --> 00:24:28,869
例如视图控制器还有视图层次结构


490
00:24:30,737 --> 00:24:33,440
我们讨论设计时刻
Interface Builder


491
00:24:33,574 --> 00:24:36,043
我们揭开了一些编译时刻的内容


492
00:24:36,510 --> 00:24:38,212
但是我们会花课程剩下的时间来


493
00:24:38,278 --> 00:24:41,181
讨论下运行时的
Interface Builder


494
00:24:41,248 --> 00:24:43,784
在您有那些不同的产品和语言的时候
发生了什么呢


495
00:24:43,917 --> 00:24:46,286
谈及这个我要带上我的同事
托尼 里恰尔迪


496
00:24:50,424 --> 00:24:51,358
谢谢你 凯文


497
00:24:52,826 --> 00:24:53,660
下午好


498
00:24:54,228 --> 00:24:56,897
p我的名字叫托尼 就职于
Interface Builder


499
00:24:58,298 --> 00:25:00,534
凯文已给了您一些超棒的练习


500
00:25:00,601 --> 00:25:04,071
关于在设计时刻创建您的UI
以及他给您看了


501
00:25:04,137 --> 00:25:06,640
在编译的时候发生了些什么


502
00:25:07,174 --> 00:25:09,209
现在我会给您一些例子


503
00:25:09,276 --> 00:25:12,446
教会您怎么在运行的时候增加动态行为


504
00:25:13,981 --> 00:25:16,783
Interface Builder
支持三个一般机制


505
00:25:16,984 --> 00:25:18,986
来控制运行时候的UI


506
00:25:20,087 --> 00:25:21,922
先用IB 
action和IB outlets


507
00:25:21,989 --> 00:25:26,593
在您的Storyboard
和源码之间创建联系


508
00:25:28,462 --> 00:25:31,098
您也可以自定义您Segue的行为


509
00:25:31,532 --> 00:25:33,433
或者动态初始化


510
00:25:33,500 --> 00:25:36,703
及使用Storyboard API
增加视图控制器


511
00:25:38,238 --> 00:25:41,542
最终您可以使用自动布局和自动尺寸


512
00:25:41,675 --> 00:25:44,077
来定义您的UI怎么根据容器的改变


513
00:25:44,144 --> 00:25:45,445
自动适应尺寸


514
00:25:46,213 --> 00:25:47,381
让我们从连接开始


515
00:25:49,183 --> 00:25:51,151
在Swift IB outlets


516
00:25:51,218 --> 00:25:53,787
默认内部展开是可选择的


517
00:25:54,922 --> 00:25:57,224
如果您在视图控制器和


518
00:25:57,291 --> 00:25:59,960
一个它视图层次
中的视图之间创建了outlet


519
00:26:00,027 --> 00:26:02,229
在视图加载后您可以安全地展开


520
00:26:03,764 --> 00:26:05,799
有的时候 您会有外加的属性


521
00:26:05,866 --> 00:26:08,135
储藏在您的视图控制器中 它会影响


522
00:26:08,202 --> 00:26:11,538
视图的外观 如果那样的话 您会想要


523
00:26:11,605 --> 00:26:14,141
使用可选链接同属性的设置观察器一起


524
00:26:14,208 --> 00:26:16,577
展开这个属性


525
00:26:17,311 --> 00:26:19,179
如果您的outlet还没有被链接


526
00:26:21,682 --> 00:26:24,651
IB Action
允许您通过手势识别器和控制器


527
00:26:24,718 --> 00:26:27,888
来回应事件


528
00:26:28,555 --> 00:26:30,891
您有可能在没有从当前视图导航走的
情况下


529
00:26:31,058 --> 00:26:33,160
使用action去更新一些状态


530
00:26:34,828 --> 00:26:37,464
您也可以使用
IB Action去动态地选择


531
00:26:37,531 --> 00:26:39,867
哪一个Segue
是在事件之后您想要去执行的


532
00:26:43,904 --> 00:26:45,706
接着
我们有Storyboard API


533
00:26:45,772 --> 00:26:47,641
mac上
的类UI Storyboard


534
00:26:47,708 --> 00:26:49,409
或者NS Storyboard


535
00:26:49,476 --> 00:26:52,179
允许您从一个
Storyboard文件抓取关联


536
00:26:52,246 --> 00:26:54,948
然后从那个
Storyboard实视图控制器


537
00:26:55,382 --> 00:26:57,751
如果您有一个需要重复实例化的UI


538
00:26:57,818 --> 00:26:59,920
这会非常有用


539
00:27:00,554 --> 00:27:03,390
如果您在低于iOS 9或者
Mac OS10 11操作系统显示


540
00:27:03,457 --> 00:27:05,225
这也是您在应用中


541
00:27:05,292 --> 00:27:07,628
链接多个
Storyboard的唯一途径


542
00:27:09,763 --> 00:27:13,233
我们在UI
控制器上也有许多API功能


543
00:27:13,300 --> 00:27:16,703
允许您自定义您Segue行为


544
00:27:16,770 --> 00:27:18,505
今天我们针对Segue做了不少改进


545
00:27:18,572 --> 00:27:20,841
来使得iOS开发尽可能地轻松


546
00:27:21,074 --> 00:27:23,710
我们针对子类UI 
Storyboard Segue或


547
00:27:23,777 --> 00:27:26,480
NS Storyboard 
Segue改进使其更轻松


548
00:27:26,547 --> 00:27:31,218
如果您想要了解这些
请来明天的Storyboard课程


549
00:27:34,188 --> 00:27:35,822
最终我们拥有了可适应性


550
00:27:37,191 --> 00:27:39,626
Interface Builder
支持两种技术


551
00:27:39,793 --> 00:27:42,696
来帮助您适应您的
UI到不同的容器尺寸


552
00:27:44,198 --> 00:27:48,068
第一点我们有自动布局允许您


553
00:27:48,168 --> 00:27:50,904
根据视图之间的关系调整尺寸和位置


554
00:27:51,238 --> 00:27:53,841
这样您就不再依赖于编代码的框架值了


555
00:27:55,809 --> 00:27:57,177
在某些情形下


556
00:27:57,244 --> 00:28:00,981
当您容器的长和宽超过了限定值


557
00:28:01,048 --> 00:28:03,517
您需要做比较大的改动


558
00:28:04,184 --> 00:28:06,820
在那些情形下我们有另外的一个大功能


559
00:28:06,887 --> 00:28:09,556
叫做尺寸类可以使得它变简单


560
00:28:11,892 --> 00:28:12,993
现在我来给做您一个演示


561
00:28:13,060 --> 00:28:15,829
您怎么用运行时的
Interface Builder


562
00:28:15,896 --> 00:28:17,397
来运用这三个一般技术


563
00:28:17,464 --> 00:28:18,699
让我们切到Xcode


564
00:28:26,740 --> 00:28:30,043
我们将建立一个可以记录您朋友


565
00:28:30,110 --> 00:28:31,912
在他们自驾旅行中行为轨迹的UI界面


566
00:28:31,979 --> 00:28:34,815
计划以后将它集成到凯文的
自驾旅行应用上


567
00:28:36,316 --> 00:28:41,355
就像您在UI中能看到的那样
我有三行标牌


568
00:28:41,822 --> 00:28:46,260
在每一个行中我从类目里显示三个标牌


569
00:28:48,595 --> 00:28:51,298
如果我们看下我们
应用中的Storyboard


570
00:28:51,365 --> 00:28:54,234
您会发现我使用栈视图执行了这个UI


571
00:28:54,868 --> 00:28:57,638
在这个栈视图中 我有三个容器视图


572
00:28:58,906 --> 00:29:02,643
一个容器视图允许您在另一个控制器中


573
00:29:02,709 --> 00:29:04,878
嵌入一个视图控制器
当您拥有时在相同场景下


574
00:29:04,945 --> 00:29:08,081
您想要使用多次的需要重复使用的
UI片段的时候


575
00:29:08,148 --> 00:29:10,450
这将相当地有用


576
00:29:12,085 --> 00:29:13,187
我嵌入的视图控制器这里


577
00:29:13,253 --> 00:29:15,022
拥有它自己的栈视图


578
00:29:15,255 --> 00:29:17,758
在这个栈视图里
标包含了下面这个牌视图控制器中的


579
00:29:17,824 --> 00:29:19,593
多个实例


580
00:29:21,261 --> 00:29:23,764
在每个类目中显示的标牌数量


581
00:29:23,830 --> 00:29:27,201
是被一个用户设置控制着的
所以在设计时我并不能够静态地获得它


582
00:29:27,935 --> 00:29:30,404
不同于使用这里为这个视图控制器


583
00:29:31,004 --> 00:29:32,139
操作的容器视图


584
00:29:32,206 --> 00:29:34,675
我用
Storyboard API初始化


585
00:29:35,609 --> 00:29:36,944
我根据


586
00:29:37,010 --> 00:29:42,182
它在标示检查器
设置的Storyboard ID


587
00:29:42,249 --> 00:29:43,717
从代码关联它到这个视图控制器


588
00:29:45,118 --> 00:29:47,221
让我们来看下我们相应的代码


589
00:29:48,622 --> 00:29:51,959
我们将使用跳跃条导航到关于我


590
00:29:52,025 --> 00:29:53,660
标牌栈视图控制器的源码


591
00:30:02,069 --> 00:30:05,506
好 您看到在我的视图这里加载方法 


592
00:30:09,776 --> 00:30:14,147
用storybook API实例化
那个标牌视图控制器来实现视控制器


593
00:30:15,082 --> 00:30:18,919
特别地我使用从UI视图控制器中


594
00:30:19,219 --> 00:30:21,121
获取的Storyboard属性


595
00:30:21,922 --> 00:30:24,591
然后我通过标示符执行
实例化视图控制器


596
00:30:25,659 --> 00:30:30,597
我传入的这个标识符就跟我们
在标示检查器里看到的一样


597
00:30:32,866 --> 00:30:35,602
在我们增加或者实例化子类后


598
00:30:35,736 --> 00:30:38,071
我们把它添加成子视图控制器


599
00:30:39,072 --> 00:30:40,174
然后我们添加它的视图为


600
00:30:40,240 --> 00:30:41,909
我们栈中一个安置的子视图


601
00:30:43,610 --> 00:30:46,547
所以这个
Storyboard API实例化


602
00:30:46,613 --> 00:30:49,716
和增加子视图控制器方面非常棒
但是如果您想要


603
00:30:49,783 --> 00:30:52,619
增加一个不同于
视图控制器相关子视图的时候


604
00:30:53,520 --> 00:30:55,522
让我们
回到Storyboard作为示例


605
00:30:58,225 --> 00:31:00,194
我们如果看下行为视图控制器顶部这里


606
00:31:00,260 --> 00:31:04,731
我在场景文档中有一个
视图在这里


607
00:31:05,465 --> 00:31:09,603
场景文档允许您存储高级别的对象与
您的视图控制器一起


608
00:31:09,970 --> 00:31:14,875
可在场景文档中放入一个视图 如果不
想视图在运行时初始化视图的一部分


609
00:31:16,009 --> 00:31:18,779
在Xcode 7里
当您在场景文档中放入一个视图


610
00:31:18,846 --> 00:31:22,015
您选择它
它就会显示在您视图控制器上方


611
00:31:22,082 --> 00:31:23,016
自己的编辑器上


612
00:31:27,421 --> 00:31:30,357
这就意味着它们并不是您视图层次结构
初始部分的情况


613
00:31:30,424 --> 00:31:33,660
您也可以在Storyboard
画布下可视化编辑您的视图


614
00:31:35,429 --> 00:31:37,164
如果这个视图有问题链接的话


615
00:31:37,231 --> 00:31:38,465
会显示错误信息


616
00:31:38,932 --> 00:31:42,302
所以我现在想要
创建一个outlet链接到这个视图


617
00:31:42,402 --> 00:31:46,240
并且如果有问题链接
我需要从代码这里增加它


618
00:31:47,307 --> 00:31:50,143
我想要打开助手编辑器


619
00:31:50,210 --> 00:31:53,647
这将带我去执行我的活动视图控制器


620
00:31:55,449 --> 00:31:58,352
然后我将要control拖拽到源码


621
00:31:58,986 --> 00:32:00,654
然后放手 我得到一个小弹出框


622
00:32:00,721 --> 00:32:02,923
允许我设置我的outlet链接


623
00:32:04,591 --> 00:32:07,661
但是第一个选项这里是我是否想要


624
00:32:07,728 --> 00:32:09,663
创建一个outlet
或者outlet集


625
00:32:10,397 --> 00:32:14,334
Outlet集是
用来批量增加或者删除


626
00:32:14,401 --> 00:32:17,738
子视图或者约束的好东西
但是不适用于我的例子


627
00:32:17,804 --> 00:32:19,439
我只是想要增加一个独立的视图


628
00:32:19,506 --> 00:32:21,141
所以我选择了outlet


629
00:32:22,242 --> 00:32:23,477
接下来我可以为连接命名


630
00:32:23,544 --> 00:32:26,280
我会叫它连接错误视图


631
00:32:28,949 --> 00:32:33,420
最后一点我想要指出的是存储类型


632
00:32:34,788 --> 00:32:36,323
可以选择强类型或者弱类型


633
00:32:37,925 --> 00:32:39,993
一般情况下
您应该设置outlet为强类型


634
00:32:40,661 --> 00:32:43,530
特别是
您链接一个outlet到一个子视图


635
00:32:43,597 --> 00:32:46,767
或者链接到一个并不会
被视图层次结构保留的约束的时候


636
00:32:47,901 --> 00:32:50,103
只有当您有一个自定义视图关联回


637
00:32:50,437 --> 00:32:54,074
以前的一些内容的时候
您才需要使用弱类型


638
00:32:54,374 --> 00:32:55,609
一般情况下并不推荐


639
00:32:56,143 --> 00:33:00,914
我会选择强类型点击连接
它会产生我的outlet


640
00:33:03,517 --> 00:33:05,786
现在我想要拷贝一些代码


641
00:33:06,353 --> 00:33:09,289
这些代码在视图加载前被提前执行


642
00:33:10,290 --> 00:33:14,194
我确认下是否有问题 如果有


643
00:33:14,561 --> 00:33:18,765
我把连接错误视图
添加到根栈视图的顶部


644
00:33:19,199 --> 00:33:21,735
我通过outlets同时获取视图


645
00:33:23,237 --> 00:33:25,539
让我们在模拟器中看下这个


646
00:33:30,844 --> 00:33:33,013
就像现在看到的那样 有问题连接


647
00:33:33,747 --> 00:33:35,949
我的视图正如
我需要的那样显示在最上方


648
00:33:37,317 --> 00:33:40,020
所以在iPad
满屏的情况下看起来不错


649
00:33:40,654 --> 00:33:43,056
如果我在分视图中运行会怎么样


650
00:33:46,493 --> 00:33:50,631
我只是拖拽分区到屏幕中间
然后放开鼠标


651
00:33:50,998 --> 00:33:53,333
您可以看到
我的UI在适应窄篇幅的时候


652
00:33:53,400 --> 00:33:54,535
显示得并不好


653
00:33:56,003 --> 00:33:59,473
我真正想要的是当宽度比较小的时候


654
00:33:59,740 --> 00:34:01,175
这些标牌垂直显示


655
00:34:01,875 --> 00:34:04,044
所以任何一个标牌可以获取


656
00:34:04,111 --> 00:34:05,512
当前屏幕本身的宽度


657
00:34:06,513 --> 00:34:09,283
同时当我们回到全屏模式的时候


658
00:34:09,349 --> 00:34:11,284
我想要我的栈视图继续


659
00:34:11,351 --> 00:34:12,753
像现在这样水平显示


660
00:34:14,955 --> 00:34:17,456
做到这点
我要回到我的Storyboard


661
00:34:17,824 --> 00:34:19,025
我要关掉助手


662
00:34:19,092 --> 00:34:20,594
给我们更大的空间


663
00:34:22,228 --> 00:34:23,864
我将选择我的栈视图


664
00:34:23,931 --> 00:34:25,364
来到它的属性视察器


665
00:34:28,768 --> 00:34:32,139
您能看到现在的栈视图设置成水平对齐


666
00:34:33,005 --> 00:34:35,708
旁边的通道属性为+按钮


667
00:34:36,577 --> 00:34:39,246
这个+
按钮允许您增加一个类尺寸自定义


668
00:34:40,080 --> 00:34:44,518
一个尺寸类是一个
一维或者二维的抽象尺寸范围 


669
00:34:44,985 --> 00:34:45,985
在我的例子里


670
00:34:46,053 --> 00:34:50,389
我想要在宽度为迷你的时候
自定义这个属性


671
00:34:51,358 --> 00:34:54,428
因为我并不在意高度 
所以我将选择任何高度


672
00:34:55,661 --> 00:34:57,764
这么做的时候 我在视察器中得到
一个新行和新值


673
00:34:57,965 --> 00:35:00,934
主要是在宽度迷你高度任意的时候


674
00:35:01,001 --> 00:35:03,470
产生作用的


675
00:35:05,038 --> 00:35:06,807
我将改变它到水平


676
00:35:08,175 --> 00:35:09,276
我重新跑一次


677
00:35:13,046 --> 00:35:15,148
又一次我们在全屏了


678
00:35:15,349 --> 00:35:18,652
我们的栈视图还是水平显示着


679
00:35:20,153 --> 00:35:21,755
现在让我们再试一下分屏模式


680
00:35:25,626 --> 00:35:26,860
好吧 我们看到了


681
00:35:29,663 --> 00:35:31,765
大家看 现在我们的配件视图


682
00:35:31,832 --> 00:35:33,467
正像我们想要的那样垂直显示着


683
00:35:33,534 --> 00:35:36,470
每个标牌都得到了半屏的宽度


684
00:35:42,209 --> 00:35:44,077
所以那只是一种方式 您可使用尺寸类


685
00:35:44,144 --> 00:35:48,081
您可以为单个属性重载属性值


686
00:35:48,448 --> 00:35:52,352
但是您也可以增加和删除整个
新的子视图或者约束


687
00:35:52,586 --> 00:35:53,520
如果您想要学的更多


688
00:35:53,587 --> 00:35:55,189
您可以使用尺寸类


689
00:35:55,255 --> 00:35:57,558
我们会在最后一年有一个非常棒的课程


690
00:35:57,624 --> 00:35:59,426
叫做使用UI套件创建可适应应用


691
00:36:00,928 --> 00:36:03,363
这就是关于示例的全部了


692
00:36:03,430 --> 00:36:04,932
所以让我们回到幻灯片


693
00:36:10,671 --> 00:36:13,240
凯文和我刚刚展示给大家很多技术


694
00:36:13,307 --> 00:36:15,175
来获取尽可能多关于
Interface Builder


695
00:36:15,242 --> 00:36:17,044
让我们来复习一下最重要的点


696
00:36:18,545 --> 00:36:21,648
第一点您看到如何使用
自动布局约束和栈视图


697
00:36:21,715 --> 00:36:23,317
来创建灵活的用户界面


698
00:36:23,383 --> 00:36:26,820
而不是依赖于硬性代码框数据


699
00:36:26,887 --> 00:36:27,921
来实现这点


700
00:36:29,723 --> 00:36:31,859
然后凯文演示给您如何使用


701
00:36:31,925 --> 00:36:34,728
可设计性和可视察性来快速地


702
00:36:34,795 --> 00:36:36,129
复写您自定义视图的外观


703
00:36:38,365 --> 00:36:39,933
我们介绍了一个新的功能来


704
00:36:40,000 --> 00:36:43,403
帮助您模块化您的UI
叫做重复关联


705
00:36:44,238 --> 00:36:47,040
然后我展示给您怎么使用
Storyboard API


706
00:36:47,107 --> 00:36:49,510
来重复地实例化重用部件


707
00:36:51,044 --> 00:36:54,181
最后您看到了您的UI怎么样使用尺寸


708
00:36:54,248 --> 00:36:56,917
来自动适应不同的容器尺寸


709
00:36:58,886 --> 00:37:00,921
如果您想要获得更多的信息


710
00:37:00,988 --> 00:37:03,557
您可以在
论坛发帖或者联系我们的宣传员


711
00:37:04,491 --> 00:37:08,562
我们也非常推荐您明天看下我们课程在
Storyboard什么是新的


712
00:37:08,629 --> 00:37:11,164
以及后天的自动布局课程


713
00:37:12,165 --> 00:37:14,401
如果您想要学习更多关于尺寸类的知识


714
00:37:14,468 --> 00:37:17,804
去年我们的创建可适应性应用的课程


715
00:37:18,405 --> 00:37:20,307
最后如果您想要学习更多关于


716
00:37:20,374 --> 00:37:22,609
使用Xcode怎么处理您的
自动布局常见问题的话


717
00:37:22,776 --> 00:37:25,679
我们在2013年也有一个很棒的课程


718
00:37:26,413 --> 00:37:28,682
谢谢大家 
也祝大家在剩下的发布会上愉快开心

