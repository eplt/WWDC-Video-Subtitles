1
00:00:19,786 --> 00:00:25,292
深入分析


2
00:00:27,861 --> 00:00:28,695
谢谢


3
00:00:31,565 --> 00:00:33,367
谢谢 我是查德·伍尔夫


4
00:00:33,634 --> 00:00:34,735
我是克里斯·马克尔


5
00:00:35,035 --> 00:00:37,271
我们是苹果的性能工具工程师


6
00:00:37,704 --> 00:00:39,506
这是会议412


7
00:00:39,573 --> 00:00:41,208
我们会深入谈一下“分析”


8
00:00:42,910 --> 00:00:46,380
也就是谈一下Instruments
中的时间分析器以及如何用它


9
00:00:46,446 --> 00:00:49,149
来优化你的应用程序


10
00:00:50,317 --> 00:00:52,886
当你想要找出你的应用程序
把大部分时间都花在哪里了


11
00:00:52,953 --> 00:00:56,089
的时候你就可以求助于时间分析器


12
00:00:56,290 --> 00:00:57,124
举个例子


13
00:00:58,425 --> 00:01:00,027
当你试图查明应用程序在


14
00:01:00,093 --> 00:01:02,629
运行时间内做了什么事时
时间分析器就会非常有用


15
00:01:02,696 --> 00:01:04,364
你想看到具体调用情况


16
00:01:05,999 --> 00:01:08,202
我们的会议会这样分成若干部分


17
00:01:08,268 --> 00:01:11,138
我们将会谈谈为什么我们
想要举办一场专门针对


18
00:01:11,205 --> 00:01:13,707
时间分析器的会议的动机


19
00:01:15,042 --> 00:01:18,245
不过会议会以向你们演示
展示它的工作原理的细节


20
00:01:18,345 --> 00:01:22,349
你的应用程序在源代码级别


21
00:01:22,416 --> 00:01:25,886
以下的工作原理为中心


22
00:01:27,487 --> 00:01:30,090
最后我们会就你们如何
自行使用时间分析器


23
00:01:30,224 --> 00:01:31,225
给你们一些小窍门


24
00:01:31,291 --> 00:01:34,161
首先快速谈谈我们的动机这次会议是受


25
00:01:34,228 --> 00:01:36,129
“Instruments 7”的
直接启发


26
00:01:36,697 --> 00:01:38,899
“Instruments 7”的
目的是展示新的外观新的感觉


27
00:01:38,966 --> 00:01:41,368
它意味着新的工艺图
并且还意味着我们想让这种


28
00:01:41,435 --> 00:01:46,573
新感觉更具响应性想让
这种新感觉更流畅


29
00:01:46,740 --> 00:01:50,143
我们会从在各个方面对
我们的UI进行优化


30
00:01:51,445 --> 00:01:53,213
我们还想尝试新的图形风格


31
00:01:53,280 --> 00:01:55,916
我们过去就想尝试新的图形风格


32
00:01:55,983 --> 00:02:00,554
但是我们现有的图形代码的性能不足


33
00:02:02,022 --> 00:02:04,258
我们知道我们不得不
把注意力放在渲染上面


34
00:02:04,758 --> 00:02:07,961
因为它是应用中的一块硬骨头


35
00:02:08,027 --> 00:02:10,964
Instruments必须处理
成百上千


36
00:02:11,031 --> 00:02:14,268
有时候甚至是数以百万的数据点
 Instruments必须把这些


37
00:02:14,868 --> 00:02:18,505
处理成一个非常容易理解的表达


38
00:02:18,805 --> 00:02:21,175
那里的算法复杂性
毫无疑问就很高了


39
00:02:22,676 --> 00:02:25,779
对于我们来说 这就意味着
我们必须对我们的应用程序中


40
00:02:25,846 --> 00:02:29,750
特别重要的一部分进行重写也就是对
位于app顶部的轨迹视图进行重写


41
00:02:31,118 --> 00:02:35,322
整个冬季 克里斯和我拿出了
新的轨迹视图的设计


42
00:02:35,956 --> 00:02:38,458
开始根据一系列的原型进行构建


43
00:02:38,959 --> 00:02:41,361
我们并没有在Instruments中
直接生成原型


44
00:02:41,428 --> 00:02:43,830
而是为了简单起见 把它拆分
到了一个单独的应用程序中


45
00:02:44,665 --> 00:02:47,935
这就是我们最近的一个原型的样子


46
00:02:49,403 --> 00:02:51,839
当我们生成原型时
我们做了一件事 我们设置了


47
00:02:51,905 --> 00:02:53,207
一项“性能预算”


48
00:02:53,874 --> 00:02:55,309
当我们分层堆放功能特性的


49
00:02:55,375 --> 00:02:58,378
时候 我们会依据这项
“预算” 不断地对


50
00:02:58,445 --> 00:03:00,948
我们的代码的性能进行评估


51
00:03:01,815 --> 00:03:04,818
当我们超出了“预算”时
我们就会借助于时间分析器


52
00:03:04,885 --> 00:03:08,255
看看到底是我们的
应用程序的哪一部分出了问题


53
00:03:09,523 --> 00:03:12,993
有时候很容易就可以修复
而有时候则不然


54
00:03:13,727 --> 00:03:14,928
因为我们生成的是原型


55
00:03:15,195 --> 00:03:17,197
所以即使我们需要进行一些
大的结构改变才能把


56
00:03:17,264 --> 00:03:20,100
性能拉回正道这也是相当容易的


57
00:03:21,602 --> 00:03:24,338
当我们把它集成回
Instruments时


58
00:03:24,638 --> 00:03:26,106
我们会再次借助于时间分析器


59
00:03:26,206 --> 00:03:28,876
找出我们的集成点中的“热点”


60
00:03:29,009 --> 00:03:32,546
这样经过几次迭代后我们最终
得到了Instruments 7


61
00:03:32,613 --> 00:03:34,281
这个版本实现了我们的性能目标


62
00:03:35,315 --> 00:03:38,051
时间分析器帮助我们
“熬过”了这个冬天


63
00:03:38,118 --> 00:03:40,921
为此我们兴奋不已
因此当苹果全球开发者大会


64
00:03:40,988 --> 00:03:45,325
来临时 我们想开一次会议
谈谈时间分析器


65
00:03:45,659 --> 00:03:47,528
谈谈它善于解决哪些问题


66
00:03:48,629 --> 00:03:52,900
我们想要和你们分享
我们写轨迹视图时的经验


67
00:03:54,001 --> 00:03:58,505
我们今年所做的就是在iOS上
创建了一个演示应用程序


68
00:03:59,173 --> 00:04:02,643
它和轨迹视图的第一个原型看起来很像


69
00:04:03,544 --> 00:04:06,613
我们也给自己设定了性能目标


70
00:04:06,680 --> 00:04:10,317
我们想要绘制十万个数据点


71
00:04:11,084 --> 00:04:15,222
我们想要平移和缩放的帧速
为完美的每秒钟六十帧


72
00:04:15,989 --> 00:04:18,825
我们还想让它支持
第一代iPad mini


73
00:04:19,493 --> 00:04:22,062
我们选择第一代iPad mini
的原因是...


74
00:04:22,696 --> 00:04:24,464
你知道我说的是什么...


75
00:04:24,531 --> 00:04:27,734
如果它能支持第一代iPad
mini 那么它在其它的平台上


76
00:04:27,801 --> 00:04:30,737
尤其是后面的平台上
也就没问题


77
00:04:30,804 --> 00:04:32,439
克里斯会向你们展示这个应用程序


78
00:04:32,706 --> 00:04:36,777
他会对它进行时间剖析
他会向你们展示把这些东西


79
00:04:36,844 --> 00:04:39,580
组合到一起时我们发现了什么东西


80
00:04:41,081 --> 00:04:45,285
谢谢 查德 这里我有
Xcode的原型应用程序


81
00:04:45,586 --> 00:04:48,055
我想点出几样东西


82
00:04:48,121 --> 00:04:51,191
当我们初步实现时
我们发现 我们根本就处理


83
00:04:51,258 --> 00:04:52,826
不了不到十万个的数据点


84
00:04:53,160 --> 00:04:55,963
一开始 我们先从一万个数据点开始


85
00:04:56,396 --> 00:04:59,733
还有一点也很重要
你应该在你的发版构建上进行


86
00:04:59,800 --> 00:05:02,569
时间剖析因为你肯定想在你进行


87
00:05:02,636 --> 00:05:05,906
剖析时 把编译器的优化利用起来


88
00:05:06,540 --> 00:05:09,510
我要开始剖析应用程序了


89
00:05:09,710 --> 00:05:12,813
我要从产品菜单中选择“剖析”


90
00:05:13,580 --> 00:05:16,483
这样就会构建应用程序
把它安装到iPad上


91
00:05:16,817 --> 00:05:18,952
并且显示出
Instrument模板用户


92
00:05:19,586 --> 00:05:22,089
这里 时间分析器已经为我们选择好了


93
00:05:22,656 --> 00:05:24,057
我要点击“选择”


94
00:05:24,491 --> 00:05:27,227
这里 你可以在我们的轨迹
视图中看到Instruments


95
00:05:27,461 --> 00:05:29,296
我们过一会儿再回来看这个


96
00:05:29,363 --> 00:05:31,265
现在我要开始录制了


97
00:05:31,732 --> 00:05:35,169
点击“录制”按钮
我们向你展示了app


98
00:05:35,235 --> 00:05:39,239
我想要强调下 你们在这里
看到的 这个并不是模拟器


99
00:05:39,306 --> 00:05:43,010
这是QuickTime对app上已有的
东西进行的镜像


100
00:05:43,810 --> 00:05:48,515
这是我们的图表我要开始滚动


101
00:05:49,183 --> 00:05:52,686
滚动没有什么不好
我要通过收聚进行缩小


102
00:05:53,220 --> 00:05:56,390
刚开始还不错不过之后就开始卡了


103
00:05:56,924 --> 00:05:58,025
这可不太妙


104
00:05:58,792 --> 00:06:02,196
最后我要用我的手指进行


105
00:06:02,262 --> 00:06:04,064
前后滚动我正在移动我的手指


106
00:06:04,131 --> 00:06:07,668
但是显示器并没有更新太卡了


107
00:06:08,202 --> 00:06:10,504
性能表现太糟糕了


108
00:06:11,238 --> 00:06:12,873
我们来看看发生了什么


109
00:06:13,140 --> 00:06:15,642
让我们回到Xcode中
回到Instruments中


110
00:06:15,809 --> 00:06:16,777
我们把分析器停下来


111
00:06:16,910 --> 00:06:19,313
快速让你们看看新的轨迹视图


112
00:06:19,713 --> 00:06:21,682
这里我们看到了CPU使用情况


113
00:06:22,082 --> 00:06:24,384
它指的是在某个特定的时间单位内


114
00:06:24,585 --> 00:06:26,320
平均的CPU使用情况


115
00:06:26,620 --> 00:06:28,722
这里的时间单位取决于
你当前的缩放程度


116
00:06:29,122 --> 00:06:31,458
当我使用我的app时
你可以看到不同的部分


117
00:06:31,925 --> 00:06:33,360
那里消耗的时间是不同的


118
00:06:33,427 --> 00:06:37,798
这是滚动 这是缩小这是
缩小时进行前后滚动


119
00:06:38,265 --> 00:06:41,401
关于轨迹视图 还有一点
很棒 就是我可以使用这个


120
00:06:41,468 --> 00:06:47,207
缩小手势来放大我感兴趣的某段数据


121
00:06:47,774 --> 00:06:50,878
如果你用的不是Trackpad
那么你可以按住选项键


122
00:06:50,978 --> 00:06:54,481
上下滚动来进行放大和缩小


123
00:06:55,115 --> 00:06:57,718
我想看看这段特定的数据


124
00:06:57,885 --> 00:06:59,720
就是这里的这个活动


125
00:07:00,020 --> 00:07:01,388
刚才我在这里进行了滚动


126
00:07:01,455 --> 00:07:05,592
为此我要使用一个过滤器
只需单击并拖动


127
00:07:06,260 --> 00:07:11,265
就可以把那些特定的样例给选中
这样我就可以专注于


128
00:07:11,331 --> 00:07:12,566
那个特定的数据


129
00:07:13,567 --> 00:07:16,370
我要在下面这里创建更多的空白


130
00:07:17,070 --> 00:07:19,339
下面这里是我们的详细视图


131
00:07:19,940 --> 00:07:22,676
它可以向我们显示
我们在某个特定的函数


132
00:07:22,743 --> 00:07:27,481
或者方法内拥有的时间分析器的
样本百分比的数量


133
00:07:27,748 --> 00:07:28,815
这样我们就有了符号名


134
00:07:28,882 --> 00:07:31,852
这是我们的百分比这是我们的符号


135
00:07:32,386 --> 00:07:37,124
当你进行时间剖析时你通常所做的
第一件事是把这个扩展开来


136
00:07:37,591 --> 00:07:42,563
然后查看某种...
在这里对数字进行对比


137
00:07:42,629 --> 00:07:45,098
这里是具体的方法函数


138
00:07:45,432 --> 00:07:48,035
看看突出来的是什么类型的情况 


139
00:07:48,402 --> 00:07:50,504
你知道的那些值得你进行
调查的情况会显示出来


140
00:07:50,871 --> 00:07:53,740
还有一个选项 如果我们
认真看看检查器窗格


141
00:07:54,174 --> 00:07:58,612
点击扩展开的细节 我们就能
看到最厚重的堆栈踪迹


142
00:07:59,146 --> 00:08:00,247
这是针对主线程的


143
00:08:00,681 --> 00:08:03,984
当我进行时间剖析希望提高性能时


144
00:08:04,051 --> 00:08:08,255
我就会关注这里因为
这里是最物有所值的


145
00:08:08,822 --> 00:08:10,290
我们来看看发生了什么


146
00:08:10,457 --> 00:08:14,428
主线程调用了应用程序的
主线程 进行循环


147
00:08:14,828 --> 00:08:18,298
核心动画开始工作了


148
00:08:21,268 --> 00:08:27,574
没有什么异常情况发生


149
00:08:28,075 --> 00:08:31,245
实际上这就是剖析时常见的事


150
00:08:31,345 --> 00:08:33,780
你想看看应用程序最常干的事情是什么


151
00:08:34,214 --> 00:08:36,850
但是看起来它并没有做什么特别的事情


152
00:08:36,917 --> 00:08:38,485
那里什么也没有


153
00:08:38,552 --> 00:08:41,655
没有要求在这里计算第四十个斐
波纳契数也没有做什么其它异常的事


154
00:08:42,456 --> 00:08:45,425
但是 你知道的看看这个调用栈


155
00:08:45,492 --> 00:08:48,829
看看这个堆栈踪迹
我知道了我的应用程序做了什么事


156
00:08:48,896 --> 00:08:52,032
这是一个简单的原型
app它的作用就是


157
00:08:52,099 --> 00:08:54,434
构建一个路径并且绘制一个路径


158
00:08:55,369 --> 00:08:58,972
实际上 我能够看到这里有一个
调用一个CG环境路径


159
00:08:59,239 --> 00:09:02,409
它没有被我的代码根据堆栈踪迹调用到


160
00:09:02,743 --> 00:09:05,078
就在这里占据了很大一块时间


161
00:09:05,145 --> 00:09:07,047
我要点击下那个看看它


162
00:09:07,881 --> 00:09:09,850
如果我们看看我们的调用树


163
00:09:10,417 --> 00:09:12,219
我就可以看到一些有趣的事


164
00:09:12,286 --> 00:09:14,855
我们可以看到根据这个调用树


165
00:09:14,922 --> 00:09:16,690
这个绘制路径会被这个


166
00:09:16,757 --> 00:09:19,092
绘制分层法在UI试图上调用


167
00:09:19,626 --> 00:09:24,264
它还会为图形视图调用我们的
drawRect


168
00:09:24,765 --> 00:09:26,767
这占据了大量的时间


169
00:09:26,834 --> 00:09:29,536
这就是app所做的其中一件事


170
00:09:29,937 --> 00:09:34,374
如果我看看这里的那个时间
环境绘制路径占据了


171
00:09:34,541 --> 00:09:38,812
你知道 样本的55%但是这个
drawRect占据的却非常少


172
00:09:39,379 --> 00:09:42,549
这就很有趣了
如果我在drawRect方法上


173
00:09:42,616 --> 00:09:45,052
右击下我就可以看到源代码


174
00:09:45,686 --> 00:09:47,821
我知道了如果你看看底部那里


175
00:09:47,955 --> 00:09:51,592
我就可以从drawRect方法上
调用绘制路径


176
00:09:52,059 --> 00:09:55,128
但是在哪个样例中都显示不出来


177
00:09:55,429 --> 00:09:58,432
只是在添加路径


178
00:09:58,699 --> 00:10:01,635
这可不太寻常


179
00:10:01,702 --> 00:10:04,738
因为我的预期是我的
drawRect方法


180
00:10:04,805 --> 00:10:05,906
运行需要一段时间


181
00:10:06,540 --> 00:10:08,275
它只是我的app完成的一半


182
00:10:08,709 --> 00:10:10,644
看这个我注意到


183
00:10:11,078 --> 00:10:12,579
drawRect返回了一个空白


184
00:10:12,846 --> 00:10:16,350
最后调用的方法是环境绘制路径


185
00:10:16,950 --> 00:10:20,521
这可能就是所谓的“尾部调用消除”


186
00:10:21,388 --> 00:10:25,259
查德会给大家讲讲什么是
“尾部调用消除”


187
00:10:25,325 --> 00:10:27,227
以及如何对它进行验证


188
00:10:30,464 --> 00:10:34,168
好的 要解释刚才克里斯看到的情况


189
00:10:34,234 --> 00:10:39,173
我们就需要理解时间分析器是怎样
知道在你的应用程序内调用什么的


190
00:10:40,040 --> 00:10:42,743
这个的技术含量就比较高了
我会一步一步向你们讲解


191
00:10:44,411 --> 00:10:48,148
左边是drawRect的代码
右边则和你想象的堆栈


192
00:10:48,215 --> 00:10:54,588
在UIKit调用drawRect
之前为那个线程找到的一样


193
00:10:56,290 --> 00:10:57,858
当向drawRect进行调用时


194
00:10:58,025 --> 00:11:01,261
和大多数函数 方法所做的事情一样


195
00:11:01,328 --> 00:11:02,863
它会建立自己的调用帧


196
00:11:03,864 --> 00:11:07,768
它会首先推送链路寄存器以及堆栈上的


197
00:11:07,868 --> 00:11:11,705
帧指针的上一个值的返回地址


198
00:11:12,039 --> 00:11:16,376
现在drawRect知道了怎样返回
它的调用程序怎样恢复帧指针


199
00:11:18,078 --> 00:11:21,515
下一件发生的事是我们
得到帧指针设置成新的基础


200
00:11:23,317 --> 00:11:26,320
然后drawRect会给它的
局部变量


201
00:11:26,386 --> 00:11:28,455
编译程序的暂存空间腾出空间


202
00:11:28,522 --> 00:11:30,357
现在我们有了一个
drawRect的帧


203
00:11:31,325 --> 00:11:34,494
现在代码开始运行了
我们到绘制路径那里


204
00:11:35,796 --> 00:11:39,166
绘制路径做的事也相同
它把自己的帧推送到了堆栈上


205
00:11:40,400 --> 00:11:43,437
时间分析器的工作方式
就是在内核中使用一项服务


206
00:11:43,737 --> 00:11:47,207
以每秒1000x的速度对
CPU所做的事进行采样


207
00:11:48,408 --> 00:11:50,511
在这个例子中如果我们采一次样


208
00:11:50,911 --> 00:11:53,280
我们就可以看到 我们是在
环境绘制路径中运行的


209
00:11:54,381 --> 00:11:58,252
然后内核会看下帧指针寄存器


210
00:11:58,318 --> 00:12:01,488
看看函数帧的基础在哪里


211
00:12:01,822 --> 00:12:03,657
然后找到调用它的程序的返回地址


212
00:12:04,291 --> 00:12:08,362
现在我们可以看到那个
drawRect是在绘制路径中调用


213
00:12:09,263 --> 00:12:11,098
如果我们想看看drawRect中


214
00:12:11,632 --> 00:12:14,268
调用了什么我们就可以使用我们推送到


215
00:12:15,035 --> 00:12:17,004
堆栈上的帧指针来找到
drawRect的基础


216
00:12:17,237 --> 00:12:20,507
然后继续返回堆栈直到我们到达底部


217
00:12:21,108 --> 00:12:22,242
这就是一次回溯


218
00:12:22,876 --> 00:12:25,212
如果我们有足够的回溯
并且把它们放到


219
00:12:25,279 --> 00:12:29,183
调用树视图你就可以搞清楚在你的
应用程序内发生了什么


220
00:12:30,083 --> 00:12:32,152
我想指出一点堆栈上的帧指针


221
00:12:32,319 --> 00:12:34,021
是绝对必须的


222
00:12:34,421 --> 00:12:37,424
如果你编译代码时
关闭了fomit-frame-pointer


223
00:12:37,524 --> 00:12:41,428
想要进行和我们这里一样的时间剖析


224
00:12:42,996 --> 00:12:44,531
让我们看看这个优化实例


225
00:12:44,598 --> 00:12:46,967
启用编辑器优化后drawRect


226
00:12:47,034 --> 00:12:48,402
就是进行编译的


227
00:12:49,303 --> 00:12:51,271
同样地我们有一个drawRect帧


228
00:12:51,738 --> 00:12:53,273
我们要准备调用绘制路径了


229
00:12:54,074 --> 00:12:57,578
你可以注意到 当绘制路径
返回drawRect时就完成了


230
00:12:57,744 --> 00:12:58,779
什么也不需要做


231
00:12:59,279 --> 00:13:00,214
它就会返回回来


232
00:13:00,280 --> 00:13:03,050
它返回时会弹出堆栈结构


233
00:13:03,483 --> 00:13:06,086
恢复帧指针的上一个值


234
00:13:06,520 --> 00:13:07,788
然后回到调用程序


235
00:13:09,022 --> 00:13:11,191
编译器看到这个后会想


236
00:13:11,458 --> 00:13:17,397
为什么绘制路径需要用到
drawRect的堆栈结构的东西？


237
00:13:18,398 --> 00:13:20,834
明明不需要的
此外返回它的调用程序时


238
00:13:20,901 --> 00:13:23,270
为什么要返回drawRect？


239
00:13:23,871 --> 00:13:27,374
那么它就会把代码重新整理成这样


240
00:13:27,674 --> 00:13:30,811
它会弹出堆栈结构恢复帧指针


241
00:13:30,878 --> 00:13:34,248
然后直接向绘制路径进行回调


242
00:13:34,414 --> 00:13:36,149
这就意味着我们无需再跳回调用程序了


243
00:13:36,984 --> 00:13:39,686
解释这个要比让你们直接看到更困难


244
00:13:39,753 --> 00:13:42,422
让我们想象一下 当运行
这个代码时它会是什么样的


245
00:13:43,524 --> 00:13:46,059
我们会弹出堆栈结构去掉局部变量


246
00:13:47,060 --> 00:13:49,329
我们会把帧指针恢复成初始值


247
00:13:49,463 --> 00:13:50,864
链路寄存器的值


248
00:13:51,665 --> 00:13:54,668
然后我们跳回绘制路径代码的开头


249
00:13:55,536 --> 00:13:58,739
绘制路径会使用它在
链路寄存器中找到的值


250
00:13:59,306 --> 00:14:02,843
帧指针中找到的值把它
自己的帧推送回堆栈


251
00:14:03,610 --> 00:14:07,080
从绘制路径的透视图中它会直接在


252
00:14:07,147 --> 00:14:09,149
UIKit的环境中
从绘制层上得到调用


253
00:14:09,950 --> 00:14:11,685
此时如果我们进行一次时间采样


254
00:14:12,119 --> 00:14:13,754
我们就可以看到同样的情况


255
00:14:15,022 --> 00:14:16,890
即使发生的不是实际的调用序列


256
00:14:16,957 --> 00:14:19,092
时间分析器看到的就是这样


257
00:14:19,660 --> 00:14:22,963
我们在我们的调用树上
最后看到的就是这个


258
00:14:23,564 --> 00:14:25,966
这就叫“尾部调用消除”
在高度优化的代码上


259
00:14:26,033 --> 00:14:29,203
很常见也有一些好处


260
00:14:30,804 --> 00:14:31,972
它能够节省堆栈内存


261
00:14:32,806 --> 00:14:35,242
节省堆栈内存时
它会让缓存保持“热度”


262
00:14:35,309 --> 00:14:38,045
然后重新利用内存缓存和数据


263
00:14:39,179 --> 00:14:42,749
它对递归代码有着深刻影响


264
00:14:42,816 --> 00:14:45,919
尤其是尾部调用递归代码
在那里 一个函数或者方法


265
00:14:45,986 --> 00:14:48,355
会最后调用自身然后返回回来


266
00:14:49,223 --> 00:14:52,893
无需推送这些帧一个递归函数内的


267
00:14:53,093 --> 00:14:56,463
尾部调用消除
就可以让性能和迭代版本


268
00:14:56,530 --> 00:15:00,200
一样好所以堆栈就不会增长


269
00:15:00,267 --> 00:15:01,735
并且性能也很优秀


270
00:15:02,536 --> 00:15:06,406
这个优化也能兼容高度递归代码


271
00:15:07,140 --> 00:15:09,109
如果为了剖析你想把它关掉


272
00:15:09,176 --> 00:15:11,111
显示一个更清晰的堆栈踪迹


273
00:15:12,145 --> 00:15:15,315
你就可以到项目的构建设置中把它关掉


274
00:15:15,782 --> 00:15:17,684
并且把编辑器标志


275
00:15:17,751 --> 00:15:20,787
从CFLAGS设置成
FNO-optimize-sibling-calls


276
00:15:20,854 --> 00:15:22,122
关掉优化


277
00:15:22,422 --> 00:15:24,625
不幸的是性能同时也会受到影响


278
00:15:25,092 --> 00:15:27,394
但是这样你可以在时间分析器
中得到更好一个的结果


279
00:15:28,562 --> 00:15:31,131
如果你选择忍受它
你想要知道是否发生了


280
00:15:31,298 --> 00:15:34,768
尾部调用消除那么你该怎么做？


281
00:15:34,835 --> 00:15:38,405
你可以看看反汇编调用最后调用的情况


282
00:15:39,473 --> 00:15:41,942
如果是个普通的调用
那么它会使用指令的


283
00:15:42,009 --> 00:15:44,711
一个分支和家族链接
那里是第一个实例


284
00:15:45,746 --> 00:15:47,614
那就意味着它会跳到新函数


285
00:15:47,681 --> 00:15:50,117
并且在链路寄存器内保存返回的值


286
00:15:51,318 --> 00:15:54,021
如果是一个尾部调用
并且我们需要直接跳到


287
00:15:54,087 --> 00:15:59,893
直接跳到新函数内 那么
它就是一个直接的分支指令没有BL


288
00:16:00,561 --> 00:16:04,665
那就是一个指令和链路的调用指令


289
00:16:04,731 --> 00:16:06,600
分支就是一个转移指令


290
00:16:06,733 --> 00:16:09,102
如果你看看它你会发现很眼熟


291
00:16:10,137 --> 00:16:14,741
现在就由克里斯来决定了
他可以禁用优化 重新编译


292
00:16:14,808 --> 00:16:17,444
或者他也可以继续由你决定


293
00:16:18,412 --> 00:16:20,747
我要看看反汇编


294
00:16:20,814 --> 00:16:24,885
在Instruments详细视图的
右上角那里


295
00:16:24,952 --> 00:16:28,055
有一个按钮
查看反汇编 如果我点击下


296
00:16:28,622 --> 00:16:30,858
我就可以看到那个方法的反汇编


297
00:16:31,091 --> 00:16:35,395
我们就可以确认添加路径
环境调用是一个分支和链路


298
00:16:35,929 --> 00:16:39,166
环境调用绘制路径是一个简单的分支


299
00:16:39,600 --> 00:16:42,669
我确信这是一个尾部调用消除的例子


300
00:16:43,036 --> 00:16:48,442
我在调用树上看到的55%的
调用都不属于我的drawRect


301
00:16:48,509 --> 00:16:51,345
它们本来应该属于
我的drawRect


302
00:16:51,845 --> 00:16:53,447
这是个好消息


303
00:16:53,514 --> 00:16:57,951
现在我知道了drawRect就是
我的最重的堆栈结构


304
00:16:58,018 --> 00:16:59,052
我的最重的堆栈踪迹


305
00:16:59,453 --> 00:17:02,456
消耗了我55%到60%的时间


306
00:17:02,723 --> 00:17:04,724
很好 我知道应该优化哪里了


307
00:17:04,892 --> 00:17:07,594
我要优化drawRect开始吧


308
00:17:08,395 --> 00:17:09,930
我们来看看这个drawRect


309
00:17:11,231 --> 00:17:14,867
看看这个drawRect 如果
有张桌子的话我早就掀了


310
00:17:15,702 --> 00:17:17,971
优化的地方不多


311
00:17:18,172 --> 00:17:20,440
很难想出一个能用的更简单的


312
00:17:20,674 --> 00:17:22,075
但是又能用的drawRect


313
00:17:22,175 --> 00:17:28,015
我们有四个函数调用 环境
你知道的 CG调用


314
00:17:28,515 --> 00:17:30,584
这个drawRect
没有起到多少作用


315
00:17:31,251 --> 00:17:33,720
那么这个实际上就是进行剖析时


316
00:17:33,787 --> 00:17:35,389
一个很常见的事


317
00:17:36,657 --> 00:17:41,762
你看了下自己的“热点”和代码


318
00:17:42,062 --> 00:17:45,799
发现你没有多少能直接在
代码中进行修改


319
00:17:45,999 --> 00:17:47,334
提高你的性能的地方


320
00:17:48,068 --> 00:17:50,404
你知道 这个节点你该做什么？


321
00:17:51,305 --> 00:17:55,776
你知道 除了掀桌子
晚上在枕头上嚎啕大哭之外


322
00:17:57,277 --> 00:18:01,715
我们所做的事 就是仔细检查
开始查看核心图像文档以及其它绘图


323
00:18:01,782 --> 00:18:03,517
你知道 Cocoa绘图资料


324
00:18:04,184 --> 00:18:07,087
我们无意中发现了这里的
这个特殊的属性


325
00:18:07,921 --> 00:18:09,823
这是
drawsAsynchrously


326
00:18:10,123 --> 00:18:12,926
你瞧！这是一个
“让我的代码更快”按钮


327
00:18:13,060 --> 00:18:17,064
是一位苹果工程师创建的


328
00:18:19,066 --> 00:18:20,334
非常棒


329
00:18:20,734 --> 00:18:23,103
在那个上面 你可以看到


330
00:18:23,170 --> 00:18:25,272
我从资料中复制出来粘贴都了那里


331
00:18:25,606 --> 00:18:27,541
它说了几件有趣的事


332
00:18:27,608 --> 00:18:31,645
首先它说 它可能提高性能
也可能不会提高性能


333
00:18:31,712 --> 00:18:32,846
你应该衡量得失


334
00:18:33,614 --> 00:18:35,749
你懂得 好了 爸爸


335
00:18:36,216 --> 00:18:37,117
我们开始度量吧


336
00:18:37,317 --> 00:18:39,887
我们看看这个能否提高性能


337
00:18:40,420 --> 00:18:43,156
这次 要启动Instruments
我要给Instruments进行


338
00:18:43,223 --> 00:18:45,325
运行command-I


339
00:18:45,726 --> 00:18:46,760
它会做同样的事情


340
00:18:47,361 --> 00:18:50,531
它会构建应用程序安装到设备上


341
00:18:51,198 --> 00:18:52,299
显示出模板选择器


342
00:18:53,267 --> 00:18:54,368
需要一点时间


343
00:18:55,802 --> 00:18:56,637
还需要一点时间


344
00:18:57,771 --> 00:18:58,705
还得再需要一点时间


345
00:18:59,173 --> 00:19:04,311
好了 我还想使用另外一种
快捷方式 如果你看看下面的选择按钮


346
00:19:04,945 --> 00:19:07,548
如果我按住选择按钮
它就变成了“剖析”


347
00:19:07,981 --> 00:19:09,850
这就意味着着
当我点击这个按钮时


348
00:19:10,150 --> 00:19:11,852
应用程序就会开始录制


349
00:19:12,186 --> 00:19:13,787
会替我省一两步


350
00:19:14,021 --> 00:19:15,055
我现在点了


351
00:19:15,822 --> 00:19:18,625
现在时间分析器出来了


352
00:19:19,092 --> 00:19:20,160
会对app进行度量


353
00:19:20,627 --> 00:19:22,496
我要快速进行一些前后滚动


354
00:19:22,563 --> 00:19:24,698
捕捉一些数据


355
00:19:25,499 --> 00:19:26,333
我想够了


356
00:19:26,400 --> 00:19:28,302
让我们把录制停下来


357
00:19:28,769 --> 00:19:33,040
我要进行过滤获得具体滚动数据


358
00:19:33,707 --> 00:19:35,843
如果我们到下面这里看看细节视图


359
00:19:36,310 --> 00:19:37,711
很有希望


360
00:19:37,945 --> 00:19:40,714
实际上上你们可以看到这里有多个线程


361
00:19:40,881 --> 00:19:42,216
线程正在发挥作用


362
00:19:42,683 --> 00:19:43,750
这很好


363
00:19:43,851 --> 00:19:45,652
如果我们继续如果我按住选项


364
00:19:45,986 --> 00:19:48,055
点击提示三角符号
我就可以看到这个线程在


365
00:19:48,622 --> 00:19:52,092
调用什么这是一些群调用


366
00:19:52,159 --> 00:19:53,493
一些CG调用 很好


367
00:19:53,560 --> 00:19:54,628
这就是绘制代码


368
00:19:55,195 --> 00:19:57,097
我们继续一个接一个检查下


369
00:19:58,265 --> 00:19:59,266
按住这个选项键


370
00:19:59,900 --> 00:20:02,202
群调用 CG调用


371
00:20:02,503 --> 00:20:04,738
很好 这个看起来很有希望


372
00:20:05,239 --> 00:20:09,142
我是多线程
理论上我的app应该更快了


373
00:20:10,043 --> 00:20:13,914
但是 多线程并不一定意味着更快


374
00:20:13,981 --> 00:20:17,217
我们应该确认它真的在帮我们做事


375
00:20:17,751 --> 00:20:21,755
有一种方法可以确认 我碰巧
知道这台设备有两个CPU


376
00:20:22,122 --> 00:20:24,157
如果CPU以最大性能


377
00:20:24,224 --> 00:20:28,662
并行运行 那么我应该会看到
在我图表上面这里


378
00:20:29,096 --> 00:20:30,497
看到200%的CPU使用情况


379
00:20:31,131 --> 00:20:33,634
但是我看不到有超过100%的情况


380
00:20:33,700 --> 00:20:36,270
那么这就是某种警告信号了
它并不一定意味着两个


381
00:20:36,537 --> 00:20:38,639
CPU没有同时工作


382
00:20:39,039 --> 00:20:40,541
它只是意味着我应该进一步检查下


383
00:20:41,074 --> 00:20:42,276
那么我们怎样进一步检查？


384
00:20:42,609 --> 00:20:44,678
Instruments就有我们称
之为“策略”的东西 


385
00:20:44,745 --> 00:20:47,314
它指的是对数据进行划分的
不同方法为的是查看数据


386
00:20:47,481 --> 00:20:48,415
这里有三个


387
00:20:48,849 --> 00:20:51,451
第一个是Instrument策略
即默认值


388
00:20:51,652 --> 00:20:52,553
我们在这里看的就是


389
00:20:53,387 --> 00:20:55,289
第二个是CPU策略


390
00:20:55,656 --> 00:20:58,926
它显示的是每个CPU或者CPU
的数据 相关数据


391
00:20:59,826 --> 00:21:01,662
最后一个是线程策略


392
00:21:01,962 --> 00:21:04,531
它给你显示了每个线程
处理的细节情况


393
00:21:05,399 --> 00:21:07,467
我们来看看CPU策略


394
00:21:08,569 --> 00:21:10,971
我们可以看到我们拥有的每个CPU


395
00:21:11,038 --> 00:21:12,606
我们可以看到它们做了多少功


396
00:21:12,673 --> 00:21:14,808
在底部我们可以看到组合使用情况


397
00:21:15,242 --> 00:21:21,982
这里有一件很棒的事可以做
当我放大的足够大


398
00:21:22,049 --> 00:21:24,251
图表向我显示的细节就会发生变更


399
00:21:25,018 --> 00:21:27,387
它就会显示那个CPU是
否处于活跃状态 


400
00:21:27,721 --> 00:21:29,957
而不再显示平均使用情况


401
00:21:30,023 --> 00:21:32,793
它就会显示活跃或者不活跃
而不再显示平均使用情况


402
00:21:33,393 --> 00:21:37,130
现在每个CPU都显示了一个
在线状态或者离线状态是否处于工作中


403
00:21:37,831 --> 00:21:41,535
这里你可以注意到
CPU从来没有一起工作中


404
00:21:41,602 --> 00:21:44,438
这里没有并行性


405
00:21:44,771 --> 00:21:48,642
你懂得 这可不好


406
00:21:49,276 --> 00:21:53,146
如果我们还想试试伤口撒盐
我们可以看看线程策略


407
00:21:54,181 --> 00:21:56,416
它可以向我们显示每个图标


408
00:21:56,817 --> 00:22:00,120
每个图标代表了时间分析器
采集的一个样本


409
00:22:00,187 --> 00:22:02,222
你可以点击 看看调用堆栈


410
00:22:02,623 --> 00:22:05,359
这里的这个是位于一个后台线程上


411
00:22:05,726 --> 00:22:08,161
你可以看到核心图形调用这是主线程


412
00:22:08,228 --> 00:22:14,668
你可以看到主线程...
我们在主线程上进行的工作


413
00:22:15,202 --> 00:22:17,204
你可以看到 如果我放大到合适的程度


414
00:22:17,804 --> 00:22:18,972
应该就是这里了我滚动下


415
00:22:19,339 --> 00:22:24,611
你可以看到两个线程并没有
真的同时工作过


416
00:22:24,811 --> 00:22:27,314
它是从一个线程跳到另一个线程


417
00:22:28,682 --> 00:22:34,354
因此drawsAsynchronously
并没有真的为我们做什么事


418
00:22:34,421 --> 00:22:36,890
从理论上来说它可能会拖慢我们


419
00:22:37,391 --> 00:22:42,429
我们不仅进行了绘制而且还进行了管理


420
00:22:42,663 --> 00:22:45,065
你懂得 核心图形系统
对它工作的线程进行了管理


421
00:22:45,132 --> 00:22:48,769
类似这种的事情 并没有什么实质作用


422
00:22:49,903 --> 00:22:51,738
我会把它关掉


423
00:22:53,006 --> 00:22:56,176
我会再掀一张桌子


424
00:22:56,543 --> 00:22:59,780
不很清晰神奇按钮没多大作用


425
00:23:00,547 --> 00:23:01,682
我们现在该怎么做？


426
00:23:02,382 --> 00:23:05,485
同样这也是时间剖析中
一个很常见的情况


427
00:23:06,320 --> 00:23:08,755
你尝试了很多事但是大部分都不起作用


428
00:23:09,489 --> 00:23:11,625
我们往回退一步


429
00:23:11,892 --> 00:23:12,726
app会怎么做？


430
00:23:13,060 --> 00:23:15,128
它构建了一条路径
然后描绘了一条路径


431
00:23:15,963 --> 00:23:17,364
我们已经看过绘制路径代码了


432
00:23:17,431 --> 00:23:19,633
我们来考虑下构建路径代码


433
00:23:19,933 --> 00:23:23,470
就在这里


434
00:23:25,105 --> 00:23:29,109
我们想做的事就是调查下
我们构建的实际路径


435
00:23:29,643 --> 00:23:32,613
这个代码的作用就是循环数据元素


436
00:23:32,880 --> 00:23:35,949
创建一条路径然后为每个
数据元素向那个路径中一行


437
00:23:36,250 --> 00:23:39,319
我们想知道我们向那个路径中
添加了多少行


438
00:23:39,386 --> 00:23:42,122
时间分析器就可以告诉我们这个信息


439
00:23:42,422 --> 00:23:44,291
它不能告诉你某个特定的方法


440
00:23:44,558 --> 00:23:47,528
函数被调用了多久被调用了多少次


441
00:23:48,228 --> 00:23:49,897
它不知道一个被调用了仅仅


442
00:23:49,963 --> 00:23:52,266
几次的慢函数同一个被调用了
很多次的快函数之间


443
00:23:52,332 --> 00:23:53,934
有什么区别


444
00:23:54,535 --> 00:23:56,970
在这个例子中 我们要借助于
NSLog 我们就可以实现


445
00:23:57,404 --> 00:24:01,341
一个情况 即我们每次添加
一个路径 我们就放大计数器一次


446
00:24:01,642 --> 00:24:05,312
然后当我们循环结束时
我们就把它录入


447
00:24:05,679 --> 00:24:07,881
重点要指出的是NSLog并不是一个


448
00:24:08,415 --> 00:24:10,617
很快的函数


449
00:24:11,151 --> 00:24:13,387
在高性能代码中你不会想让它出现的


450
00:24:13,520 --> 00:24:16,056
除了收集诊断信息或者进行调试以外


451
00:24:16,123 --> 00:24:18,825
你可能不会想用它做任何其它事情


452
00:24:19,393 --> 00:24:21,762
当你用完后把它从代码中删掉


453
00:24:21,995 --> 00:24:23,897
在这个例子中 我们仅仅添加
注释 这样你可以看到


454
00:24:24,665 --> 00:24:29,636
我们发现 我们在例子中的
这个点这里添加了十万行


455
00:24:30,204 --> 00:24:32,506
这是没有必要的


456
00:24:32,573 --> 00:24:36,076
事实上 这台设备上无论如何
也显示不了十万行


457
00:24:37,110 --> 00:24:39,079
尤其是当你缩的足够小所有的数据


458
00:24:39,146 --> 00:24:41,682
就都需要适合一百个屏幕点


459
00:24:42,015 --> 00:24:44,251
没理由在那里绘制十万行


460
00:24:44,318 --> 00:24:47,754
我们绘制一百行就可以了


461
00:24:47,955 --> 00:24:48,956
这样工作就少了很多


462
00:24:49,923 --> 00:24:54,127
我们继续 创建一个执行来实现它


463
00:24:54,728 --> 00:24:58,065
如果是多个数据元素
数据点位于一个单一的


464
00:24:58,165 --> 00:25:01,368
屏幕点那么它就会找出最大值


465
00:25:01,435 --> 00:25:02,669
绘制一条单一的行


466
00:25:03,136 --> 00:25:07,341
如果我们使用一百个屏幕点
我们就会创建一百个屏幕行


467
00:25:08,408 --> 00:25:11,378
我们来切换到那个执行


468
00:25:12,312 --> 00:25:14,481
我们对它的感觉很好


469
00:25:14,581 --> 00:25:18,352
我们把元素数量的上限改成了十万


470
00:25:18,418 --> 00:25:20,621
而不是一万


471
00:25:21,488 --> 00:25:23,790
我们看看这对我们是否有帮助


472
00:25:25,559 --> 00:25:29,630
我要使用command-I来启动
Instruments


473
00:25:30,030 --> 00:25:31,899
因为Instruments已经打开了
它就会把它弄到


474
00:25:31,965 --> 00:25:35,369
前台立即开始录制


475
00:25:37,004 --> 00:25:38,872
好了 一个新的录制


476
00:25:39,540 --> 00:25:43,243
我们来滚动下滚动看起来没问题


477
00:25:44,478 --> 00:25:45,846
我再缩小下


478
00:25:46,747 --> 00:25:49,216
缩放性能也有了非常大的提高


479
00:25:49,383 --> 00:25:52,085
需要的时间更多
因为我要缩小的数据更多了


480
00:25:52,853 --> 00:25:54,054
看起来真的很好


481
00:25:54,888 --> 00:25:56,623
我要进行前后滑动


482
00:25:56,690 --> 00:25:59,226
现在它能很好地追踪我的手指了


483
00:25:59,726 --> 00:26:02,696
它能跟得上我的手指真棒


484
00:26:04,031 --> 00:26:05,799
万岁！都搞定了！


485
00:26:07,601 --> 00:26:09,536
还差一点


486
00:26:11,038 --> 00:26:12,506
当我们前后滚动时


487
00:26:12,573 --> 00:26:15,108
如果我们看一下我们使用的
CPU的实际数量


488
00:26:15,709 --> 00:26:18,345
我们就可以看到 你懂得
有时候会降到60%


489
00:26:18,412 --> 00:26:20,180
通常是七十到八十秒


490
00:26:21,048 --> 00:26:23,951
从技术上说
我们实现了我们的性能目标


491
00:26:24,551 --> 00:26:27,454
我们要做的
我们接下来要对这个app


492
00:26:27,721 --> 00:26:28,655
原型做什么？


493
00:26:28,722 --> 00:26:30,591
我们添加了一些附加特性


494
00:26:31,191 --> 00:26:36,263
我们知道我们需要比这里更多的净空


495
00:26:36,997 --> 00:26:42,169
我们怎样能让它更快？
我们怎样能让这个app更好？


496
00:26:42,236 --> 00:26:44,338
我们怎样实现性能目标？


497
00:26:45,405 --> 00:26:46,940
我们专注下这个


498
00:26:47,441 --> 00:26:48,675
我们来过滤下那个数据


499
00:26:50,143 --> 00:26:52,579
我要给我自己一点空间


500
00:26:53,180 --> 00:26:55,282
在这个例子中我要按住选项键


501
00:26:56,250 --> 00:26:57,985
点击“主要”把它展开


502
00:26:58,085 --> 00:27:02,222
我就可以到这里看到这里的这个方法


503
00:27:02,890 --> 00:27:06,460
你懂得 现在绘制路径就足够快了


504
00:27:06,527 --> 00:27:11,198
反而是构建路径成了瓶颈


505
00:27:12,266 --> 00:27:14,701
我想关注下这个方法


506
00:27:15,035 --> 00:27:16,436
我要点击下“聚焦”按钮


507
00:27:16,803 --> 00:27:21,708
它会把方法中的所有事情移动到一边


508
00:27:21,775 --> 00:27:26,480
把这个方法中


509
00:27:27,080 --> 00:27:29,082
我们的百分比标准化


510
00:27:29,149 --> 00:27:33,587
这个方法把55%的时间用在了
获取下个元素上


511
00:27:34,221 --> 00:27:38,892
把10到11%的时间用在了
objc msgSend上


512
00:27:39,560 --> 00:27:42,930
关于objc msgSend
我知道的是


513
00:27:42,996 --> 00:27:45,299
它是一个超快的方法


514
00:27:45,365 --> 00:27:46,733
它是经过极致优化的


515
00:27:47,134 --> 00:27:51,438
但是如果我能把那个10%
拿回来 我还是想要


516
00:27:52,539 --> 00:27:58,445
如果我们看看我们代码里面
我们就可以看到它已经 


517
00:27:58,512 --> 00:27:59,646
很干净了


518
00:27:59,713 --> 00:28:03,383
我们大部分的时间都花在了
获取下个元素上


519
00:28:04,084 --> 00:28:06,787
这里的这个百分比 要比
树状视图中的略微高一点


520
00:28:07,120 --> 00:28:09,690
因为它包括了
objc msgSend的时间


521
00:28:10,090 --> 00:28:14,795
如果我把它去掉
这个迭代程序就更快了


522
00:28:15,128 --> 00:28:19,366
希望我就可以实现我想要的性能提升


523
00:28:19,600 --> 00:28:23,103
请查德给我们讲讲如何实现这一点


524
00:28:26,106 --> 00:28:29,042
我们来谈谈objc msgSend


525
00:28:30,410 --> 00:28:35,148
无论你何时使用方括号符号


526
00:28:35,349 --> 00:28:37,951
无论你何时使用点符号
来访问一个对象的属性


527
00:28:38,552 --> 00:28:41,822
编辑器就会把它隐式插入


528
00:28:43,156 --> 00:28:46,026
它的目的是查找选择器的实现方法


529
00:28:46,093 --> 00:28:48,662
然后调用那个方法


530
00:28:49,029 --> 00:28:51,598
我们如何在Objective-C中
进行动态分派


531
00:28:51,665 --> 00:28:52,799
要讲的东西还很多


532
00:28:54,101 --> 00:28:59,139
Objc msgSend非常快
也不会推送堆栈结构


533
00:28:59,773 --> 00:29:02,376
当你看你的时间剖析时


534
00:29:02,576 --> 00:29:04,311
通常来说你不会看到它的效果


535
00:29:05,412 --> 00:29:08,549
你能看到它的时机
就是在一个完美的例子中


536
00:29:08,615 --> 00:29:11,451
就像我们在我们的
迭代程序中看到的那样


537
00:29:11,518 --> 00:29:15,088
我们要做的就是迭代超过十万个点


538
00:29:15,155 --> 00:29:19,359
用一个小的方法主体
称之为“获得下一个方法”


539
00:29:19,426 --> 00:29:21,428
只需增加一对值返回一个结构即可


540
00:29:22,529 --> 00:29:26,200
那么接下来要发生的
就是Objective-C消息发送


541
00:29:26,266 --> 00:29:30,070
开销时间会积累到一个可测量的程度


542
00:29:31,405 --> 00:29:34,074
是否有方法可以避开开销呢？


543
00:29:35,442 --> 00:29:37,544
不一定


544
00:29:38,212 --> 00:29:41,181
Objective-C从设计上
就是一种动态语言


545
00:29:41,481 --> 00:29:43,851
要访问对象和类的方法你就必须


546
00:29:44,117 --> 00:29:47,454
进行objc msgSend调用


547
00:29:48,255 --> 00:29:52,025
每次它都会这样做
因为你可以在运行时间


548
00:29:52,092 --> 00:29:53,694
转换方法执行


549
00:29:54,161 --> 00:29:57,631
Objective-C内没有
编译时间


550
00:29:57,698 --> 00:29:59,600
比如说我想调用这个特殊的方法主体


551
00:30:00,534 --> 00:30:04,505
这里唯一的异常是 如果
你进行所谓的“方法缓存”


552
00:30:04,905 --> 00:30:07,307
你可以自己查找方法执行


553
00:30:07,774 --> 00:30:09,543
然后通过函数指针调用它


554
00:30:10,244 --> 00:30:12,846
一般来说我不推荐你们这么做


555
00:30:13,347 --> 00:30:15,282
你可以想象的到它很脆弱


556
00:30:15,782 --> 00:30:20,687
一般来说 根据我的经验它没有给过
我期望的性能你得想想我们起初


557
00:30:21,255 --> 00:30:23,757
到这里的目的是什么


558
00:30:24,124 --> 00:30:28,028
我们到这里的原因获得下个
元素方法有一个小的方法主体


559
00:30:28,729 --> 00:30:31,565
即使你通过函数指针调用它
你也必须对自变量


560
00:30:31,632 --> 00:30:34,234
进行整理把帧推送到堆栈上


561
00:30:34,301 --> 00:30:35,936
并且在你完成后把它们弹出来


562
00:30:36,803 --> 00:30:38,839
你们在上一组幻灯片中看到的正是这个


563
00:30:38,906 --> 00:30:42,142
开销可能会很大增加后会再返回


564
00:30:43,177 --> 00:30:47,781
我想要指出的是方法缓存并不像


565
00:30:47,848 --> 00:30:49,449
直接插入那样快在这个例子中


566
00:30:49,516 --> 00:30:53,120
我们真正想实现的是
直接插入那个小的方法主体


567
00:30:54,488 --> 00:30:56,390
我们在Objective-C中
该怎样实现？


568
00:30:56,790 --> 00:30:59,059
你还有其它选项


569
00:30:59,159 --> 00:31:01,461
首先 你本来应该用 C


570
00:31:02,396 --> 00:31:04,398
你本来应该用结构而不是一个


571
00:31:04,464 --> 00:31:08,001
迭代程序举例来说 你可以向这个
方法中传递一个C线


572
00:31:08,702 --> 00:31:13,640
如果你想要那个OO特点
你可以使用C++


573
00:31:14,274 --> 00:31:16,210
你在Objective-C中使用
C++的方法


574
00:31:16,276 --> 00:31:18,679
是把文件从a .m
重命名为a .mm


575
00:31:18,879 --> 00:31:20,714
然后你就可以使用C++语法


576
00:31:21,448 --> 00:31:23,183
因为通常Arc是默认打开的


577
00:31:23,350 --> 00:31:27,487
然后你取出Objective-C
对象把它们放进


578
00:31:27,955 --> 00:31:32,025
STL容器内把它们放到
你的类和结构的实体变量中


579
00:31:33,126 --> 00:31:37,231
这很方便
你也可以得到C++的性能好处


580
00:31:37,297 --> 00:31:39,766
我在Instruments中大量用它
以便在轨迹视图


581
00:31:39,833 --> 00:31:45,272
以及Instruments
其它关键的地方尽可能地快


582
00:31:46,039 --> 00:31:50,110
根据我的亲身经验
这个有一个主要的下降趋势


583
00:31:50,677 --> 00:31:53,313
你需要提前知道
你的代码的哪一部分会


584
00:31:53,614 --> 00:31:56,783
从C++中受益
哪一部分代码会从


585
00:31:57,317 --> 00:31:59,820
Objective-C中受益


586
00:32:00,487 --> 00:32:02,956
有时候像我们在演示示例中那样


587
00:32:03,156 --> 00:32:05,826
你可能在那里犯错误
并且直到进行剖析才意识到


588
00:32:06,193 --> 00:32:07,594
我们是用Objective-C
写了我们的


589
00:32:07,661 --> 00:32:11,832
Objective-C没有意识到
它在我们的时间剖析中有多慢


590
00:32:12,900 --> 00:32:17,538
除了我刚刚提到的这些
你还有其它更好的选项吗？


591
00:32:19,006 --> 00:32:23,210
当然了 你知道的已经有了


592
00:32:26,580 --> 00:32:29,183
Swift非常完美因为不像
Objective-C


593
00:32:29,249 --> 00:32:31,652
Swift只有在注释为动态时
它才是动态的


594
00:32:32,386 --> 00:32:35,989
如果你确保性能关键类是内部的


595
00:32:36,056 --> 00:32:39,760
并且使用整体模块优化


596
00:32:39,860 --> 00:32:43,130
编译器或者整体工具链
就可以确定何时只有


597
00:32:43,430 --> 00:32:45,199
一个方法执行


598
00:32:45,432 --> 00:32:49,369
并且把它内联到调用点
让你的性能有明显的提升


599
00:32:49,436 --> 00:32:52,940
尤其是对迭代程序这个例子


600
00:32:53,607 --> 00:32:56,944
因为我们是在生成原型
在Swift的视图控制器中


601
00:32:57,010 --> 00:32:59,413
重写迭代程序就非常容易了


602
00:32:59,947 --> 00:33:01,181
克里斯之前干过这个


603
00:33:02,850 --> 00:33:09,623
我有一个Swift执行已经就绪了


604
00:33:10,057 --> 00:33:14,862
这是Objective-C执行的
一个简易的接口


605
00:33:14,928 --> 00:33:17,164
采用了他们在今天上午的
会议上提出的关于...


606
00:33:18,665 --> 00:33:22,269
...优化Swift代码的几点建议


607
00:33:22,636 --> 00:33:24,805
具体来说就是打开整体模块优化


608
00:33:25,506 --> 00:33:28,342
让我们来剖析下这个
Command-I


609
00:33:29,042 --> 00:33:29,877
它会开始构建


610
00:33:30,711 --> 00:33:33,480
安装到设备上


611
00:33:34,081 --> 00:33:36,350
它会开始进行剖析


612
00:33:39,052 --> 00:33:42,823
好的 我要把应用程序提前
这样你们就能看到


613
00:33:44,124 --> 00:33:45,292
这是滚动


614
00:33:45,926 --> 00:33:47,060
看起来不错


615
00:33:48,295 --> 00:33:49,162
缩小


616
00:33:49,696 --> 00:33:51,298
好了


617
00:33:51,932 --> 00:33:52,766
缩小


618
00:33:53,033 --> 00:33:54,201
非常棒 非常快


619
00:33:54,368 --> 00:33:55,936
要缩小很多数据


620
00:33:57,671 --> 00:34:02,075
现在 如果我前后移动
它移动的就非常快了


621
00:34:03,911 --> 00:34:04,745
太棒了


622
00:34:06,647 --> 00:34:09,349
谢谢 实际上我们可以到这里


623
00:34:09,416 --> 00:34:11,385
看看CPU使用情况


624
00:34:11,818 --> 00:34:15,022
你懂得我们取得的优化超过了


625
00:34:15,088 --> 00:34:19,193
我们的预期去掉
objc msgSend


626
00:34:19,259 --> 00:34:23,797
我们本来预期会
有5到6%的提升 这个有点低


627
00:34:25,132 --> 00:34:28,402
如果我关掉这个提示三角符号 
你就可以看到


628
00:34:28,902 --> 00:34:31,572
它们两个以此运行 你可以
看到之前的运行更低...


629
00:34:31,972 --> 00:34:37,010
当前的运行很明显更低


630
00:34:37,643 --> 00:34:39,580
事实上如果我到这儿


631
00:34:39,646 --> 00:34:44,150
查找我的构建路径方法
现在我就必须进行搜索


632
00:34:44,384 --> 00:34:45,652
这就是你进行搜索的方法


633
00:34:46,954 --> 00:34:50,424
如果我点击command-F
这个对话就会显示出来


634
00:34:50,991 --> 00:34:53,827
我可以输入构建路径 


635
00:34:54,995 --> 00:34:58,899
它会在这里给我显示我的方法


636
00:34:59,967 --> 00:35:03,670
如果我们看看这个 你就可以
在这里看到我的Swift代码


637
00:35:04,204 --> 00:35:07,674
我的获得下一个调用就在这里


638
00:35:08,175 --> 00:35:09,810
没有在任何样例中显示出来


639
00:35:14,214 --> 00:35:15,749
你懂得没有样例包括了这个


640
00:35:16,116 --> 00:35:19,186
为什么？因为Swift能够把它内联


641
00:35:19,820 --> 00:35:22,322
鞭子意味着这里没有函数开销


642
00:35:22,389 --> 00:35:24,191
没有方法调用开销等等


643
00:35:24,258 --> 00:35:28,595
因为迭代程序的代码
和其余的代码是内联的


644
00:35:28,662 --> 00:35:32,132
它就有了进一步优化
这就解释了出现比我们预期的


645
00:35:32,199 --> 00:35:34,034
更高的性能的原因


646
00:35:34,668 --> 00:35:37,638
它是忽略了动态调度


647
00:35:39,006 --> 00:35:42,042
查德 你还有什么想对大家说的么？


648
00:35:43,744 --> 00:35:44,878
当然了 我们还剩五分钟！


649
00:35:47,581 --> 00:35:50,751
当你自行探索Instruments时
这里有一些小窍门


650
00:35:51,385 --> 00:35:55,722
首先要指出的是在录制设置下面


651
00:35:56,190 --> 00:35:57,624
叫做“录制等待线程”


652
00:35:58,058 --> 00:35:59,293
我提到过我们使用样例


653
00:35:59,359 --> 00:36:01,528
活跃CPU的服务和内核


654
00:36:01,795 --> 00:36:04,097
但是如果你有空闲的线程
被一个加锁阻塞或者等待


655
00:36:04,164 --> 00:36:07,134
输入/输出
你就可以勾选这个复选框


656
00:36:07,467 --> 00:36:09,736
服务就同样也会对空闲线程进行采样


657
00:36:10,370 --> 00:36:12,172
如果你有代码和加锁争夺支配权


658
00:36:12,239 --> 00:36:14,741
那么当你激活录制等待线程时


659
00:36:15,142 --> 00:36:17,711
你会看到热区显示出来


660
00:36:18,946 --> 00:36:20,781
我还发现了另外一件有趣的事


661
00:36:21,448 --> 00:36:25,886
在“显示设置”中调用树那里


662
00:36:26,386 --> 00:36:27,454
调用树被反转了过来


663
00:36:28,689 --> 00:36:31,658
打个比喻就是它把调用树颠倒了过来


664
00:36:31,992 --> 00:36:36,096
在树的底部节点看到的就不是叶子


665
00:36:36,196 --> 00:36:37,831
那就是没有被调用到任何地方的函数


666
00:36:38,098 --> 00:36:38,966
它们显示到了顶部


667
00:36:39,299 --> 00:36:42,302
如果某个实用功能同时
被五六个地方调用了


668
00:36:42,636 --> 00:36:46,607
你把调用树反转过来
看看到底是谁在调用


669
00:36:46,807 --> 00:36:48,375
那个特定的函数


670
00:36:48,909 --> 00:36:51,211
它给你提供了调用树上的
数据的一个不同的视角


671
00:36:51,979 --> 00:36:53,847
当你在调用树上右键点击一个节点


672
00:36:54,548 --> 00:36:58,852
你就可以看到环境菜单
这也是那里的一件有趣的事


673
00:36:59,086 --> 00:37:03,123
我经常做的一件事就是给调用者记账


674
00:37:03,423 --> 00:37:06,426
那么你就可以给调用者的方法
记一笔欠函数的账


675
00:37:07,027 --> 00:37:10,130
你可以给调用者记一笔欠
整个框架库的账


676
00:37:11,064 --> 00:37:14,635
那里还有一个选项可以修剪子树


677
00:37:14,701 --> 00:37:16,904
如果你当时不想处理某个具体的问题


678
00:37:16,970 --> 00:37:20,641
你可以把它从数据上
修剪掉然后专注于你想专注的事情


679
00:37:22,543 --> 00:37:23,777
我们从中学到了什么？


680
00:37:25,679 --> 00:37:29,583
就是通过这个我要提醒你们的第一件事


681
00:37:29,917 --> 00:37:32,352
就是提前合并性能目标


682
00:37:33,387 --> 00:37:35,455
如果你像我们一样
进行了一个大的性能重写


683
00:37:35,522 --> 00:37:38,859
你要首先设好预算然后对它进行监视


684
00:37:38,926 --> 00:37:41,428
因为一旦你开始在它的顶部
分层放置大量的代码


685
00:37:41,495 --> 00:37:42,963
要改变就很难了


686
00:37:44,431 --> 00:37:45,499
其次 要经常进行度量


687
00:37:45,832 --> 00:37:48,535
在我们的整个演示中我们用时间
分析器进行了时间剖析


688
00:37:48,602 --> 00:37:52,105
我们用那个数据来找出“热区”


689
00:37:52,172 --> 00:37:56,076
然后把它返回最后我们就
得到了一个运行良好的应用程序


690
00:37:56,610 --> 00:38:00,681
如果你还是不明白 可能
你可能很幸运 直接点吧


691
00:38:01,081 --> 00:38:03,483
我会从一个测量开始
然后把它当成领头羊来追随


692
00:38:05,152 --> 00:38:06,720
第三 这个对我来说很重要


693
00:38:07,187 --> 00:38:09,022
我鼓励你们深入挖掘下去


694
00:38:09,790 --> 00:38:11,558
你第一眼看到的某些性能问题可能


695
00:38:11,625 --> 00:38:13,827
看上去是无解的


696
00:38:14,294 --> 00:38:16,763
你说别人的的代码中就出现过这种问题


697
00:38:16,830 --> 00:38:18,365
或者是运行时间的副效应


698
00:38:19,166 --> 00:38:22,135
我们给出你时间分析器
运行时间的详细资料的


699
00:38:22,202 --> 00:38:24,938
原因给出你反汇编视图的样子


700
00:38:25,506 --> 00:38:29,176
就是想向你们展示那是一个
细节丰富的一个完整的世界


701
00:38:29,443 --> 00:38:34,414
用它你就可以像我们
今天一样解决性能问题


702
00:38:34,982 --> 00:38:38,619
我鼓励你们带着创造性去
进一步挖掘


703
00:38:38,852 --> 00:38:40,854
看看像这样的会议


704
00:38:40,988 --> 00:38:44,525
我知道你们能够修复
问题 实现你们想要的性能目标


705
00:38:46,960 --> 00:38:48,896
只要你今天开始干就行


706
00:38:49,263 --> 00:38:52,599
史蒂芬·莱塞是我们的
开发工具福音传道者


707
00:38:52,666 --> 00:38:54,868
如果你有问题的话就可以联系他


708
00:38:55,769 --> 00:39:00,641
与我们相关的会议是
“能量调试问题”


709
00:39:00,941 --> 00:39:03,644
证明了如果你在CPU上的代码
是有效的 CPU耗能就会更低


710
00:39:03,810 --> 00:39:05,846
那次会议是周三举行的


711
00:39:06,380 --> 00:39:09,917
明天还会有一个关于iOS
以及Watch OS的会议


712
00:39:10,284 --> 00:39:13,287
好消息是 时间分析器
也能用于watch上的app


713
00:39:13,353 --> 00:39:14,188
这是一项大福利


714
00:39:14,821 --> 00:39:16,423
祝你们在会议剩余的时间内过得愉快

