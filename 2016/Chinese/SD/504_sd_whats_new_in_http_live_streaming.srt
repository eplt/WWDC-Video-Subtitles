1
00:00:19,353 --> 00:00:21,421
HTTP Live Streaming的新特性


2
00:00:21,488 --> 00:00:22,322
打开了吗？


3
00:00:26,293 --> 00:00:27,127
下午好


4
00:00:27,928 --> 00:00:29,196
我是Roger Pantos


5
00:00:29,263 --> 00:00:32,031
本次会话关于"HTTP Live
Streaming的新特性"


6
00:00:32,766 --> 00:00:36,403
我们谈论HLS有七八年之久了


7
00:00:36,470 --> 00:00:40,407
然而 每次我谈的时候
营销部的人都说


8
00:00:40,741 --> 00:00:43,544
"你一定要跟人们说
有什么新进展了！"


9
00:00:43,710 --> 00:00:47,948
所以开始吧
这就是新的内容


10
00:00:49,216 --> 00:00:52,052
但首先
用20秒简介HLS


11
00:00:52,286 --> 00:00:55,255
HLS重点在于播放
播放列表 什么是播放列表？


12
00:00:55,322 --> 00:00:57,291
就是这样的东西
是TXT文件


13
00:00:57,558 --> 00:01:00,594
上面有标签
是蓝色的那些


14
00:01:00,894 --> 00:01:04,096
还有分段 白色的那些
每一个都是10秒的媒体文件


15
00:01:04,164 --> 00:01:07,201
如果你想播放一个
你在这些标签中翻找一遍


16
00:01:07,267 --> 00:01:09,036
找找有趣的东西


17
00:01:09,102 --> 00:01:12,673
比如...这个写着
这是INF分段 先加载它


18
00:01:12,906 --> 00:01:13,740
所以去加载


19
00:01:14,241 --> 00:01:16,243
然后加载segment1
播放它


20
00:01:16,310 --> 00:01:17,945
加载segment2
播放它


21
00:01:18,011 --> 00:01:20,514
可能这是直播播放列表
所以你刷新播放列表


22
00:01:20,581 --> 00:01:22,282
加载segment3
播放它


23
00:01:22,349 --> 00:01:24,718
简而言之
这基本上就是HLS


24
00:01:25,085 --> 00:01:27,888
所以现在我们都
明白这是怎么一回事了


25
00:01:28,622 --> 00:01:29,890
我们来讲讲新的内容


26
00:01:30,624 --> 00:01:31,959
很好 好了


27
00:01:33,427 --> 00:01:35,095
MPEG-4 Fragment Support


28
00:01:35,162 --> 00:01:37,898
MPEG-4是个什么东西
为什么要被分成片段？


29
00:01:39,333 --> 00:01:42,069
在座的大多数人
可能熟悉MPEG-4文件


30
00:01:42,135 --> 00:01:46,473
如果你的硬盘上有一部电影
这很可能就是MP4格式的


31
00:01:46,540 --> 00:01:47,908
或者是相近的格式


32
00:01:48,909 --> 00:01:53,146
如果你去深入观察
它包括一个样本表


33
00:01:53,213 --> 00:01:57,651
通常是开头
然后所有的样本数据都在其后


34
00:01:58,418 --> 00:01:59,853
我们最初是这样做的


35
00:01:59,920 --> 00:02:04,791
之后 我们推出了新的分段
随后称之为片段


36
00:02:04,858 --> 00:02:08,362
片段基本上是指一种方法
能将你的MPEG-4文件


37
00:02:08,428 --> 00:02:11,698
分割成这些
小的可播放数据岛


38
00:02:11,765 --> 00:02:14,168
小的样本表
小的样本数据


39
00:02:14,234 --> 00:02:16,670
小的样本表
更多小的样本数据


40
00:02:17,204 --> 00:02:20,741
这些小岛
都叫做"片段"


41
00:02:21,241 --> 00:02:26,613
所以我们今天宣布的
本质上就是你现在能做的是


42
00:02:26,680 --> 00:02:30,651
你能够将这些东西
这些MPEG-4片段


43
00:02:30,717 --> 00:02:33,053
在你的HLS播放列表中
当做分段使用


44
00:02:33,120 --> 00:02:35,489
就像传输流文件那样


45
00:02:35,556 --> 00:02:37,591
或者基本音频流


46
00:02:38,392 --> 00:02:41,929
我们会更新细则
来给你详细信息


47
00:02:41,995 --> 00:02:44,331
我认为现在
会有本次会议的链接


48
00:02:45,399 --> 00:02:46,233
不过...


49
00:02:47,734 --> 00:02:53,507
它能让你做的
本质上是使用fMP4分段


50
00:02:53,574 --> 00:02:58,812
传输流能做的事
你都可以用fMP4做到


51
00:02:58,979 --> 00:03:02,916
这包括iframe播放列表
包括不连续性


52
00:03:02,983 --> 00:03:06,486
包括直播流 等等
同样的功能


53
00:03:06,753 --> 00:03:10,290
当然 我们会应用到
我们所有的HLS平台上


54
00:03:10,490 --> 00:03:13,827
所以你可以选择将你所有的
流媒体编码成fMP4文件


55
00:03:13,894 --> 00:03:16,029
然后在所有平台上使用


56
00:03:16,597 --> 00:03:21,101
为什么要这么做？
简言之 互操作性


57
00:03:21,635 --> 00:03:26,740
如果你要将你整个
媒体库用一种方式编码


58
00:03:26,807 --> 00:03:31,812
传输到Apple平台上
之后你还要重新进行编码


59
00:03:31,879 --> 00:03:35,649
换一种方式 例如传输到
Android设备上 那就太糟了


60
00:03:36,683 --> 00:03:39,653
但如果你只有一个库


61
00:03:40,120 --> 00:03:43,724
那你的传输成本会下降
你的存储成本会下降...


62
00:03:43,924 --> 00:03:45,726
缓存的使用率会更好


63
00:03:45,792 --> 00:03:49,029
因为你不再是拼命抢用缓存了


64
00:03:49,363 --> 00:03:52,032
而且作为附加福利


65
00:03:53,267 --> 00:03:56,603
还有 如果你有
单一的生产链


66
00:03:56,737 --> 00:03:58,705
你可以在你全部的生态系统中


67
00:04:00,507 --> 00:04:04,077
使用相同的工具和验证方法


68
00:04:04,411 --> 00:04:05,746
作为附加福利


69
00:04:05,812 --> 00:04:09,449
因为fMP4不使用
同样的信息分包


70
00:04:09,516 --> 00:04:10,918
而传输流使用


71
00:04:11,451 --> 00:04:17,057
在较低的比特率下
你会得到略微更高的效率


72
00:04:17,124 --> 00:04:18,791
所以这算是附赠的好处


73
00:04:19,959 --> 00:04:24,198
所以HLS对各位播放列表
作家带来了什么变化？


74
00:04:24,698 --> 00:04:26,633
实际上 没什么变化


75
00:04:26,700 --> 00:04:29,536
如果我们拿之前
看过的播放列表


76
00:04:29,603 --> 00:04:33,040
并将它转化成fMP4格式
我们只需要这样做


77
00:04:33,440 --> 00:04:37,044
我们更改初始化分段
使其指向Movie Box


78
00:04:37,110 --> 00:04:40,347
然后每个分段
就成为了MPEG-4片段


79
00:04:41,014 --> 00:04:42,115
这就行了


80
00:04:42,182 --> 00:04:45,319
播放列表级别上的
其他东西几乎是一样的


81
00:04:45,819 --> 00:04:49,156
在分段级别上
这里还有一点我想谈谈


82
00:04:49,223 --> 00:04:50,357
那就是加密


83
00:04:50,457 --> 00:04:53,927
如你所知 HLS有
两种不同的加密方法


84
00:04:53,994 --> 00:04:56,463
你要么可以只加密整个分段


85
00:04:56,663 --> 00:04:58,398
AES CBC 全部加密


86
00:04:58,665 --> 00:05:01,702
这对传输流或是
fMP4都是一样的


87
00:05:02,202 --> 00:05:06,039
对于样本加密 例如
如果你想用FairPlay Streaming


88
00:05:06,273 --> 00:05:10,077
这就稍微复杂了
因为你必需说明


89
00:05:10,143 --> 00:05:12,679
哪部分文件已加密
哪部分未加密


90
00:05:13,380 --> 00:05:16,850
这一次...上一次
我们做的是传输流


91
00:05:16,917 --> 00:05:18,652
我们本质上创造出我们自己的格式


92
00:05:19,386 --> 00:05:21,655
这一次 我们决定
使用现有的格式


93
00:05:21,889 --> 00:05:23,190
而且...


94
00:05:26,560 --> 00:05:29,596
在这MPEG中叫做
"共用加密"


95
00:05:29,663 --> 00:05:31,832
是一种标准
几年前推出的


96
00:05:32,032 --> 00:05:35,602
最新版的标准里
有一个叫做cbcs的模式


97
00:05:35,669 --> 00:05:37,738
这可以兼容
FairPlay Streaming


98
00:05:37,804 --> 00:05:40,240
所以如果你在
HLS中做样本加密


99
00:05:40,440 --> 00:05:43,610
你会使用共用加密
的cbcs模式来做


100
00:05:44,411 --> 00:05:47,114
有了加密
播放列表和其他东西


101
00:05:47,181 --> 00:05:50,851
这基本上就是
HLS的全部内容了


102
00:05:51,118 --> 00:05:53,120
围绕片段化MPEG-4


103
00:05:53,520 --> 00:05:57,791
但如果我们要想实现
那个快乐 闪亮 有活力的世界


104
00:05:57,858 --> 00:06:00,961
在那里每个人可以
只有一条目录


105
00:06:01,161 --> 00:06:04,364
可以传输到任何地方
那我们就必须超越HLS


106
00:06:04,631 --> 00:06:07,901
我们要做的一件事是
我们需要写下一套规则


107
00:06:07,968 --> 00:06:12,673
上面写着 "你要这样
创作你的fMP4分段或


108
00:06:12,739 --> 00:06:15,976
片段诸如此类
来让它们在任何地方播放"


109
00:06:16,610 --> 00:06:18,345
而且我们也一直在这方面努力


110
00:06:18,812 --> 00:06:23,016
一开始是我们和
微软做的一个假设演练


111
00:06:23,083 --> 00:06:26,486
一旦当我们进展到
觉着靠谱的时候


112
00:06:26,553 --> 00:06:30,724
觉着能行了
我们就向MPEG提了这件事


113
00:06:31,024 --> 00:06:33,927
那里的很多人都认为
这个想法很不错


114
00:06:33,994 --> 00:06:38,899
所以最后得出的
是一套约束条件


115
00:06:38,966 --> 00:06:42,169
用于如何创建你的fMP4分段


116
00:06:42,469 --> 00:06:45,873
所以你要将
音频和视频分开传输


117
00:06:46,039 --> 00:06:48,742
你要在每个视频分段
开头加入一个iframe


118
00:06:48,809 --> 00:06:51,245
你要保证能严格
对齐所有分段


119
00:06:51,311 --> 00:06:52,779
涵盖不同的比特率


120
00:06:53,413 --> 00:06:56,583
你不需要做这些的
如果你的目标只是HLS


121
00:06:56,984 --> 00:07:01,622
当你想要让你的媒体库
拥有最广泛的受众


122
00:07:01,688 --> 00:07:05,125
那我们为你准备了一系列推荐


123
00:07:05,392 --> 00:07:11,365
我认为这会让所有人
受益...至少我希望如此


124
00:07:12,266 --> 00:07:13,200
所以...


125
00:07:13,634 --> 00:07:17,905
现在我要转换一下
来谈谈其他事情


126
00:07:18,272 --> 00:07:20,407
大家都爱讨论的话题
...元数据


127
00:07:21,008 --> 00:07:26,013
所以为了描述它
我首先开始谈谈


128
00:07:26,079 --> 00:07:29,750
一些我们已经在HLS上为
元数据所做的现有的东西


129
00:07:30,651 --> 00:07:32,486
静态元数据和ID3


130
00:07:32,986 --> 00:07:36,990
静态元数据是用于
静态元数据的 不出意料


131
00:07:37,858 --> 00:07:40,360
它会提供
内容标题之类的东西


132
00:07:40,427 --> 00:07:41,828
大多数是文本


133
00:07:42,062 --> 00:07:44,431
这就能很容易地
放入播放列表文件中


134
00:07:44,498 --> 00:07:46,466
要么直接是标签


135
00:07:46,533 --> 00:07:50,037
或者打包成JSON文件
然后通过URL引用


136
00:07:52,639 --> 00:07:55,175
现在只有一个标题
或一个作者


137
00:07:55,242 --> 00:07:58,512
或一个版权
对应每个演示文件 是静态的


138
00:07:59,213 --> 00:08:03,183 line:1
但这样的好处是
在你任何想要的时候都能获得


139
00:08:03,250 --> 00:08:04,618 line:1
马上就能获得


140
00:08:06,053 --> 00:08:08,021 line:1
所以拿它和ID3对比


141
00:08:10,557 --> 00:08:16,063 line:1
因为计时元数据和
媒体演示文件的时间轴相连接


142
00:08:16,129 --> 00:08:19,066 line:1
还经常在流媒体中
用于为事件发信号


143
00:08:19,132 --> 00:08:22,169 line:1
例如 广告的开始
节目的开始


144
00:08:23,504 --> 00:08:28,008 line:1
它存在于媒体格式的本身
所以是一种叫做ID3的二进制格式


145
00:08:28,642 --> 00:08:32,145 line:1
这让它体积小巧
同时还变得难以创作


146
00:08:32,212 --> 00:08:34,014 line:1
因为需要专业的工具


147
00:08:34,081 --> 00:08:36,082 line:1
如果你要排除故障
这会让你痛不欲生


148
00:08:36,149 --> 00:08:37,417 line:1
很难读取ID3


149
00:08:38,352 --> 00:08:40,287 line:1
但你想要多少数量都行


150
00:08:40,354 --> 00:08:42,856 line:1
而且可以放置到
时间轴上的任意位置


151
00:08:43,056 --> 00:08:44,391 line:1
所以这十分强大


152
00:08:45,125 --> 00:08:47,961 line:1
而在另一面
因为它存在于媒体文件中


153
00:08:48,028 --> 00:08:50,831 line:1
我们只能在播放之后
才能提供给你


154
00:08:52,165 --> 00:08:55,302 line:1
所以这个新玩意
有什么作用？


155
00:08:56,803 --> 00:09:01,775 line:1
我们添加的是一种在播放列表
自身内部创建计时元数据的方式


156
00:09:02,743 --> 00:09:07,714 line:1
所以现在你在ID3中用的
同样东西都可以在这上面使用


157
00:09:09,449 --> 00:09:12,719 line:1
你可以将它们创建成文本
这很简单


158
00:09:12,920 --> 00:09:15,489 line:1
你可以轻松地把它们
放入播放列表中


159
00:09:16,723 --> 00:09:18,325 line:1
而且想要多少数量都行


160
00:09:18,392 --> 00:09:21,295 line:1
它们可以覆盖
可以嵌套 什么都行


161
00:09:22,729 --> 00:09:26,567 line:1
另一方面
因为它们在播放列表中


162
00:09:26,633 --> 00:09:29,837 line:1
我们读取完播放列表之后
就可以马上提供给你整个集合


163
00:09:30,671 --> 00:09:32,639 line:1
无论播放指针位于
媒体文件的哪个位置


164
00:09:33,240 --> 00:09:35,075
这就非常有助于


165
00:09:35,142 --> 00:09:38,378
做特别像是
导航控制之类的事情


166
00:09:39,813 --> 00:09:45,219
所以它是什么样子？
我们如何应用它呢？


167
00:09:45,586 --> 00:09:48,555
我们在HLS中已经有
日期的概念了


168
00:09:48,822 --> 00:09:53,360
PROGRAM-DATE-TIME标签允许
你精准地在播放列表内部发送时间信号


169
00:09:53,427 --> 00:09:55,295
所以我们以此为基础 我们说


170
00:09:55,529 --> 00:10:01,268
每个比特的元数据都
将会被表达成时间范围


171
00:10:01,668 --> 00:10:04,304
并附带有一组的属性


172
00:10:04,805 --> 00:10:07,574
其中一些是我们的
其中一些是你们的


173
00:10:09,877 --> 00:10:11,979
我们设置句法
所以能整洁地从直播流


174
00:10:12,045 --> 00:10:13,947
添加和移除这些东西


175
00:10:14,214 --> 00:10:16,517
所以这能完美契合
直播工作流


176
00:10:18,785 --> 00:10:20,454
它是什么样子？


177
00:10:21,255 --> 00:10:22,956
我们来看一下这些句子


178
00:10:24,758 --> 00:10:27,294
我们将新的标签称作
DATERANGE标签


179
00:10:27,361 --> 00:10:28,562
这是另一个播放列表


180
00:10:28,629 --> 00:10:30,831
第一句基本上
在说现在是什么时间


181
00:10:31,064 --> 00:10:33,333
第二个是DATERANGE标签
如果你去看看


182
00:10:33,400 --> 00:10:36,670
你能看到
这是由属性组成的


183
00:10:37,037 --> 00:10:40,841
这些蓝色的部分是细则中定义出来的


184
00:10:41,108 --> 00:10:43,210
ID START-DATE
DURATION


185
00:10:44,044 --> 00:10:50,317
我们为各位保留了X-namespace
这与HTTP相似


186
00:10:50,384 --> 00:10:53,554
这样你能用它来
放入你想要的属性值对


187
00:10:53,854 --> 00:10:57,524
在本案例中 有人决定
放入AD-ID和beacon URL


188
00:10:58,392 --> 00:10:59,893
这是一个示例


189
00:10:59,960 --> 00:11:02,362
这是它们在播放列表中的样子


190
00:11:03,830 --> 00:11:08,669
当你在进行内容创建时
你可以用在直播或点播上


191
00:11:08,735 --> 00:11:11,171
这只需要有
DATERANGE标签和日期


192
00:11:11,872 --> 00:11:15,709
很明显 在创建播放列表时
你可以将这些东西放进去


193
00:11:15,976 --> 00:11:19,880
不过另一个好处是
因为播放列表易于操作


194
00:11:19,947 --> 00:11:22,282
如果你有后期制作工作流


195
00:11:22,349 --> 00:11:24,651
在做广告插入


196
00:11:24,718 --> 00:11:27,054
可以非常容易地使用元数据


197
00:11:27,120 --> 00:11:29,323
同时增强播放列表和演示文件


198
00:11:30,591 --> 00:11:32,192
应众人要求


199
00:11:32,259 --> 00:11:36,763
我们还包括了如何
映射SCTE-35的规则


200
00:11:36,830 --> 00:11:41,068
你可以在源媒体文件中找到它
然后用于DATERANGE标签之内


201
00:11:41,201 --> 00:11:46,306
这样你可以在HLS中
无损地执行SCTE-35


202
00:11:47,574 --> 00:11:51,011
最后我们添加了
媒体流验证程序的支持


203
00:11:51,178 --> 00:11:52,779
我想花点时间


204
00:11:52,846 --> 00:11:55,315
宣传一下
我们有的新工具


205
00:11:55,749 --> 00:11:57,284
我们办了一次演讲


206
00:11:57,351 --> 00:11:59,486
现在我们没有时间说这件事


207
00:11:59,553 --> 00:12:02,422
但我们办了一次演讲
谈论了新的工具


208
00:12:02,756 --> 00:12:04,691
所以我鼓励大家去看看


209
00:12:04,892 --> 00:12:07,661
你可以在你的应用
或其他东西上点播


210
00:12:08,595 --> 00:12:10,764
你应该看看
有什么新的本领


211
00:12:10,831 --> 00:12:13,267
特别出现在验证程序上了


212
00:12:14,434 --> 00:12:15,569
对于重放


213
00:12:15,636 --> 00:12:20,240
当你想让视频流
中的元数据起作用


214
00:12:21,975 --> 00:12:24,011
你要有一组
AVFoundation API


215
00:12:24,211 --> 00:12:26,813
所以这个时候
你一定要在应用内部


216
00:12:27,381 --> 00:12:31,151
而且API本质上就是
"给我你目前有的所有数据"


217
00:12:31,552 --> 00:12:35,189
然后如果你有直播播放列表
当有新内容出现时要通知我


218
00:12:36,323 --> 00:12:41,562
这中心围绕在
一个新的对象 叫做


219
00:12:41,728 --> 00:12:44,932
AVPlayerItemMetadataCollector


220
00:12:45,599 --> 00:12:49,603
我们这里有一个小样本
你能看到没有什么特别的


221
00:12:50,704 --> 00:12:52,639
你创建资源和PlayerItem


222
00:12:52,706 --> 00:12:54,908
然后你说
"我想收集一些元数据"


223
00:12:54,975 --> 00:12:57,110
所以你创建
MetadataCollector


224
00:12:57,377 --> 00:13:00,013
你将自己设定成委托
这样我们可以将内容告诉你


225
00:13:00,214 --> 00:13:01,882
然后将它添加到
PlayerItem


226
00:13:02,249 --> 00:13:07,321
这就好了
之后你就得到所有元数据项了


227
00:13:07,788 --> 00:13:11,658
所以使用起来十分容易
十分强大


228
00:13:12,025 --> 00:13:15,262
我认为这会很快成为
一种首选方式


229
00:13:15,329 --> 00:13:17,564
来将元数据输入到HLS中


230
00:13:18,432 --> 00:13:21,835
所以接下来
我们今天要讲的


231
00:13:21,902 --> 00:13:27,140
是另一个功能
这也是应众人要求的


232
00:13:27,641 --> 00:13:33,847
那就是离线模式下
播放HLS的功能


233
00:13:39,920 --> 00:13:41,922
我想请我的同事


234
00:13:41,989 --> 00:13:44,258
Jordan Schneider
上台给大家作说明


235
00:13:52,165 --> 00:13:57,471
嗨 看看幻灯片好不好用


236
00:13:58,672 --> 00:13:59,540
好了


237
00:13:59,773 --> 00:14:03,744
在iOS 10中 我们让你能够下载


238
00:14:03,810 --> 00:14:06,647
并播放HLS内容不需要网络连接


239
00:14:07,381 --> 00:14:11,151
现在你可以将离线媒体
重播功能提供给你们的用户了


240
00:14:11,218 --> 00:14:13,687
使用现有的流媒体库


241
00:14:14,354 --> 00:14:17,324
作为此功能的一部分
我们扩展了


242
00:14:17,391 --> 00:14:20,594
去年我们推出的
FairPlay Streaming支持


243
00:14:21,195 --> 00:14:24,131
来兼容离线HLS


244
00:14:24,698 --> 00:14:28,702
而且我们给大家提供
一种下载HLS内容的方式


245
00:14:28,769 --> 00:14:30,571
即使你的应用在后台运行


246
00:14:31,104 --> 00:14:36,076
最后 我们推出播放
部分下载内容的功能


247
00:14:36,143 --> 00:14:38,478
即使你的下载可能还在进行中


248
00:14:39,313 --> 00:14:44,251
所以第一个问题-
应该何时使用离线HLS？


249
00:14:44,685 --> 00:14:48,355
没错 如果你想将这种功能


250
00:14:48,422 --> 00:14:52,159
主要用于
当用户想要播放内容的时候


251
00:14:52,226 --> 00:14:55,128
然而他们可能没有网络连接


252
00:14:55,195 --> 00:14:56,964
例如当他们进入飞行模式


253
00:14:57,130 --> 00:15:00,567
不过 此项功能并非
针对于预先加载媒体文件


254
00:15:00,868 --> 00:15:03,504
我们有使用AVPlayerItem
的其他做法


255
00:15:04,671 --> 00:15:09,810
所以为什么使用HLS播放离线内容
而不是直接下载好电影文件呢？


256
00:15:10,277 --> 00:15:13,514
第一点 你的内容
可能已经是用HLS制作了


257
00:15:13,580 --> 00:15:18,318
所以采用HLS来播放
离线内容可能对你非常便利


258
00:15:18,385 --> 00:15:19,953
从工程学角度来说


259
00:15:20,354 --> 00:15:22,523
同时除了视频轨


260
00:15:22,890 --> 00:15:26,927
电影文件可以包括很多
不同的音频轨和字幕轨


261
00:15:26,994 --> 00:15:30,297
你的用户可能不太需要
或是在离线存留着


262
00:15:30,998 --> 00:15:35,269
在HLS中 因为所有的
轨道都是分隔保存于


263
00:15:35,335 --> 00:15:41,341 line:1
服务器的不同播放列表中
我们能实现更大一点的灵活度


264
00:15:41,608 --> 00:15:45,779 line:1
我们能精确控制
被下载的媒体选择


265
00:15:46,046 --> 00:15:50,217 line:1
节省用户的时间 网络数据
和设备上的存储空间


266
00:15:50,684 --> 00:15:55,756 line:1
例如 默认下 我们下载了
一个用户的默认媒体选择


267
00:15:55,822 --> 00:15:59,293 line:1
用户在离线播放时
很可能只会关心这些文件


268
00:15:59,359 --> 00:16:03,030 line:1
我们还给你提供的方式是
确切配置


269
00:16:03,096 --> 00:16:06,733 line:1
你和用户想下载的
可以离线回放的内容


270
00:16:08,268 --> 00:16:12,339 line:1
离线播放HLS
的另一好处在于


271
00:16:12,406 --> 00:16:14,208 line:1
使用相同的资源


272
00:16:14,274 --> 00:16:18,478 line:1
我们仍可以下载
未被下载的媒体选择选项


273
00:16:18,545 --> 00:16:21,915 line:1
只要它们还存储在
你的服务器中 这非常不错


274
00:16:22,783 --> 00:16:24,585
所以怎么做呢？


275
00:16:25,319 --> 00:16:29,489
在iOS 10中 我们推出一个
新的类 用于下载AVAssets


276
00:16:29,556 --> 00:16:31,058
叫做AVAssetDownloadTask


277
00:16:31,625 --> 00:16:35,262
这个类继承了
URL会话的功能


278
00:16:35,495 --> 00:16:39,700
更重要的是
在后台下载资源的功能


279
00:16:39,766 --> 00:16:43,203
即使你的应用没有使用
其所有的机制运行


280
00:16:43,804 --> 00:16:45,572
我们让你有能力...


281
00:16:45,639 --> 00:16:48,342
控制下载哪些媒体选择


282
00:16:48,775 --> 00:16:50,844
因为这是HLS


283
00:16:50,911 --> 00:16:54,815
我们让你有能力
选择你想要的资源品质


284
00:16:54,882 --> 00:16:56,917
还可以离线下载下来


285
00:16:57,451 --> 00:17:01,321 line:1
AVAssetDownloadTask
的界面是这个样


286
00:17:01,688 --> 00:17:04,090 line:1
继承了
URLSessionTask


287
00:17:04,156 --> 00:17:06,359 line:1
我想在这里提一下
这不是继承了


288
00:17:06,425 --> 00:17:08,328 line:1
URLSessionDownloadTask


289
00:17:08,662 --> 00:17:12,799 line:1
作用很相似 但是
我想指出几点不同之处


290
00:17:13,599 --> 00:17:18,672 line:1
所以为了创建这些东西
你要设置URLSession


291
00:17:18,739 --> 00:17:21,909 line:1
现在我们有一个特定的
URLSession子类 叫做


292
00:17:21,974 --> 00:17:25,212 line:1
AVAssetDownloadURLSession
你需要使用这些东西


293
00:17:25,279 --> 00:17:28,849 line:1
所以调用makeAssetDownloadTask
来创建资源下载任务


294
00:17:29,349 --> 00:17:31,518 line:1
之后为了选择品质


295
00:17:31,585 --> 00:17:34,388 line:1
我们有最低要求
比特率的选项键


296
00:17:34,454 --> 00:17:36,390 line:1
以及媒体选择键


297
00:17:37,124 --> 00:17:40,060 line:1
现在我应该说一下
每个AVAssetDownloadTask


298
00:17:40,127 --> 00:17:42,829
对应单个的媒体选择


299
00:17:43,096 --> 00:17:46,233
如果你想在同一资源上
下载多个媒体选择


300
00:17:46,300 --> 00:17:49,770
那你需要设置多个
AVAssetDownloadTask才行


301
00:17:50,037 --> 00:17:51,972
我会在几张幻灯片中展示的


302
00:17:52,706 --> 00:17:55,509
要想使用这些东西
我们要这样做


303
00:17:55,809 --> 00:17:59,179
首先要设置一个
AVAssetDownloadTask


304
00:17:59,246 --> 00:18:01,615
任意进行配置
然后开始下载


305
00:18:02,082 --> 00:18:05,452
我们要响应下载过程中
可能发生的任何事件


306
00:18:05,519 --> 00:18:07,754
例如监控下载进程


307
00:18:08,255 --> 00:18:09,723
一旦下载完毕


308
00:18:09,790 --> 00:18:13,527
我们要存储位置
来在离线时进行回放


309
00:18:14,261 --> 00:18:18,031
你可能要下载额外的
媒体选择供你的用户所用


310
00:18:18,699 --> 00:18:21,235
最后 你要播放该内容


311
00:18:22,369 --> 00:18:26,006
所以要想设置这些下载


312
00:18:26,073 --> 00:18:28,542
设置完资源后
首先要做的是


313
00:18:28,609 --> 00:18:31,678
你要去设置
backgroundConfiguration


314
00:18:31,745 --> 00:18:34,648
来自background
URLSessionConfiguration


315
00:18:35,482 --> 00:18:38,685
然后你要创建你的
AssetDownloadURLSession


316
00:18:39,052 --> 00:18:41,021
然后创建你的下载任务


317
00:18:41,154 --> 00:18:45,325
这里我有一个下载任务
下载品质


318
00:18:45,392 --> 00:18:47,928
的媒体比特率
大概是每秒2兆位


319
00:18:48,228 --> 00:18:52,699
但默认下 我们会下载
提供的最高品质的视频


320
00:18:53,367 --> 00:18:56,303
一旦设置完成
因为这是URLSessionTask


321
00:18:56,370 --> 00:18:58,272
你可以调用resume
来设置你的下载


322
00:18:59,439 --> 00:19:02,843
所以一旦下载开始了
那你就要去监控它


323
00:19:03,010 --> 00:19:07,347
为此 我们为你准备了新协议
叫做AVAssetDownloadDelegate


324
00:19:07,581 --> 00:19:12,286
这继承了URLSessionTaskDelegate
中相同的委托方法


325
00:19:12,586 --> 00:19:16,623
我想指出两件事
是我们在这里推出的


326
00:19:17,157 --> 00:19:21,562
一个是我们使用的
监控下载进程的方法


327
00:19:22,196 --> 00:19:26,166
在此方法中
我们显示出下载进程


328
00:19:26,233 --> 00:19:30,704
和时间范围 而不是字节
来实现更好的媒体界面表达


329
00:19:31,271 --> 00:19:32,739
之后我们有一个


330
00:19:32,806 --> 00:19:36,009
didFinishDownloadingTo location
委托方法 来通知你


331
00:19:36,076 --> 00:19:38,612
下载文件的所在位置


332
00:19:38,912 --> 00:19:41,982
这相似于
URLSessionDownloadDelegate


333
00:19:42,049 --> 00:19:46,086
的协议方法 你需要做的
事情的预期


334
00:19:46,153 --> 00:19:50,424
当你得到这个委托方法
是稍微有点不同的


335
00:19:50,490 --> 00:19:52,059
我马上就指出来


336
00:19:53,594 --> 00:19:57,331
这是我们进程
委托方法的一个示例


337
00:19:57,397 --> 00:20:02,503
这里我将时间范围转化成
已完成下载的百分数


338
00:20:02,569 --> 00:20:05,606
我不会对其深入说明
不过这就是它的做法


339
00:20:06,507 --> 00:20:09,743
你的应用可能在
下载过程中被关闭


340
00:20:10,043 --> 00:20:13,547
进程可能被终止
那你怎么办？


341
00:20:13,614 --> 00:20:14,915
你的下载会继续


342
00:20:14,982 --> 00:20:17,551
为了应对该情况
你的响应方法完全与


343
00:20:17,618 --> 00:20:19,486
URLSessionDownloadTasks
相同


344
00:20:19,786 --> 00:20:22,556
当你的应用启用后
你要去设置


345
00:20:22,623 --> 00:20:26,159
另一个后台配置
你使用的标识符相同于


346
00:20:26,226 --> 00:20:30,297
最初设置下载时的标识符
然后从中创建一个URLSession


347
00:20:30,631 --> 00:20:32,499
从那里
调用getAllTasks方法


348
00:20:32,566 --> 00:20:35,669
然后这里 你可以恢复
你的AVAssetDownloadTask


349
00:20:35,736 --> 00:20:37,738
其中会有当前的进程


350
00:20:37,804 --> 00:20:40,541
你可以用它来更新
应用中可能有的任何UI


351
00:20:40,607 --> 00:20:43,744
然后你甚至可以用它
来抓取原始AVAsset


352
00:20:43,810 --> 00:20:45,546
之前你用它来
设置你的下载


353
00:20:46,246 --> 00:20:50,584
所以一旦下载完成
首先你要做的是


354
00:20:50,651 --> 00:20:52,786
储存下载资源的位置


355
00:20:53,420 --> 00:20:57,925
所以每当有东西存到这个位置
这个方法就会被调用


356
00:20:57,991 --> 00:21:02,963
包括当部分下载的内容
被用户取消的时候


357
00:21:03,297 --> 00:21:05,666
现在你可以用


358
00:21:05,732 --> 00:21:12,172
先前取消的下载内容恢复下载


359
00:21:12,472 --> 00:21:16,443
或者你甚至可以用它
回放部分下载的内容


360
00:21:16,510 --> 00:21:18,612
如果你不想让那个下载


361
00:21:18,679 --> 00:21:21,582
或者那个内容
占用你的应用储存空间


362
00:21:21,815 --> 00:21:24,017
那你可能要在这里删除它


363
00:21:24,451 --> 00:21:25,352
所以...


364
00:21:26,019 --> 00:21:28,055
不同于
URLSessionDownloadDelegate


365
00:21:28,255 --> 00:21:32,059
我们希望各位
不要将资源从这里移开


366
00:21:32,459 --> 00:21:36,096
我们这样做是因为让系统
能够找到这些文件是很重要的


367
00:21:36,163 --> 00:21:38,398
因为系统会回收磁盘空间


368
00:21:38,465 --> 00:21:41,301
如果磁盘空间很少的话
而且会在某个时刻


369
00:21:41,368 --> 00:21:44,838
会从应用容器中删除该资源


370
00:21:45,339 --> 00:21:50,043
所以你想保存的是
位置的相对路径


371
00:21:50,110 --> 00:21:54,147
从这里 你能够在将来
恢复你的资源 从而进行回放


372
00:21:55,582 --> 00:21:59,953
所以 现在你下载完
资源的一个版本


373
00:22:00,287 --> 00:22:03,023
比如说 你想下载
额外的媒体选择


374
00:22:03,190 --> 00:22:07,794
这个适合在我们的
didCompleteWithError委托方法中做


375
00:22:07,861 --> 00:22:10,197
这跟URLSessionTask
有的那个一样


376
00:22:10,797 --> 00:22:13,200
适合在这里做的原因是


377
00:22:13,267 --> 00:22:16,570
因为同一资源上的
媒体选择是连续下载的


378
00:22:16,803 --> 00:22:22,142
通常这里适合进行
任何完成下载的清理工作


379
00:22:22,543 --> 00:22:27,381
所以用额外媒体选择
选项来进行增强


380
00:22:27,447 --> 00:22:28,682
比如 西班牙语音频


381
00:22:28,749 --> 00:22:31,685
我们首先会抓取
要下载的spanishOption


382
00:22:32,085 --> 00:22:37,958
然后我们改变最初放入的
AVMediaSelection


383
00:22:38,025 --> 00:22:40,928
从这里选择spanishOption


384
00:22:41,495 --> 00:22:43,130
一旦选择好了


385
00:22:43,197 --> 00:22:46,133
我们要去创建一个新的
AVAssetDownloadTask


386
00:22:46,633 --> 00:22:48,702
最好是在同一会话中


387
00:22:48,769 --> 00:22:51,872
外加传递我们要
下载的额外媒体选择


388
00:22:51,939 --> 00:22:55,075
然后我们调用resume
这样整个过程就会重复


389
00:22:55,142 --> 00:22:58,512
如果想的话 我们可以
之后下载额外媒体选择


390
00:23:00,380 --> 00:23:02,449
现在我们谈谈
播放的事情


391
00:23:03,083 --> 00:23:09,656
假如说我们有...这里示范了
如何创建下载任务的方法


392
00:23:09,723 --> 00:23:13,193
注意到我输入了一个
带有networkURL的资源了吗？


393
00:23:13,594 --> 00:23:17,297
但我们离线回放HLS


394
00:23:17,364 --> 00:23:20,501
如果我们仍可以用
原始的urlAsset


395
00:23:20,567 --> 00:23:25,572
那我们应该使用
那个AVAsset实例来播放


396
00:23:26,106 --> 00:23:29,676
我们可以从AssetDownloadTask
上的urlAsset属性中抓取


397
00:23:30,043 --> 00:23:32,145
如果你输入带有
networkURL的新资源


398
00:23:32,212 --> 00:23:35,682
AVFoundation无法知道
从何处寻找下载的内容


399
00:23:35,983 --> 00:23:39,553
所以你应该使用同一资源
然后你就能离线回放了


400
00:23:40,053 --> 00:23:45,158
然而 如果你无法引用
那个原始AVAsset


401
00:23:45,559 --> 00:23:50,631
例如 很长时间之后
你的应用可能没在运作


402
00:23:50,898 --> 00:23:54,801
那你要做的就是
创建新的AVAsset


403
00:23:54,868 --> 00:23:57,571
用我们提供给你的下载位置


404
00:23:57,638 --> 00:24:00,407
在didFinishDownloadingTo
委托方法中


405
00:24:00,474 --> 00:24:02,342
并用它创建一个
PlayerItem


406
00:24:03,143 --> 00:24:09,149
在这个案例中 如果你想
对资源进行操作 例如


407
00:24:09,216 --> 00:24:11,552
用额外媒体选择下载来增强


408
00:24:11,618 --> 00:24:13,620
你真的应该重新使用
那个同一个资源


409
00:24:13,687 --> 00:24:18,659
你不应该有大量的AVAsset
指向磁盘上相同的fileURL


410
00:24:18,759 --> 00:24:21,495
这有助于让
AVFoundation高效地


411
00:24:21,562 --> 00:24:24,331
重新使用已经下载的媒体数据


412
00:24:25,299 --> 00:24:29,503
所以我们还有一个附加级
来帮助你严谨规定


413
00:24:29,570 --> 00:24:33,941
用户能离线播放的内容
这叫做AVAssetCache


414
00:24:34,341 --> 00:24:37,344
你从一个AVAsset的
资源缓存属性中抓取


415
00:24:37,711 --> 00:24:41,181
这有两个作用
一个是能告诉你


416
00:24:41,248 --> 00:24:44,885
是否这个资源的
各个版本都能离线播放


417
00:24:45,385 --> 00:24:47,721
另一个是
它能告诉你


418
00:24:47,788 --> 00:24:50,991
是否出现了可用于
离线的特定媒体选择选项


419
00:24:51,225 --> 00:24:53,660
如果它不允许离线
但还是能够播放的


420
00:24:53,727 --> 00:24:56,997
前提是要有网络连接
而且那个媒体选择选项


421
00:24:57,064 --> 00:24:59,800
仍然存在于
你去下载的那个服务器上


422
00:25:00,334 --> 00:25:03,170
这就是如何使用
AVAssetDownloadTask


423
00:25:03,237 --> 00:25:06,640
并播放后续的下载资源


424
00:25:06,740 --> 00:25:09,710
我应该提一下第五点
如果你在下载资源磁盘上播放


425
00:25:09,776 --> 00:25:12,946
这会在该过程的任何时刻发生


426
00:25:13,013 --> 00:25:16,583
这甚至可能在
开始下载之前发生


427
00:25:16,650 --> 00:25:19,653
或在下载过程中发生
而且AVFoundation会高效地


428
00:25:19,720 --> 00:25:22,990
重新使用已经从网络上
下载下来的内容


429
00:25:23,924 --> 00:25:25,392
我想换一下话题


430
00:25:25,459 --> 00:25:27,828
来谈谈
保护离线内容


431
00:25:29,029 --> 00:25:32,032
去年 我们推出了
FairPlay Streaming


432
00:25:32,099 --> 00:25:34,801
为HLS生态系统带来了
强大的内容保护


433
00:25:35,536 --> 00:25:37,237
然而 在iOS 9中


434
00:25:37,304 --> 00:25:40,374
FairPlay Streaming需要
对密钥服务器的活动连接


435
00:25:40,440 --> 00:25:43,177
这无法用在离线回放上面


436
00:25:43,710 --> 00:25:45,812
所以今年我们扩展
FairPlay Streaming


437
00:25:45,879 --> 00:25:49,850
使其在离线HLS情况下
无需网络连接也能工作


438
00:25:50,317 --> 00:25:54,922
我们的做法是将你的密钥
以安全的方式打包并存储在磁盘上


439
00:25:54,988 --> 00:25:56,790
并重新用于离线回放


440
00:25:57,191 --> 00:26:00,394
但你的应用本身
还是会保存这个密钥


441
00:26:00,460 --> 00:26:03,697
并响应来自
AVFoundation的密钥请求


442
00:26:03,764 --> 00:26:07,668
用于每次回放 一旦密钥
进入缓存 就不需要接入网络了


443
00:26:08,569 --> 00:26:12,306
所以要想支持这些密钥
需要对你的密钥服务器进行更改


444
00:26:12,372 --> 00:26:15,409
具体是新的TLV值
这样你的密钥服务器


445
00:26:15,475 --> 00:26:19,046
必须明确地选择加入密钥
从而满足使用离线回放的资格


446
00:26:20,180 --> 00:26:23,550
最后
我们想提醒一下FPS Keys


447
00:26:23,784 --> 00:26:26,687
你必须在主播放列表中
将它们声明为会话密钥


448
00:26:26,753 --> 00:26:28,922
如果你想确认
是否下载完成的话


449
00:26:29,590 --> 00:26:30,424
所以...


450
00:26:31,091 --> 00:26:33,260 line:1
为离线FairPlay Streaming
保存密钥


451
00:26:33,327 --> 00:26:37,331 line:1
真的就是基于在线
FairPlay Streaming的请求流


452
00:26:37,531 --> 00:26:41,435 line:1
你要更改的只是和修改
这个请求流有关的内容


453
00:26:41,902 --> 00:26:44,905 line:1
我在这里快速总结一下
来指出你需要做的事情


454
00:26:45,172 --> 00:26:47,508 line:1
但如要了解更多信息
你应该观看去年的演讲


455
00:26:47,574 --> 00:26:49,343 line:1
我们在那里讲得十分详细了


456
00:26:50,477 --> 00:26:52,679 line:1
与FairPlay Streaming
回放一样


457
00:26:52,746 --> 00:26:54,448 line:1
AVFoundation会
下载你的播放列表


458
00:26:54,515 --> 00:26:57,084 line:1
并在找到密钥标签时
触发密钥请求


459
00:26:57,150 --> 00:27:00,554 line:1
这会让你的应用有机会
保存密钥 从而用于离线回放


460
00:27:01,088 --> 00:27:05,192 line:1
所以你的应用首先会
回调AVFoundation


461
00:27:05,259 --> 00:27:06,860 line:1
来获取流媒体密钥请求


462
00:27:07,160 --> 00:27:10,797 line:1
然后会和你的服务器对话
这会取走


463
00:27:10,864 --> 00:27:14,835 line:1
那个流媒体密钥请求 然后
给你一个内容密钥上下文或CKC


464
00:27:15,302 --> 00:27:17,971 line:1
在线上FairPlay Streaming中
你会在这里完成


465
00:27:18,038 --> 00:27:21,909 line:1
请求流 并用那个CKC
返回到AVFoundation


466
00:27:22,442 --> 00:27:25,312 line:1
然而
在离线FairPlay Streaming中


467
00:27:25,712 --> 00:27:29,116 line:1
在这里你要将那个CKC
交给AVFoundation


468
00:27:29,183 --> 00:27:31,852 line:1
这样AVFoundation
能将其冻干成一种格式


469
00:27:31,919 --> 00:27:35,422 line:1
可以安全存储在
你应用的存储空间中


470
00:27:35,656 --> 00:27:39,793 line:1
你也可以在后续的
回放中重新用上它


471
00:27:39,927 --> 00:27:40,761 line:1
之后...


472
00:27:40,827 --> 00:27:43,297 line:1
一旦你将它写入
你的应用存储空间中


473
00:27:43,363 --> 00:27:46,500 line:1
你要将那个冻干的密钥
返回给AVFoundation


474
00:27:46,567 --> 00:27:47,668 line:1
来完成这个请求


475
00:27:47,935 --> 00:27:50,304 line:1
如果你的应用离线了
那你需要做的只是


476
00:27:50,370 --> 00:27:53,373 line:1
从你的应用存储空间中
读取那个冻干的密钥 并返还给


477
00:27:53,440 --> 00:27:56,543 line:1
AVFoundation 这样
不需要网络就能做得到


478
00:27:57,945 --> 00:28:00,280
所以我们来看看这究竟
会怎样改变你的代码


479
00:28:00,714 --> 00:28:04,852
在线上FairPlay Streaming中
这些密钥请求作为


480
00:28:04,918 --> 00:28:06,687
AVAssetResourceLoader
的一部分


481
00:28:06,887 --> 00:28:11,124
具体是AVAssetResourceLoadingRequest
上面的委托方法


482
00:28:11,491 --> 00:28:13,560
一旦收到请求
首先你要做的是


483
00:28:13,627 --> 00:28:19,099
请求AVFoundation
创建流媒体内容密钥请求


484
00:28:19,166 --> 00:28:21,702
或是SPC
这会发送到你的服务器上


485
00:28:21,768 --> 00:28:26,073
这会返回一个CKC 之后
你用它来响应AVFoundation


486
00:28:27,541 --> 00:28:30,744
现在 在离线FairPlay Streaming中
我们有一个新方法


487
00:28:30,811 --> 00:28:32,980
这是用来冻干密钥的方法


488
00:28:33,046 --> 00:28:36,650
你输入从服务器返回的CKC


489
00:28:36,950 --> 00:28:41,255
然后返回那个为你保存的
数据团 从而用于离线存储


490
00:28:42,022 --> 00:28:44,791
我们还有一个新的内容类型
作为这个请求流的一部分


491
00:28:44,858 --> 00:28:46,527
是persistentContentKey类型


492
00:28:46,894 --> 00:28:48,262
和一个新的选项


493
00:28:48,328 --> 00:28:52,232
来为应用方法输入我们的
流媒体内容密钥请求数据


494
00:28:54,034 --> 00:28:58,839
所以我们是这样
修改那个密钥请求流的


495
00:28:58,906 --> 00:29:00,874
用于我们要离线保存的密钥


496
00:29:01,441 --> 00:29:06,146
我们首先要做的是请求
AVFoundation创建SPC


497
00:29:06,547 --> 00:29:09,683
不同之处是我们要输入
所需的persistentKey选项


498
00:29:09,750 --> 00:29:12,019
这样 AVFoundation
和你的密钥服务器


499
00:29:12,085 --> 00:29:16,290
会知道去请求一个
适用于冻干过程的密钥


500
00:29:16,957 --> 00:29:19,560
所以它将SPC发送到
你的服务器 从而得到CKC


501
00:29:19,927 --> 00:29:23,330
一旦拿回了CKC 你就调用
你的persistentContentKey方法


502
00:29:23,397 --> 00:29:26,066
来创建这个冻干的密钥
然后可以保存于磁盘上


503
00:29:26,500 --> 00:29:28,769
之后你要将这个密钥
真正写到你的磁盘上


504
00:29:28,836 --> 00:29:33,073
你要将内容类型设置成
persistentContentKey类型


505
00:29:33,674 --> 00:29:38,445
然后用那个持久性CKC
来完成数据加载请求


506
00:29:38,512 --> 00:29:40,714
那个CKC保存在你的磁盘上


507
00:29:41,448 --> 00:29:43,183
现在如果你离线了


508
00:29:43,250 --> 00:29:46,053
或者比如说 你之前已经
满足了这个密钥请求


509
00:29:46,587 --> 00:29:48,655
那你要这样做


510
00:29:49,189 --> 00:29:51,458
你会得到
资源loadingRequest


511
00:29:52,292 --> 00:29:58,498
你只需从应用存储空间中
读取你的冻干密钥


512
00:29:59,266 --> 00:30:03,003
设置persistentContentKey类型
然后响应密钥loadingRequest


513
00:30:03,070 --> 00:30:06,507
完全不需要接入网络
这很明显是必须的


514
00:30:06,573 --> 00:30:09,543
因为你可能在飞行模式下


515
00:30:09,610 --> 00:30:12,379
并且在这个过程中
没有任何网络连接


516
00:30:13,514 --> 00:30:15,849
这就是如何修改
FairPlay Streaming


517
00:30:15,916 --> 00:30:18,051
来用于你的离线HLS内容


518
00:30:19,253 --> 00:30:22,856
现在我想谈谈管理
资源的最佳做法


519
00:30:23,490 --> 00:30:26,426
很重要的一点是
这些下载会占用


520
00:30:26,493 --> 00:30:29,429
你的应用磁盘使用量
所以你要稍微多留意


521
00:30:30,063 --> 00:30:32,733
你真的应该清除
磁盘上任何不需要的资源


522
00:30:33,066 --> 00:30:36,637
具体点 你一定要
为你的用户提供一种


523
00:30:36,703 --> 00:30:39,206
查看所有下载内容的方式


524
00:30:39,273 --> 00:30:42,176
并允许他们删除
那些不再需要的内容


525
00:30:44,111 --> 00:30:48,582
要记住 用户取消的下载
还会保留在磁盘上


526
00:30:48,649 --> 00:30:52,119
你可以用这些资源在
将来的某个时刻恢复下载


527
00:30:52,186 --> 00:30:55,255
如果你不想恢复下载
那你就要注意在


528
00:30:55,322 --> 00:30:58,025
取消下载的时候
删除那些资源


529
00:30:59,126 --> 00:31:04,164
我们希望各位基于
明确的用户行动来保留下载


530
00:31:04,231 --> 00:31:06,667
你不应该去下载一堆东西


531
00:31:06,733 --> 00:31:08,902
因为用户可能不想离线观看


532
00:31:09,636 --> 00:31:12,940
我们冒昧地
选择性排除了这些下载


533
00:31:13,006 --> 00:31:14,241
在iCloud备份上面


534
00:31:16,310 --> 00:31:18,946
我之前提过了
你应该做好准备 这个系统会在


535
00:31:19,012 --> 00:31:22,416
在低磁盘空间的情况下
删除资源来回收磁盘空间


536
00:31:22,916 --> 00:31:25,152
这不会在应用运行的时候发生


537
00:31:25,219 --> 00:31:27,521
这只会在你应用终止后发生


538
00:31:28,589 --> 00:31:32,893
当你的程序启动后
你应该稍微保守地


539
00:31:32,960 --> 00:31:35,696
推测你的资源是否真的


540
00:31:35,762 --> 00:31:37,931
提前下载在磁盘上了


541
00:31:40,400 --> 00:31:44,771
你不要将资源从我们
提供的位置中移走


542
00:31:44,838 --> 00:31:48,609
因为让系统能够找到
这些资源是非常重要的


543
00:31:50,110 --> 00:31:55,349
最终 因为下载的资源可能包含


544
00:31:55,415 --> 00:31:57,985
未被下载的媒体选择


545
00:31:58,051 --> 00:32:01,355
注意不要改变你服务器上的资源


546
00:32:01,488 --> 00:32:08,495
如果你一定要更改
媒体播放列表的位置


547
00:32:08,562 --> 00:32:10,831
并改变你的主播放列表


548
00:32:10,898 --> 00:32:14,001
那你应该将修改后的资源
托管到新的URL上


549
00:32:14,067 --> 00:32:16,336
而不是更改原来的那个


550
00:32:17,471 --> 00:32:19,473
这就是 离线HLS


551
00:32:19,540 --> 00:32:23,143
我们高兴向各位发布
并期待各位会采用它


552
00:32:24,111 --> 00:32:27,214
总之 今年我们有
新功能供你们使用


553
00:32:27,281 --> 00:32:34,221
我们有MP4片段支持
这会带来通用的媒体格式


554
00:32:34,288 --> 00:32:37,324
可以用在你们所支持的
所有不同平台上


555
00:32:37,958 --> 00:32:40,761
记住 这个兼容所有的HLS功能


556
00:32:40,827 --> 00:32:43,897
而且对HLS播放列表
只需微小改动便可采用


557
00:32:45,065 --> 00:32:49,536
接下来 我们有使用DATERANGE标签
的新播放列表内的元数据


558
00:32:49,603 --> 00:32:54,641
在直播内容中
非常适合使用元数据


559
00:32:54,708 --> 00:32:57,277
内容可能有动态更新的元数据


560
00:32:57,344 --> 00:32:59,179
像是广告边界之类的东西


561
00:33:00,047 --> 00:33:03,450
最后我们提供离线HLS回放


562
00:33:03,817 --> 00:33:08,455
其中我们有一个
强大的媒体下载引擎


563
00:33:08,522 --> 00:33:12,292 line:1
你还可以配置要下载的
媒体选择和品质


564
00:33:12,926 --> 00:33:16,663 line:1
我们还扩展
FairPlay Streaming支持


565
00:33:16,730 --> 00:33:18,632 line:1
没有网络连接时也能工作


566
00:33:19,867 --> 00:33:21,301 line:1
所以要想获取更多信息


567
00:33:21,368 --> 00:33:26,106
包括如何使用
AVAssetDownloadTask的样本代码


568
00:33:26,173 --> 00:33:29,810
和关于这些新版本的
更多的资料


569
00:33:29,877 --> 00:33:34,114
去查看我们开发网站上
针对本次会议的页面


570
00:33:36,116 --> 00:33:39,319
我想指出
Roger之前提到的会议


571
00:33:39,586 --> 00:33:42,723
已播出的创作和验证演讲


572
00:33:43,190 --> 00:33:47,661
现在你可以在WWDC应用
上观看这个视频


573
00:33:48,095 --> 00:33:50,063
我极力推荐观看


574
00:33:50,831 --> 00:33:53,734
感谢各位的到来
希望大家会喜欢之后的发布会

