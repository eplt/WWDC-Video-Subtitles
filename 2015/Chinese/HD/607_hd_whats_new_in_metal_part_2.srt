1
00:00:20,053 --> 00:00:23,590
在Metal中有什么新内容
第二部分


2
00:00:23,657 --> 00:00:24,491
谢谢


3
00:00:28,495 --> 00:00:31,832
早上好 欢迎来到第二部分的讲座
Metal展示中有什么新内容


4
00:00:32,031 --> 00:00:33,467
我叫丹·大町市


5
00:00:33,867 --> 00:00:36,603
我是苹果GPU软件架构团队的工程师


6
00:00:37,237 --> 00:00:40,407
今天我的同事 安娜·吉洪诺夫
和我将会谈一谈


7
00:00:40,474 --> 00:00:42,809
基于Metal的技术


8
00:00:43,143 --> 00:00:46,313
有助于在
iOS 和OS X上向你提供令人


9
00:00:46,380 --> 00:00:48,448
惊叹的渲染体验


10
00:00:50,717 --> 00:00:53,520
因此这是三个讲座中的第二部分


11
00:00:53,587 --> 00:00:56,690
在本年度讨论Metal的WWDC上


12
00:00:57,524 --> 00:00:58,492
第一个讲座中


13
00:00:58,892 --> 00:01:03,263
罗布·多啦夫 谈论了
去年对Metal的开发


14
00:01:04,031 --> 00:01:08,235
他还描述了我们刚刚
发布的Metal的新功能


15
00:01:09,469 --> 00:01:14,308
他还描述了它的瘦身功能
如何与Metal应用完美匹配


16
00:01:16,577 --> 00:01:19,847
在本次讲座中 我首先要谈到


17
00:01:20,180 --> 00:01:26,687
Metalkit方便的APIs使你
更快捷地使用Metal应用


18
00:01:27,487 --> 00:01:32,392
然后 安娜 将会
谈论Metal性能着色器架构


19
00:01:32,926 --> 00:01:36,096
在具有A8处理器的iOS设备上


20
00:01:36,797 --> 00:01:39,333
它可为可用的公用数据并行操作


21
00:01:39,399 --> 00:01:42,669
提供很好的着色器


22
00:01:45,205 --> 00:01:46,640
明天你将有机会


23
00:01:47,040 --> 00:01:50,477
来听取Metal性能优化技术讲座


24
00:01:50,878 --> 00:01:54,181
在那里将介绍Metal系统追踪工具


25
00:01:54,915 --> 00:02:00,087
且向你提供一些有效的
Metal应用的最好的范例


26
00:02:03,123 --> 00:02:05,025
现在就开始介绍用于Metal应用的


27
00:02:05,225 --> 00:02:07,528
Metalkit实用功能


28
00:02:09,930 --> 00:02:16,003
因为Metal是一个低级的API
你要做许多事情来建立和运行


29
00:02:17,771 --> 00:02:20,274
MetalKit希望使用这个


30
00:02:20,340 --> 00:02:22,609
来为经常使用的场景


31
00:02:22,843 --> 00:02:24,945
提供有效的实现


32
00:02:26,013 --> 00:02:29,149
这样你就可以很容易创建和渲染


33
00:02:29,917 --> 00:02:31,952
并且我们对标准的库存代码


34
00:02:32,019 --> 00:02:35,689
增强了性能和稳定性


35
00:02:35,856 --> 00:02:37,424
你自己就可以实现


36
00:02:38,158 --> 00:02:40,327
你需要很少的维护


37
00:02:40,794 --> 00:02:43,530
因为维护的负担从你转到了我们


38
00:02:46,033 --> 00:02:49,970
这样MetalKit由三部分组成


39
00:02:50,938 --> 00:02:53,240
第一部分是MetalKit视图


40
00:02:53,841 --> 00:02:57,644
一个介于iOS
和OSX之间的统一的视图类


41
00:02:58,212 --> 00:02:59,580
用于渲染你的Metal场景


42
00:03:01,114 --> 00:03:03,083
第二部分是纹理载入器


43
00:03:03,684 --> 00:03:08,989
用于创建磁盘上的图像文件的纹理对象


44
00:03:09,957 --> 00:03:13,493
最后
Metal Kit的模块I/O集成


45
00:03:13,861 --> 00:03:17,164
上载和管理
来自Metal渲染的网格数据


46
00:03:20,501 --> 00:03:25,572
MetalKit视图是获Metal
视频渲染的最简单的方法


47
00:03:27,407 --> 00:03:31,144
它是iOS和OS X的统一类


48
00:03:32,012 --> 00:03:35,749
它在这个两个操作
系统上提供了几乎相同的接口


49
00:03:36,149 --> 00:03:42,289
但是它本身是iOS的UI视图
的子类以及OSX上的NS视图的子类


50
00:03:44,725 --> 00:03:48,462
它的主要工作是
为你管理可显示渲染目标


51
00:03:49,396 --> 00:03:51,265
并且为这些渲染目标


52
00:03:51,331 --> 00:03:53,534
自动产生渲染路径描述符


53
00:03:55,936 --> 00:03:59,206
它的超级灵活之处在于


54
00:03:59,273 --> 00:04:02,209
它可以执行你的绘制代码


55
00:04:03,443 --> 00:04:06,079
你可以使用一个基于定时器的模式


56
00:04:06,213 --> 00:04:09,216
该模式可以在有规律的间隔内


57
00:04:09,449 --> 00:04:11,618
与显示同步执行你的绘制代码


58
00:04:12,819 --> 00:04:14,288
或者你可以使用基于事件的模式


59
00:04:14,354 --> 00:04:18,158
每当发生触摸或UI事件时
该模式在就将触发你的绘制代码


60
00:04:18,225 --> 00:04:20,093
这样你就可以对那个事件做出响应


61
00:04:21,060 --> 00:04:22,162
最后也许你可以在


62
00:04:22,229 --> 00:04:27,067
你的帧频率下第二线程上的开放环路下


63
00:04:27,701 --> 00:04:29,102
驱动你的绘制代码


64
00:04:32,072 --> 00:04:35,676
因此有两种
方法使用MetalKit视图


65
00:04:37,144 --> 00:04:39,580
最简单的方法是执行一个代表


66
00:04:39,713 --> 00:04:42,549
来处理你的绘制及重新调整运行的大小


67
00:04:43,350 --> 00:04:46,687
在这个实例中
你可以执行在视图中绘制方法


68
00:04:47,221 --> 00:04:50,390
来处理你的包括对任何渲染命令编码


69
00:04:50,724 --> 00:04:52,459
的每帧的更新


70
00:04:53,861 --> 00:04:57,464
你还可以执行按尺寸布局视图的方法


71
00:04:58,599 --> 00:05:00,834
来处理你的视图的尺寸的改变


72
00:05:01,502 --> 00:05:04,705
在这里你可以更新投影矩阵


73
00:05:05,005 --> 00:05:06,940
或者改变纹理的大小


74
00:05:07,007 --> 00:05:09,376
以更好地匹配你的显示区域


75
00:05:10,844 --> 00:05:15,315
如果你有其它的需要改写的视图


76
00:05:16,183 --> 00:05:18,552
可将MetalKit视图设为子类


77
00:05:19,620 --> 00:05:21,321
在iOS的这个实例中


78
00:05:21,655 --> 00:05:23,757
你将要改写绘制矩形方法


79
00:05:25,125 --> 00:05:26,460
来处理你的每帧更新


80
00:05:27,327 --> 00:05:30,330
以及布局视图方法来处理大小调整


81
00:05:31,164 --> 00:05:33,834
同样的在OSX上你要处理


82
00:05:34,101 --> 00:05:36,637
你要改写这两种方法绘制矩形


83
00:05:36,703 --> 00:05:38,805
和设置桢大小方法


84
00:05:44,845 --> 00:05:49,750
在这里有个设置视图控制器的例子


85
00:05:49,950 --> 00:05:53,153
也可以作为我们视图的代表


86
00:05:54,454 --> 00:05:59,660
在视图无法加载方法中
我们在接收到针对视图的一个引用后


87
00:06:00,561 --> 00:06:02,963
我们将我们自己指定为代表


88
00:06:06,900 --> 00:06:11,438
在OS上特别重要的是我们需要选择


89
00:06:11,505 --> 00:06:13,373
和设置一个Metal设备


90
00:06:15,375 --> 00:06:18,078
一旦我们完成了 我们就可以配置


91
00:06:18,145 --> 00:06:19,980
一些视图的功能包括


92
00:06:20,314 --> 00:06:23,517
针对色彩、深度和模板缓冲


93
00:06:23,584 --> 00:06:24,852
的自定义像素格式


94
00:06:27,054 --> 00:06:28,655
我们还可以通过将


95
00:06:28,722 --> 00:06:32,526
采样计数功能增加
到数值1以上来使用多重采样


96
00:06:34,695 --> 00:06:37,231
或者我们还可以
设置我们的自定义清除色彩


97
00:06:41,201 --> 00:06:45,639
这里有个实现每帧更新的


98
00:06:45,806 --> 00:06:48,575
MetalKit视图
的最基本的使用方法


99
00:06:49,510 --> 00:06:53,447
在我们的绘制视图方法中
我们叫做视图渲染


100
00:06:53,714 --> 00:06:55,916
是render
past descriptor


101
00:06:55,983 --> 00:06:59,653
你首次访问每个画面的这个功能


102
00:07:00,087 --> 00:07:02,523
该视图就会调用核心动画


103
00:07:02,823 --> 00:07:04,658
并且获得一个可绘制返回


104
00:07:05,259 --> 00:07:08,395
在这里你可以
对渲染命令编码来进行渲染


105
00:07:10,497 --> 00:07:12,966
这样我们就渲染了
我们最终的render pass


106
00:07:13,467 --> 00:07:15,202
就会在这个可绘制中展现出来


107
00:07:16,670 --> 00:07:18,939
然后我们就将展现这个可绘制


108
00:07:19,006 --> 00:07:20,741
它保存在视图的当前的可绘制功能中


109
00:07:21,808 --> 00:07:23,343
并且我们将提交我们的指令缓冲器


110
00:07:25,045 --> 00:07:26,914
因为构建你的每帧更新很重要


111
00:07:27,281 --> 00:07:30,384
让我花一分钟


112
00:07:30,651 --> 00:07:33,053
来说说管理这些可绘制


113
00:07:34,588 --> 00:07:36,890
这样这个系统中有有限的可绘制


114
00:07:37,424 --> 00:07:40,027
都由核心动画来管理


115
00:07:41,562 --> 00:07:44,164
由于它们通常只有几个 因为


116
00:07:44,231 --> 00:07:45,566
它们的大小占用了一些空间


117
00:07:46,567 --> 00:07:49,269
这些可绘制通过许多级别的


118
00:07:49,603 --> 00:07:52,472
显示管道层被同时使用


119
00:07:53,907 --> 00:07:55,209
这里大致说下它是如何工作的


120
00:07:55,642 --> 00:07:57,644
首先
你的应用程序对要在可绘制上渲染的


121
00:07:57,711 --> 00:07:58,912
指令进行编码


122
00:08:00,013 --> 00:08:02,216
当你的应用程序对下个帧进行编码时


123
00:08:02,583 --> 00:08:05,652
它将那个可绘制向下发送到GPU


124
00:08:05,886 --> 00:08:09,690
GPU对那个画面进行渲染 核心动画


125
00:08:09,756 --> 00:08:11,592
在这个阶段可以和其他层一起


126
00:08:11,658 --> 00:08:15,028
对那个可绘制进行合成


127
00:08:17,364 --> 00:08:19,666
最后显示器获取了可绘制


128
00:08:19,733 --> 00:08:21,001
把它放在屏幕上


129
00:08:21,969 --> 00:08:24,004
显示器不能用任何东西来替代它


130
00:08:24,071 --> 00:08:25,806
直到可获得另一个可绘制


131
00:08:26,106 --> 00:08:29,109
如果前面的任何阶段花费了很长时间


132
00:08:29,409 --> 00:08:31,178
它只能等一会儿


133
00:08:31,612 --> 00:08:36,817
显示器不能将那个可绘制反向循环


134
00:08:36,884 --> 00:08:38,952
直到你的帧上有它有可用的东西


135
00:08:42,322 --> 00:08:47,528
让我们来看看
你的带有这些可绘制的应用框架


136
00:08:49,296 --> 00:08:51,732
首先你调用保留有一个 可绘制的


137
00:08:51,798 --> 00:08:54,268
MetalKit视图当前渲染描述符


138
00:08:57,070 --> 00:09:00,107
然后用你想要的渲染
指令对那个可绘制进行编码


139
00:09:00,774 --> 00:09:06,413
最后你呈现和提交
那个会将它发回到核心动画中的可绘制


140
00:09:07,981 --> 00:09:11,985
一切都好如果我们只是渲染一个
单独的render pass


141
00:09:12,753 --> 00:09:16,256
但是很有可能我们将做其他的操作


142
00:09:18,058 --> 00:09:20,994
如一些应用逻辑对


143
00:09:22,196 --> 00:09:26,300
无须可绘制 用offscreen
render pass进行编码


144
00:09:27,734 --> 00:09:31,171
或运行一些
物理计算核心程序或其他程序


145
00:09:33,640 --> 00:09:37,411
在这种情况下
我们本质上是在占用我们未来可绘制


146
00:09:37,811 --> 00:09:39,346
因为在后续帧中


147
00:09:39,613 --> 00:09:41,815
我们会调用这个当前的渲染描述符


148
00:09:42,249 --> 00:09:43,750
它会呆在那儿


149
00:09:43,851 --> 00:09:47,454
等待成为可用的 可能等不到


150
00:09:47,521 --> 00:09:50,858
因为我们正在做其它的操作并且将它


151
00:09:50,924 --> 00:09:52,526
保留了比我们所需的更长的时间


152
00:09:52,593 --> 00:09:54,228
因此要解决这个问题


153
00:09:54,862 --> 00:09:59,867
让我们在访问当前渲染描述符之前
进行这些操作


154
00:10:00,434 --> 00:10:04,304
我们注意到这不是


155
00:10:04,404 --> 00:10:05,839
MetalKit特有的问题


156
00:10:05,906 --> 00:10:11,078
如果你在直接访问核心动画的时候
滚动视图 你会注意到这个问题


157
00:10:12,179 --> 00:10:17,651
因此在任何情况下这种信息都很有用


158
00:10:18,519 --> 00:10:23,190
这里有个每帧渲染更新的更完整的例子


159
00:10:23,824 --> 00:10:27,327
首先 如所述我们想要
更新我们的应用程序的渲染状态


160
00:10:28,061 --> 00:10:30,097
对任何的offscreen
passes进行编码


161
00:10:30,163 --> 00:10:31,999
做任何我们不需要 可绘制的东西


162
00:10:34,101 --> 00:10:36,203
然后我们就能够继续像以前那样


163
00:10:36,670 --> 00:10:39,206
获取当前渲染通道描述符


164
00:10:39,273 --> 00:10:42,276
为最终的pass的指令进行编码
然后呈现和提交我们的指令缓冲器


165
00:10:43,010 --> 00:10:45,646
关键点是这两个阶段


166
00:10:45,846 --> 00:10:48,248
越靠近越好


167
00:10:49,016 --> 00:10:52,152
它是我们保持资源的临界区段


168
00:10:52,719 --> 00:10:55,055
我们不想将它保留时间过长


169
00:10:57,624 --> 00:10:58,825
关于视图的就说这么多


170
00:11:00,227 --> 00:11:01,895
让我们开始讨论纹理载入器


171
00:11:04,131 --> 00:11:06,033
纹理载入很简单


172
00:11:07,100 --> 00:11:11,338
你给一个引用
然后你就得到一个成形


173
00:11:11,672 --> 00:11:12,840
的Metal纹理


174
00:11:14,141 --> 00:11:18,579
它不只是简单而且功能齐全


175
00:11:19,646 --> 00:11:22,216
它异步解码文件


176
00:11:22,983 --> 00:11:26,486
并且在分别的线程上创建纹理


177
00:11:27,921 --> 00:11:31,325
它支持许多通用图像文件格式包括


178
00:11:31,391 --> 00:11:36,230
JPG、TIF和PNG还支持PVR


179
00:11:36,330 --> 00:11:38,632
和KTX纹理文件格式


180
00:11:38,999 --> 00:11:41,068
这些格式的有趣之处


181
00:11:41,568 --> 00:11:43,203
是它们以原始形式保存数据


182
00:11:43,270 --> 00:11:47,107
并且可以上传到你的Metal纹理中


183
00:11:47,174 --> 00:11:48,609
不需要任何的改变


184
00:11:49,543 --> 00:11:53,580
另你可以将MIT maps数据编码


185
00:11:54,314 --> 00:11:57,484
成其他类型的纹理


186
00:11:57,551 --> 00:12:01,355
包括3D纹理、立体地图
和纹理数组


187
00:12:06,026 --> 00:12:07,194
它的用法很简单


188
00:12:08,729 --> 00:12:10,964
首先我们通过提供一个设备


189
00:12:11,431 --> 00:12:13,400
来创建了一个纹理上载器对象


190
00:12:15,202 --> 00:12:20,374
然后一旦我们有了那个纹理上载器对象
我们就能用它创建许多的纹理


191
00:12:21,175 --> 00:12:25,646
首先提供一个图像文件的URL地址


192
00:12:26,747 --> 00:12:28,849
然后就可提供许多的选项 


193
00:12:28,916 --> 00:12:33,020
包括 如何处理文件中的sRGB信息


194
00:12:33,220 --> 00:12:36,290
或者是我们是否想
在创建这个纹理的时候


195
00:12:36,523 --> 00:12:37,991
为MIT maps分配内存


196
00:12:39,693 --> 00:12:42,496
最后我们要提供一个完成处理块


197
00:12:42,930 --> 00:12:44,631
只要纹理载入器已经完成了


198
00:12:45,098 --> 00:12:48,969
上载纹理并且创建了它
就会执行块


199
00:12:49,169 --> 00:12:52,639
它会将纹理处理器发回给你
你可以将它保存在以后


200
00:12:53,140 --> 00:12:55,676
需要时用来渲染


201
00:12:57,344 --> 00:12:59,379
纹理载入器非常简单


202
00:12:59,513 --> 00:13:01,949
让我们继续进行Model I/O


203
00:13:04,952 --> 00:13:07,154
模型I/0是一个新的结构是与


204
00:13:07,221 --> 00:13:09,790
iOS 9和OS X
El Capitan一块引入的


205
00:13:11,225 --> 00:13:12,960
它的一个关键特点是


206
00:13:13,060 --> 00:13:17,698
它可以为你上载许多的模型文件格式


207
00:13:18,999 --> 00:13:21,768
如果你需要可以为你专门格式创建


208
00:13:21,969 --> 00:13:25,005
你自己的导入器和导出器


209
00:13:27,007 --> 00:13:28,242
这里非常酷的特点是


210
00:13:28,642 --> 00:13:33,013
做offline baking操作


211
00:13:33,814 --> 00:13:38,018
可创建静态环境光遮蔽地图生成光照图


212
00:13:39,052 --> 00:13:42,055
它还包括你的网格的立体像素化


213
00:13:43,457 --> 00:13:48,462
它提供了一种集中于你的渲染代码


214
00:13:48,529 --> 00:13:49,630
和写入你的着色器的方法


215
00:13:49,696 --> 00:13:52,266
你不需要创建一些parchers


216
00:13:52,332 --> 00:13:53,700
来将一些东西从磁盘中取出


217
00:13:53,767 --> 00:13:57,104
你必须少和串行打交道


218
00:13:57,771 --> 00:14:00,607
你只需要上载一个
带有Model I/O的模型文件


219
00:14:01,642 --> 00:14:03,577
把它放入你可用它做渲染的一些构成中


220
00:14:04,244 --> 00:14:06,813
开始写入你的着色器


221
00:14:09,650 --> 00:14:12,152
MetalKit
在这种情况下提供了什么


222
00:14:12,219 --> 00:14:15,455
它的程序有效使用
Metal的Model I/O


223
00:14:16,790 --> 00:14:20,561
它提供了将Model I/O
网格优化上载到Metal缓冲器中


224
00:14:21,695 --> 00:14:25,933
MetalKit
对象内部的网格数据封装


225
00:14:27,000 --> 00:14:29,803
有许多函数用于为网格数据


226
00:14:30,537 --> 00:14:31,672
的Metal管道做准备


227
00:14:34,741 --> 00:14:38,145
让我来指导


228
00:14:38,245 --> 00:14:42,482
如何用Model I/O
来上载一个模型文件的步骤


229
00:14:43,517 --> 00:14:46,019
并且用Metal来将它渲染到屏幕上


230
00:14:48,388 --> 00:14:49,690
这里就是我们要采取的步骤


231
00:14:53,861 --> 00:14:58,932
首先创建一个Metal渲染状态管道


232
00:14:58,999 --> 00:15:01,869
我们将用来创建我们的网格
来渲染我们的网格


233
00:15:03,604 --> 00:15:06,240
然后通过初始化
Model I/O asset


234
00:15:06,340 --> 00:15:08,942
用asset来上载模型文件


235
00:15:10,777 --> 00:15:14,448
我们就可以创建MetalKit网格


236
00:15:14,515 --> 00:15:16,083
以及子网格对象


237
00:15:17,484 --> 00:15:19,853
最后用Metal来渲染那些对象


238
00:15:22,623 --> 00:15:26,159
因此集中于创建
一个Metal渲染状态管道


239
00:15:27,327 --> 00:15:29,429
我们要特别注意


240
00:15:29,763 --> 00:15:31,498
创建一个顶点描述器


241
00:15:31,965 --> 00:15:37,971
该描述器将会对需要的网格
提供给管道的顶点的布局进行描述


242
00:15:39,473 --> 00:15:43,210
这里是顶点着色器的基本内容


243
00:15:45,379 --> 00:15:48,248
它使用限制符级基本上


244
00:15:48,315 --> 00:15:51,785
说明了我们每个顶点的输入它们的布局


245
00:15:52,319 --> 00:15:55,656
用我们的objective-C代码
使用顶点描述符


246
00:15:56,757 --> 00:15:58,158
对着色器以外进行描述


247
00:15:59,626 --> 00:16:02,396
它使用了这里所定义的


248
00:16:03,564 --> 00:16:04,865
顶点输入架构


249
00:16:06,099 --> 00:16:09,403
这个顶点输入架构的主要部分是


250
00:16:09,503 --> 00:16:12,973
这些功能
我们要使用这些指数来连接


251
00:16:13,040 --> 00:16:16,310
Objective-C
编码的外部和内部


252
00:16:17,144 --> 00:16:23,684
注意这些浮点矢量
类型定义了数据在着色器中的样子


253
00:16:24,351 --> 00:16:27,387
不是实际上数据从我们的


254
00:16:27,454 --> 00:16:29,356
Objective-C编码送入


255
00:16:29,423 --> 00:16:30,691
着色器的样子


256
00:16:38,899 --> 00:16:41,235
对此需要创建一个顶点描述符


257
00:16:43,070 --> 00:16:46,240
我将把这个顶点输入结构


258
00:16:46,306 --> 00:16:49,743
放在这作为参考但是我要提醒你


259
00:16:49,810 --> 00:16:53,380
它定义的不是被送入到着色器时


260
00:16:53,447 --> 00:16:54,715
的数据的布局


261
00:16:55,115 --> 00:17:01,188
我们实际上创建的是下面
的Metal顶点描述符


262
00:17:01,822 --> 00:17:06,260
我们要做的是针对属性0


263
00:17:08,729 --> 00:17:15,068
用三个浮点 三个浮点值


264
00:17:16,002 --> 00:17:17,271
来定义这个位置


265
00:17:17,738 --> 00:17:23,210
对于属性1 色彩将由


266
00:17:23,277 --> 00:17:26,747
四个无符号的字符组成


267
00:17:26,980 --> 00:17:29,650
不是上面的四个浮点 四个无符号字符


268
00:17:29,917 --> 00:17:31,385
它紧接在位置数据之后


269
00:17:32,519 --> 00:17:36,823
有12个比特的相位差


270
00:17:41,094 --> 00:17:44,531
对于属性2的纹理坐标


271
00:17:45,399 --> 00:17:49,036
我们将定义它用了两个半浮点


272
00:17:50,637 --> 00:17:55,742
它紧跟在位置和颜色数据之后


273
00:17:55,843 --> 00:17:57,544
有16比特的相位差


274
00:17:59,913 --> 00:18:04,384
通过将
缓存器的stride设置设为20


275
00:18:04,651 --> 00:18:05,819
将每个顶点的大小


276
00:18:05,886 --> 00:18:07,654
规定为20比特


277
00:18:12,059 --> 00:18:15,729
这样就定义了我们的顶点阵列


278
00:18:15,796 --> 00:18:17,698
内的每个顶点的布局


279
00:18:21,368 --> 00:18:23,570
这样我们就得到了
我们的Metal顶点描述符


280
00:18:23,971 --> 00:18:26,106
我们能够将
它分配到我们的渲染状态管道


281
00:18:27,641 --> 00:18:31,011
并且用渲染
对不起 用渲染管道描述符


282
00:18:31,311 --> 00:18:34,248
我们就能够
创建一个Metal渲染状态管道


283
00:18:36,617 --> 00:18:39,586
现在我们开始上载我们的asset


284
00:18:41,388 --> 00:18:44,591
用Model I/O来完成那个任务


285
00:18:46,326 --> 00:18:49,029
我们实际上使用我们在


286
00:18:49,096 --> 00:18:50,364
前一步创建的顶点描述符


287
00:18:51,331 --> 00:18:55,068
一个MetalKit网格缓冲器对象


288
00:18:55,502 --> 00:18:58,005
一个网格缓冲器分配器对象


289
00:18:59,339 --> 00:19:00,874
在我们继续向下讲时


290
00:19:01,441 --> 00:19:03,877
我多说几句强调一下它的重要性


291
00:19:06,547 --> 00:19:11,418
Model I/O顶点描述器


292
00:19:11,685 --> 00:19:14,521
以及Metal顶点描述器非常类似


293
00:19:15,689 --> 00:19:18,659
但是尽管
Model I/O顶点描述器描述了


294
00:19:18,725 --> 00:19:20,794
网格内的顶点属性的布局


295
00:19:22,663 --> 00:19:24,998
但是Metal顶点描述器描述了


296
00:19:25,065 --> 00:19:27,167
作为渲染状态管道的输入


297
00:19:27,668 --> 00:19:29,169
的顶点属性的布局


298
00:19:30,537 --> 00:19:33,707
它们专门设计成看起来相似


299
00:19:34,441 --> 00:19:38,512
因为它们包含属性和缓冲器布局对象


300
00:19:39,379 --> 00:19:44,952
原因是这样就简化了
将一个对象翻译成另一个的过程


301
00:19:47,354 --> 00:19:51,758
在Model I/O顶点
描述器中的每个属性


302
00:19:52,025 --> 00:19:53,861
都有一个可识别的字符串库名称


303
00:19:54,828 --> 00:19:59,433
Model I/O分配了一个
缺省的名称 如果模型内不存在


304
00:19:59,499 --> 00:20:03,237
或者是那个模型文件不支持这些名称


305
00:20:03,770 --> 00:20:08,041
这些名称包括位置、
法向量、纹理、坐标颜色等


306
00:20:09,376 --> 00:20:11,512
Model I/O用
基于MDLVertex


307
00:20:11,578 --> 00:20:14,748
属性常数的字符串来定义这些


308
00:20:15,849 --> 00:20:19,887
有许多文件
包括你可以自定义那些名称的


309
00:20:19,953 --> 00:20:23,123
Alembic文件格式


310
00:20:23,857 --> 00:20:26,960
注意 如果你要改变名称


311
00:20:27,027 --> 00:20:31,798
你需要用那些
自定义名称来访问这些属性


312
00:20:33,734 --> 00:20:39,072
所以我们建议你创建一个
自定义Model I/O顶点描述器


313
00:20:39,139 --> 00:20:42,376
因为在缺省下
Model I/O上载的顶点


314
00:20:42,576 --> 00:20:43,810
为高精度


315
00:20:44,077 --> 00:20:47,181
而且占用大量内存的浮点类型


316
00:20:48,182 --> 00:20:52,452
这是使用
Model I/O的优势之一


317
00:20:52,920 --> 00:20:58,926
你实际上可以上载一个模型格式


318
00:20:58,992 --> 00:21:03,463
具有你所喜爱的任何形式的顶点数据


319
00:21:03,530 --> 00:21:06,600
将那个数据变成你能够实际使用的格式


320
00:21:07,301 --> 00:21:09,770
在这种情况下我们想用最小的类型


321
00:21:10,137 --> 00:21:11,205
提供给管道


322
00:21:11,605 --> 00:21:13,941
以满足你们的精确性要求


323
00:21:14,174 --> 00:21:17,678
这将提高你们的顶点带宽效率


324
00:21:18,045 --> 00:21:20,714
当你们在将每个顶点提供给管道的时候


325
00:21:21,081 --> 00:21:23,083
你实际上不想要一个膨胀的顶点


326
00:21:25,886 --> 00:21:28,689
这里就是我们前面定义的


327
00:21:28,755 --> 00:21:30,891
当创建我们的
Metal顶点描述符时的布局


328
00:21:33,560 --> 00:21:37,197
现在我们通过从Metal中调用
MTKModel I/O顶点格式


329
00:21:37,598 --> 00:21:42,569
来创建我们的
Model I/O顶点描述符


330
00:21:43,303 --> 00:21:45,439
我们所提供
我们的Metal顶点描述符


331
00:21:45,706 --> 00:21:51,545
就构建了这个Model I/O
顶点描述符的大部分


332
00:21:52,379 --> 00:21:55,716
然而我们还需要
为每个属性标个名字


333
00:21:55,782 --> 00:21:59,152
这样Model I/O
就知道我们谈论的是什么


334
00:22:00,053 --> 00:22:03,590
因此对于属性0我们用顶点


335
00:22:03,657 --> 00:22:06,226
属性位置名称来标记


336
00:22:07,461 --> 00:22:10,764
类似地如属性1和2 我们用


337
00:22:10,831 --> 00:22:13,700
颜色和纹理坐标属性来做标记


338
00:22:17,371 --> 00:22:20,107
这里我们要做的另外的事是我们要创建


339
00:22:20,340 --> 00:22:24,478
一个MetalKit
并且我们会提供一个Metal设备


340
00:22:25,012 --> 00:22:29,383
这个对象所做的
就是允许Model I/O来


341
00:22:29,917 --> 00:22:35,122
直接将顶点
数据上载到GPU备份内存中


342
00:22:35,923 --> 00:22:39,059
你不一定要使用一个
MetalKit网格缓冲器分配器


343
00:22:39,860 --> 00:22:44,198
但是它所做的是为网格内的


344
00:22:44,665 --> 00:22:49,870
这些顶点和指标缓冲器分配系统内存


345
00:22:50,137 --> 00:22:53,574
当你想真的要渲染它
我们需要从系统内存拷贝到


346
00:22:53,640 --> 00:22:56,743
GPU备份内存中


347
00:22:56,810 --> 00:23:01,615
因此为了更有效最好使用这些网格


348
00:23:01,715 --> 00:23:05,018
缓存分配器中的一个
这里我们要说下如何使用它


349
00:23:06,119 --> 00:23:08,422
我们要上载我们的asset文件


350
00:23:10,090 --> 00:23:13,126
我们将提供URL地址


351
00:23:15,295 --> 00:23:17,231
将会告诉Model I/O如何对


352
00:23:17,297 --> 00:23:20,000
每个顶点进行布局的
Model I/O顶点描述符


353
00:23:21,368 --> 00:23:24,404
我们还将提供该网格缓存分配器


354
00:23:25,005 --> 00:23:27,941
这样Model I/O
就能直接上载数据到


355
00:23:28,008 --> 00:23:29,142
GPU备份内存中


356
00:23:31,712 --> 00:23:33,680
现在我们获得的我们的asset


357
00:23:35,549 --> 00:23:37,918
让我们真正地
来创建一些MetalKit网格


358
00:23:37,985 --> 00:23:39,419
以及一些网格对象


359
00:23:41,421 --> 00:23:43,557
这里是通过Model I/O


360
00:23:43,624 --> 00:23:46,293
来创建asset的一个例子


361
00:23:47,861 --> 00:23:51,598
在asset的内部
我们可能会有相机对象


362
00:23:53,200 --> 00:23:54,368
光照对象...


363
00:23:55,435 --> 00:24:00,040
以及对我们
目前非常重要的网格对象


364
00:24:00,307 --> 00:24:04,044
MetalKit首先与
这些网格对象相关


365
00:24:04,111 --> 00:24:08,215
它并不直接与光线
和相机对象打交道


366
00:24:08,282 --> 00:24:14,021
因为那种数据取决于
你的自定义的着色器和你的引擎


367
00:24:14,655 --> 00:24:19,459
你可以真的探究这个对象
或者向内查看这个对象


368
00:24:19,526 --> 00:24:23,797
取出相机和光亮信息
插入到你的着色器中


369
00:24:24,064 --> 00:24:27,100
但是MetalKit并不
直接参与到那个过程中


370
00:24:28,068 --> 00:24:34,708
因此我们所能做的就是
直接将这个asset


371
00:24:37,611 --> 00:24:42,382
传到这个网格中
网格来自asset类函数


372
00:24:42,716 --> 00:24:46,253
将会创建MetalKit网格的阵列


373
00:24:51,024 --> 00:24:53,994
让我们看看这个网格对象内部都有什么


374
00:24:55,229 --> 00:24:57,397
首先是这些顶点缓存器


375
00:24:57,464 --> 00:25:00,100
包括位置属性


376
00:25:00,367 --> 00:25:04,004
法向量属性 纹理属性等等


377
00:25:04,404 --> 00:25:07,508
在我们的例子中 我们只需要一个阵列


378
00:25:07,708 --> 00:25:09,376
因为我们对所有我们的数据进行交错


379
00:25:09,943 --> 00:25:13,614
然而我们用多重阵列来定义布局


380
00:25:13,680 --> 00:25:16,283
因此你就会有多重顶点缓存器


381
00:25:16,783 --> 00:25:21,321
你可以定义那个属性0可以在


382
00:25:21,421 --> 00:25:23,957
一个单独阵列的内部
这样你就会在一个阵列


383
00:25:24,491 --> 00:25:28,161
中有一阵列的位置
在下一个中有一阵列的纹理坐标


384
00:25:28,629 --> 00:25:31,398
下一个是色彩阵列等等


385
00:25:35,569 --> 00:25:37,638
该网格还包括一个定义了这个


386
00:25:37,704 --> 00:25:39,339
布局的顶点描述符


387
00:25:39,439 --> 00:25:41,842
与我们初始化我们的asset时


388
00:25:41,909 --> 00:25:44,478
刚刚创建的和送入的是相同的对象


389
00:25:46,413 --> 00:25:49,716
网格包含有许多的子网格对象


390
00:25:50,083 --> 00:25:54,021
每个子网格对象的
主要部分是这个变址缓存器


391
00:25:54,621 --> 00:25:58,425
它引用顶点缓存器内部的顶点


392
00:26:00,027 --> 00:26:03,063
另外你能够使用许多属性


393
00:26:03,564 --> 00:26:05,599
来用Metal调用一个绘制


394
00:26:08,702 --> 00:26:14,041
获得了Metal kit网格
和子网格对象


395
00:26:16,844 --> 00:26:18,512
让我们继续来渲染它们


396
00:26:21,582 --> 00:26:26,053
首先我们要循环访问每个顶点缓冲器


397
00:26:27,421 --> 00:26:29,723
可能有稀疏阵列 因此需要确定


398
00:26:29,790 --> 00:26:32,326
每个缓存器里真的有东西


399
00:26:33,460 --> 00:26:35,896
但是一旦我们确定了
我们就可以继续


400
00:26:35,963 --> 00:26:39,700
并且在我们的渲染
编码器中设置顶点缓存器


401
00:26:40,701 --> 00:26:43,337
顶点缓存器实际上有两个属性


402
00:26:43,570 --> 00:26:47,140
缓存器本身
以及缓存器内部的相位差


403
00:26:47,608 --> 00:26:50,244
它是你的顶点数据驻留的地方


404
00:26:52,079 --> 00:26:57,050
我们还需要提供一个缓冲索引
告诉管道


405
00:26:57,551 --> 00:26:59,319
数据的精确位置


406
00:27:01,788 --> 00:27:03,824
就可以真正地渲染我们的网格了


407
00:27:04,892 --> 00:27:06,460
我们将循环访问每个子网格


408
00:27:07,895 --> 00:27:10,163
并且调用我们的绘制指数基元


409
00:27:11,131 --> 00:27:13,166
注意这个子网格具有


410
00:27:13,700 --> 00:27:18,505
这个绘制指数参数的所有参数


411
00:27:21,041 --> 00:27:25,412
今天将这个MetalKit基本样本


412
00:27:25,746 --> 00:27:28,682
发布到WWDC 2015网站上


413
00:27:29,383 --> 00:27:31,285
我希望你们将它下载下来


414
00:27:31,351 --> 00:27:34,121
它描述了许多我介绍的技术


415
00:27:34,521 --> 00:27:38,926
它使用Model I/O来上载
这个塞入一个OBJ文件中的


416
00:27:38,992 --> 00:27:44,665
小型飞机对象
并且创建一了个MetalKit网格


417
00:27:45,132 --> 00:27:47,234
并且将它在屏幕上进行渲染


418
00:27:47,534 --> 00:27:51,171
这样你就能明白究竟如何去做


419
00:27:51,672 --> 00:27:53,640
我鼓励你们多看看


420
00:27:56,210 --> 00:27:58,545
我的就这么多
我叫丹·大町市


421
00:27:58,612 --> 00:28:02,015
如果对我今天讨论的题目有什么问题


422
00:28:02,082 --> 00:28:03,684
我明天就在Metal实验室


423
00:28:03,951 --> 00:28:07,287
我想要欢迎我的同事
安娜·吉洪诺夫


424
00:28:07,354 --> 00:28:13,126
上台来谈Metal性能着色器架构
谢谢


425
00:28:18,832 --> 00:28:19,666
早晨好


426
00:28:20,267 --> 00:28:22,669
谢谢你 丹
谢谢你的介绍 我叫 安娜


427
00:28:23,203 --> 00:28:26,206
我将和你们谈谈Metal性能着色器


428
00:28:26,273 --> 00:28:27,274
让我们开始


429
00:28:27,941 --> 00:28:29,910
首先Metal性能着色器是什么


430
00:28:30,410 --> 00:28:34,214
它是Metal内 的用于GPU的


431
00:28:34,281 --> 00:28:35,916
优化性能数据并行算法


432
00:28:37,050 --> 00:28:38,719
你什么时候和为什么要使用它？


433
00:28:39,553 --> 00:28:41,388
如果你在写C代码并且你要


434
00:28:41,455 --> 00:28:42,923
填加一个C代码排序算法


435
00:28:42,990 --> 00:28:44,691
到你的CPU应用中


436
00:28:44,958 --> 00:28:49,329
你肯定不会抓来一个就用
除非出于你自身的利益


437
00:28:49,963 --> 00:28:53,066
你更有可能使用函数库提供给你的实现


438
00:28:53,400 --> 00:28:58,005
因为它已经经过了调试和优化


439
00:28:59,006 --> 00:29:01,975
同样如果你想要在我们的平台上


440
00:29:02,042 --> 00:29:05,445
添加一个图像处理
操作到你的CPU应用程序中


441
00:29:05,512 --> 00:29:07,080
你将会使用加速架构


442
00:29:07,481 --> 00:29:08,715
因为它使用了vlmage


443
00:29:09,583 --> 00:29:10,717
它是一个强大的


444
00:29:10,784 --> 00:29:14,988
高性能的调整图像处理架构


445
00:29:16,256 --> 00:29:19,126
因为它使用了CPU的向量处理


446
00:29:20,194 --> 00:29:21,662
这只是几个例子


447
00:29:22,529 --> 00:29:25,566
重要的是可以为你的CPU应用程序


448
00:29:25,632 --> 00:29:26,834
提供丰富的环境


449
00:29:27,868 --> 00:29:30,103
对于GPU情况有些不同


450
00:29:30,871 --> 00:29:32,239
你的选择变少


451
00:29:32,973 --> 00:29:34,474
但是我们将会改变这种情况


452
00:29:34,908 --> 00:29:38,145
我们的目标是丰富
我们的Metal编程环境


453
00:29:40,447 --> 00:29:42,683
我们选择了一系列的通用过滤器


454
00:29:42,749 --> 00:29:45,986
我们知道这些通用过滤器通常使用


455
00:29:46,053 --> 00:29:47,955
在你的图像处理应用和游戏中


456
00:29:49,723 --> 00:29:53,660
这些算法为iOS进行了优化并且


457
00:29:53,894 --> 00:29:55,963
可以使用于A8处理器的IOS 9中


458
00:29:57,798 --> 00:30:00,434
Metal性能着色器架构有两个目标


459
00:30:00,801 --> 00:30:03,103
性能和容易使用


460
00:30:03,337 --> 00:30:05,405
将它设计成容易融合到


461
00:30:05,506 --> 00:30:06,907
你的Metal应用中


462
00:30:07,474 --> 00:30:10,143
让它直接在Metal资源上进行操作


463
00:30:10,611 --> 00:30:12,079
它们是输入和输出


464
00:30:13,180 --> 00:30:15,148
我们不只是给你提供一批的这些高性能


465
00:30:15,215 --> 00:30:19,753
优化的极好的核心程序


466
00:30:19,920 --> 00:30:21,688
我们还十分关注


467
00:30:21,755 --> 00:30:25,125
启动这些核心程序的必要的宿主代码


468
00:30:25,726 --> 00:30:28,028
我们对如何将并行计算分离


469
00:30:28,362 --> 00:30:30,998
的决策流程也很重视


470
00:30:32,032 --> 00:30:34,401
你所要做的工作就是将这个架构的优势


471
00:30:34,468 --> 00:30:36,670
应用到你的应用程序中


472
00:30:36,870 --> 00:30:38,872
通常只需要几行的代码


473
00:30:40,440 --> 00:30:42,643
它简单地就像是调用一个库函数


474
00:30:44,211 --> 00:30:46,180
现在我就像你们介绍这个架构


475
00:30:46,380 --> 00:30:48,448
让我们看看可用的操作


476
00:30:49,750 --> 00:30:52,386
这里是个完整的列表 我们从头开始


477
00:30:52,653 --> 00:30:54,421
实际上我只是挑几个说


478
00:30:54,488 --> 00:30:55,589
并且我还要举例说明


479
00:30:57,224 --> 00:30:59,726
首先该架构支持直方图过滤器


480
00:31:00,027 --> 00:31:02,729
直方图均衡和规格过滤器


481
00:31:03,830 --> 00:31:06,099
均衡和规格过滤器


482
00:31:06,567 --> 00:31:10,537
允许你改变你的图像


483
00:31:10,604 --> 00:31:12,206
中的色彩强度的分布


484
00:31:12,840 --> 00:31:15,075
均衡过滤器是个很特殊的例子


485
00:31:15,542 --> 00:31:16,944
它将当前的分布


486
00:31:17,411 --> 00:31:20,013
改变为统一的分布


487
00:31:20,881 --> 00:31:22,983
而规格过滤器使你能够设置


488
00:31:23,050 --> 00:31:24,852
你所选择的任何分布


489
00:31:25,219 --> 00:31:27,621
你指定将要在过滤器中使用的直方图


490
00:31:30,591 --> 00:31:34,394
这是均衡过滤器的一个例子


491
00:31:37,998 --> 00:31:40,200
它增加了图像的整体对比度


492
00:31:40,367 --> 00:31:43,203
这里它描绘的天空中的彩虹非常美丽


493
00:31:43,971 --> 00:31:45,439
我想提醒的一件事是


494
00:31:45,839 --> 00:31:48,609
这些过滤器并不是其本身的结束


495
00:31:49,576 --> 00:31:51,612
它们可以在一个更加复杂的算法中


496
00:31:52,012 --> 00:31:53,480
用作中间步骤


497
00:31:53,881 --> 00:31:57,284
直方图过滤器可以用来实现


498
00:31:57,351 --> 00:31:58,886
tune mapping的中间步骤


499
00:31:58,952 --> 00:32:01,655
这种技术常用于图形开发者来


500
00:32:02,089 --> 00:32:05,092
接近高动态范围的外观继续


501
00:32:06,159 --> 00:32:09,763
我们还支持Lancos重采样


502
00:32:10,230 --> 00:32:12,466
它是高质量的重采样算法


503
00:32:12,599 --> 00:32:16,703
可以用来缩减 放大
压缩和拉伸图像


504
00:32:18,071 --> 00:32:21,909
在这个例子中 我垂直地拉伸图片


505
00:32:22,075 --> 00:32:24,511
并且水平地挤压图片同时还保存


506
00:32:24,578 --> 00:32:25,512
图像的内容


507
00:32:27,748 --> 00:32:29,616
你还可以支持阀值过滤器


508
00:32:30,150 --> 00:32:31,952
如果与Sobel过滤器链接在一起


509
00:32:32,085 --> 00:32:33,487
它还可以被用来查找图像的边缘


510
00:32:35,122 --> 00:32:36,290
让我们来看个例子


511
00:32:37,824 --> 00:32:39,693
这是阀值过滤器的输出


512
00:32:40,294 --> 00:32:44,932
现在它进入Sobel过滤器
来给你提供图像的边缘


513
00:32:46,633 --> 00:32:50,904
最后支持整个范围的卷积核


514
00:32:50,971 --> 00:32:53,841
包括通用卷积
在这里你可以指定你自己的


515
00:32:53,907 --> 00:32:55,275
卷积矩阵


516
00:32:55,742 --> 00:32:57,711
我们还支持高斯模糊


517
00:32:57,945 --> 00:32:59,780
box tent和Sobel过滤器


518
00:33:00,180 --> 00:33:03,150
我最后的例子将是高斯模糊


519
00:33:03,750 --> 00:33:05,319
你们都应该很熟悉


520
00:33:05,719 --> 00:33:07,354
我们想在我们的UL中使用


521
00:33:07,821 --> 00:33:09,857
你想要在你自己的应用程序中


522
00:33:09,923 --> 00:33:11,425
使用高斯模糊会怎么样呢


523
00:33:12,526 --> 00:33:15,395
性能着色器架构会使它非常简单


524
00:33:16,730 --> 00:33:17,798
你要问有多简单？


525
00:33:18,732 --> 00:33:20,601
我预先告诉你


526
00:33:20,667 --> 00:33:22,703
只有两行代码


527
00:33:23,537 --> 00:33:28,408
首先你必须创建一个模糊过滤器对象


528
00:33:28,475 --> 00:33:33,347
然后你必须将这个
过滤器编码到指令缓存器中


529
00:33:37,451 --> 00:33:38,552
谢谢大家


530
00:33:41,188 --> 00:33:43,924
有一件事我想再次指出和提醒的是


531
00:33:44,424 --> 00:33:47,594
API将你的通用
Metal资源看作是输入


532
00:33:48,161 --> 00:33:50,030
你的设备、你的指令缓存器、你的纹理


533
00:33:51,098 --> 00:33:53,433
这些都是你已经在你的应用程序中


534
00:33:53,500 --> 00:33:55,169
创建的Metal资源


535
00:33:57,271 --> 00:33:59,106
现在我已经向你展示了这两行代码


536
00:33:59,540 --> 00:34:02,075
让我们看看它们插入到你


537
00:34:02,342 --> 00:34:04,278
当前的Metal工作流程的哪个位置


538
00:34:04,745 --> 00:34:07,147
这是你的指令缓存器的图解表示法


539
00:34:08,447 --> 00:34:10,617
它包括你将要提交到


540
00:34:10,684 --> 00:34:12,186
设备中的所有命令


541
00:34:12,719 --> 00:34:14,288
你就像平时那样操作就行了


542
00:34:15,054 --> 00:34:17,157
你通过发送绘制调用来渲染你的屏幕


543
00:34:18,292 --> 00:34:21,328
你通过发送核心程序来进行效果处理


544
00:34:22,129 --> 00:34:26,199
现在你已经决定
你的处理效果之一是模糊过滤器


545
00:34:26,934 --> 00:34:29,770
正好是这个地方


546
00:34:31,938 --> 00:34:36,310
不要忘记你还要像平时那样
提交你的命令到设备中


547
00:34:36,376 --> 00:34:37,411
这里什么都没有改变


548
00:34:39,279 --> 00:34:43,417
现在如果你想要看我刚才
完成的例子中的示例代码


549
00:34:43,483 --> 00:34:46,320
你可以上网
developer.Apple.com


550
00:34:46,553 --> 00:34:50,056
下载叫做Metal性能着色器的例子
世界你好


551
00:34:52,226 --> 00:34:53,293
我前面已经提到过


552
00:34:53,360 --> 00:34:57,731
Metal性能着色器架构
有两个目的性能和易于使用


553
00:34:58,232 --> 00:35:00,300
我刚才展示了它是多么容易使用


554
00:35:01,168 --> 00:35:03,070
让我们快速地看看幕后


555
00:35:03,537 --> 00:35:05,472
将要告诉你的性能的秘密


556
00:35:07,641 --> 00:35:09,476
对于这些过滤器的每一个


557
00:35:09,543 --> 00:35:13,647
包括高斯模糊过滤器
我们要选择恰当的算法


558
00:35:14,081 --> 00:35:18,852
恰当的这里的意思
是正确的并且是最快的


559
00:35:19,319 --> 00:35:24,591
对于输入数据、输入参数


560
00:35:24,825 --> 00:35:27,361
设备GPU的特别组合是最快的


561
00:35:28,262 --> 00:35:29,496
我这样说是什么意思


562
00:35:30,364 --> 00:35:32,633
有许多方法可以实现高斯模糊


563
00:35:33,100 --> 00:35:36,270
有constant cost
log 2 linear


564
00:35:36,336 --> 00:35:37,738
以及强力运算


565
00:35:39,273 --> 00:35:40,841
所有这些方法的启动费用和


566
00:35:40,908 --> 00:35:42,309
日常开支都不相同


567
00:35:42,676 --> 00:35:45,646
一种方法可能对于小的核半径


568
00:35:45,979 --> 00:35:48,815
非常好但在大的核半径上表现不佳


569
00:35:49,983 --> 00:35:54,321
重要的是我们要实现每一种方法


570
00:35:54,421 --> 00:35:57,057
并且通过实验来发现哪个


571
00:35:57,124 --> 00:35:59,459
对于一个特别的输入问题、输入参数


572
00:35:59,526 --> 00:36:04,097
和设备GPU的组合是最快的


573
00:36:05,265 --> 00:36:06,500
在这个过程之后


574
00:36:07,000 --> 00:36:11,538
所有的核都被调整成为你的核半径


575
00:36:12,439 --> 00:36:13,841
你的像素格式


576
00:36:14,408 --> 00:36:16,944
你的基础硬件结构的存储层次的参数


577
00:36:17,311 --> 00:36:19,279
以及每个线程的像素数目


578
00:36:19,346 --> 00:36:21,148
以及线程组规模的参数


579
00:36:21,215 --> 00:36:23,584
这决定了如何将你的工作并行分离


580
00:36:25,018 --> 00:36:26,486
最后我将会提到


581
00:36:27,187 --> 00:36:30,624
该架构还为你做CPU优化工作


582
00:36:32,526 --> 00:36:35,028
它优化了程序上载速度


583
00:36:36,263 --> 00:36:40,634
它还重复使用中间纹理


584
00:36:41,201 --> 00:36:45,072
它还为你做计算编码优化


585
00:36:45,472 --> 00:36:47,241
特别的是它还能察觉


586
00:36:47,641 --> 00:36:51,044
你是否是在连续使用多重计算编码器


587
00:36:51,111 --> 00:36:52,412
如果是这样它就会将它们合并


588
00:36:55,048 --> 00:36:57,417
我们为你完成了所有的这些步骤


589
00:36:58,418 --> 00:37:01,021
非常酷
但以代码的角度来看是什么样子


590
00:37:01,088 --> 00:37:03,724
如对于我刚刚向你们展示的


591
00:37:03,790 --> 00:37:04,725
优化高斯模糊着色器


592
00:37:07,427 --> 00:37:08,862
好了 你准备好了么？


593
00:37:09,696 --> 00:37:11,131
这就是代码


594
00:37:12,499 --> 00:37:13,534
现在你们都知道了


595
00:37:13,600 --> 00:37:15,936
如何实现你们自己的优化高斯模糊


596
00:37:16,203 --> 00:37:17,337
对么我敢打赌 你没想到


597
00:37:17,404 --> 00:37:19,573
在这个讲座中能学到这个


598
00:37:19,840 --> 00:37:23,010
言归正传这是49 Metal
kernels


599
00:37:23,076 --> 00:37:25,245
2,000行的kernel代码


600
00:37:25,312 --> 00:37:29,750
以及821个不同的
Metal高斯模糊实现


601
00:37:30,584 --> 00:37:35,789
每个实现都是这些49个Metal
kernels一些组合


602
00:37:35,856 --> 00:37:37,424
因此看起来我们做了很多的工作


603
00:37:37,691 --> 00:37:38,692
现在不必由你来做


604
00:37:39,493 --> 00:37:40,894
让我们看看


605
00:37:40,961 --> 00:37:44,665
运行中的Metal性能着色器架构


606
00:37:51,238 --> 00:37:53,273
首先我将演示一个简单的


607
00:37:53,373 --> 00:37:58,545
可分离高斯模糊实现的教科书


608
00:37:59,947 --> 00:38:01,715
只需要1分钟就可写入到Metal


609
00:38:01,782 --> 00:38:03,951
这可能是你刚开始时应该使用的东西


610
00:38:04,017 --> 00:38:05,586
如果你要实现你的模糊


611
00:38:05,652 --> 00:38:08,188
并且你手头没有Metal性能着色器


612
00:38:08,922 --> 00:38:11,258
现在我们非常愉快地
在每秒60帧在运行着


613
00:38:11,325 --> 00:38:13,193
但是我们实际上还没有做任何工作


614
00:38:13,994 --> 00:38:15,195
sigma数值是0


615
00:38:15,596 --> 00:38:19,399
让我们改变sigma数值到6


616
00:38:19,466 --> 00:38:21,134
我们就降到了每秒8帧


617
00:38:21,969 --> 00:38:23,303
我们还敢继续么


618
00:38:23,370 --> 00:38:24,738
让我们试着sigma 20


619
00:38:27,307 --> 00:38:30,844
好了 现在我们降到了每秒3帧


620
00:38:30,911 --> 00:38:32,179
那样就无法工作了


621
00:38:33,013 --> 00:38:34,748
让我们转换到Metal性能


622
00:38:34,815 --> 00:38:35,949
着色器实现


623
00:38:37,551 --> 00:38:39,887
现在我们返回到了每秒60帧


624
00:38:39,953 --> 00:38:42,789
没有做任何工作sigma为6


625
00:38:43,423 --> 00:38:44,858
每秒仍然是60帧


626
00:38:45,592 --> 00:38:46,560
Sigma为20


627
00:38:47,127 --> 00:38:48,595
仍然是每秒60帧


628
00:38:49,863 --> 00:38:53,367
我们还得继续 真的模糊它


629
00:38:53,700 --> 00:38:55,169
仍然是每秒60帧


630
00:38:55,235 --> 00:38:56,470
看起来我们赢了


631
00:39:13,053 --> 00:39:15,322
这样你的屏幕刷新速率是60赫兹


632
00:39:17,090 --> 00:39:20,994
这就意味着我们以每秒60帧在运行


633
00:39:21,061 --> 00:39:24,898
这样你在演示中
所看到的优化高斯模糊着色器


634
00:39:24,965 --> 00:39:28,335
的性能最高是每秒60帧


635
00:39:29,102 --> 00:39:33,941
这就意味着你有
16.6毫秒来画你的帧


636
00:39:34,575 --> 00:39:36,543
这还包括你的系统可能要做的


637
00:39:36,610 --> 00:39:38,779
合成工作


638
00:39:39,813 --> 00:39:43,584
这个图表显示你在不同的sigma值


639
00:39:43,650 --> 00:39:47,254
的优化高斯模糊过滤器的执行时间


640
00:39:47,321 --> 00:39:48,422
你可以看到执行时间


641
00:39:49,656 --> 00:39:52,759
要比16.6毫秒少得多


642
00:39:53,794 --> 00:39:56,363
这就意味着你仍然有额外的时间


643
00:39:56,430 --> 00:39:57,965
来做多余的GPU工作


644
00:39:59,499 --> 00:40:02,769
而且仍然能达到希望的每秒60帧


645
00:40:05,472 --> 00:40:07,708
现在还有一些细节需要说明


646
00:40:09,476 --> 00:40:12,212
有时候你需要在很大的图片上工作


647
00:40:12,279 --> 00:40:13,380
你需要并列式显示


648
00:40:14,548 --> 00:40:15,983
有时候你需要只在你的


649
00:40:16,049 --> 00:40:17,317
图像的一部分上工作


650
00:40:17,718 --> 00:40:18,986
针对那个有个机制


651
00:40:19,486 --> 00:40:21,889
它叫做源偏移和
destination剪裁矩形


652
00:40:23,090 --> 00:40:25,626
剪裁矩形有起始点和大小


653
00:40:26,193 --> 00:40:28,795
它决定了目的纹理的区域


654
00:40:28,862 --> 00:40:30,697
将由过滤器来进行更新


655
00:40:31,899 --> 00:40:34,334
源偏移只有起始点


656
00:40:35,135 --> 00:40:37,905
大小是隐含的
由剪裁矩形来决定的


657
00:40:37,971 --> 00:40:41,542
它只是你的目的纹理的
左上角的一个相位差


658
00:40:42,309 --> 00:40:45,379
它们共同工作给你提供了最后的图像


659
00:40:48,448 --> 00:40:50,651
在Metal性能着色器架构中


660
00:40:50,717 --> 00:40:53,654
你的来源和目的是相同纹理中的一个


661
00:40:54,621 --> 00:40:56,590
在这种情况下剪裁矩形


662
00:40:56,890 --> 00:40:59,560
以同样的方式工作


663
00:41:03,463 --> 00:41:06,233
当来源和目的是相同的


664
00:41:06,400 --> 00:41:08,235
我们管它叫in-place操作


665
00:41:08,836 --> 00:41:10,037
用它来节约内存


666
00:41:11,271 --> 00:41:14,208
你怎样做才能对这些in-place
过滤器进行编码呢


667
00:41:15,175 --> 00:41:17,878
你必须要使用编码命令缓冲区方法


668
00:41:17,945 --> 00:41:20,614
和一个分配器
fall by back copy


669
00:41:22,382 --> 00:41:25,285
有一件事要记住的是
着色器并不总是可能


670
00:41:25,352 --> 00:41:27,020
运行in place


671
00:41:27,087 --> 00:41:28,922
它取决于你的过滤器


672
00:41:28,989 --> 00:41:30,791
过滤器参数和性能


673
00:41:31,425 --> 00:41:32,893
如果你希望这个操作永远成功


674
00:41:32,960 --> 00:41:35,495
使用一个复制分配器


675
00:41:36,063 --> 00:41:37,664
它就会被自动调用


676
00:41:38,432 --> 00:41:41,635
除非在in place
操作不可能的情况下


677
00:41:42,035 --> 00:41:44,872
我们将为你创建一个新的目的纹理


678
00:41:46,206 --> 00:41:47,674
这样在必要情况下操作


679
00:41:47,741 --> 00:41:49,276
可在out of place 进行


680
00:41:50,811 --> 00:41:54,214
有简单fall back copy
分配器的例子


681
00:41:55,816 --> 00:41:58,952
这个例子只是创建了一个
新的具有相同的像素格式和大小


682
00:41:59,720 --> 00:42:02,823
的目的纹理


683
00:42:02,890 --> 00:42:04,625
因为源纹理非常简单


684
00:42:05,792 --> 00:42:07,961
之前我向你们
展示了一个in place 操作


685
00:42:08,028 --> 00:42:10,731
在这个操作中 你只对目的纹理的


686
00:42:10,797 --> 00:42:12,099
一部分进行了更改


687
00:42:12,766 --> 00:42:15,869
在剪裁矩形之外的任何东西都没有改变


688
00:42:16,236 --> 00:42:18,372
在复制分配器中你还可以这样做


689
00:42:19,339 --> 00:42:21,675
只需要用你的源纹理的环境


690
00:42:21,742 --> 00:42:23,544
来初始化你的目的纹理


691
00:42:26,346 --> 00:42:28,615
我还想提到的是所有常见


692
00:42:28,682 --> 00:42:31,118
的Metal资源如你的设备和


693
00:42:31,185 --> 00:42:32,252
你的指令缓冲器


694
00:42:32,319 --> 00:42:34,288
你都可在复制分配器中获得


695
00:42:35,322 --> 00:42:37,090
现在我对细节进行了说明


696
00:42:37,157 --> 00:42:38,292
让我们来总结一下


697
00:42:39,660 --> 00:42:43,363
我想说的是请使用Metal支持架构


698
00:42:43,430 --> 00:42:45,499
MetalKit和Metal性能着色器


699
00:42:45,766 --> 00:42:47,601
它们非常强健
它们经过优化


700
00:42:47,868 --> 00:42:49,002
正如我向你们展示的


701
00:42:49,069 --> 00:42:51,605
它们很容易融入
你们的Metal的应用程序中


702
00:42:52,005 --> 00:42:54,641
它们会给你的应用程序带来更多的时间


703
00:42:54,908 --> 00:42:57,644
你可以把时间用在
制作独特的应用程序上


704
00:42:57,911 --> 00:43:00,047
而不是浪费在一般的工作上


705
00:43:00,547 --> 00:43:02,482
另外的好处是


706
00:43:02,716 --> 00:43:04,952
你可以花更少的代码来编写和维护


707
00:43:05,886 --> 00:43:10,424
到我们的实验室来向我们提出反馈意见
让我们知道如何开始或者向我们提问


708
00:43:10,791 --> 00:43:15,963
让我们知道是否想让新的工具或着色器
添加到支持架构中


709
00:43:17,564 --> 00:43:19,700
你随时可以在网上发现更多的信息


710
00:43:19,766 --> 00:43:21,602
我们可以提供文档视频


711
00:43:21,969 --> 00:43:25,205
充分利用苹果开发论坛和技术支持


712
00:43:25,706 --> 00:43:26,840
对于一般的疑问


713
00:43:26,907 --> 00:43:29,843
请联系我们的游戏技术大师
阿伦·谢弗


714
00:43:31,879 --> 00:43:35,015
你可以在网上观看以前的讲座


715
00:43:35,249 --> 00:43:38,785
但如果你想
学习新Metal性能优化技术


716
00:43:39,319 --> 00:43:41,688
明天上午11:00来听我们的讲座


717
00:43:41,788 --> 00:43:42,623
谢谢

