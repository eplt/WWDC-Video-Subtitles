1
00:00:19,853 --> 00:00:22,890
UI Testing在Xcode


2
00:00:28,128 --> 00:00:28,962
早上好


3
00:00:29,296 --> 00:00:32,366
欢迎来到Xcode
Xcode的用户界面测试


4
00:00:33,133 --> 00:00:34,168
我的名字是威尔·特纳


5
00:00:34,635 --> 00:00:35,969
这位是布鲁克·柯兰翰


6
00:00:36,703 --> 00:00:39,640
我们俩都一起在研发
Xcode的开发工具


7
00:00:40,541 --> 00:00:44,411
我们今天非常激动因为
因为我们今天要和你们分享


8
00:00:44,478 --> 00:00:48,448
一个在Xcode开发工具
测试技术上的


9
00:00:48,515 --> 00:00:50,150
很大的突破


10
00:00:51,318 --> 00:00:52,719
就是用户界面的测试


11
00:00:53,187 --> 00:00:57,991
通过用户界面的测试 
您可以找到用户界面的一些元素,


12
00:00:58,559 --> 00:01:03,096
与 他们互动 并验证
并验证用户界面属性的状态 


13
00:01:04,263 --> 00:01:07,768
除了用户界面测试 我们
我们已经介绍了用户界面记录


14
00:01:07,901 --> 00:01:10,737
这将允许 您为 您的项目


15
00:01:10,804 --> 00:01:13,006
快速设定用户界面测试 


16
00:01:14,241 --> 00:01:17,744
最后 我们已经更新了
在Xcode的测试报告 


17
00:01:17,811 --> 00:01:21,515
显示了通过和失败的和
测试的结果 


18
00:01:21,648 --> 00:01:24,384
以适应用户界面测试的新的数据


19
00:01:26,153 --> 00:01:29,122
所以我想谈谈
核心技术


20
00:01:29,389 --> 00:01:32,025
对于用户界面测试 
首先是 XC测试test 


21
00:01:32,459 --> 00:01:34,628
其次是辅助功能 


22
00:01:35,762 --> 00:01:38,799
所以XC测试test是Xcode的
测试框架 


23
00:01:38,932 --> 00:01:42,503
在它的里面  您创建测试用例的子类


24
00:01:42,870 --> 00:01:46,940
您执行测试方法 并
并用断言来验证


25
00:01:47,040 --> 00:01:49,343
您期望的
结果是正确的 


26
00:01:50,944 --> 00:01:54,982
XCte测试st集成Xcode 
这意味着 您可以


27
00:01:55,048 --> 00:01:58,552
通过这个用户名
完成编码、 测试 


28
00:01:58,819 --> 00:02:01,221
和直接从 您的原始编码


29
00:02:01,321 --> 00:02:04,358
测试的能力 和
并直接就在那里看到结果 


30
00:02:05,425 --> 00:02:08,595
您也通过Xcode Server
得到连续整合


31
00:02:08,662 --> 00:02:09,963
和Xcodebuild 创建


32
00:02:11,131 --> 00:02:14,801
最后 XC测试test支持
Swift和Objective-C


33
00:02:14,902 --> 00:02:16,970
所以 您可以选择 您最适合的


34
00:02:17,037 --> 00:02:18,172
母语编码语言


35
00:02:20,407 --> 00:02:22,709
Xctest测试在
Xcode 5里是


36
00:02:22,776 --> 00:02:24,211
作为一个单元测试框架存在的 


37
00:02:24,378 --> 00:02:28,715
在Xcode 6里 我们扩大了 
支持的性能测试 


38
00:02:29,249 --> 00:02:31,785
这让 您能捕捉到
 您的编码中的回归 


39
00:02:31,985 --> 00:02:33,153
并确保 继续


40
00:02:33,220 --> 00:02:36,290
在每次发布时
都有最佳表现 


41
00:02:37,090 --> 00:02:38,659
现在的Xcode 7


42
00:02:38,725 --> 00:02:40,827
我们已经介绍了
您可以使用的用户界面测试的


43
00:02:40,894 --> 00:02:43,096
的正确性和性能测试 


44
00:02:44,598 --> 00:02:45,699
这就是XCtest 测试


45
00:02:45,999 --> 00:02:47,668
现在让我们再来看一看
在辅助功能 


46
00:02:48,569 --> 00:02:51,471
辅助功能是
在我们的平台上的


47
00:02:51,672 --> 00:02:54,708
这给不启用的用户在我们的设备
设备和所有其他用户接受


48
00:02:54,775 --> 00:02:56,710
我们的应用上
提供同样体验的


49
00:02:57,044 --> 00:02:58,412
一种技术 


50
00:02:59,112 --> 00:03:02,282
为了能够达到辅助功能 
 提供了丰富的关于用户界面的


51
00:03:02,349 --> 00:03:05,886
语义数据的设定
这种技术可用语音


52
00:03:05,953 --> 00:03:08,989
来引导用户
使用这个应用 


53
00:03:09,690 --> 00:03:13,327
用户界面测试使用 和
和辅助功能与用户界面工具包


54
00:03:13,393 --> 00:03:16,463
和应用程序包的整合 
所以 当 您使用这些框架中的控制


55
00:03:16,530 --> 00:03:19,499
您会马上就能
得到大量的免费的


56
00:03:19,800 --> 00:03:21,335
可访问支持 


57
00:03:22,302 --> 00:03:24,137
还提供应用程序接口
来让 您可以


58
00:03:24,204 --> 00:03:27,241
微调辅助功能的数据 


59
00:03:28,642 --> 00:03:31,011
这里的的关键是
使用用户界面测试 


60
00:03:31,178 --> 00:03:32,513
您的测试将与应用程序进行


61
00:03:32,913 --> 00:03:34,948
像普通用户一样的互动互动 


62
00:03:36,650 --> 00:03:38,485
用户界面测试
有几个要求


63
00:03:38,652 --> 00:03:39,887
您应该需要了解 


64
00:03:39,953 --> 00:03:44,157
首先是 取决于
在操作系统中的新功能 


65
00:03:44,224 --> 00:03:45,959
如果您用的是iOS 则需要iOS 9


66
00:03:46,026 --> 00:03:48,862
如果您用X操作系统 则需要操作系
统10和.11 


67
00:03:50,731 --> 00:03:52,432
用户界面测试保护
保护您的隐私 


68
00:03:52,866 --> 00:03:57,070
这样做意味着 您
需要启用iOS设备


69
00:03:57,137 --> 00:04:01,141
才可以为开发和连接
一个受信的运行主机Xcode 


70
00:04:03,510 --> 00:04:05,946
在X操作系统上 
 您需要给一个特殊的Xcode


71
00:04:06,013 --> 00:04:09,016
帮助程式许可 
第一次运行用户界面测试时


72
00:04:09,082 --> 00:04:11,285
会有提示 您这么做 


73
00:04:13,153 --> 00:04:15,956
让我们来看看什么
在 您的项目开始用户界面测试时


74
00:04:16,223 --> 00:04:17,658
需要做些什么 


75
00:04:18,524 --> 00:04:20,827
首先 有一个
新的Xcode的目标类型 


76
00:04:21,228 --> 00:04:24,598
传统来说上 单元测试是
在Xcode中特定的目标类型 


77
00:04:24,932 --> 00:04:27,167
现在用户界面测试
也是目标类型 


78
00:04:28,101 --> 00:04:30,871
我们还为 您介绍了
一大套的新的应用程序接口


79
00:04:31,104 --> 00:04:35,475
作为用户界面测试和
用户界面记录 


80
00:04:35,642 --> 00:04:37,945
这将使 您
很快就可以开始了 


81
00:04:39,980 --> 00:04:43,851
因此 Xcode测试目标
支持用户界面测试的


82
00:04:43,951 --> 00:04:45,018
特殊要求 


83
00:04:45,419 --> 00:04:47,654
这包括执行
 您正在测试的应用程序中的


84
00:04:47,721 --> 00:04:49,356
一个单独的程序 


85
00:04:50,123 --> 00:04:52,559
也处理
隐私保护中使用


86
00:04:52,626 --> 00:04:53,727
使用辅助功能的许可权 


87
00:04:55,362 --> 00:04:59,333
这些目标都有Cocoa和Cocoa
Touch新的范本


88
00:04:59,900 --> 00:05:02,069
而且这个的助手和
都会将根据 您喜欢的方式


89
00:05:02,503 --> 00:05:04,171
设定好开始 


90
00:05:05,105 --> 00:05:08,175
有一个目标要测试
用户界面测试包的设定


91
00:05:08,242 --> 00:05:10,811
以确定 您正在测试
的应用程序 


92
00:05:13,447 --> 00:05:16,483
新的应用程序接口有
三个重点类别 


93
00:05:16,950 --> 00:05:18,385
首先是应用程序 


94
00:05:19,553 --> 00:05:20,954
其次是元素 


95
00:05:21,121 --> 00:05:23,390
第三是元素查询 


96
00:05:23,891 --> 00:05:25,926
我们将稍后将对这些
应用程序接口


97
00:05:25,993 --> 00:05:28,762
进行一次深入的介绍 


98
00:05:30,364 --> 00:05:32,566
用户界面记录让您
与您的应用程序 掌上设备


99
00:05:32,633 --> 00:05:34,835
掌上设备模拟器 或OS X
Mac 


100
00:05:34,902 --> 00:05:38,338
进行互动 


101
00:05:38,639 --> 00:05:42,342
当 您这样做时  
 生成必要的编码


102
00:05:42,409 --> 00:05:43,977
重建这些相互作​​用 


103
00:05:44,545 --> 00:05:48,482
您可以新建测试
测试或扩展现有测试 


104
00:05:51,118 --> 00:05:54,454
让我们来看看
这是什么 


105
00:05:55,055 --> 00:05:56,690
布鲁克 让我们看看一个快速演示 


106
00:06:04,765 --> 00:06:05,599
谢谢 威尔 


107
00:06:06,800 --> 00:06:07,901
所以 事不宜迟 


108
00:06:08,702 --> 00:06:10,170
我今天的演示所
使用的项目


109
00:06:10,237 --> 00:06:12,239
是李斯特的应用 


110
00:06:12,306 --> 00:06:13,240
这个例子项目


111
00:06:13,307 --> 00:06:15,809
您可以从
developer.apple.com下载


112
00:06:16,243 --> 00:06:19,246
那么我们开始 现在
现在我的目标配置


113
00:06:19,313 --> 00:06:21,114
正是我想要的那样 但
但我想指出的是


114
00:06:21,181 --> 00:06:23,584
要测试的目标
是李斯特应用 


115
00:06:23,650 --> 00:06:24,952
这是一个我的测试将能够


116
00:06:25,018 --> 00:06:26,687
与之互动的应用程序 


117
00:06:31,024 --> 00:06:35,329
所以现在我得到了我的
新的测试类别 


118
00:06:35,896 --> 00:06:40,467
这里还有一个小测试方法
方法和设定功能


119
00:06:40,601 --> 00:06:43,270
这将会被使用


120
00:06:43,337 --> 00:06:47,508
会在我的测试方法被使用之前
启动应用程序 


121
00:06:47,574 --> 00:06:49,710
我在这个类别下所添加的
所有测试方法


122
00:06:49,776 --> 00:06:50,611
都会这么做 


123
00:06:51,645 --> 00:06:54,448
所以在让我们从李斯特A应用里PP
里添加一个新的测试 


124
00:06:54,648 --> 00:06:59,753
我要把鼠标
移到方法中 按一下


125
00:06:59,820 --> 00:07:01,922
按一下调试栏里的
记录按钮 


126
00:07:04,858 --> 00:07:06,860
现在 Xcode已经开始
启动我的应用程序了 


127
00:07:06,927 --> 00:07:07,761
启动好了 


128
00:07:08,128 --> 00:07:12,032
李斯特应用允许
我来管理一系列的清单 


129
00:07:12,533 --> 00:07:15,235
因此可能人们做的
最常见的事情是


130
00:07:17,638 --> 00:07:19,139
从他们的名单中
补充、删除项目 


131
00:07:19,406 --> 00:07:21,074
所以我要
点击这里 添加项目 


132
00:07:21,508 --> 00:07:23,510
看起来我们在这食品杂货清单中


133
00:07:23,577 --> 00:07:25,812
有很多东西 


134
00:07:25,879 --> 00:07:27,648
那我添加饼干 


135
00:07:27,981 --> 00:07:30,417
您可以看到 当我在打字时


136
00:07:31,285 --> 00:07:33,153
源标题正在更新 


137
00:07:33,720 --> 00:07:36,857
如果我按删除 
 也从文字栏里删除


138
00:07:36,924 --> 00:07:37,925
我删除的东西 


139
00:07:41,395 --> 00:07:43,263
下一件我要做的事


140
00:07:43,330 --> 00:07:45,866
就是点击一下饼干项目


141
00:07:46,033 --> 00:07:47,034
把 标记为完成 


142
00:07:47,601 --> 00:07:49,236
我要做的另一件事是


143
00:07:49,303 --> 00:07:51,738
从清单中删除项目 


144
00:07:51,805 --> 00:07:55,375
所以我点击编辑 
然后删除饼干 


145
00:07:55,843 --> 00:07:58,312
删除确认
 终于完成 


146
00:07:59,413 --> 00:08:01,915
好 现在我有一个
简单的测试从名单上


147
00:08:01,982 --> 00:08:03,483
从名单上添加、移除项目 


148
00:08:04,284 --> 00:08:05,118
所以我点击停止


149
00:08:05,786 --> 00:08:06,787
让我们看看什么情况 


150
00:08:15,028 --> 00:08:16,230
新增了饼干


151
00:08:17,097 --> 00:08:18,031
并且正在移除  


152
00:08:18,398 --> 00:08:19,233
我们完成了 


153
00:08:27,808 --> 00:08:30,544
谢谢 当测试与用户界面元素
进行互动的时候 


154
00:08:30,611 --> 00:08:33,580
我们得到间接的验证
这些用户界面元素的存在 


155
00:08:33,914 --> 00:08:36,149
但我们没办法
得到验证的是


156
00:08:36,250 --> 00:08:38,150
事物更改应用程序的状态 


157
00:08:38,251 --> 00:08:40,854
例如 当我们打开
那个饼干按钮 


158
00:08:41,154 --> 00:08:43,789
我们没有得到任何
验证该按钮的状态


159
00:08:43,857 --> 00:08:45,158
实际上改变了 


160
00:08:46,426 --> 00:08:49,630
后来的测试中 当你点击


161
00:08:49,696 --> 00:08:52,432
确认删除的按钮时 


162
00:08:52,866 --> 00:08:55,602
我们知道删除确认按钮
已经被点击了 


163
00:08:56,036 --> 00:08:58,872
但运行测试
无法验证


164
00:08:58,939 --> 00:09:01,341
饼干那一行
实际上被删除了 


165
00:09:02,409 --> 00:09:04,778
所以要得到这些验证的话 


166
00:09:04,845 --> 00:09:07,080
我需要添加一些断言 


167
00:09:07,915 --> 00:09:11,618
首先我要做的是添加一个断言


168
00:09:11,685 --> 00:09:15,656
说这里的饼干按钮
实际上已经改变了 的状态 


169
00:09:15,722 --> 00:09:17,624
要这样做的话 我会
我会添加一个新的常数 


170
00:09:17,691 --> 00:09:19,693
称这个为饼干按钮吧 


171
00:09:22,296 --> 00:09:24,231
我将要改变这个测试


172
00:09:24,298 --> 00:09:25,299
就要点击这个常数 


173
00:09:27,401 --> 00:09:30,537
现在 要新增我的断言
我需要一些状态 


174
00:09:30,604 --> 00:09:35,242
一些元素属性的断言 


175
00:09:35,609 --> 00:09:38,378
还有饼干按钮
是XUI元素的


176
00:09:39,046 --> 00:09:41,448
还有XUI元素
有一个价值的属性 


177
00:09:41,982 --> 00:09:43,851
我要做什么 我要
我要在这里设定中断点 


178
00:09:44,718 --> 00:09:45,853
并将测试运行到该点 


179
00:09:53,060 --> 00:09:54,862
所以我们在这里有
测试状态了


180
00:09:54,928 --> 00:09:56,630
里面有添加
饼干那一行 


181
00:09:57,431 --> 00:09:59,399
还没有
点击按钮 


182
00:10:02,503 --> 00:10:03,504
所以我要在
调试器那里 


183
00:10:03,937 --> 00:10:08,408
列印出这个饼干
按钮的数值 


184
00:10:23,156 --> 00:10:24,691
--好 


185
00:10:24,992 --> 00:10:28,562
我可以看到饼干按钮的
的价值是


186
00:10:28,929 --> 00:10:30,030
数位为零的字串 


187
00:10:31,999 --> 00:10:34,501
下一步我要
跨过那条线 


188
00:10:34,701 --> 00:10:36,069
所以现在 点击了
饼干按钮 


189
00:10:36,570 --> 00:10:39,072
我又一次将列印出 的数值 
现在我可以看到


190
00:10:40,641 --> 00:10:43,877
该按钮的值是
数字一的字串 


191
00:10:44,444 --> 00:10:46,180
好 所以现在我有了
我需要的一切资讯


192
00:10:46,446 --> 00:10:49,183
要断言当 被点击时
按钮的数值会变化 


193
00:10:53,353 --> 00:10:54,454
所以我要用XCT


194
00:10:54,988 --> 00:10:57,191
断言平衡assert
equal来添加一个断言 


195
00:11:00,294 --> 00:11:02,229
我会断言被点击后的数值


196
00:11:02,296 --> 00:11:04,765
是一个数字为一的字串 


197
00:11:05,199 --> 00:11:07,534
这个值现在是任何的类型 


198
00:11:07,601 --> 00:11:11,538
所以我需要
断言这是一个字串 


199
00:11:11,972 --> 00:11:13,640
所以我使用字串 


200
00:11:15,709 --> 00:11:17,444
并断言 被点击后是”“一”“ 


201
00:11:19,012 --> 00:11:21,782
而且我断言
 被点击前是


202
00:11:21,849 --> 00:11:23,617
数字零的数位字串 


203
00:11:25,652 --> 00:11:26,553
最后


204
00:11:27,154 --> 00:11:30,858
当
当删除按钮确认后


205
00:11:30,924 --> 00:11:34,261
我就断言
饼干那行消失 


206
00:11:34,328 --> 00:11:35,262
我启用XCT


207
00:11:35,329 --> 00:11:37,164
断言平衡assert 
equal并断言


208
00:11:37,231 --> 00:11:38,966
这个按钮就不再存在了 


209
00:11:44,037 --> 00:11:46,640
现在 如果我再运行这个测试我们
我们应该看到同样的东西


210
00:11:46,707 --> 00:11:48,475
但也通过
所有的这些断言 


211
00:11:58,986 --> 00:12:00,621
好 我现在刚刚
添加了我的第一次测试 


212
00:12:01,922 --> 00:12:02,756
交给  了 威尔 


213
00:12:09,930 --> 00:12:10,864
<br/> 
那相当厉害 


214
00:12:10,931 --> 00:12:13,367
您可以看到布鲁克
就像普通用户一样


215
00:12:13,433 --> 00:12:16,837
非常容易地使用这个应用 


216
00:12:17,437 --> 00:12:19,806
而且在很短的时间内就
创建了一个测试 


217
00:12:20,240 --> 00:12:22,609
他可以拓展那个测试
用XCT 断言assert来


218
00:12:22,676 --> 00:12:27,080
做了一些额外的验证
就可以用最少小的功夫


219
00:12:27,147 --> 00:12:29,249
给他的项目增加可靠性 


220
00:12:29,917 --> 00:12:30,918
那是相当令人兴奋的 


221
00:12:33,220 --> 00:12:36,390
所以 您可以看到我们新增的
用户界面测试目标 


222
00:12:36,723 --> 00:12:38,859
非常简单明了 就像
就像我们所有其 他目标 


223
00:12:38,926 --> 00:12:40,427
是有帮助和范本的 


224
00:12:41,395 --> 00:12:46,567
使用记录 与应用程序互动 
创建使用元素、


225
00:12:46,633 --> 00:12:49,203
综合事件的编码


226
00:12:49,303 --> 00:12:53,440
然后用XCT断言
来验证 


227
00:12:55,709 --> 00:12:58,846
让我们来看一看
这个用户界面测试 


228
00:13:00,581 --> 00:13:02,583
我之前提到过
有三个类别 


229
00:13:02,850 --> 00:13:05,452
xxx
<br/>
<br/>
<br/>
他们是XCUIApplication


230
00:13:05,652 --> 00:13:07,421
XCUIElement 和


231
00:13:07,487 --> 00:13:09,857
XCUIElementquery


232
00:13:10,224 --> 00:13:11,258
他们是如何工作的？


233
00:13:11,592 --> 00:13:14,595
让我们从一个非常
简单 


234
00:13:14,962 --> 00:13:16,697
比布鲁克的例子更简单的例子 


235
00:13:17,264 --> 00:13:19,099
一行一行地演示给你们看


236
00:13:19,900 --> 00:13:21,001
首先我先启动


237
00:13:21,068 --> 00:13:22,069
应用对象 


238
00:13:22,469 --> 00:13:24,872
这是一个
我的应用代理 


239
00:13:25,572 --> 00:13:26,507
然后我启动  


240
00:13:26,874 --> 00:13:27,941
启动好了 


241
00:13:29,376 --> 00:13:32,646
然后我用元素和
查询去找添加按钮 


242
00:13:33,747 --> 00:13:35,549
然后我点击综合事件 


243
00:13:36,984 --> 00:13:40,153
最后 我加上了一个
像布鲁克那样的断言


244
00:13:40,587 --> 00:13:43,056
来确保用户界面
在测试结束时


245
00:13:43,123 --> 00:13:44,024
有了预期的状态 


246
00:13:46,159 --> 00:13:48,362
所以我提到
UIApplication应用程序


247
00:13:48,428 --> 00:13:50,464
是一个为测试应用程序
的代理 


248
00:13:51,198 --> 00:13:54,067
的启动和关闭的


249
00:13:54,134 --> 00:13:55,869
周期是独立的 


250
00:13:56,270 --> 00:13:58,305
因为 您的测试是
在一个单独的过程中运行 


251
00:13:58,772 --> 00:14:01,575
您可以明确地控制
应用程序什么时候启动


252
00:14:01,942 --> 00:14:03,010
及和什么时候被终止 


253
00:14:06,480 --> 00:14:09,983
当 您启动时 总是
产生一个新的程序 


254
00:14:10,250 --> 00:14:12,953
所以这就是为什么我们


255
00:14:13,020 --> 00:14:17,024
不给 您完全的程序 
因为 您有很多


256
00:14:17,090 --> 00:14:19,593
需要 您操控的应用在运行 


257
00:14:20,027 --> 00:14:23,030
但通过每次
干净无干扰的地启动 


258
00:14:23,330 --> 00:14:25,933
我们帮 您将 您的测试中


259
00:14:25,999 --> 00:14:27,100
必须要处理的变数最小化 


260
00:14:27,901 --> 00:14:29,570
所以 如果 已经运行 


261
00:14:29,703 --> 00:14:32,739
再次启动将终止
先前正在运行的实体 


262
00:14:34,775 --> 00:14:38,478
应用也是寻找元素的开始 


263
00:14:38,979 --> 00:14:40,280
让我们谈一谈元素 


264
00:14:40,914 --> 00:14:42,449
XCUIElement元素


265
00:14:42,516 --> 00:14:44,918
就像应用程序
 是一个代理对象 


266
00:14:45,219 --> 00:14:47,454
但这一次是作为测试应用中的


267
00:14:47,654 --> 00:14:48,922
用户界面元素 


268
00:14:49,590 --> 00:14:50,824
元素有几种类型 


269
00:14:51,491 --> 00:14:54,194
有的类型是按钮 或
或格子、 或视窗 等等 


270
00:14:54,795 --> 00:14:57,064
它们有我们所说的
数据的识别字


271
00:14:57,264 --> 00:15:00,367
字串 这些是通过可访问的
系统得到的


272
00:15:00,901 --> 00:15:04,371
它们是识别字


273
00:15:05,939 --> 00:15:09,343
例如 如果 您添加了一个按钮 


274
00:15:09,710 --> 00:15:12,579
您要找这个按钮


275
00:15:12,646 --> 00:15:16,149
键入识别字添加 


276
00:15:17,818 --> 00:15:20,420
在您的应用程序
层次结构中的元素 


277
00:15:20,487 --> 00:15:22,990
应用程序
就像一棵树的根 


278
00:15:23,290 --> 00:15:25,559
如果 您回想以前学习
计算机科学的日子 


279
00:15:25,626 --> 00:15:26,927
您就会想起数据的树形结构 


280
00:15:27,728 --> 00:15:32,966
李斯特应用中
我们有一棵很简单的树形结构


281
00:15:33,033 --> 00:15:34,968
在应用的顶部 我们有


282
00:15:35,035 --> 00:15:38,071
我们有像导航栏
和“添加”按钮 


283
00:15:39,740 --> 00:15:40,941
杂货标签 


284
00:15:41,074 --> 00:15:42,109
等等 


285
00:15:42,709 --> 00:15:44,545
所以每一个都是在 您的测试中


286
00:15:45,279 --> 00:15:46,780
您可以参考的一个元素 


287
00:15:48,916 --> 00:15:50,317
这些都是查询用的


288
00:15:50,751 --> 00:15:53,587
这个层次结构
以及作为类型和识别字


289
00:15:53,854 --> 00:15:54,955
都用来寻找 您的元素 


290
00:15:56,390 --> 00:15:57,991
当 您使用元素时


291
00:15:58,058 --> 00:16:00,160
在 您的测试中
它 们必须是独一无二的 


292
00:16:00,861 --> 00:16:01,728
所以是什么意思？


293
00:16:02,095 --> 00:16:04,665
每一个元素都是由一个查询支持的 


294
00:16:04,998 --> 00:16:07,868
查询必须变成一个单一的实体 


295
00:16:09,203 --> 00:16:11,672
否则 当我们整合事件时


296
00:16:11,738 --> 00:16:14,341
要点击按键 但很多个按钮


297
00:16:14,408 --> 00:16:16,543
都符合条件 所以没办法确定 


298
00:16:16,610 --> 00:16:18,679
我们就不知道
 您要我们做什么了 


299
00:16:19,079 --> 00:16:22,482
类似的地 如果 您问我们
元素的属性 


300
00:16:22,983 --> 00:16:25,886
我们不知道 您到底
指的是哪一个？


301
00:16:25,953 --> 00:16:27,154
也许一个也不是 


302
00:16:27,621 --> 00:16:29,623
所以元素查询最重要的是


303
00:16:29,690 --> 00:16:31,892
要缩小到只有一个符合的范围 


304
00:16:33,093 --> 00:16:35,529
如果 他们没有做到这一点


305
00:16:35,929 --> 00:16:37,831
当 您访问元素时就会
就会出现失败的信息 


306
00:16:38,966 --> 00:16:40,000
这有一个例外 


307
00:16:40,067 --> 00:16:42,269
这是一个在
XCUIElement元素上叫做


308
00:16:42,336 --> 00:16:44,538
存在属性的应用程序接口 


309
00:16:44,638 --> 00:16:48,175
这让 您测试
元素存在的安全性 


310
00:16:48,742 --> 00:16:50,844
您可以用这个
像布鲁克那样验证


311
00:16:50,911 --> 00:16:52,679
用户界面中被删除的元素


312
00:16:52,779 --> 00:16:56,016
您也可以用来处理


313
00:16:56,083 --> 00:16:57,451
可能在某些情况下有条件的


314
00:16:57,584 --> 00:16:59,319
用户界面的案例 


315
00:16:59,386 --> 00:17:02,456
例如 如果 您要
保存一个档案到一个位置


316
00:17:02,523 --> 00:17:05,358
另一个档案已存在
这时会出现


317
00:17:05,425 --> 00:17:06,527
确认单 


318
00:17:06,960 --> 00:17:08,762
但那不会每次都出现 


319
00:17:08,829 --> 00:17:10,396
只在是案件冲突的时候出现 


320
00:17:10,464 --> 00:17:13,834
您可以用一个存在属性去
检查这些情况 


321
00:17:14,968 --> 00:17:18,271
元素就是事件整合
应用程序接口时出现的​​ 


322
00:17:18,872 --> 00:17:22,675
事件整合就是我们如何
模拟用户和应用程序的互动 


323
00:17:22,742 --> 00:17:26,113
并做到系统的最底层 
所以当用户体验的时候


324
00:17:26,180 --> 00:17:29,716
所有东西都
经过了同样的通道 


325
00:17:29,783 --> 00:17:32,486
整合事件的应用程序接口
是有具体的平台的


326
00:17:33,020 --> 00:17:33,987
但也有些例外 


327
00:17:34,588 --> 00:17:37,057
我们有按钮点击 
如在X操作系统中


328
00:17:37,124 --> 00:17:41,728
相应的 在iOS中
在iOS中就是按键敲击 


329
00:17:41,795 --> 00:17:44,731
我们有类型文字 
这在两个平台都是一样的


330
00:17:44,798 --> 00:17:46,300
并且是字串文字 


331
00:17:48,869 --> 00:17:53,173
XCUI元素查询Elementquery
是用于指定元素的 


332
00:17:54,141 --> 00:17:58,745
查询最终变成一系列的
可访问的元素 


333
00:17:58,812 --> 00:18:01,849
他们只能找到具有
辅助功能的元素 


334
00:18:02,749 --> 00:18:05,152
他们将在这一组中
找到答案 


335
00:18:07,588 --> 00:18:10,858
这意味着 您可以通过计数属性获得一
些符合条件的答案 


336
00:18:12,259 --> 00:18:14,962
您也可以通过下标和识别字


337
00:18:15,395 --> 00:18:18,165
来指定不同的元素


338
00:18:19,132 --> 00:18:21,001
或者使用索引里的
应用程序接口的元素


339
00:18:21,068 --> 00:18:23,270
我们稍后会讨论这个 


340
00:18:25,172 --> 00:18:26,507
那么查询是如何工作呢？


341
00:18:27,741 --> 00:18:29,576
我提到元素的层次结构 


342
00:18:30,410 --> 00:18:33,947
这个层次结构的一方面是


343
00:18:34,014 --> 00:18:34,915
如何查询 


344
00:18:35,115 --> 00:18:36,817
另一方面是过滤 


345
00:18:37,851 --> 00:18:40,387
过滤是集中一个组合并


346
00:18:40,454 --> 00:18:42,990
并根据特定的范围条件
减少那个组合里面的内容 


347
00:18:44,424 --> 00:18:48,128
我们再次用李斯特的例子
下面是我们如何表达


348
00:18:48,195 --> 00:18:51,198
某些关系 
首先是后代关系 


349
00:18:51,265 --> 00:18:54,067
我将展示给你们看 


350
00:18:54,768 --> 00:18:57,070
所有金色的格子
都是它的​​后代孩子 


351
00:18:58,238 --> 00:19:01,308
另一方面孩子孩子是
更具限制性的关系 


352
00:19:01,375 --> 00:19:05,546
这些元素都是直接在
 您查询这些元素下面的 


353
00:19:05,612 --> 00:19:08,015
所以 表格中的孩子们
只是这些格子 


354
00:19:08,982 --> 00:19:11,752
最后我们使用的关系
是包含关系 


355
00:19:12,186 --> 00:19:14,621
这个关系很有用特别是当


356
00:19:14,688 --> 00:19:17,324
特别是对有些元素 如一些格子 
 他们没有很多


357
00:19:17,391 --> 00:19:19,560
独特的数据 


358
00:19:19,960 --> 00:19:22,129
但它们包含了
独特的元素 


359
00:19:22,429 --> 00:19:25,232
例如 第一单元
包含食品标签 


360
00:19:26,700 --> 00:19:31,104
过滤让我们采取
像象这种类型的元素 


361
00:19:32,272 --> 00:19:35,609
或识别字在之前的


362
00:19:35,843 --> 00:19:37,811
在之前的过滤的基础上创建查询 


363
00:19:38,412 --> 00:19:41,982
这样做的话我们可以


364
00:19:42,282 --> 00:19:45,319
越过识别字
直接看数值


365
00:19:45,652 --> 00:19:47,688
或做部分匹配
如“以您开头”


366
00:19:47,754 --> 00:19:48,789
诸如此类 


367
00:19:50,591 --> 00:19:53,894
我们在应用程序接口中
结合关系和过滤


368
00:19:53,961 --> 00:19:56,663
第一个是descendants
matchingtype


369
00:19:56,730 --> 00:19:57,631
后代匹配类型


370
00:19:57,698 --> 00:19:59,166
您能想出
那是什么 


371
00:19:59,633 --> 00:20:02,135
在它的后代中寻找
匹配的某一类型 


372
00:20:02,569 --> 00:20:05,272
这是您将使用的最常见的查询 


373
00:20:05,672 --> 00:20:09,042
比如我能找到在应用程序中


374
00:20:09,109 --> 00:20:11,578
所有的按钮通过


375
00:20:12,246 --> 00:20:14,147
通过descendentsmatchingtype
后代匹配查询按钮 


376
00:20:15,015 --> 00:20:17,751
类似的地 我可以找到
表中的所有格子


377
00:20:18,218 --> 00:20:19,786
我只要告诉表格


378
00:20:19,853 --> 00:20:21,021
要找descendents
matchingtype


379
00:20:21,088 --> 00:20:22,055
后代匹配查询的格子 


380
00:20:22,122 --> 00:20:24,124
或者
另一个与功能表项目有关的例子 


381
00:20:25,425 --> 00:20:28,996
这是非常常见的查询
我们为每一种类型


382
00:20:29,062 --> 00:20:30,864
都提供便利的应用程序接口 


383
00:20:31,732 --> 00:20:34,067
descendents
matchingtype


384
00:20:34,134 --> 00:20:36,370
后代匹配查询按钮 就变成了按钮 


385
00:20:37,471 --> 00:20:39,273
descendents
matchingtype


386
00:20:39,339 --> 00:20:40,874
后代匹配查询格子
成为格子 等等


387
00:20:41,208 --> 00:20:43,143
等等诸如此类的 


388
00:20:44,011 --> 00:20:48,215
这些便利的应用程序接口
能让您的测试变得非常有效


389
00:20:48,382 --> 00:20:49,349
且准确 


390
00:20:56,256 --> 00:20:58,258
Children
matchingtype


391
00:20:58,325 --> 00:21:00,994
类型是
过滤关系中的中的另一组合 


392
00:21:01,061 --> 00:21:03,764
所以我们要区分


393
00:21:03,830 --> 00:21:06,466
子孙关系间的不同 
符合条件的子孙


394
00:21:06,633 --> 00:21:08,802
而且只有特定的子孙关系
是孩子关系 


395
00:21:10,404 --> 00:21:13,707
所有的按钮都是Aapp按钮


396
00:21:13,807 --> 00:21:16,410
如果我想找到孩子关系的按钮


397
00:21:16,476 --> 00:21:18,011
我可以打开导航栏并说


398
00:21:18,078 --> 00:21:21,248
并说说childrenmatchingtype
孩子匹配类型按钮


399
00:21:21,548 --> 00:21:24,017
这虽然不如查询那样常用 


400
00:21:24,084 --> 00:21:26,486
但有时候用于区分的时候
会很有用 


401
00:21:28,288 --> 00:21:29,756
最后 包含类型 


402
00:21:30,357 --> 00:21:34,428
这使我们能够找到
描述 他们的后代的元素 


403
00:21:35,295 --> 00:21:37,497
所以在我们有些格子里


404
00:21:37,564 --> 00:21:40,634
格子是匿名的 


405
00:21:40,701 --> 00:21:43,070
他们没有任何
识别特征 


406
00:21:43,704 --> 00:21:45,772
但它们确实包含着
独特标签 


407
00:21:46,440 --> 00:21:48,308
标签也被称为
作为静态文字 


408
00:21:49,409 --> 00:21:53,213
所以在这里我可以建立一个
格子查询


409
00:21:53,280 --> 00:21:56,216
去查找那些
包含类型静态文字


410
00:21:56,350 --> 00:21:58,151
且识别字是杂货的格子 


411
00:21:58,652 --> 00:21:59,987
这将帮我找到
第一个格子 


412
00:22:00,721 --> 00:22:03,223
还有与该应用程序接口
不同的属性 


413
00:22:05,492 --> 00:22:07,194
那些是我们的三个
结合了关系和过滤的


414
00:22:07,261 --> 00:22:09,296
应用程序接口 


415
00:22:09,596 --> 00:22:12,032
后代匹配类型
 孩子匹配类型 


416
00:22:12,566 --> 00:22:15,002
包含类型
还有所有的


417
00:22:15,068 --> 00:22:16,904
后代匹配类型
的应用程序接口 


418
00:22:19,139 --> 00:22:20,607
另一关于查询强大的
的事情是


419
00:22:20,674 --> 00:22:22,376
他们可以
绑在一起 


420
00:22:22,743 --> 00:22:26,847
所以我们可以采取
一个查询的输出使它变成


421
00:22:26,914 --> 00:22:29,483
使它变成下一个的输入 就像 您一样
在Unix命令列里


422
00:22:29,550 --> 00:22:30,651
把命令都连接在一起 


423
00:22:31,385 --> 00:22:33,253
这是非常强大的 
并且让 您建立


424
00:22:33,320 --> 00:22:35,656
复杂的查询 而且


425
00:22:35,722 --> 00:22:37,157
而且这是很准确又而明了的 


426
00:22:38,258 --> 00:22:41,428
所以在这里有我们的
应用


427
00:22:41,495 --> 00:22:43,497
我只是想找到
表中的标签 


428
00:22:43,997 --> 00:22:44,932
我从应用程序开始 


429
00:22:45,866 --> 00:22:47,000
然后我到了表格 


430
00:22:47,634 --> 00:22:50,003
然后我寻找静态文字
 然后就完成了 


431
00:22:50,170 --> 00:22:51,305
我有这三个标签 


432
00:22:54,341 --> 00:22:56,577
有时查询会自己结束 


433
00:22:56,643 --> 00:22:59,346
您想得到查询的计数
 可能断言的项目数量


434
00:22:59,413 --> 00:23:01,248le
项目数量是正确的 


435
00:22:59,413 --> 00:23:01,248
项目数量是正确的 


436
00:23:01,582 --> 00:23:04,451
但往往一个查询目标
是要找到一个元素 


437
00:23:04,518 --> 00:23:06,887
我们所有的元素
都由有查询支持着 


438
00:23:07,487 --> 00:23:10,557
从查询中得到一个元素
我们提供了的几个


439
00:23:10,624 --> 00:23:11,491
不同的选择 


440
00:23:11,758 --> 00:23:14,761
第一个是下标 
这使我们能够进行查询


441
00:23:15,095 --> 00:23:17,331
然后使用识别字来下标 


442
00:23:17,598 --> 00:23:20,501
那应该会出现杂货标签 
的一个元素 


443
00:23:21,735 --> 00:23:23,837
也可以用元素和指数这样做 


444
00:23:24,071 --> 00:23:26,507
如果我有一套格子 也许
也许一些表中的行


445
00:23:26,573 --> 00:23:27,774
我想 


446
00:23:27,841 --> 00:23:30,577
我可以再在一个一个地
启用元素和指数 


447
00:23:31,945 --> 00:23:35,215
如果我有一个查询
我知道的唯一解决方法 


448
00:23:35,482 --> 00:23:38,485
帽子是一个单一的东西 也许
也许我只有一个导航栏


449
00:23:38,552 --> 00:23:41,355
在我的应用程序中 我可以
我可以使用元素属性


450
00:23:41,622 --> 00:23:44,091
来创建一个受查询的
支持新的元素 


451
00:23:46,660 --> 00:23:48,929
我们什么时候评估查询？


452
00:23:49,496 --> 00:23:51,465
所以 他们实际上不是
真正的当您创造他们


453
00:23:51,532 --> 00:23:52,766
在您创造它们的时候的评估 


454
00:23:52,833 --> 00:23:55,135
它们是按需评估
或者按他们的需要 


455
00:23:55,702 --> 00:23:59,773
这意味着只有当 您整合事件
或读取属性值的时候


456
00:24:00,073 --> 00:24:04,144
才会对一个元素
查询进行评估 


457
00:24:04,211 --> 00:24:06,580
您可以创建元素
但在 您使用 之前 


458
00:24:06,647 --> 00:24:07,814
该查询都不会被评估 


459
00:24:08,549 --> 00:24:12,052
类似的地 如果 您直接
创建一个查询


460
00:24:12,119 --> 00:24:14,922
当 您得到一些
匹配或如果您调用一个


461
00:24:14,988 --> 00:24:16,924
应用程序接口
而得出所有的匹配 


462
00:24:16,990 --> 00:24:19,226
则 必须是
在这一点上评估


463
00:24:20,260 --> 00:24:23,897
用户界面更改时
我们将重新评估查询 


464
00:24:24,231 --> 00:24:26,967
所以 您总是使用着用
应用中最新的数据


465
00:24:27,034 --> 00:24:30,237
而不是十秒前的数据


466
00:24:30,304 --> 00:24:32,472
或2分钟前的数据 
视 您的测试长度而定


467
00:24:33,941 --> 00:24:36,410
您可以思考一下查询


468
00:24:36,476 --> 00:24:38,946
查询和元素类似于网址 


469
00:24:39,646 --> 00:24:42,583
他们是有一个网址 
 您可以创建一个网址


470
00:24:42,649 --> 00:24:44,818
但您不能立即获取资源 


471
00:24:44,885 --> 00:24:48,322
直到 您真正
去创建您的网址请求


472
00:24:48,388 --> 00:24:52,392
或实际网址得到解决 


473
00:24:52,860 --> 00:24:55,229
即使这样的网址是无效的 


474
00:24:55,395 --> 00:24:57,831
只要没到那个点上 
都不会有错误提示


475
00:24:58,732 --> 00:25:03,403
类似的 查询和元素 
 它们只是


476
00:25:03,570 --> 00:25:06,139
在测试中的应用
可访问的元素的规格 


477
00:25:06,874 --> 00:25:09,209
所以创建他们


478
00:25:09,276 --> 00:25:11,745
不到您要使用它们的时候不会有任何变
化


479
00:25:11,879 --> 00:25:13,447
等 您要使用时它们才会做出反应 


480
00:25:15,883 --> 00:25:17,050
所以这就是应用程序接口 


481
00:25:17,751 --> 00:25:20,320
这三个类别：
应用


482
00:25:20,387 --> 00:25:23,290
是启动 您的应用


483
00:25:23,724 --> 00:25:26,660
元素像应用程序但是
元素的在您的应用程序中的


484
00:25:26,727 --> 00:25:29,363
中的一个代理；
最后是查询 


485
00:25:29,696 --> 00:25:32,599
是用更复杂的方法
指定元素 


486
00:25:34,368 --> 00:25:35,969
所以现在我想
我想讲一下


487
00:25:36,036 --> 00:25:37,938
关于辅助功能
和用户界面测试 


488
00:25:38,405 --> 00:25:39,339
我之前提到过


489
00:25:39,640 --> 00:25:43,076
辅助功能数据
使用户界面测试成为可能 


490
00:25:44,611 --> 00:25:48,849
所以这是不难看出
辅助功能数据


491
00:25:49,116 --> 00:25:53,353
的质量如何将影响 您的测试 


492
00:25:53,720 --> 00:25:55,489
事实上 辅助功能数据
质量越好


493
00:25:55,556 --> 00:25:58,258
您就越更容易写应用程序的测试


494
00:25:58,325 --> 00:26:01,495
随着时间的推移 
这些测试也就越更可靠 


495
00:26:02,129 --> 00:26:05,232
所以当 您提高
辅助功能


496
00:26:05,299 --> 00:26:07,167
您在您的应用程序中


497
00:26:07,234 --> 00:26:08,168
就得到了双倍的好处 


498
00:26:08,836 --> 00:26:11,071
您不仅
更容易为 您自己测试


499
00:26:11,305 --> 00:26:13,307
而且也为我们的不启用的用户


500
00:26:13,373 --> 00:26:14,508
体验带来了提升高 


501
00:26:14,908 --> 00:26:17,711
我建议您在用户界面测试和
辅助功能工作的时候


502
00:26:17,778 --> 00:26:19,346
要记住这一点 


503
00:26:21,448 --> 00:26:23,317
有时需要做一些调试 


504
00:26:23,884 --> 00:26:27,454
有时一个元素可能不
可访问 即使 您使用记录功能


505
00:26:27,521 --> 00:26:29,590
也不能显示 


506
00:26:30,457 --> 00:26:32,893
那可能是因为
自定义视图子类


507
00:26:32,960 --> 00:26:34,828
可能默认无法访问 


508
00:26:35,529 --> 00:26:38,065
或者它实际上不是一个视图 


509
00:26:38,265 --> 00:26:41,468
而是一个在低层图形
子系统的图形对象


510
00:26:41,535 --> 00:26:43,570
如涂层之类的 


511
00:26:44,671 --> 00:26:46,573
在其 他情况下 
元素是可见的


512
00:26:46,640 --> 00:26:49,042
但具有较差的辅助功能数据 


513
00:26:49,343 --> 00:26:50,978
我在看的
所有这些包含查询的格子


514
00:26:51,078 --> 00:26:54,681
如果这些格子本身
有更好的辅助功能数据


515
00:26:54,748 --> 00:26:57,351
部分可能已经消失了 


516
00:26:58,485 --> 00:27:01,121
当这情况出现时 
我想向您指出几点 


517
00:27:01,388 --> 00:27:03,991
第一个是
用户界面记录


518
00:27:04,291 --> 00:27:06,793
因为用户界面记录将
向给 您最直观地的展示


519
00:27:07,094 --> 00:27:09,997
测试系统是如何看待元素的 


520
00:27:10,430 --> 00:27:14,134
但除了那之外 在我们的平台上
还有辅助功能检查员 


521
00:27:14,434 --> 00:27:17,171
他们会让 您看到的
在应用程序中的


522
00:27:17,471 --> 00:27:19,439
原始辅助功能数据 


523
00:27:21,642 --> 00:27:23,577
当 您需要改进数据 


524
00:27:24,077 --> 00:27:26,013
您第一步应该要看界面生成器 


525
00:27:26,613 --> 00:27:31,084
界面生成器有很好的
辅助功能检查员


526
00:27:31,518 --> 00:27:34,121
让 您可以启用
或禁用辅助功能 


527
00:27:34,354 --> 00:27:37,124
为可访问属性设定值 


528
00:27:37,524 --> 00:27:40,227
并配置特征  这些特征
这些特征对元素是如何表达的


529
00:27:40,294 --> 00:27:43,363
作为用户界面测试的一种类型
将产生有直接的影响 


530
00:27:45,132 --> 00:27:47,434
如果 您是用不能访问
界面生成器的元素


531
00:27:47,501 --> 00:27:50,304
您还可以使用应用程序接口 


532
00:27:50,904 --> 00:27:52,139
您可以在NS可达


533
00:27:52,206 --> 00:27:54,508
NSAccessibility里
用应用程序接口


534
00:27:54,575 --> 00:27:57,344
UIAccessibility
可达直接控制元素的


535
00:27:57,411 --> 00:27:59,246ddle
辅助功能 


536
00:28:01,748 --> 00:28:04,384
所以请记住上面的那点
让我们再看一个演示 


537
00:28:04,852 --> 00:28:05,919
这一次布鲁克要带我们


538
00:28:05,986 --> 00:28:09,389
通过更复杂的测试再加上一点


539
00:28:09,456 --> 00:28:10,657
再加上一点辅助功能调试 


540
00:28:11,058 --> 00:28:12,526
-布鲁克？
 -谢谢 威尔 


541
00:28:19,900 --> 00:28:22,469
所以在上一个演示中我们看到
添加一个测试


542
00:28:22,736 --> 00:28:26,306
可以添加和删除
清单中的项目 


543
00:28:28,008 --> 00:28:30,444
我在这里 我会在这个区域的
用户界面


544
00:28:30,511 --> 00:28:32,012
添加更多一些测试 


545
00:28:32,412 --> 00:28:33,580
首先 我要添加一个测试


546
00:28:34,081 --> 00:28:37,851
让您可以在相同的清单
清单新增多个项目 


547
00:28:38,318 --> 00:28:41,889
这多个项目是有相同的名称清单 


548
00:28:42,589 --> 00:28:45,592
所以我要在这里复制上次测试的


549
00:28:45,659 --> 00:28:46,527
这个编码 


550
00:28:48,195 --> 00:28:51,932
我叫这个为新的测试
测试 添加到饼干 


551
00:28:53,033 --> 00:28:54,101
我现在把编码粘贴好了 


552
00:28:55,302 --> 00:28:56,136
好


553
00:28:56,570 --> 00:28:59,039
现在我有一个测试


554
00:28:59,506 --> 00:29:01,742
要贴在杂货标签上 


555
00:29:02,442 --> 00:29:05,345
接下来将要添加的
新的饼干到项目清单里 


556
00:29:05,746 --> 00:29:09,716
然后就要点击
在那个项目中的饼干按钮


557
00:29:09,983 --> 00:29:12,085
验证
 实际上是


558
00:29:12,152 --> 00:29:14,254
连接上的状态 


559
00:29:15,222 --> 00:29:17,057
所以要加上第二个项目
在这里项目我就也


560
00:29:17,124 --> 00:29:18,258
我也在这里复制这个编码 


561
00:29:19,927 --> 00:29:23,964
然后看看第二个新的按钮
也连接上了吗 


562
00:29:24,598 --> 00:29:26,133
现在我要复制这一段 


563
00:29:26,667 --> 00:29:28,669
所以让我们运行这个测试
看看这是如何工作的 


564
00:29:34,608 --> 00:29:35,843
现在让我添加第一个 


565
00:29:36,944 --> 00:29:37,811
第二个 


566
00:29:38,779 --> 00:29:40,547
啊 断言失败了 


567
00:29:40,914 --> 00:29:44,551
在这一行中说 我们得到的的


568
00:29:44,751 --> 00:29:47,988
的饼干按钮的数值在
在两二次左右 


569
00:29:48,622 --> 00:29:50,257
我们的实际上断言实际上是失败的 


570
00:29:50,424 --> 00:29:52,593
看来是因为多相匹配而失败的 


571
00:29:53,026 --> 00:29:55,195
我想我知道这里发生了什么 


572
00:29:56,530 --> 00:30:00,167
饼干按钮常数是指定的 


573
00:30:00,234 --> 00:30:02,636
这个只是寻找表格上所有的按钮 


574
00:30:02,736 --> 00:30:05,739
然后找到一个所谓的饼干按钮 


575
00:30:06,206 --> 00:30:07,741
通过这一点 在测试中 


576
00:30:07,808 --> 00:30:11,144
有两2个按钮被称为饼干 


577
00:30:11,211 --> 00:30:14,948
会找它们两个但是


578
00:30:15,015 --> 00:30:17,885
但只返回一个数值


579
00:30:17,951 --> 00:30:19,253
因为有两个匹配的结果 


580
00:30:20,220 --> 00:30:23,257
我现在知道了是因为
是因为看到了测试运行 


581
00:30:23,690 --> 00:30:27,361
通常 您不会是看到 您的测试运行 


582
00:30:28,362 --> 00:30:30,864
所以我们认为我们应该
为 您提供一个


583
00:30:30,931 --> 00:30:33,967
可以看到测试运行的方法


584
00:30:34,801 --> 00:30:38,138
我们已经在Xcode的试验报告中
添加了这个资讯 


585
00:30:39,606 --> 00:30:42,376
所以如果我去报告
导航栏和点击


586
00:30:42,442 --> 00:30:43,677
并点击最近的测试报告 


587
00:30:44,077 --> 00:30:47,381
您可以看到测试
添加到了饼干测试 


588
00:30:48,348 --> 00:30:51,885
如果我展开这个条目  您
您可以看到在测试过程中发生的


589
00:30:51,952 --> 00:30:53,387
所有的活动 


590
00:30:54,221 --> 00:30:57,057
在这里我看到了这最后的一条的
饼干按钮项目 


591
00:30:57,324 --> 00:30:59,159
这是我们要找的失败 
多相匹配 


592
00:30:59,893 --> 00:31:03,564
还有一个快速查找按钮
在这里 我可以在这里看


593
00:31:04,231 --> 00:31:05,666
将显示
应用程序发生时的


594
00:31:05,732 --> 00:31:07,167
确切的状态 


595
00:31:07,234 --> 00:31:09,436
正如我们所知道的原因一样


596
00:31:09,503 --> 00:31:10,938
有两排都叫做饼干 


597
00:31:11,505 --> 00:31:13,607
其中一个被选中
另外一个没被选中 


598
00:31:19,513 --> 00:31:23,650
如果我想要看到完整的断言的话


599
00:31:24,384 --> 00:31:25,319
<br/> 
我可以去查看日志


600
00:31:26,653 --> 00:31:28,722
在这里我可以展开测试日志 


601
00:31:32,559 --> 00:31:37,264
在这里我们可以看到
完整的失败的断言


602
00:31:37,331 --> 00:31:40,167
展示辅助功能等级的
的两个按钮 


603
00:31:42,369 --> 00:31:44,304
在这里我可以看到
是的 有一个按钮


604
00:31:44,371 --> 00:31:46,173
没有被选中
另一个被选中了 


605
00:31:47,674 --> 00:31:49,176
正如我所预计的一样 


606
00:31:50,010 --> 00:31:51,578
让我们返回去
去把那个问题解决好 


607
00:31:52,613 --> 00:31:55,582
最简单的
解决这个问题的方法是


608
00:31:55,649 --> 00:31:56,550
再次使用记录 


609
00:31:57,084 --> 00:31:59,520
我会在这个断言失败前
设定一个中断点


610
00:31:59,586 --> 00:32:01,488
然后在那个点那里运行测试 


611
00:32:11,331 --> 00:32:15,102
好的 
所以现在我得到了我想要获得的


612
00:32:15,969 --> 00:32:18,172
那个为被选中的按钮的数值 


613
00:32:18,338 --> 00:32:20,841
我要做的就是
要点击记录 


614
00:32:23,043 --> 00:32:23,877
点击按钮


615
00:32:24,945 --> 00:32:25,879
停止记录 


616
00:32:26,513 --> 00:32:29,416
现在我有办法关联到那个按钮了 


617
00:32:30,217 --> 00:32:33,387
我要用常数用表来
把这个给清除一下 


618
00:32:34,288 --> 00:32:36,690
这个就叫做饼干按钮2 


619
00:32:36,790 --> 00:32:38,158
新的测试出现了 


620
00:32:45,699 --> 00:32:47,801
现在来解决测试问题
我要用那个新的参考


621
00:32:47,868 --> 00:32:49,670
改变以下的每一个三行 


622
00:32:53,874 --> 00:32:56,043
当我再次运行测试 
 就应该是成功的了 


623
00:33:06,887 --> 00:33:07,721
好！


624
00:33:13,327 --> 00:33:14,261
好的 


625
00:33:14,328 --> 00:33:16,563
现在我有一个测试
可以从清单添加和删除项目


626
00:33:16,630 --> 00:33:19,066
另一个测试可在同一个清单里
添加两2个项目的测试


627
00:33:19,132 --> 00:33:21,401
并验证它们都存在 


628
00:33:22,202 --> 00:33:23,237
现在我要建立一个测试


629
00:33:23,504 --> 00:33:26,306
这将清单中的所有项目都删除 


630
00:33:29,510 --> 00:33:30,777
我又一次使用记录 


631
00:33:34,748 --> 00:33:39,453
点击杂货标签的编辑 然后删除


632
00:33:40,120 --> 00:33:42,856
测试行中的苹果那行 


633
00:33:45,759 --> 00:33:47,261
好吧？
点击停止录制 


634
00:33:48,028 --> 00:33:53,100
这样的测试差不多就是我想要的 


635
00:33:53,634 --> 00:33:57,704
但我想做的是 
我想让我的测试与对应用的


636
00:33:57,771 --> 00:33:59,173
数据无关 


637
00:33:59,439 --> 00:34:01,708
我想把所有的项目删除
 但我不想要它们


638
00:34:01,775 --> 00:34:05,245
指向它们的标签 


639
00:34:06,480 --> 00:34:08,282
因为那会变得很啰嗦 


640
00:34:08,715 --> 00:34:11,952
所以首先我要做的是


641
00:34:13,453 --> 00:34:14,655
您看到这些标记在这里 


642
00:34:14,721 --> 00:34:20,494
这些标记提供了获得相同的
用户界面元素的多种途径 


643
00:34:20,561 --> 00:34:23,764
在这种情况下 首先删除苹果按钮 


644
00:34:23,830 --> 00:34:24,831
我可以把这个叫做


645
00:34:24,898 --> 00:34:27,801
桌面按钮
table.button删除苹果 


646
00:34:28,001 --> 00:34:31,038
我可以更具体地的


647
00:34:32,105 --> 00:34:34,041
在苹果的格子里


648
00:34:34,574 --> 00:34:36,342
说这是删除苹果按钮


649
00:34:37,177 --> 00:34:38,445
我就采用这个


650
00:34:40,947 --> 00:34:43,050
双击 把它转换为文字 


651
00:34:44,784 --> 00:34:46,085
所以现在


652
00:34:47,821 --> 00:34:48,655
我有了两2排


653
00:34:49,456 --> 00:34:50,991
像以前获得一样的元素那样 


654
00:34:51,291 --> 00:34:55,094
我想做的是通过索引获取格子 


655
00:34:55,161 --> 00:34:57,664
我会加一个常数叫let格 表格 


656
00:34:59,333 --> 00:35:00,367
并设定这个


657
00:35:00,434 --> 00:35:03,470
与桌面单元table.cells元
素索引相同 


658
00:35:03,937 --> 00:35:08,742
因为自从苹果是索引1
我就用那个 


659
00:35:09,510 --> 00:35:11,144
我只需把那个常数


660
00:35:12,679 --> 00:35:13,814
替换成这个关联


661
00:35:17,417 --> 00:35:18,418
好的 
我几乎完成了 


662
00:35:19,520 --> 00:35:22,422
下一部分我需要改变的是
的是如何把


663
00:35:22,489 --> 00:35:25,826
按钮从格子里弄出来 
因为其他行不


664
00:35:25,993 --> 00:35:27,227
不会有删除苹果的按钮 


665
00:35:27,294 --> 00:35:29,897
他们会有删除橙子
或删除面包的按钮 


666
00:35:30,264 --> 00:35:33,300
我只需要找到那个标签


667
00:35:33,834 --> 00:35:35,936
开头写着删除这个词 


668
00:35:36,637 --> 00:35:38,438
我需要使用属性


669
00:35:41,842 --> 00:35:43,043
所以在这里


670
00:35:44,411 --> 00:35:45,512
我用匹配属性


671
00:35:45,879 --> 00:35:46,847
找到了标签


672
00:35:46,914 --> 00:35:49,550
开头为删除的按钮 


673
00:35:51,385 --> 00:35:54,521
所以 我最后要改变的是 


674
00:35:54,588 --> 00:35:56,757
我想补充一个
像之前一样的断言 


675
00:35:56,823 --> 00:35:59,193
我想验证一下
一下在我们删除后


676
00:35:59,259 --> 00:36:00,627
那格子消失了没 


677
00:36:01,261 --> 00:36:03,163
我将使用XCT
AssertEqual断言匹配 


678
00:36:03,230 --> 00:36:06,600
并断言这些格子
存在属性返回是false否的


679
00:36:06,667 --> 00:36:09,069
当我们点击了
确认删除按钮 


680
00:36:11,071 --> 00:36:12,105
我要现在要运行测试 


681
00:36:21,615 --> 00:36:23,383
苹果那行已被删除


682
00:36:25,252 --> 00:36:26,320
但断言是失败的 


683
00:36:26,720 --> 00:36:28,889
我可能知道是怎么回事 


684
00:36:30,457 --> 00:36:33,493
要显示是怎么回事
现在我要将使用调试器 


685
00:36:33,594 --> 00:36:36,196
我会在这里设置一个断点
并再次运行测试 


686
00:36:36,263 --> 00:36:37,130
运行到相同的断点 


687
00:36:45,305 --> 00:36:46,139
好 


688
00:36:47,307 --> 00:36:50,644
在调试器中 我现在
我现在启用格子的调试说明 


689
00:36:58,886 --> 00:37:01,755
调试说明
有大量的信息


690
00:37:01,822 --> 00:37:03,891
是关于有关如何格子是如何运作的 


691
00:37:04,391 --> 00:37:07,127
因此 在我启动它的时候
时候可以看到 


692
00:37:07,895 --> 00:37:10,631
这个格子第一个
去应用程序里找


693
00:37:14,368 --> 00:37:16,036
然后它再到找到
表格里找 


694
00:37:17,571 --> 00:37:18,639
然后到元素里去寻找 


695
00:37:18,972 --> 00:37:21,942
然后到所有元素和
索引里去找 


696
00:37:22,609 --> 00:37:24,811
我可以看到 它实际上
找到橙子那行 


697
00:37:25,979 --> 00:37:28,015
它看起来可能是


698
00:37:29,183 --> 00:37:34,888
当我们调用这个格子的
的存在属性时 


699
00:37:35,822 --> 00:37:37,658
它实际上是自己重新启动 


700
00:37:37,858 --> 00:37:40,160
虽然我们除去了苹果那排


701
00:37:40,961 --> 00:37:45,933
在索引里又有了新的格子 


702
00:37:46,800 --> 00:37:49,036
所以总的来说是没问题的 


703
00:37:50,270 --> 00:37:52,973
这只是意味着我需要
另外的方法来


704
00:37:53,140 --> 00:37:55,442
来找出我们是否
已经删除了那行 


705
00:37:56,009 --> 00:37:57,945
所以我要添加一个断言 


706
00:37:58,011 --> 00:37:59,947
断言格子的数量


707
00:38:00,147 --> 00:38:01,281
到达这一点 


708
00:38:03,250 --> 00:38:05,919
所以 我要增加一个新的属性
属性称为“计数”


709
00:38:08,422 --> 00:38:11,592
我把这个设置为等于
表中格子的计数 


710
00:38:14,628 --> 00:38:18,465
然后 断言
这等于计数减1 


711
00:38:20,033 --> 00:38:22,569
现在 最后一件事我将
会说这个是一个


712
00:38:22,636 --> 00:38:24,471
一个删除所有项目的测试 


713
00:38:25,239 --> 00:38:27,975
把它改为添加循环


714
00:38:30,277 --> 00:38:31,211
循环 然后


715
00:38:31,278 --> 00:38:33,113
只要表格里还有一个格子


716
00:38:33,180 --> 00:38:35,749
就一遍又一遍的不停循环 


717
00:38:39,119 --> 00:38:40,153
让我们来运行一下 


718
00:38:46,894 --> 00:38:49,429
好的它移除了苹果和桔子橘子那排 


719
00:38:55,402 --> 00:38:56,236
好 


720
00:39:04,645 --> 00:39:07,681
最后一件事
就是添加一个测试


721
00:39:07,814 --> 00:39:10,751
来使用在编辑界面看到的颜色那行 


722
00:39:15,556 --> 00:39:17,791
我再一次
使用记录器 


723
00:39:21,395 --> 00:39:23,330
我将点击杂货标签和编辑 


724
00:39:24,064 --> 00:39:24,898
现在


725
00:39:25,098 --> 00:39:26,867
这里的UI颜色


726
00:39:27,367 --> 00:39:29,570
让我
可以改变列表的颜色 


727
00:39:29,870 --> 00:39:31,305
它现在看起来是绿色的 


728
00:39:31,905 --> 00:39:35,742
所以我会尝试改变它
红色或者蓝色怎么样？


729
00:39:37,778 --> 00:39:39,947
好了 所以当我点击
这些按钮 看起来


730
00:39:40,013 --> 00:39:42,749
看起来它没有记录我想要的 


731
00:39:42,816 --> 00:39:44,952
它看起来像是它
记录了一个


732
00:39:45,018 --> 00:39:47,821
所谓的静态文本颜色
您看在这里 


733
00:39:48,555 --> 00:39:51,825
所以 我认为可能是什么
出了问题就是


734
00:39:51,892 --> 00:39:54,127
就是这些UI元素
可能是对辅助功能


735
00:39:54,194 --> 00:39:55,062
不可见 


736
00:39:56,096 --> 00:39:57,130
所以 我要停止记录 


737
00:39:58,799 --> 00:40:01,635
我可以使用
辅助检查


738
00:40:01,702 --> 00:40:02,603
来告诉我是怎么回事 


739
00:40:03,170 --> 00:40:05,672
右键单击Xcode然后
去开启的开发工具 


740
00:40:05,739 --> 00:40:06,840
辅助检查 


741
00:40:08,342 --> 00:40:11,411
而辅助检查
提供了大量的信息 


742
00:40:11,478 --> 00:40:15,048
但我只想使用
快捷方式 命令S7 


743
00:40:15,782 --> 00:40:19,219
这将突出
鼠标光标下面的UI元素 


744
00:40:21,321 --> 00:40:22,923
如果我把鼠标光标


745
00:40:22,990 --> 00:40:25,726
放在面包这个词这里 
按命令F7 


746
00:40:25,993 --> 00:40:27,327
它就突出面包 


747
00:40:29,096 --> 00:40:31,431
如果我把它放在
面包删除按钮这里 


748
00:40:31,765 --> 00:40:33,066
您可以看到 
它突出了这一点 


749
00:40:35,802 --> 00:40:37,905
现在 让我们看看
如果我把鼠标光标


750
00:40:37,971 --> 00:40:40,073
放在这个黄色按钮
会发生什么 


751
00:40:42,276 --> 00:40:44,178
啊哈！它突出了
整排 


752
00:40:45,913 --> 00:40:46,847
所以这几乎证实了


753
00:40:46,914 --> 00:40:49,650
这个UI元素根本
对辅助功能是不可见的 


754
00:40:51,084 --> 00:40:52,452
幸运的是 我可以用故事板


755
00:40:52,819 --> 00:40:55,255
改变这种情况 
解决这个问题 


756
00:41:00,027 --> 00:41:01,161
我现在打开故​​事板 


757
00:41:05,532 --> 00:41:07,868
在我的故事板这里
我有同样的按钮


758
00:41:09,703 --> 00:41:12,773
如果我打开检查 
我可以看到


759
00:41:12,840 --> 00:41:17,978
这些按钮实际上有
一类的可点击的颜色视图 


760
00:41:18,045 --> 00:41:19,913
我熟悉这个类别 


761
00:41:19,980 --> 00:41:22,516
我知道它实际上
不是用户界面按钮 


762
00:41:24,451 --> 00:41:26,553
这是自定义视图如果我再往下
辅助检查的部分


763
00:41:26,920 --> 00:41:29,823
我可以看到
它是没有被启用 


764
00:41:30,257 --> 00:41:33,327
我已经过了一遍并且
并且添加了标签 


765
00:41:34,461 --> 00:41:37,731
为了解决这个问题  我需要做的
我需要做的是选择所有的按钮 


766
00:41:40,634 --> 00:41:45,339
然后我会启用辅助功能的选框 


767
00:41:45,606 --> 00:41:46,740
由于它他们像按钮 


768
00:41:46,807 --> 00:41:48,242
我纠结要不要给
它们按钮的特性 


769
00:41:51,678 --> 00:41:52,513
好吧？


770
00:41:52,846 --> 00:41:54,381
现在让我们再来运行
这个应用程序 


771
00:42:02,656 --> 00:42:05,792
而现在我要再次记录
这个测试 


772
00:42:06,093 --> 00:42:08,629
点击杂货和编辑 


773
00:42:09,496 --> 00:42:12,533
然后红色  然后橙色 


774
00:42:12,799 --> 00:42:15,536
黄、 绿、 蓝和灰 


775
00:42:17,371 --> 00:42:19,940
好  它实际上
记录所有这些 


776
00:42:21,642 --> 00:42:23,911
我会停止记录
让我们来运行它看看


777
00:42:23,977 --> 00:42:26,313
它是否可以回放 


778
00:42:33,020 --> 00:42:35,956
好  我已经修复了
访问我的应用程序 


779
00:42:36,657 --> 00:42:38,292
而且我也让
它变得更容易测试 


780
00:42:39,026 --> 00:42:40,327
如果我要
完成这一测试 


781
00:42:41,461 --> 00:42:43,830
我可能会增加
一些断言验证


782
00:42:43,897 --> 00:42:45,232
这些按钮的变化的状态 


783
00:42:45,465 --> 00:42:46,700
现在 我将舞台还给威尔 


784
00:42:53,907 --> 00:42:55,375
所以这
所以这真的挺棒 


785
00:42:55,475 --> 00:42:58,846
尤其是使它变得多么的简易


786
00:42:58,912 --> 00:43:01,281
以前配音用户
用户没能那么幸运地


787
00:43:01,348 --> 00:43:04,818
做到这些  现在只是
现在只是在界面生成器做了


788
00:43:04,885 --> 00:43:07,154
几个简单的变化
布鲁克能够使


789
00:43:07,221 --> 00:43:09,656
能够使它变得可访问
并和UI可测 


790
00:43:12,025 --> 00:43:15,128
因此 在演示中 
更先进的UI测试 


791
00:43:15,195 --> 00:43:17,731
您看到在一些情况下
它如何处理冲突


792
00:43:17,798 --> 00:43:20,834
和一些个查询  以及如何
以及如何纠正这些查询 


793
00:43:20,901 --> 00:43:25,305
以及如何调试它 
如何建立循环


794
00:43:25,739 --> 00:43:28,775
并对其进行验证  以及如何
还有如何使用存在的属性


795
00:43:28,842 --> 00:43:32,446
并且还强调如何
重新评估查询 


796
00:43:32,679 --> 00:43:35,916
他们用标准
创造了它们 


797
00:43:35,983 --> 00:43:39,253
这标准就是确定
怎样重新评估 


798
00:43:39,686 --> 00:43:41,922
我们使用索引1一的元素 


799
00:43:41,989 --> 00:43:45,058
这里要指出的是  苹果
苹果标签在第一时间通过UI改变后 


800
00:43:45,292 --> 00:43:47,427
UI改变后它就马上消失了 


801
00:43:47,594 --> 00:43:50,864
现在被指向橘子标签
橘子标签 然后最后 


802
00:43:51,565 --> 00:43:52,766
如何提高辅助功能 


803
00:43:52,999 --> 00:43:56,904
这样做的回报是非常棒的 


804
00:43:59,006 --> 00:44:01,041
布鲁克也给你们看了
一眼测试报告 


805
00:44:01,108 --> 00:44:03,810
我们在Xcode 7
做了一些努力来


806
00:44:03,911 --> 00:44:07,381
检修它他们的UI测试 


807
00:44:07,714 --> 00:44:11,018
概括总括来说就是  测试报告
测试报告就是所有的运行测试


808
00:44:11,084 --> 00:44:12,386
您看到的结果 


809
00:44:12,953 --> 00:44:16,323
它显示了通过或失败
失败 失败消息 


810
00:44:16,990 --> 00:44:18,192
性能测试的


811
00:44:18,258 --> 00:44:20,294
性能指标
都显示在报告里 


812
00:44:21,061 --> 00:44:24,231
您在XCode和Xcode 
Server里得到相同的用户界面 


813
00:44:24,364 --> 00:44:26,333
这是一个一致的
经验


814
00:44:26,400 --> 00:44:28,869
不管您是否正在寻找
整合或


815
00:44:28,936 --> 00:44:30,571
您在本地计算机刚刚做的运行 


816
00:44:31,438 --> 00:44:33,941
在Xcode Server
您也能获得每个设备的结果 


817
00:44:34,007 --> 00:44:36,810
因为您可以有设备
能可以同时


818
00:44:36,877 --> 00:44:37,778
整合多种设备 


819
00:44:38,478 --> 00:44:41,114
对UI测试的一点补充一点是 


820
00:44:41,548 --> 00:44:43,784
我们在UI测试中收集了
多余的数据 


821
00:44:43,851 --> 00:44:45,652
这包括屏幕截图 


822
00:44:46,320 --> 00:44:50,290
您看到了它是如何帮助布鲁克
调试他的查询冲突


823
00:44:50,357 --> 00:44:53,060
通过在查询失败时
拿出屏幕截图 


824
00:44:54,094 --> 00:44:59,066
此外 我们还整理了应用程序接口
调用进入这些嵌套活动


825
00:44:59,132 --> 00:45:02,135
来帮助您了解
应用程序接口调用是如何工作的 


826
00:45:02,769 --> 00:45:04,638
让我们一起来看看
这样的一个例子 


827
00:45:04,972 --> 00:45:06,273
这不在名单草案里 


828
00:45:06,340 --> 00:45:07,441
它是一个不同的应用程序 


829
00:45:07,875 --> 00:45:11,044
但我要告诉您
在嵌套的活动


830
00:45:11,111 --> 00:45:12,880
几个步骤
是如何分解的 


831
00:45:13,580 --> 00:45:15,749
这个例子我们
我们输入到测试现场


832
00:45:15,816 --> 00:45:18,886
然后所以您就可以调用高层次的
应用程序接口型式测试 


833
00:45:19,686 --> 00:45:21,221
但在内部里它已经分解了 


834
00:45:21,622 --> 00:45:24,258
在第一步我们等待
应用程序空闲下来 


835
00:45:24,625 --> 00:45:27,127
我们实际上观察
测试的应用程序的


836
00:45:27,461 --> 00:45:28,762
主运行循环 


837
00:45:29,129 --> 00:45:31,265
因为我们不希望
在它忙于处理的时候 


838
00:45:31,632 --> 00:45:32,966
发送事件给它 


839
00:45:33,033 --> 00:45:35,002
我们希望它是
尽可能快速响应的 


840
00:45:35,736 --> 00:45:41,175
一旦它的闲置 我们就从辅助功能
那捕捉到我们的数据


841
00:45:41,575 --> 00:45:42,776
然后我们启动查询 


842
00:45:42,843 --> 00:45:45,078
确保它的匹配
正好是一个 


843
00:45:46,180 --> 00:45:48,682
下一步  我们综合
我们综合真实事件


844
00:45:48,749 --> 00:45:50,817
<br/> 
在该区域插入文本 


845
00:45:51,618 --> 00:45:55,088
最后 我们在应用程序空闲之后
再等待多一点的时间 


846
00:45:55,155 --> 00:45:58,158
因为 再一次 我们要
我们要以可靠的和确定的方式


847
00:45:58.225 --> 00:46:01.461 align:middle
掌控 


848
00:45:58,225 --> 00:46:01,461
掌控 


849
00:46:03,096 --> 00:46:05,532
快相是在关键的步骤


850
00:46:05,599 --> 00:46:07,601
截屏用的 


851
00:46:07,968 --> 00:46:11,471
您可以在这里看到
我输入的文本后的状态 


852
00:46:11,738 --> 00:46:13,540
确保一切都和您预计的样子一样 


853
00:46:16,343 --> 00:46:19,913
因此 UI测试显然是
那种您可以为你您的应用程序做的


854
00:46:19,980 --> 00:46:22,049
巨大的扩展 


855
00:46:22,449 --> 00:46:24,051
所以您在想什么
时候用它呢 对吗？


856
00:46:24,451 --> 00:46:26,720
我们已经有单元测试了 


857
00:46:27,120 --> 00:46:30,157
UI测试是一种补充测试
测试 而不是替代 


858
00:46:30,557 --> 00:46:33,460
您应该对您的模拟的目标
继续使用单位测试 


859
00:46:33,527 --> 00:46:35,195
和您的控制器逻辑 


860
00:46:35,529 --> 00:46:38,398
因为单元测试将更能
精确查明在您的代码中


861
00:46:38,465 --> 00:46:39,499
出现的故障 


862
00:46:40,200 --> 00:46:43,370
UI测试可以让您
覆盖更广泛的功能范围


863
00:46:43,437 --> 00:46:45,672
但跟踪故障


864
00:46:45,739 --> 00:46:47,341
却更能会比较困难 


865
00:46:47,741 --> 00:46:51,111
这是在您的项目的单元测试之间
和UI测试之间 


866
00:46:51,178 --> 00:46:53,113
寻找合适的平衡 


867
00:46:54,781 --> 00:46:56,717
适合UI测试的人选 


868
00:46:57,217 --> 00:46:58,352
嗯 想想您的应用程序 


869
00:46:58,418 --> 00:47:00,254
您有用户客户 
您展示给他们看 


870
00:47:00,320 --> 00:47:02,489
您很少能展示一系列的
演示给他们的 


871
00:47:02,556 --> 00:47:03,724
您给他们过一遍后说“好 


872
00:47:03,790 --> 00:47:04,992
这是您要怎么做”
 “ 


873
00:47:05,492 --> 00:47:08,595
一系列的演示是
UI测试的很好的候选人 


874
00:47:08,662 --> 00:47:11,932
经过每日每夜的构建之后


875
00:47:12,266 --> 00:47:13,734
您会知道这些演示非常有用 


876
00:47:14,635 --> 00:47:17,070
第二 除此之外 
常见的工作流程 


877
00:47:17,638 --> 00:47:20,974
如果它是一个编辑应用程序 
那么这个应用程序是做什么用的


878
00:47:21,074 --> 00:47:22,376
您如何编辑文档 


879
00:47:23,777 --> 00:47:25,913
任何自定义视图 


880
00:47:26,513 --> 00:47:29,449
最后基于文档的工作流程
工作流程 打开和保存 


881
00:47:29,750 --> 00:47:31,485
这些都是可以
自动化的很好的事情 


882
00:47:31,685 --> 00:47:33,921
它他们如果进行单元测试的话
的话会很难捕捉 


883
00:47:33,987 --> 00:47:36,657
如果它他们出错了
会对用户产生巨大的影响 


884
00:47:39,092 --> 00:47:40,494
因此 UI测试 


885
00:47:41,562 --> 00:47:42,696
在新的XCode 7中 


886
00:47:43,764 --> 00:47:45,732
开启打开了您如何测试
您的应用程序的


887
00:47:45,799 --> 00:47:48,101
的各种可能性 


888
00:47:49,269 --> 00:47:51,905
在UI测试您
您查找并和与用户体验元素互动


889
00:47:52,139 --> 00:47:55,275
互动和您整合事件


890
00:47:55,342 --> 00:47:58,011
驱使它他们  就是些
就是些普通用户会做的事情 


891
00:47:58,979 --> 00:48:01,648
您可以验证的用户界面
属性和状态 


892
00:48:03,517 --> 00:48:06,620
和UI记录让您超快速地
创建这些测试 


893
00:48:06,854 --> 00:48:07,888
超级简单 


894
00:48:09,489 --> 00:48:11,592
最后 我们已经彻底改革了
了测试报告


895
00:48:12,059 --> 00:48:15,562
让您能更好地
了解您的测试是如何工作的


896
00:48:16,063 --> 00:48:17,698
并收集更多
关于它他们的数据 


897
00:48:18,665 --> 00:48:19,700
所以这就是UI测试 


898
00:48:28,408 --> 00:48:30,644
那么关于更多的信息
我们已经上传到XCtest 


899
00:48:30,711 --> 00:48:32,145
XC测试上了 


900
00:48:32,212 --> 00:48:35,215
您可以在通过Xcode和
我们的网站中得到它 


901
00:48:35,549 --> 00:48:37,784
辅助功能也
有很好的的文件 


902
00:48:37,851 --> 00:48:39,052
我建议你们去看看 


903
00:48:40,521 --> 00:48:43,223
开发者论坛是提出问题
与交流技巧和与其他


904
00:48:43,290 --> 00:48:47,060
您如何使用方法的好地方 


905
00:48:47,127 --> 00:48:50,330
我们的宣传员传道斯特凡·莱斯是
一个可以帮您开始使用的


906
00:48:50,564 --> 00:48:51,498
很好的联系人 


907
00:48:52,733 --> 00:48:55,469
这里也有一些相关教程
如果您稍后要观看的话


908
00:48:55,536 --> 00:48:58,038
可以观看昨天早上的关于
关于辅助功能的教程 


909
00:48:58,539 --> 00:49:00,474
如果想的话
也可在您的午餐时间观看


910
00:49:01,041 --> 00:49:04,478
持续整合、代码覆盖率 新技术


911
00:49:04,811 --> 00:49:08,715
在Xcode Server上您可以
在看明天下午观看 


912
00:49:09,082 --> 00:49:10,284
希望每一个人都有很大收获 

