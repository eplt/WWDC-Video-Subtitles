1
00:00:19,820 --> 00:00:25,025
Xcode中的持续集成和代码覆盖


2
00:00:33,600 --> 00:00:34,434
早上好


3
00:00:35,402 --> 00:00:38,472
欢迎参加“Xcode中的
持续集成和代码覆盖”


4
00:00:38,939 --> 00:00:41,842
我的名字是马特·莫里亚蒂
我是Xcode团队的一名工程师


5
00:00:42,242 --> 00:00:44,978
今天 能在这里给大家讲讲
我们在Xcode中推出的一些工具


6
00:00:45,045 --> 00:00:47,014
我感到激动万分这些工具可以帮助你们


7
00:00:47,080 --> 00:00:49,850
从测试中受益更多我们也希望
它们可以激励你写更多的测试


8
00:00:53,153 --> 00:00:54,922
今天 我们先来讲讲


9
00:00:54,988 --> 00:00:56,256
Xcode Server


10
00:00:56,590 --> 00:00:58,859
Xcode Server是我们
捆绑到Xcode上的一项


11
00:00:58,959 --> 00:01:00,093
持续集成产品


12
00:01:01,595 --> 00:01:03,497
然后我们再来讲讲
XcodeServer


13
00:01:03,564 --> 00:01:04,864
和Xcode 7中有什么新料


14
00:01:05,165 --> 00:01:09,036
并且重点关注下我们
今年引入的新的代码覆盖特性


15
00:01:10,804 --> 00:01:12,439
会议的下半程我们会来讲一些


16
00:01:12,673 --> 00:01:14,975
Xcode Server更多的
高级特性


17
00:01:15,242 --> 00:01:16,677
这些特性可以允许你把它集成到


18
00:01:16,743 --> 00:01:18,812
你的团队的独特的工作流程上


19
00:01:19,613 --> 00:01:20,714
当然了 在会议整个过程中


20
00:01:20,781 --> 00:01:23,116
我们都会通过演示向你们
展示这些东西是如何实现的


21
00:01:24,418 --> 00:01:25,285
让我们开始吧


22
00:01:27,754 --> 00:01:30,157
Xcode Server是我们
通过Xcode 5


23
00:01:30,224 --> 00:01:31,458
引入Xcode的一项特性


24
00:01:31,825 --> 00:01:35,596
它是关于对一个叫做
“持续集成”的进程提供支持的


25
00:01:36,830 --> 00:01:40,200
持续集成的目的 是为了
提高你们团队的协作效率


26
00:01:40,634 --> 00:01:42,169
让你们得以打造更好的软件


27
00:01:43,237 --> 00:01:44,171
那么这意味着什么？


28
00:01:44,404 --> 00:01:47,708
这意味着定期把你的全部代码取下来


29
00:01:48,008 --> 00:01:52,446
然后进行构建、测试
让构建错误、测试失败等问题


30
00:01:52,679 --> 00:01:53,680
尽快浮出水面


31
00:01:53,947 --> 00:01:55,516
这样你就可以立即修复它们


32
00:01:58,218 --> 00:02:00,721
你们实现持续集成的方式有很多


33
00:02:00,921 --> 00:02:03,690
但是我们认为Xcode 
Server更加适合像你们一样的


34
00:02:03,757 --> 00:02:04,858
app开发者原因有两个


35
00:02:06,360 --> 00:02:08,294
第一个原因设置它很容易


36
00:02:08,662 --> 00:02:10,497
因为与OS X Server
进行了集成


37
00:02:10,663 --> 00:02:13,133
如果你已经在你的Mac上安装了
OS X Server和Xcode


38
00:02:13,200 --> 00:02:15,802
那么你离让一个持续集成
服务器定期测试你的项目


39
00:02:16,003 --> 00:02:17,371
就很近了


40
00:02:19,773 --> 00:02:23,343
第二个原因Xcode
Server和Xcode有深度集成


41
00:02:23,544 --> 00:02:25,812
我们深谙如何构建Xcode项目


42
00:02:26,180 --> 00:02:28,515
深谙如何兼容设备等等此类的事情


43
00:02:28,682 --> 00:02:30,751
这样我们就可以尽量少地问你们问题


44
00:02:30,817 --> 00:02:34,154
就可以设置完毕定期检查你的代码


45
00:02:36,990 --> 00:02:39,726
在我们展开讲之前
我想先讲几个我们在谈起


46
00:02:39,793 --> 00:02:42,129
Xcode Server
时要提到的概念


47
00:02:42,829 --> 00:02:44,498
第一个概念你可能已经熟悉了


48
00:02:44,865 --> 00:02:47,000
哪怕你之前从没有
用过Xcode Server


49
00:02:47,501 --> 00:02:48,702
这个概念就是Scheme


50
00:02:49,269 --> 00:02:52,139
每次你在Xcode中运行
你的项目或者测试时


51
00:02:52,206 --> 00:02:53,707
你运行的就是一个Scheme


52
00:02:53,774 --> 00:02:55,409
一般来说会自动为你创建Scheme


53
00:02:55,475 --> 00:02:57,377
不过你也可以创建你自己的
定制Scheme


54
00:02:57,444 --> 00:02:59,913
它们基本上就构成了
构建你的项目的“食谱”


55
00:03:00,314 --> 00:03:03,550
告诉你构建的目标是什么
运行的测试包是什么


56
00:03:03,750 --> 00:03:06,153
传递给你执行的自变量
是什么 诸如此类的事情


57
00:03:07,120 --> 00:03:09,256
当需要设置Bot时
对Xcode Server来说


58
00:03:09,323 --> 00:03:11,091
Scheme就非常重要了


59
00:03:12,626 --> 00:03:17,231
Bot是我们倾向于把它
当成你的团队的一员


60
00:03:18,398 --> 00:03:20,567
它其实就是采取某种特定的方案构建好


61
00:03:20,868 --> 00:03:22,936
然后根据你定义的日程表运行


62
00:03:23,203 --> 00:03:25,205
并完全遵照你的说明执行某些操作


63
00:03:25,706 --> 00:03:27,274
然后把结果汇报给你


64
00:03:29,910 --> 00:03:32,513
每当我们按照日程表运行你的项目时


65
00:03:32,646 --> 00:03:34,181
我们就称之为集成


66
00:03:34,248 --> 00:03:37,885
它就好比是把你的团队
每个成员所做的变更集成到一起


67
00:03:38,151 --> 00:03:40,554
然后看看结果如何


68
00:03:43,790 --> 00:03:45,092
既然我们都已经达成共识了


69
00:03:45,158 --> 00:03:46,660
那么就让我们来谈谈Xcode 7


70
00:03:46,727 --> 00:03:48,529
和Xcode Server中
有什么新料


71
00:03:49,596 --> 00:03:52,933
如果在Xcode 6之前你就用过
Xcode Server的话


72
00:03:53,233 --> 00:03:55,035
你就知道每次你对
一个Bot进行编辑时


73
00:03:55,169 --> 00:03:58,438
我们会让你重新走一遍
生成Bot的整个工作流程


74
00:03:58,505 --> 00:04:00,340
不过提前填写好了很多值


75
00:04:01,041 --> 00:04:03,877
如果你只是想做一些简单的变更
比如添加一个触发器


76
00:04:03,944 --> 00:04:06,046
修改你的方案诸如此类的事情


77
00:04:06,113 --> 00:04:07,714
那么这就有点单调乏味了


78
00:04:08,081 --> 00:04:09,750
现在我们有了这个选项卡式的界面 


79
00:04:09,816 --> 00:04:12,920
你就可以进去完成你
想要的更改然后退出


80
00:04:19,026 --> 00:04:20,894
看来大家都是选项卡式工作流程的粉丝


81
00:04:22,462 --> 00:04:24,998
我们还对Xcode 7中的
源代码管理做了多项改进


82
00:04:25,599 --> 00:04:27,467
而我们之前则是会试图自动处理


83
00:04:28,235 --> 00:04:32,673
你的源代码管理并且向你隐藏了
细节不过我们现在让你看到了


84
00:04:32,739 --> 00:04:36,610
更多 这样你就可以清晰地看到
你的Bot将要校验的储存库是哪个


85
00:04:37,244 --> 00:04:39,847
并且你还可以选择不要校验某些储存库


86
00:04:40,180 --> 00:04:42,950
对于你要校验的储存库来说
现在你可以看到并且选择


87
00:04:43,016 --> 00:04:45,986
你要校验的分支是哪个而不是...


88
00:04:47,754 --> 00:04:48,589
谢谢


89
00:04:51,191 --> 00:04:53,427
而不是寄希望于Xcode
希望它自行正确搞明白


90
00:04:57,231 --> 00:04:59,666
我们还改进了源代码管理的安全性


91
00:04:59,933 --> 00:05:02,870
具体来说指的就是SSH指纹对比


92
00:05:03,170 --> 00:05:05,005
以及自签名证书


93
00:05:05,372 --> 00:05:09,710
这两项都不会自动成为安全的输送方式


94
00:05:09,776 --> 00:05:12,379
它们要求你信任你连接的服务器


95
00:05:12,713 --> 00:05:16,116
这样如果服务器之后发生了变更


96
00:05:16,450 --> 00:05:20,387
你就知道它们有了新的指纹它们
可能在冒充你以为你正在连接的服务器


97
00:05:20,787 --> 00:05:24,258
之前Xcode会自动信任这些服务器


98
00:05:24,591 --> 00:05:26,994
而不做任何验证


99
00:05:27,227 --> 00:05:29,897
现在我们要求你明确
信任这些中的哪些服务器


100
00:05:30,163 --> 00:05:33,166
然后我们会把指纹储存起来
这样如果之后它发生了变更


101
00:05:33,400 --> 00:05:35,502
我们就不会从错误的服务器上进行校验


102
00:05:38,772 --> 00:05:41,742
我们同样也更新了你在你的
集成中看到的多个报告


103
00:05:42,242 --> 00:05:44,511
所以说测试报告也整理过了更紧凑了


104
00:05:45,646 --> 00:05:48,849
现在在你的测试中
看出断言故障就更加容易了


105
00:05:52,553 --> 00:05:55,689
日志视图的性能提升也得到了大幅提升


106
00:05:55,923 --> 00:05:58,859
之前我们试图向你展示你的
全部日志的堆叠视图


107
00:05:59,259 --> 00:06:01,562
但是当你视图展开某项日志时


108
00:06:01,628 --> 00:06:04,064
这就出现了明显的性能代偿


109
00:06:04,131 --> 00:06:06,166
现在我们一次只向你展示一条日志 


110
00:06:06,233 --> 00:06:08,068
你可以通过左上角的
弹出按钮来选择日志


111
00:06:08,168 --> 00:06:11,438
现在查看大的日志文件也非常快了


112
00:06:20,280 --> 00:06:23,584
提到持续集成让Xcode 
Server脱颖而出的一件事情


113
00:06:23,650 --> 00:06:25,686
是它知道Xcode项目会产生


114
00:06:25,953 --> 00:06:28,488
什么类型的问题它还知道


115
00:06:28,555 --> 00:06:31,458
构建错误是什么样的
知道测试失败是什么样的


116
00:06:31,725 --> 00:06:35,229
它不会仅仅向你显示一些
原始的纯文本日志文件


117
00:06:35,462 --> 00:06:38,365
让你自己仔细查看然后
找出发生了什么问题


118
00:06:39,399 --> 00:06:41,969
说到此类问题我们做了很多巧妙的事情


119
00:06:42,035 --> 00:06:44,104
就是为了让这些问题
浮出水面 对你有所裨益


120
00:06:45,639 --> 00:06:46,740
当你运行集成时...


121
00:06:46,907 --> 00:06:48,509
Xcode 6中同样也是如此...


122
00:06:48,642 --> 00:06:52,913
我们会向你展示这个漂亮的报告
告诉你在你的构建中出了什么问题


123
00:06:53,914 --> 00:06:56,216
因为我们会把这次集成
和之前的集成进行对比


124
00:06:56,283 --> 00:06:59,219
我们就能让新问题浮现出来
这样我们就可以精确定位出


125
00:06:59,286 --> 00:07:02,856
是哪次集成出了问题是哪次提交
把某个特定的问题带进来了


126
00:07:03,290 --> 00:07:08,795
这样的话找到原因查出问题所在
修复问题就非常容易了


127
00:07:12,799 --> 00:07:15,335
围绕“问题” 我们在Xcode 7
中还添加了一些新东西


128
00:07:15,636 --> 00:07:17,137
假如说你现在看到发生了一个问题


129
00:07:17,371 --> 00:07:20,274
你要么可以看到是不是
你的错 这样你好修复


130
00:07:20,407 --> 00:07:22,376
它要么你可以看到问题的原因


131
00:07:22,442 --> 00:07:24,378
比如我就知道那里错了我就可以


132
00:07:24,444 --> 00:07:26,380
进去快速修复它把这个搞定


133
00:07:26,813 --> 00:07:28,849
然后你可以认领问题
这样你的名字就放上去了


134
00:07:28,916 --> 00:07:30,617
这样当你的团队中的每个人查看报告时


135
00:07:30,817 --> 00:07:32,853
他们就可以看到这个这
样他们就知道自己不用


136
00:07:32,920 --> 00:07:34,688
操心这个事了因为你已经在处理了


137
00:07:37,057 --> 00:07:38,926
如果问题是间歇性的或者是你知道


138
00:07:38,992 --> 00:07:41,929
已经修复了的问题你就可以


139
00:07:42,095 --> 00:07:43,230
把它们“消音”一段时间


140
00:07:43,430 --> 00:07:44,932
它们就会从报告中消失


141
00:07:46,400 --> 00:07:48,802
这样的话你可以集中精神关注那些


142
00:07:48,869 --> 00:07:50,437
确实需要你关注的事而不用和你知道


143
00:07:50,504 --> 00:07:52,873
已经解决了的事情搅和到一起


144
00:07:58,278 --> 00:08:01,648
不过关于Xcode Server
最棒的一点是我们能在多大程度上


145
00:08:01,715 --> 00:08:04,117
和Xcode引入的
其它各项特性进行交互


146
00:08:04,351 --> 00:08:06,520
因为我们在Xcode 7上
有一些很棒的新特性


147
00:08:06,787 --> 00:08:09,623
我们也专门拿出时间
把这些特性集成到了


148
00:08:09,690 --> 00:08:10,858
Xcode Server


149
00:08:11,358 --> 00:08:12,693
我想看看其中的几项特性


150
00:08:14,895 --> 00:08:17,564
用户界面测试是
Xcode 7上的新特性


151
00:08:19,032 --> 00:08:21,034
我们专门对此进行了处理


152
00:08:21,101 --> 00:08:23,136
确保了它能完美兼容
Xcode Server


153
00:08:23,871 --> 00:08:26,473
当你运行Mac测试或者
iOS模拟器测试时


154
00:08:26,807 --> 00:08:28,308
我们会在你的服务器后台


155
00:08:28,375 --> 00:08:29,610
创建一个全屏会话


156
00:08:29,877 --> 00:08:31,144
你的全部测试都是在那里


157
00:08:31,378 --> 00:08:33,013
运行的这就意味着你无需担心启动


158
00:08:33,212 --> 00:08:36,817
你的应用程序时 是否处于
适用于Xcode 2的正确环境中


159
00:08:37,017 --> 00:08:38,150
我们会替你搞定它


160
00:08:38,519 --> 00:08:40,220
如果你用的是真实的iOS设备


161
00:08:40,453 --> 00:08:42,422
那么你就可以看到UI测试在设备上


162
00:08:42,489 --> 00:08:44,224
逐句通过应用程序


163
00:08:50,864 --> 00:08:52,566
用户界面测试是以一个高水平的标准


164
00:08:52,699 --> 00:08:54,801
对你的应用程序进行测试的绝佳方式


165
00:08:54,868 --> 00:08:56,470
测试的方式和你的用户看到的一致


166
00:08:56,537 --> 00:08:58,772
并且会对所有的不同
层在一起的相互交互进行测试


167
00:08:59,006 --> 00:09:03,744
如果你同时还有一个服务器
在各种设备上运行这些测试那就更棒了


168
00:09:05,345 --> 00:09:06,246
对于一项方案来说


169
00:09:09,750 --> 00:09:12,519
“点播资源”是iOS 9上
的一项新特性


170
00:09:12,786 --> 00:09:16,657
通过避免在你的包中存储太多的资源


171
00:09:16,723 --> 00:09:18,158
它就可以让你的apps包更小


172
00:09:18,392 --> 00:09:20,394
如果你的app已经上
架了App Store


173
00:09:20,460 --> 00:09:22,095
App Store就会替你充当主机


174
00:09:23,063 --> 00:09:25,132
这样 当需要的时候
你的应用程序就可以下载


175
00:09:25,332 --> 00:09:28,035
这些资源而当你不用的时候
就可以从磁盘上删除


176
00:09:29,703 --> 00:09:31,905
那么当你在发布之前
需要做内部产品质量测试


177
00:09:31,972 --> 00:09:35,342
需要测试你的应用程序的构建


178
00:09:35,709 --> 00:09:38,245
并且你的app
已经上架App Store了


179
00:09:38,779 --> 00:09:40,280
对于资源来说那时候会发生什么？


180
00:09:40,347 --> 00:09:42,382
那时候 App Store就不会
再为这些资源充当主机了


181
00:09:42,449 --> 00:09:45,652
你做的变更太快
App Store没法再充当主机了


182
00:09:46,820 --> 00:09:48,555
但是如果你是从Xcode 
Server上


183
00:09:48,622 --> 00:09:49,923
获取的内部产品质量构建


184
00:09:49,990 --> 00:09:52,693
并且你是让你的集成
为你生成了你安装到


185
00:09:53,293 --> 00:09:55,863
你的设备上的IPAS
那么这就会自动为你进行处理


186
00:09:56,196 --> 00:09:59,099
你不需要勾选选项框你什么也
不用做Xcode Server


187
00:09:59,166 --> 00:10:01,702
会自行知道在你的
应用程序内有了点播资源


188
00:10:01,768 --> 00:10:03,770
它就会在自己的服务器上
为这些资源充当主机


189
00:10:03,837 --> 00:10:05,706
如何找到这些资源


190
00:10:13,180 --> 00:10:15,582
最后 我还想再讲讲
Xcode 7上的另外一项


191
00:10:15,649 --> 00:10:17,718
新的特性这项特性
和Xcode Server


192
00:10:17,784 --> 00:10:19,453
以及持续集成都配合的天衣无缝


193
00:10:19,653 --> 00:10:20,621
这就是“代码覆盖”


194
00:10:23,557 --> 00:10:28,061
“代码覆盖”就是一种对你的
 测试的值进行度量的工具具体来说


195
00:10:28,262 --> 00:10:30,330
当我们运行测试时
我们想知道实际运行的


196
00:10:30,631 --> 00:10:31,532
代码是什么


197
00:10:32,466 --> 00:10:35,969
因为你很容易就会出现你的
应用程序上有一大堆


198
00:10:36,036 --> 00:10:39,072
测试套件你很难进行变更


199
00:10:39,139 --> 00:10:41,608
你不注意的话就不会出现回归这种情况


200
00:10:42,609 --> 00:10:45,512
但是你怎么知道你到底
需要多少项测试才算足够？


201
00:10:45,879 --> 00:10:48,715
假如说我有一个应用程序
并且有二百项单元测试


202
00:10:49,116 --> 00:10:53,220
但是这些测试却仅仅覆盖了
我的应用程序的20%？


203
00:10:53,921 --> 00:10:56,690
要是这样的话
它们可不像我想的那样有用


204
00:10:57,024 --> 00:10:59,593
因此代码覆盖为的就是
把这些信息呈现给你


205
00:10:59,793 --> 00:11:01,261
这样你就可以做出明智的决策


206
00:11:01,895 --> 00:11:05,465
它可以让你运行你的测试
并且正确度量运行的代码


207
00:11:05,766 --> 00:11:08,869
是哪个更重要的是度量出完全
未经测试的代码是哪个


208
00:11:09,169 --> 00:11:11,738
这个代码就是当你继续添加新的特性时


209
00:11:11,805 --> 00:11:14,875
可能出现回归的代码而你之前
是不会从你的测试中知道的


210
00:11:17,177 --> 00:11:19,713
因此我们认为对于那些
真的在意测试的团队来说


211
00:11:19,780 --> 00:11:20,848
代码覆盖真的很重要


212
00:11:21,148 --> 00:11:23,917
这也是我们把代码覆盖集成到
Xcode的原因


213
00:11:25,519 --> 00:11:27,154
像其它很棒的Xcode特性一样


214
00:11:27,321 --> 00:11:29,923
代码覆盖在构建时就和
LLVM有着紧密集成


215
00:11:30,724 --> 00:11:33,760
因此当你在你的方案中收集
启用的代码覆盖时


216
00:11:33,894 --> 00:11:35,629
编译器就会对你的代码进行指导


217
00:11:35,896 --> 00:11:38,599
我们就可以计算每个表达的执行频率


218
00:11:39,166 --> 00:11:41,568
然后我们就会在IDE中
把这个信息呈现给你


219
00:11:43,003 --> 00:11:44,671
我们现在有两种方式可以实现这一点


220
00:11:45,405 --> 00:11:48,575
第一种是当你进到你的
测试的报告导航器中


221
00:11:48,742 --> 00:11:51,445
你之前在Xcode 6中
就可以这么做 不过现在在


222
00:11:51,512 --> 00:11:53,881
Xcode 7中有了一个贴有
“覆盖”标签的新标签


223
00:11:55,415 --> 00:11:59,119
如果你查看这个报告
你就可以根据目标 文件


224
00:11:59,186 --> 00:12:01,555
以及方式进行查看
这样就可以知道你的应用程序


225
00:12:01,622 --> 00:12:02,990
的各个不同部分的覆盖情况


226
00:12:04,391 --> 00:12:07,361
这样你就可以从一个较高的
层面来查看你的应用程序


227
00:12:07,594 --> 00:12:10,130
然后向下挖掘下 看看
值得你注意的部分是哪个


228
00:12:11,932 --> 00:12:16,336
如果我发现某种方法的覆盖率是75%


229
00:12:17,037 --> 00:12:18,038
这也算是个好消息


230
00:12:18,105 --> 00:12:20,941
但是我并没有获得
怎样才能进行修复的信息


231
00:12:21,008 --> 00:12:24,411
我不知道我的代码的哪些
分支测试到了哪些分支没有测试到


232
00:12:25,679 --> 00:12:28,582
当你悬停在这些方法或者文件上时


233
00:12:28,649 --> 00:12:31,752
我就可以点击弹出的箭头
这些就会显示出源代码编辑器


234
00:12:31,919 --> 00:12:34,421
我们就可以在那里通过
内联注释 高亮显示你的


235
00:12:34,488 --> 00:12:36,290
应用程序中未被覆盖的部分


236
00:12:36,557 --> 00:12:38,625
对于那些已被覆盖的
部分来说 我们则会告诉你


237
00:12:38,692 --> 00:12:40,160
它们在测试中被执行的次数


238
00:12:48,001 --> 00:12:51,271
代码覆盖在Xcode IDE中
本身就已经很棒了


239
00:12:51,605 --> 00:12:54,408
不过我想当你把它放到Xcode
Server上时 它会更棒


240
00:12:54,641 --> 00:12:56,810
你在那里有一个Bot在各种设备上


241
00:12:56,877 --> 00:12:58,212e
运行你的项目


242
00:13:00,214 --> 00:13:02,049
集成和Bot的一个特别之处在于


243
00:13:02,115 --> 00:13:04,418
你可以设置它们在一系列的设备上运行


244
00:13:04,484 --> 00:13:06,453
而不是一次仅能运行在一台设备上


245
00:13:06,520 --> 00:13:08,021
就像你在Xcode中所做的那样


246
00:13:08,956 --> 00:13:11,291
当你这么做的时候
我们会集中向你展示你全部


247
00:13:11,358 --> 00:13:13,527
设备的覆盖数据
并且我们以橙色高亮显示


248
00:13:13,594 --> 00:13:19,032
在你的设备上有着不同的
覆盖的方法 目标 或者文件


249
00:13:19,333 --> 00:13:21,935
这样你就可以看看这些不一样的地方


250
00:13:22,069 --> 00:13:25,172
看看它是否属于bug
还是属于某种预期行为


251
00:13:26,073 --> 00:13:29,309
你在不同的设备上有不同的代码覆盖


252
00:13:29,510 --> 00:13:32,112
这相当普遍尤其是在用户界面代码中


253
00:13:32,312 --> 00:13:33,947
你在不同的设备上可能有不同的代码


254
00:13:34,014 --> 00:13:35,983
比如一台iPad和一部
iPhone就不同


255
00:13:38,452 --> 00:13:41,555
Xcode Server还可以为你
提供的一件事情


256
00:13:41,722 --> 00:13:44,157
是一份存储追踪你的项目的
存在期的档案


257
00:13:44,658 --> 00:13:46,994
这样当你查看某个集成的代码覆盖时


258
00:13:47,060 --> 00:13:49,830
我们就可以高亮显示变更发生的时间 


259
00:13:50,030 --> 00:13:53,967
这些变更在代码覆盖中的方法以及文件


260
00:13:54,201 --> 00:13:57,070
这样你就可以精确定位到
某次具体的提交集合


261
00:13:59,840 --> 00:14:03,243
档案还使得我们可以显示
趋势 之前在Xcode 6中


262
00:14:03,310 --> 00:14:05,846
我们有构建历史图表以及你的
Bot的测试历史图表


263
00:14:06,313 --> 00:14:09,183
这样当你添加更多的测试的时候
你就可以看到图表发生变动


264
00:14:09,449 --> 00:14:11,818
你就可以看到事情进展如何


265
00:14:12,252 --> 00:14:13,520
你的Bot的稳定性如何


266
00:14:13,854 --> 00:14:15,822
不过现在我们又有了一项
新的代码覆盖图


267
00:14:16,089 --> 00:14:19,193
可以表明随着时间的变化
你的项目的整体覆盖趋势


268
00:14:20,294 --> 00:14:23,163
这样的话 你就可以知道
举例来说是否有所提升


269
00:14:23,230 --> 00:14:25,199
这样你就可以知道当你添加特性时


270
00:14:25,365 --> 00:14:27,100
你是否需要给这些特性添加测试


271
00:14:27,467 --> 00:14:30,437
或者你是否需要给
之前没有覆盖到的特性添加测试


272
00:14:31,071 --> 00:14:33,740
或者也可能出现向下的趋势
这是因为你进展太快了


273
00:14:33,807 --> 00:14:35,542
没有对你刚加的特性进行测试


274
00:14:35,776 --> 00:14:37,945
这样 就可以帮助你做出明智的决策


275
00:14:38,078 --> 00:14:40,480
决定下一步该怎么办
决定如何分配你的开发时间


276
00:14:44,318 --> 00:14:46,887
当然了 如果你在你的工作区
使用大屏幕来显示你的


277
00:14:46,954 --> 00:14:50,123
Bot的整体状况
那么在你的项目的测试数量


278
00:14:50,190 --> 00:14:53,961
下面我们还会向你显示你的整体
覆盖百分比这样你就可以密切注视它


279
00:14:56,930 --> 00:14:57,764
好的


280
00:14:57,831 --> 00:14:59,633
现在我想请我的同事埃里克上来


281
00:14:59,700 --> 00:15:02,202
请他给大家演示一些Xcode
以及Xcode Server上的


282
00:15:02,269 --> 00:15:03,103
代码覆盖特性


283
00:15:10,844 --> 00:15:11,712
谢谢 马特


284
00:15:12,880 --> 00:15:15,482
我要向你们演示一个
我们开发的供内部使用的


285
00:15:15,682 --> 00:15:17,684
应用程序我们用它来跟踪大家互相


286
00:15:17,751 --> 00:15:18,819
欠下的请喝咖啡的次数


287
00:15:19,219 --> 00:15:21,088
去年你可能已经看过这个应用程序了


288
00:15:21,154 --> 00:15:22,890
自那之后我们又做了一些改进


289
00:15:24,057 --> 00:15:26,960
它的基本规则是
如果有人替你修复了一个bug


290
00:15:27,027 --> 00:15:29,363
或者你欠了别人一个人情
那么你就需要请对方喝咖啡


291
00:15:29,563 --> 00:15:31,398
我们专门有一个应用程序对此进行跟踪


292
00:15:32,199 --> 00:15:34,201
和其它优秀的应用程序一样
我们也有单元测试


293
00:15:34,268 --> 00:15:36,036
来确保当我们添加新的特性时


294
00:15:36,103 --> 00:15:38,138
不会影响到已有的工作代码


295
00:15:39,973 --> 00:15:42,743
对这些进行测试只算成功的一半


296
00:15:42,809 --> 00:15:45,746
当对应用程序进行实际的全面测试时


297
00:15:45,946 --> 00:15:49,216
我不知道我能坦然面对的
单元测试有多少个


298
00:15:49,283 --> 00:15:51,785
我想看看覆盖情况看看情况如何


299
00:15:53,220 --> 00:15:55,088
不过也许我们没有那么多的测试


300
00:15:55,355 --> 00:15:56,190
让我们来看看


301
00:15:56,423 --> 00:15:58,859
实际上 在我来这儿之前
我已经运行过了测试


302
00:15:59,860 --> 00:16:01,495
我们可以直接在设备上看看测试结果


303
00:16:01,562 --> 00:16:02,396
我们只有七项测试


304
00:16:02,563 --> 00:16:04,164
这可很不妙


305
00:16:05,032 --> 00:16:07,768
不过这是一个小的应用程序


306
00:16:07,835 --> 00:16:09,903
也许这已经足以覆盖所有的事情了


307
00:16:10,003 --> 00:16:11,839
最起码这些测试都通过了所以开局不错


308
00:16:11,905 --> 00:16:12,873
我们来看看覆盖情况


309
00:16:15,309 --> 00:16:16,710
如果我们来看看这里的覆盖报告


310
00:16:16,777 --> 00:16:19,112
我们就可以看到这个应用程序
被分解成了两个目标


311
00:16:19,179 --> 00:16:22,382
我们有一个UI层面的应用程序即
coffeeboard.app


312
00:16:22,716 --> 00:16:24,451
测试覆盖情况不太好


313
00:16:25,419 --> 00:16:28,188
不过没关系 这是一个UI应用程序
我应该给它写一些UI测试


314
00:16:28,255 --> 00:16:30,791
我更关心这个基础水平的框架


315
00:16:31,024 --> 00:16:32,926
我们可以在这里看到
只有50%测试覆盖


316
00:16:32,993 --> 00:16:37,130
这可不太妙因为如果我们努力的话
就可以实现100%覆盖


317
00:16:38,165 --> 00:16:42,369
看起来真正落后的类是这个事务类


318
00:16:43,604 --> 00:16:45,339
如果我们看看这个事务类


319
00:16:46,039 --> 00:16:47,508
我们就可以看到这里有一堆的类


320
00:16:47,574 --> 00:16:49,476
在我们的各项单元测试中
并没有被调用到


321
00:16:50,043 --> 00:16:52,145
我们创建了一些事务
我们可以看到它们在


322
00:16:52,212 --> 00:16:53,714
初始化程序中被调用了


323
00:16:54,414 --> 00:16:56,350
但是我们并没有实际用它们来做什么事


324
00:16:56,817 --> 00:16:58,385
我再来解释下我们的app


325
00:16:58,452 --> 00:16:59,720
它有一项很棒的特性


326
00:17:00,220 --> 00:17:02,623
使用了我们的一个专属算法


327
00:17:02,723 --> 00:17:05,526
如果我欠马特两杯咖啡
而他又欠我一杯咖啡


328
00:17:05,893 --> 00:17:08,729
那么我们就会把这两个数字合并
就成了我欠马特一杯咖啡


329
00:17:09,997 --> 00:17:11,397
因为算法是秘密的我就想确保


330
00:17:11,464 --> 00:17:14,101
这个算法经过了仔细测试因为数学


331
00:17:14,167 --> 00:17:16,970
不是我的强项我就更得确保不出问题


332
00:17:17,938 --> 00:17:20,540
我们来看看它的源文件


333
00:17:20,607 --> 00:17:22,776
就像马特说过的那样
我要使用那个悬停后


334
00:17:23,010 --> 00:17:27,013
显示出来的箭头
直接进到我的源码编辑器


335
00:17:28,147 --> 00:17:32,019
这里我们可以看到一大堆
深色的高亮显示区域


336
00:17:32,319 --> 00:17:35,189
在我的源码编辑器中
使用了默认的背景色的


337
00:17:35,255 --> 00:17:37,090
代码在这里背景色是白色


338
00:17:37,391 --> 00:17:40,527
就是已经在测试中覆盖了的代码
所以我并不太需要担心它们


339
00:17:40,694 --> 00:17:44,398
我更关心的是那些
以灰色背景显示的代码


340
00:17:44,998 --> 00:17:47,768
我可以确认它们未被覆盖到
因为在右边这里


341
00:17:48,135 --> 00:17:49,403
我们可以看到一堆“零”


342
00:17:49,603 --> 00:17:53,740
表明这个代码从未通过
我的任何单元测试


343
00:17:54,675 --> 00:17:55,509
这可不好


344
00:17:56,810 --> 00:17:59,479
现在让我们在这个单元
测试中导航下 然后再来看看这个


345
00:18:00,180 --> 00:18:01,949
如果我到事务测试那里


346
00:18:03,684 --> 00:18:05,185
我就可以发现我并没有任何测试


347
00:18:05,252 --> 00:18:06,820
这就出问题了


348
00:18:07,120 --> 00:18:08,789
让我们现在把它修复


349
00:18:09,156 --> 00:18:11,325
我要在这里创建一个小的空白区


350
00:18:12,025 --> 00:18:13,293
写一些Swift代码


351
00:18:14,461 --> 00:18:16,597
当然了 我假设
你们都有神奇的宏命令


352
00:18:16,663 --> 00:18:18,165
可以为你们添加各种单元测试


353
00:18:18,465 --> 00:18:20,033
我们就是这样开发程序的不是吗？


354
00:18:26,440 --> 00:18:28,075
我要在设备上运行下测试


355
00:18:28,141 --> 00:18:29,309
这需要一点时间


356
00:18:29,376 --> 00:18:31,979
就像马特说过的那样当你的代码运行时


357
00:18:32,045 --> 00:18:34,715
我们会用LLVM对你的代码
进行指导 这样我们就可以


358
00:18:34,781 --> 00:18:36,216
看到到底运行的是哪个表达式


359
00:18:36,783 --> 00:18:40,354
趁着它在我的设备上运行
我要去看看方案


360
00:18:40,621 --> 00:18:43,190
要记住既然它是LLVM的一项特性


361
00:18:43,257 --> 00:18:44,892
那么它在Xcode上也是可选项


362
00:18:44,958 --> 00:18:47,594
打开它的方式是进到方案编辑器


363
00:18:48,061 --> 00:18:49,329
然后选择测试操作


364
00:18:49,763 --> 00:18:52,833
然后确保“收集数据覆盖”
那个勾选框已经勾选了


365
00:18:53,901 --> 00:18:55,502
这样就可以确保我得到覆盖数据


366
00:18:56,270 --> 00:18:57,838
时间正好我的所有测试都成功了


367
00:18:58,205 --> 00:19:00,374
太好了 只要我用神奇的
宏命令来构建 就总会成功


368
00:19:01,542 --> 00:19:03,710
如果我现在看看
测试报告 我可以看到


369
00:19:04,478 --> 00:19:05,779
我有更多的单元测试


370
00:19:05,979 --> 00:19:07,214
但这并不是故事的全部


371
00:19:07,281 --> 00:19:08,649
我们再看一次覆盖报告


372
00:19:10,884 --> 00:19:12,519
这里 我们能看到一张更漂亮的图片


373
00:19:12,786 --> 00:19:15,656
如果我在上面放大下我们
就可以看到我现在覆盖了76%


374
00:19:15,856 --> 00:19:18,592
虽然不是100%覆盖
但是已经比我们之前的情况好得多了


375
00:19:20,160 --> 00:19:22,896
我要把事务类再次显露出来


376
00:19:22,963 --> 00:19:25,132
这里我们可以看到
更多的这些类现在得到了覆盖


377
00:19:25,199 --> 00:19:27,701
我现在测试的是合并代码
之前我一直很担心这些代码


378
00:19:28,001 --> 00:19:29,403
害我损失了好多睡眠时间


379
00:19:30,370 --> 00:19:33,073
这里有件有趣的事
如果我们返回源编辑器


380
00:19:34,374 --> 00:19:36,443
然后看看等效方法


381
00:19:36,510 --> 00:19:38,745
如果你之前注意的话
当时它只是被部分覆盖了


382
00:19:38,812 --> 00:19:41,181
我们在这里就可以看到原因所在


383
00:19:41,682 --> 00:19:42,749
我们看看这个等效方法


384
00:19:42,816 --> 00:19:46,420
我们并没有把我们的事务类
同某个不是事务类的类进行对比


385
00:19:46,887 --> 00:19:50,257
因此这个返回的假值永远不会
在任何我们的单元测试中被调用到


386
00:19:50,991 --> 00:19:53,260
当你查看不同的分支时
能够看到这个覆盖情况


387
00:19:53,327 --> 00:19:55,529
用处会很大
尤其是当你的代码中有很多


388
00:19:55,596 --> 00:19:58,332
分支逻辑
你知道会出现边界情况


389
00:19:58,765 --> 00:20:02,135
这样的话你就可以确保当你写你的
单元测试时每种边界情况都能覆盖到


390
00:20:02,970 --> 00:20:04,972
我们还可以看到
这个代码被覆盖了多次


391
00:20:05,038 --> 00:20:08,175
因此你是否知道你的代码中
有这种多个实例到底同一路径


392
00:20:08,242 --> 00:20:10,844
但是最终却并不相同的情况就非常重要


393
00:20:10,911 --> 00:20:12,346
你需要全部覆盖它们


394
00:20:14,648 --> 00:20:16,850
刚才我做的事情都非常单独枯燥


395
00:20:16,917 --> 00:20:19,553
因此我希望有人能替我整天跑这些测试


396
00:20:19,620 --> 00:20:23,156
我就不需要担心这个
不需要对它们进行对比


397
00:20:23,223 --> 00:20:25,526
但是有人告诉我
预算表中没有雇佣一名


398
00:20:25,592 --> 00:20:26,760
实习生来做这件事的钱


399
00:20:27,594 --> 00:20:29,263
我们来看看Xcode Server


400
00:20:29,530 --> 00:20:31,965
我已经为此设置了一个
Bot 跑在一个已经


401
00:20:32,032 --> 00:20:34,401
有了这个提交的不同分支
我们来看看这个Bot


402
00:20:36,370 --> 00:20:38,172
就像刚才马特在幻灯片中演示的那样


403
00:20:38,238 --> 00:20:41,508
当Bot运行了二十四小时后


404
00:20:41,575 --> 00:20:44,044
当它运行了一段时间后
我们就可以从更高层面


405
00:20:44,378 --> 00:20:46,046
对我的项目进行一次总览


406
00:20:46,914 --> 00:20:48,882
顶部这里 我们为你显示了
高阶统计数字


407
00:20:49,483 --> 00:20:53,387
你可以看到任何时间
任一周、时、月、年


408
00:20:53,820 --> 00:20:55,656
或者自从你的Bot
运行以来的统计数字


409
00:20:56,957 --> 00:20:58,158
然后我们可以看到构建历史


410
00:20:58,225 --> 00:21:01,361
在这里 我们会为你显示随着时间
变化的错误报警以及问题分析


411
00:21:01,528 --> 00:21:03,263
在这个实例中我之前有一些报警


412
00:21:03,330 --> 00:21:04,498
不过我已经修复了它们


413
00:21:04,898 --> 00:21:06,200
所以现在我们显示没有问题


414
00:21:06,834 --> 00:21:09,136
对于持续集成来说接下来的两个图表


415
00:21:09,203 --> 00:21:11,872
可能是最重要的前提是假设
你的项目构建的很干净


416
00:21:11,939 --> 00:21:13,073
没有报警或者错误


417
00:21:13,640 --> 00:21:14,708
那就是你的测试


418
00:21:15,209 --> 00:21:17,411
在这个例子中我们可以看到
我之前有几个测试失败


419
00:21:17,477 --> 00:21:18,946
不过我还是在持续添加测试


420
00:21:19,580 --> 00:21:22,816
这很棒 不过我们真正想看到
的是 顺利通过的测试数量


421
00:21:22,883 --> 00:21:27,688
持续增长并且这些测试也让
代码覆盖持续增长


422
00:21:27,888 --> 00:21:29,923
如果你的测试增加了
但是覆盖情况却没有增加


423
00:21:30,457 --> 00:21:32,492
那么你实际增加的价值
就没有你想象的大


424
00:21:33,694 --> 00:21:35,996
如果我看下上次集成的覆盖情况


425
00:21:36,063 --> 00:21:38,265
这是我刚刚进行的提交你们没有看到


426
00:21:38,332 --> 00:21:39,433
但是我保证我确实提交了


427
00:21:39,833 --> 00:21:41,902
我们就可以直接进到覆盖报告


428
00:21:43,303 --> 00:21:45,339
当我本地跑我的测试时这个看起来


429
00:21:45,405 --> 00:21:47,040
就和我们在Xcode中看到的很像


430
00:21:47,708 --> 00:21:49,710
和Xcode中的类似
我们也是按照目标


431
00:21:50,077 --> 00:21:51,712
按照不同的类进行了划分


432
00:21:51,945 --> 00:21:53,514
我可以展开那个事务类


433
00:21:54,348 --> 00:21:56,683
看到相同的方法覆盖层次
也一模一样


434
00:21:57,384 --> 00:21:58,652
不过有两个不同之处


435
00:21:58,785 --> 00:22:00,654
在这个例子中
我就可以在报告中看到


436
00:22:00,721 --> 00:22:02,222
随着时间推移发生的变化


437
00:22:02,289 --> 00:22:04,024
这样我就不用再查看两份报告


438
00:22:04,091 --> 00:22:06,293
看看覆盖是否有所增加了


439
00:22:06,360 --> 00:22:07,961
尤其是在改动不大的情况下


440
00:22:08,028 --> 00:22:10,864
我们就可以让它显示在这里了


441
00:22:11,431 --> 00:22:13,901
现在 在CB 
foundation.framework


442
00:22:13,967 --> 00:22:16,003
我的覆盖率比之前提高了22%


443
00:22:16,870 --> 00:22:20,607
尤其是事务类的覆盖率也增加了48%


444
00:22:22,042 --> 00:22:24,444
下面这里我们用橙色高亮显示了一件


445
00:22:24,511 --> 00:22:26,813
有趣的事即设备的差异之处


446
00:22:27,281 --> 00:22:30,017
实际上
在Xcode Server报告内


447
00:22:30,083 --> 00:22:33,287
我可以点击这个复选框
让设备的差异之处立即


448
00:22:33,787 --> 00:22:34,855
显示出来


449
00:22:35,389 --> 00:22:37,724
在这个例子中看起来
这个详细视图控制器


450
00:22:38,258 --> 00:22:40,093
并没有在我的iPhone上显示出来


451
00:22:40,327 --> 00:22:42,062
这实际上并不意外


452
00:22:42,129 --> 00:22:44,264
在这个例子中 我们的
应用程序用的是分割视图


453
00:22:44,798 --> 00:22:46,733
除非有人点一下
否则第二个视图控制器


454
00:22:46,800 --> 00:22:48,569
并不会在iPhone上显示出来


455
00:22:48,669 --> 00:22:50,604
我们的单元测试并没有执行那个代码


456
00:22:50,971 --> 00:22:53,507
这并没有什么特别不寻常不过你要确保


457
00:22:53,574 --> 00:22:54,942
如果出现此类事情


458
00:22:55,209 --> 00:22:56,410
那么它们不会出乎你的意料


459
00:22:56,476 --> 00:22:58,745
这也就是我们为什么让你们
可以在Xcode Server中


460
00:22:58,812 --> 00:23:01,114
很容易看到不同种类的设备的
差异之处的原因所在


461
00:23:01,849 --> 00:23:04,418
这样就可以很容易找出
本来应该被覆盖的代码


462
00:23:04,484 --> 00:23:05,652
实际上没有覆盖到


463
00:23:07,120 --> 00:23:09,923
这个就是显示了代码覆盖的持续集成


464
00:23:09,990 --> 00:23:11,558
那么我要再请马特来给大家谈一些


465
00:23:11,625 --> 00:23:13,560
Xcode Server
更多的高级特性


466
00:23:20,834 --> 00:23:21,668
谢谢 埃里克


467
00:23:22,803 --> 00:23:24,872
就像埃里克刚刚说过的
我要来给大家谈一些


468
00:23:24,938 --> 00:23:26,773
Xcode Server
更多的高级特性


469
00:23:27,474 --> 00:23:30,911
我知道你们很多开发者
都对扩展Xcode Server


470
00:23:31,211 --> 00:23:34,715
把它和你们团队的工作
流程的一部分集成起来很感兴趣


471
00:23:35,048 --> 00:23:39,052
我们知道你们并不能
仅仅靠Xcode Server


472
00:23:39,119 --> 00:23:41,889
这个工具就能搞定一切
因此我们想给你们提供


473
00:23:41,955 --> 00:23:43,524
让Xcode Server
和你们手上的所有


474
00:23:43,590 --> 00:23:45,225
工具兼容完全拟合你们团队的方式


475
00:23:46,693 --> 00:23:49,429
我们有两种方式今天我要
就如何把Xcode Server


476
00:23:49,963 --> 00:23:52,132
集成到你使用的所有工具上谈一谈


477
00:23:52,699 --> 00:23:54,201
首先是触发器


478
00:23:55,702 --> 00:23:58,071
触发器是在Xcode 6中
引入的引入触发器的目的


479
00:23:58,939 --> 00:24:02,643
是为了在你的Bot
以及你的集成的生命周期内


480
00:24:02,776 --> 00:24:04,311
把定制操作集成到上面


481
00:24:05,245 --> 00:24:07,381
触发器可以是邮件通知
提供关于你的集成


482
00:24:07,447 --> 00:24:09,583
集成运行情况出现了什么问题


483
00:24:09,650 --> 00:24:12,586
提交者是谁等等此类事情的细节


484
00:24:12,653 --> 00:24:18,058
以及配置信息或者
你也可以选择某种程序语言


485
00:24:18,725 --> 00:24:20,561
把触发器写成任意脚本


486
00:24:21,962 --> 00:24:24,164
我们默认使用Bash来跑这些脚本


487
00:24:24,231 --> 00:24:27,134
因此你可以向你的触发器中
输入任何老的shell命令


488
00:24:27,201 --> 00:24:28,035
照样可以生效


489
00:24:28,502 --> 00:24:30,771
但是如果你照着写命令行工具那样


490
00:24:30,838 --> 00:24:33,607
在你的脚本顶部包含了
一个hash bang


491
00:24:33,941 --> 00:24:36,410
我们就会用它
你也可以使用任何你喜欢的解释器


492
00:24:36,944 --> 00:24:39,546
如果你愿意的话 你甚至还可以
用Swift来写你的触发器


493
00:24:40,647 --> 00:24:41,882
埃里克稍后会给你们演示下


494
00:24:44,284 --> 00:24:49,523
触发器可以在你的集成运行
之前或者之后运行


495
00:24:49,890 --> 00:24:52,092
每一段代码都能让你的Bot


496
00:24:52,159 --> 00:24:53,660
做一些很酷的事


497
00:24:54,361 --> 00:24:56,330
在你的源代码之后集成运行之前


498
00:24:56,530 --> 00:24:58,465
运行的触发器会进行检验


499
00:24:58,532 --> 00:25:00,667
这点很重要
因为这就意味着你可以访问


500
00:25:00,734 --> 00:25:04,838
你的项目 并且在构建之前
进行任何你想要的自动变更


501
00:25:06,573 --> 00:25:10,477
集成之后运行的触发器
可以根据集成的结果进行控制


502
00:25:10,544 --> 00:25:14,281
这样触发器就可以仅在
集成成功时或者仅在测试失败时运行


503
00:25:14,681 --> 00:25:17,518
它们也可以访问很多
关于你的集成中发生了


504
00:25:17,718 --> 00:25:19,319
什么事情的信息


505
00:25:21,288 --> 00:25:23,524
我们提供访问这些信息的
一种方式是通过


506
00:25:23,590 --> 00:25:24,925
环境变量来访问


507
00:25:25,959 --> 00:25:29,997
这个仅仅是当你的脚本运行时
定义的某些变量的样本


508
00:25:30,264 --> 00:25:32,866
任何值得你用的脚本语言
都能让你很容易地理解


509
00:25:32,933 --> 00:25:34,868
这些环境变量让你可以把它们用起来


510
00:25:36,336 --> 00:25:38,071
我们举个例子看看你能用它们做什么


511
00:25:38,305 --> 00:25:42,176
去年我们演示了一个触发器
每当完成一项集成的时候


512
00:25:42,242 --> 00:25:44,511
触发器就会在一个逾限聊天室
内贴出一条消息


513
00:25:44,811 --> 00:25:46,613
我们是使用了Bot的名称集成的数量


514
00:25:46,680 --> 00:25:48,081
以及结果来实现的


515
00:25:49,183 --> 00:25:51,552
把它设置起来很容易很快


516
00:25:53,587 --> 00:25:56,657
这里我想请你们注意两件事


517
00:25:56,723 --> 00:25:58,392
因为它们看起来比较怪看起来不协调


518
00:25:59,026 --> 00:26:01,028
对于运行的集成以及相应的Bot来说


519
00:26:01,094 --> 00:26:03,463
我们有一个BotID和一个集成ID


520
00:26:03,830 --> 00:26:06,166
如果我们只给你这些那就有点怪了


521
00:26:06,366 --> 00:26:07,901
你用一个ID做不了什么事


522
00:26:07,968 --> 00:26:09,536
这个ID是一个任意的字符串


523
00:26:10,204 --> 00:26:12,472
那这个字符串有什么好处？
没有用户想看这个字符串


524
00:26:13,540 --> 00:26:16,009
这个字符串本身做不了
什么事 但是当这个字符串


525
00:26:16,076 --> 00:26:18,345
和Xcode Server API
结合起来后事情就非常有趣了


526
00:26:20,113 --> 00:26:22,482
Xcode Server
API构成了


527
00:26:22,549 --> 00:26:24,685
Xcode ID
和Xcode Server


528
00:26:24,751 --> 00:26:25,586
通信的基础


529
00:26:25,886 --> 00:26:28,455
你也可以控制这个API为你自己所用


530
00:26:28,622 --> 00:26:30,123
用它来做一些很有趣的事


531
00:26:31,992 --> 00:26:34,761
和大多数网络服务APIs一样
这个API构造时遵循的也是


532
00:26:34,862 --> 00:26:36,129
开源的 相沿成习的标准


533
00:26:37,531 --> 00:26:41,668
我们在服务器和客户端之间
使用HTTPS来进行来回的安全通信


534
00:26:41,869 --> 00:26:46,039
通过那个加密渠道
我们使用基本认证来进行认证


535
00:26:49,009 --> 00:26:51,512
我们的API遵循的是一个REST


536
00:26:51,578 --> 00:26:54,047
模式像Bot和集成一样
与资源进行交互


537
00:26:54,248 --> 00:26:57,818
使用标准的HTTP谓词
比如获取、发布、打补丁、


538
00:26:57,885 --> 00:27:02,990
删除等等 在这些资源上执行操作


539
00:27:04,558 --> 00:27:07,561
当然了 我们还使用了JSON
来对数据进行来回通信


540
00:27:07,794 --> 00:27:09,596
JSON用起来很简单
解析起来也很简单


541
00:27:09,663 --> 00:27:11,298
它是网络服务的通用语


542
00:27:11,498 --> 00:27:12,332
大家都在用它


543
00:27:15,269 --> 00:27:18,405
对你来说Xcode
Server这个雄心勃勃的扩展器


544
00:27:18,805 --> 00:27:22,109
是个好消息因为这意味着无论你偏好
什么样的编程语言 什么样的环境


545
00:27:22,309 --> 00:27:25,145
你肯定都能找到表达
HTTPS以及JSON的方法


546
00:27:25,212 --> 00:27:28,382
也就意味着你能够让几乎所有的东西
同Xcode Server进行交谈


547
00:27:29,883 --> 00:27:33,120
我们来看看我们都能怎样
使用这个API


548
00:27:34,721 --> 00:27:37,090
我们能问我们的服务器的
最简单的问题是什么？


549
00:27:37,791 --> 00:27:40,661
我们从这个问题开始
我的服务器上有什么Bot？


550
00:27:41,328 --> 00:27:42,362
这个很简单


551
00:27:42,496 --> 00:27:44,665
我们向Bot资源发一个get请求


552
00:27:45,432 --> 00:27:48,035
如果你看看那里的URI
你就可以看到我们是通过端口


553
00:27:48,101 --> 00:27:52,773
20,343进行通信的 我们所有的
API请求都有一个API前缀


554
00:27:53,407 --> 00:27:56,777
这个并不重要但是当你们在
你们自己的服务器上


555
00:27:57,010 --> 00:27:59,880
尝试这个API的时候
我希望你们记住这一点


556
00:28:01,582 --> 00:28:04,418
当我们发送完那个请求后
我们就得到了一个JSON对象


557
00:28:04,484 --> 00:28:05,986
告诉我们得到的结果的数量


558
00:28:06,220 --> 00:28:08,055
给我们提供一个与结果自身相关的阵列


559
00:28:09,223 --> 00:28:13,427
每个JSON对象都代表一个在我们的
服务器上设置 配置的Bot


560
00:28:14,061 --> 00:28:17,431
和大多数Bot一样
Bot也有一个ID它们也有一个名字


561
00:28:17,564 --> 00:28:19,733
和你在创建
它们时在Xcode中给的一样


562
00:28:20,100 --> 00:28:22,069
它们也有各个配置参数
和你在设置Bot时


563
00:28:22,669 --> 00:28:24,471
设置的配置参数一样


564
00:28:26,607 --> 00:28:28,775
好的 那么我们还能做什么？
既然有了一个Bot


565
00:28:29,042 --> 00:28:31,211
我们来看看这个Bot
运行了什么样的集成


566
00:28:32,646 --> 00:28:36,116
现在我们可以访问那个
Bot的集成子资源了


567
00:28:39,086 --> 00:28:40,954
这样做我们就可以得到一个和我们之前


568
00:28:41,221 --> 00:28:43,891
看到的非常相似的结果
除了现在的结果...


569
00:28:44,091 --> 00:28:46,293
代表集成而不是代表Bot


570
00:28:47,461 --> 00:28:50,130
但是集成也同样属于资源
它们也有自己的ID


571
00:28:50,531 --> 00:28:53,700
一件有趣的事是我们也保存了


572
00:28:53,967 --> 00:28:56,837
集成上的Bot的快照这很重要


573
00:28:56,937 --> 00:28:58,839
因为随着时间推移你的项目会发生变更


574
00:28:58,906 --> 00:29:01,141
你可能采用新的
Xcode特性 类似这样的事


575
00:29:01,441 --> 00:29:03,644
当你编辑的时候 机器人
程序的配置也可能发生变更


576
00:29:03,944 --> 00:29:05,812
因此我们存储了一张集成的快照


577
00:29:05,879 --> 00:29:07,781
这样当集成运行时
你就可以知道到底你的


578
00:29:07,981 --> 00:29:09,283
Bot是怎样配置的


579
00:29:11,885 --> 00:29:15,322
我们同样会跟踪你的集成的
构造过程的步骤


580
00:29:15,455 --> 00:29:17,224
完成后你可以在那里看到一个结果


581
00:29:17,558 --> 00:29:20,460
你还可以看到你的集成发生的
各种不同的问题的分类


582
00:29:20,727 --> 00:29:24,731
之前的集成的变更的分类


583
00:29:26,800 --> 00:29:29,102
这些都是之前我向
你们展示的get请求


584
00:29:29,203 --> 00:29:31,772
非常适合收集信息


585
00:29:32,172 --> 00:29:35,209
不过如果你在用API的话
你可能想用它做些事情


586
00:29:36,176 --> 00:29:38,812
那么我们到底可以做什么事 
来对我们的服务器产生影响呢？


587
00:29:39,246 --> 00:29:41,081
我们可以手动触发一个集成


588
00:29:41,648 --> 00:29:44,418
也许我们有某种不属于Xcode
 Server内置调度


589
00:29:44,484 --> 00:29:46,486
程序的自动化流程
我们就希望使用这个流程


590
00:29:46,553 --> 00:29:48,355
来为某些Bot触发集成


591
00:29:50,057 --> 00:29:52,526
这个实现起来也很容易
我们可以使用相同的URL


592
00:29:52,726 --> 00:29:55,295
把我们的HTTP方法
改成一个post


593
00:29:57,831 --> 00:30:01,268
这样的话我们就从“我想列出这个
Bot的集成”变成了


594
00:30:01,335 --> 00:30:03,337
“我想为这个bot
创建一个新的集成 ”


595
00:30:05,439 --> 00:30:06,540
如果我们发出这个请求


596
00:30:07,074 --> 00:30:08,976
我们就可以得到一个代表
一项集成的对象


597
00:30:09,042 --> 00:30:11,211
和你们之前看到的很相似
不过这个对象轻了很多


598
00:30:11,512 --> 00:30:15,482
在构造过程中集成上面
设置了许多项属性


599
00:30:15,782 --> 00:30:17,484
不过这个集成会仅仅处于挂起状态


600
00:30:17,718 --> 00:30:20,521
直到构造程序在队列中捡起它
开始实际运行它


601
00:30:22,890 --> 00:30:26,460
在我们的API中
大部分的post终点都要求你


602
00:30:26,693 --> 00:30:27,995
在主体中放置一些JSON


603
00:30:28,061 --> 00:30:31,265
然后说明这是这个资源的属性


604
00:30:31,331 --> 00:30:34,568
这是我正在创建的事物的属性


605
00:30:35,169 --> 00:30:37,004
在这里集成属于某种特例


606
00:30:37,371 --> 00:30:41,108
因为Bot在本质上已经成了那个样子


607
00:30:41,241 --> 00:30:43,777
它们已经成了每个新的集成的模板


608
00:30:44,044 --> 00:30:46,647
因此它们知道创建一个新的集成
它们需要知道的一切


609
00:30:47,781 --> 00:30:50,150
或者说 它们最起码知道
一般情况下需要知道的一切


610
00:30:50,384 --> 00:30:52,619
你也可以对你的集成有某种影响


611
00:30:52,686 --> 00:30:54,988
举例来说如果你想要一个运行时非常


612
00:30:55,055 --> 00:30:56,390
干净、没有残余物构造块效应


613
00:30:56,690 --> 00:30:58,859
的集成那么你就可以通过向主体中


614
00:30:59,226 --> 00:31:02,296
传递某些JSON 告诉主体这个
集成在运行之前应该先进行


615
00:31:02,429 --> 00:31:04,631
清理这种方式来实现


616
00:31:06,700 --> 00:31:09,303
这里有一个例子是你能用
我们的API做什么事情的例子


617
00:31:09,436 --> 00:31:12,039
现在我想把埃里克请回来
请他给你们做一个


618
00:31:12,105 --> 00:31:13,540
Xcode某些高级特性的演示


619
00:31:20,814 --> 00:31:21,648
再次感谢 马特


620
00:31:22,749 --> 00:31:24,751
就像马特所说的我们要通过这个项目


621
00:31:24,818 --> 00:31:27,154
向你们演示一些
Xcode Server的高级特性


622
00:31:27,988 --> 00:31:30,157
和你们中的许多人一样


623
00:31:30,824 --> 00:31:33,260
我们这个app也是内部开发的


624
00:31:33,327 --> 00:31:37,364
不过我们也想把它分发出去我想要
非常容易地就能区分我的内部构建


625
00:31:37,698 --> 00:31:38,732
以及我的外部构建


626
00:31:39,533 --> 00:31:42,169
对此 最常见的一个策略是
如果我们看看我们的“资产目录”


627
00:31:42,236 --> 00:31:43,737
我们就可以看到两张不同的图片


628
00:31:43,904 --> 00:31:46,240
在第一个例子中
我们可以看到标准app图标


629
00:31:46,306 --> 00:31:48,408
就是这个白色的咖啡杯


630
00:31:49,810 --> 00:31:51,712
对于我们的内部构建来说


631
00:31:51,845 --> 00:31:55,249
我们想要始终显示一个
黑色的咖啡杯图标


632
00:31:55,315 --> 00:31:56,450
把它作为一个内部标记


633
00:31:56,917 --> 00:31:59,620
这样的话 当我们在我们的
设备上运行内部构建时


634
00:32:00,354 --> 00:32:01,588
我们就知道它们是内部构建


635
00:32:01,655 --> 00:32:04,758
而不是我们可能上架App 
Store或者通过我们的正常通道


636
00:32:04,825 --> 00:32:05,759
分发出去的外部构建


637
00:32:06,627 --> 00:32:08,795
这就非常有用
当我们发现一个bug时


638
00:32:09,429 --> 00:32:11,365
我们就知道就希望只
有我们能看到这个bug


639
00:32:12,900 --> 00:32:15,602
还有一种方式我们可以
用来区分我们的内部app


640
00:32:16,103 --> 00:32:17,938
就是当我们运行内部构建时


641
00:32:18,472 --> 00:32:20,240
我们通常都有一个设置包


642
00:32:20,307 --> 00:32:23,076
在那个设置包中像很多应用程序一样


643
00:32:23,143 --> 00:32:25,379
我们会定义一个版本
在这里就是版本2.0


644
00:32:25,445 --> 00:32:27,347
因为我们刚刚做了一些很大的变更


645
00:32:28,048 --> 00:32:30,918
2.0对于我们内部用户来说
已经足够完美了


646
00:32:30,984 --> 00:32:33,587
不过向App Store提交时
我们不会提交这个版本


647
00:32:34,388 --> 00:32:37,391
不过对于内部使用来说
我们可能还想要一些更多的细粒度信息


648
00:32:37,558 --> 00:32:40,427
再进一步具体来说 我们想让
构建有某种唯一标识符


649
00:32:41,662 --> 00:32:44,131
在这个例子中我想用
Xcode Server来区分


650
00:32:44,331 --> 00:32:48,735
构建是来自在我的服务器上的哪个集成


651
00:32:49,703 --> 00:32:51,271
我到Bot那里看看


652
00:32:52,739 --> 00:32:54,174
这个Bot和我之前用的一样


653
00:32:54,241 --> 00:32:55,876
我要编辑下这个工作流程


654
00:32:57,377 --> 00:32:59,646
正如马特说的那样
现在这是完全非线性的


655
00:33:00,013 --> 00:33:02,516
因为我对触发器最感兴趣
我就直接到那里了


656
00:33:04,117 --> 00:33:05,652
让我们开始第一...


657
00:33:05,819 --> 00:33:07,688
开始我们的第一步 变更图标


658
00:33:08,188 --> 00:33:10,424
我要打开一个我已经写好的触发器脚本


659
00:33:10,891 --> 00:33:12,893
在这个例子中
这是一个简单的批处理脚本


660
00:33:12,960 --> 00:33:14,795
因为我们要做的都是简单的文件操作


661
00:33:15,028 --> 00:33:18,966
我们要使用XES源目录环境变量


662
00:33:19,032 --> 00:33:22,603
来找出那个app图标的路径


663
00:33:23,770 --> 00:33:25,506
然后我们要把它删掉


664
00:33:26,139 --> 00:33:28,242
然后我们要把我们的服务器版本取出来


665
00:33:28,308 --> 00:33:29,510
把它移动到这个位置


666
00:33:30,143 --> 00:33:32,112
那么这就会成为一个集成前触发器


667
00:33:32,279 --> 00:33:34,581
因为我们想让它在我们的
源代码检查完毕


668
00:33:34,648 --> 00:33:37,150
准备构建但是并没有真的
进行构建时运行


669
00:33:38,185 --> 00:33:41,121
我要把它当成一个
运行脚本触发器来复制


670
00:33:42,656 --> 00:33:46,493
现在对设置包进行设置就会有点棘手了


671
00:33:46,560 --> 00:33:48,929
我可以使用一个批处理脚本
来设置 但是那就需要手动


672
00:33:48,996 --> 00:33:51,698
编辑大量的批处理脚本
或者在一个批处理脚本中


673
00:33:51,765 --> 00:33:53,400
放大量的plist代码会很痛苦


674
00:33:54,168 --> 00:33:57,070
那么我要启用一个Swift触发器


675
00:33:57,738 --> 00:34:00,440
在这个例子中和bash触发器类似


676
00:34:00,507 --> 00:34:03,277
我要给用户宾·斯威夫特
设置为使用hash bang


677
00:34:04,645 --> 00:34:07,814
我还没有写完所以请等我一下


678
00:34:08,748 --> 00:34:11,051
我要获取导入基础 我在那里就可以


679
00:34:11,485 --> 00:34:13,920
获得我想从Swift获得的
其它额外的权限


680
00:34:14,721 --> 00:34:17,090
导入基础后
我要使用NSProcess信息


681
00:34:17,157 --> 00:34:20,226
来获得我在bash中其它脚本上
使用的


682
00:34:20,393 --> 00:34:22,362
那些环境变量


683
00:34:22,462 --> 00:34:24,898
在这个例子中就是XCS源目录


684
00:34:27,935 --> 00:34:30,504
然后我要找到我所有的设置包


685
00:34:30,571 --> 00:34:32,873
这里 有了Swift事情就更有趣了


686
00:34:32,940 --> 00:34:37,043
我可以在Swift中
把plist当成一本字典载入


687
00:34:37,110 --> 00:34:40,380
我并不需要亲自手动对plist文件
进行任何编辑


688
00:34:40,947 --> 00:34:44,083
当我想往上面添加什么
东西时 这就非常有用


689
00:34:44,685 --> 00:34:47,521
我只需要在swift中
创建一个新的字典常量


690
00:34:48,188 --> 00:34:50,456
然后把它塞进我的字典中


691
00:34:51,558 --> 00:34:57,130
这里我们把集成编号的
环境变量设置成这个构建编号标题


692
00:34:58,131 --> 00:35:01,001
最后在完成脚本之前


693
00:35:01,068 --> 00:35:02,803
我要把它写出到磁盘


694
00:35:02,870 --> 00:35:07,307
这样 当我们实际构建时
它就可以在我的设置包中被拾取到


695
00:35:08,542 --> 00:35:10,310
为此 我只需要在下面
添加另一个触发器


696
00:35:11,512 --> 00:35:12,346
好的


697
00:35:14,081 --> 00:35:15,382
现在我有了两个触发器


698
00:35:17,317 --> 00:35:19,586
现在 我就可以在这里推送
“现在开始集成”按钮


699
00:35:19,653 --> 00:35:21,488
得到一个新的集成但是我想在服务器上


700
00:35:21,855 --> 00:35:24,992
用一些马特提到的API来实现这个


701
00:35:26,460 --> 00:35:28,395
我要再启用一个我拥有的应用程序


702
00:35:29,196 --> 00:35:32,833
如果我们看这里
我们就能看到一个应用程序


703
00:35:32,900 --> 00:35:36,003
它已经连接到了插入我的
电脑的一个串行设备上


704
00:35:37,070 --> 00:35:40,941
它使用了示例代码的某些
输入/输出套件


705
00:35:41,008 --> 00:35:42,910
那么我们就要来读取那个缓冲器


706
00:35:43,277 --> 00:35:46,613
无论我们什么时候在那个缓冲器上看到
有内容我们就要运行这一代码块


707
00:35:47,281 --> 00:35:52,286
我要打开一个NSURL会话我要调用
能够获得所有的Bot的API


708
00:35:52,886 --> 00:35:54,221
这只不过是本地主机


709
00:35:54,288 --> 00:35:57,024
马特之前提到过的端口API/Bot


710
00:35:57,191 --> 00:35:58,692
就会成为get方法


711
00:35:59,560 --> 00:36:04,298
我要调用它使用NS JSON序列化
API然后在各个Bot中


712
00:36:04,565 --> 00:36:09,236
进行读取 找出咖啡板Bot的ID


713
00:36:10,003 --> 00:36:11,205
我想集成的就是那个Bot


714
00:36:12,539 --> 00:36:15,042
有了那个ID 我就可以
像马特之前展示的那样


715
00:36:15,108 --> 00:36:16,543
使用Bot/我的


716
00:36:16,844 --> 00:36:22,349
通用唯一标识符/集成
创建一个新的URL


717
00:36:22,416 --> 00:36:24,651
把那个请求切换成一个post请求


718
00:36:25,018 --> 00:36:26,620
这样就会创建一个新集成


719
00:36:26,887 --> 00:36:29,556
为此我们并不真的在意集成要做什么事


720
00:36:30,457 --> 00:36:31,992
要触发这个


721
00:36:32,759 --> 00:36:35,162
我设法绕过安全机制
取得了这个有趣的小按钮


722
00:36:35,863 --> 00:36:38,265
我要把它插入我的Mac


723
00:36:41,101 --> 00:36:43,237
然后我要运行这个应用程序


724
00:36:46,039 --> 00:36:47,107
我们要再试试


725
00:36:53,046 --> 00:36:54,748
在我运行之前确保它完全连接好了


726
00:36:55,349 --> 00:36:56,783
不想操之过急 好的


727
00:36:58,051 --> 00:37:00,420
很好 现在应用程序开始运行了
拾取了调制解调器


728
00:37:00,854 --> 00:37:04,491
我要在我的Bot这里放大下


729
00:37:04,558 --> 00:37:07,094
然后等一会儿就是用这个按钮


730
00:37:08,629 --> 00:37:09,463
创建一个新的集成


731
00:37:17,037 --> 00:37:19,072
就是完全用我们的API中的这个按钮


732
00:37:19,239 --> 00:37:21,108
我不想等待集成完毕
我要直接向你们展示


733
00:37:21,175 --> 00:37:24,378
发生了什么 在这里我们可以看到集成


734
00:37:24,444 --> 00:37:27,881
我可以把它安装到我之前
使用的本地设备上进行测试


735
00:37:29,283 --> 00:37:34,454
安装 如果我打开QuickTime


736
00:37:35,756 --> 00:37:36,990
你们就可以看到我看到的
东西...好的


737
00:37:42,396 --> 00:37:43,230
这是我的设备


738
00:37:44,364 --> 00:37:46,433
你可以看到我们在设备上有了内部图标


739
00:37:46,500 --> 00:37:47,968
尽管我从来没有把它切换成本地


740
00:37:48,035 --> 00:37:50,470
我们是从服务器上下载的
现在我们的app


741
00:37:51,271 --> 00:37:52,472
我们知道 是一个内部构建


742
00:37:53,640 --> 00:37:56,376
这些就是Xcode Server
上面的一些更多的高级特性


743
00:37:56,543 --> 00:38:00,147
我要请马特再讲讲你们可以
在实验室的什么位置找到我们


744
00:38:00,214 --> 00:38:01,348
诸如此类的事情


745
00:38:02,382 --> 00:38:03,217
马特？


746
00:38:09,523 --> 00:38:10,490
好的 谢谢 埃里克


747
00:38:10,557 --> 00:38:11,692
太棒了


748
00:38:11,959 --> 00:38:14,528
我最喜欢按下大大的
红色按钮 进行集成了


749
00:38:17,531 --> 00:38:20,868
这里还有一些更多的你们可以
在我们的API中使用的端点


750
00:38:20,934 --> 00:38:24,605
或者最起码说对于你们这些
开发者来说是这样的


751
00:38:24,972 --> 00:38:29,676
这些还有很多的端点
但是它们是被锁定的仅限内部使用


752
00:38:29,743 --> 00:38:34,982
我们想要的是真正的安全确保当集成在
运行时不会和太多的东西混杂在一起


753
00:38:36,483 --> 00:38:38,585
尤其与客户端服务器之间的交互


754
00:38:38,785 --> 00:38:40,988
你可能会在更多的地方
而不仅仅是你的网络上


755
00:38:41,522 --> 00:38:42,656
把你的服务器公开出去


756
00:38:43,590 --> 00:38:46,126
不过当我们稍后上传了
这个开发视频以及幻灯片后


757
00:38:46,627 --> 00:38:51,598
我建议你引用这个幻灯片
在你们自己的服务器上尝试这些端点


758
00:38:51,832 --> 00:38:52,999
然后看看你们会得到什么


759
00:38:53,200 --> 00:38:54,902
看看对于你们团队来说有什么有趣的事


760
00:38:57,404 --> 00:39:00,674
今天我们看了我们在Xcode上对
Xcode Server所在的改进


761
00:39:00,741 --> 00:39:02,809
无论是从质量方面来说


762
00:39:02,876 --> 00:39:06,013
还是从采用添加到Xcode 7
中的新测试特性


763
00:39:06,079 --> 00:39:08,849
来说 尤其是新的代码覆盖特性


764
00:39:09,149 --> 00:39:11,552
用来度量你的应用程序
代码在你的测试中


765
00:39:11,618 --> 00:39:14,488
实际被用到的情况真是再合适不过了


766
00:39:15,522 --> 00:39:17,324
当然了我们也向你们演示了扩展


767
00:39:17,591 --> 00:39:20,928
Xcode Server通过触发器
以及Xcode Server API把它


768
00:39:20,994 --> 00:39:23,430
更好地与你们的
团队进行集成的两种方法


769
00:39:25,933 --> 00:39:27,634
要获取更多信息我们有一个


770
00:39:27,701 --> 00:39:30,771
开发者库有一个“持续集成指导”


771
00:39:31,271 --> 00:39:33,240
当然了你也可以在开发者论坛上


772
00:39:33,307 --> 00:39:34,241
贴出任何问题


773
00:39:36,310 --> 00:39:37,845
有几场会议与此相关


774
00:39:38,111 --> 00:39:40,380
它们都已经结束了


775
00:39:40,547 --> 00:39:42,049
有些是刚刚结束的


776
00:39:42,716 --> 00:39:46,954
昨天结束的是“Xcode中的UI
测试”不过我建议你们去看看视屏


777
00:39:47,020 --> 00:39:49,089
今天我们也谈及了UI测试
但是我们并没有向你们演示


778
00:39:49,156 --> 00:39:50,390
它在Server中是如何运作的


779
00:39:50,490 --> 00:39:53,527
它的自动化程度很高
不过UI测试特性真的很棒


780
00:39:53,594 --> 00:39:54,661
我建议你们去试试


781
00:39:55,429 --> 00:39:58,165
如果关于如何使用Xcode
Server你想了解更多信息


782
00:39:58,232 --> 00:40:00,934
那么去年我们在Xcode 6会议中
演示了如何从头开始


783
00:40:01,001 --> 00:40:03,470
设置你的服务器
如何在“持续集成”中


784
00:40:03,537 --> 00:40:07,207
初始设置你的Bot


785
00:40:09,376 --> 00:40:12,079
谢谢大家 祝你们在苹果全球开发者
大会剩余的时间内过得愉快

