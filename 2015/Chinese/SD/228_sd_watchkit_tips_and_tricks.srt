1
00:00:28,428 --> 00:00:29,930
JAKE BEHRENS: 早上好


2
00:00:30,764 --> 00:00:32,866
欢迎来到 
"WatchKit 提示和技巧"


3
00:00:32,933 --> 00:00:34,268
我叫Jake Behrens，


4
00:00:34,334 --> 00:00:36,937
我是苹果watchOS框架的讲师


5
00:00:38,038 --> 00:00:40,407
今天，我们将讨论
如何利用的不同的方法


6
00:00:40,474 --> 00:00:44,378
去优化你在
watchOS上安装的应用


7
00:00:44,444 --> 00:00:45,746
在 watchOS 1中


8
00:00:46,780 --> 00:00:49,116
将会有很多我们需要讨论的东西


9
00:00:49,349 --> 00:00:52,653
同样这个也适用于watchOS 2


10
00:00:53,020 --> 00:00:55,155
在讨论的过程中 我将会指出这些


11
00:00:58,025 --> 00:01:00,794
如今 随着之前苹果手表的发布之后


12
00:01:01,328 --> 00:01:03,230
在写第一个手表app的过程中


13
00:01:03,297 --> 00:01:06,767
我们有了和很多个
开发者一起工作的经历


14
00:01:07,568 --> 00:01:10,537
在这个过程中我们学到了很多


15
00:01:11,071 --> 00:01:13,740
而今天我们也将会和你们分享很多关于


16
00:01:15,075 --> 00:01:17,411
类似于怎样优化你的网络


17
00:01:17,945 --> 00:01:22,249
或者怎样减少你的
下载时间等很有用的知识


18
00:01:23,851 --> 00:01:25,953
所以 首先让我们从数据和交流开始吧


19
00:01:26,753 --> 00:01:28,355
正如我前面所提到


20
00:01:28,655 --> 00:01:33,293
从你的web服务器上或者安装的苹果
应用程序中 获取信息是至关重要的


21
00:01:33,627 --> 00:01:35,395
以至于你必须将一部分内容


22
00:01:35,729 --> 00:01:38,999
去实际的显示给用户


23
00:01:41,201 --> 00:01:44,171
现在，想象一下
你的用户正在车站等候


24
00:01:44,738 --> 00:01:47,975
他们抬高了自己的手腕
他们正在和你的应用程序进行交互


25
00:01:48,375 --> 00:01:50,544
突然你启动了一个网络请求


26
00:01:50,611 --> 00:01:53,113
然后公共汽车从拐角处开过来了


27
00:01:53,514 --> 00:01:55,916
因为他们得到了自己
想要的东西所以用户们放下了胳膊


28
00:01:56,183 --> 00:02:00,287
然后他们匆忙地朝着
公共汽车赶去上车然后坐下来


29
00:02:01,021 --> 00:02:03,357
好了你要做的事情
就是确保下一次提高手腕


30
00:02:03,423 --> 00:02:05,893
他们重新回到你的应用程序中的时候


31
00:02:06,193 --> 00:02:08,294
数据仍然在那儿等着他们


32
00:02:08,895 --> 00:02:11,164
而不是你必须重新读取它


33
00:02:11,932 --> 00:02:13,734
所以 你怎样才能有
效的完成这个过程呢？


34
00:02:14,368 --> 00:02:17,638
好 第一部分就是你需要一个网络请求


35
00:02:18,038 --> 00:02:20,007
这是你如何获得信息的过程


36
00:02:21,708 --> 00:02:26,914
下一步你需要做的就是
询问系统是谁请求了


37
00:02:26,980 --> 00:02:28,182
后台的任务中断处理


38
00:02:28,549 --> 00:02:33,086
这种方法是向系统提出要求
说“嘿 我需要一些时间


39
00:02:33,554 --> 00:02:36,490
因为我可能需要完成某个进程
一旦你开始


40
00:02:36,557 --> 00:02:38,358
暂停我的 WatchKit 
扩展程序时”


41
00:02:40,794 --> 00:02:44,164
更进一步 如果你碰上后台任务声明


42
00:02:44,431 --> 00:02:46,166
你会需要将其保持在打开的状态上


43
00:02:46,366 --> 00:02:49,236
以便你的网络请求能够得以完成


44
00:02:51,205 --> 00:02:52,773
那我们怎样去完成这些呢？


45
00:02:53,173 --> 00:02:54,508
现在我们要一起走过整个过程


46
00:02:55,609 --> 00:03:00,480
第一件事你需要做的
是设置好你的网络请求


47
00:03:00,881 --> 00:03:04,351
为此我们将使用
默认 NSURLSession


48
00:03:05,219 --> 00:03:09,423
现在注意 我不会
使用后台 NSURLSession


49
00:03:09,790 --> 00:03:11,024
因为在哪种情况下


50
00:03:11,091 --> 00:03:13,227
如果我们的 WatchKit 
扩展程序被暂停了


51
00:03:13,293 --> 00:03:14,862
其完成就会取决


52
00:03:14,962 --> 00:03:16,730
于我们总的 iPhone 应用程序


53
00:03:16,797 --> 00:03:19,032
如果我们要把我们能做的一切


54
00:03:19,299 --> 00:03:21,301
都在 WatchKit 
扩展程序中完成


55
00:03:22,803 --> 00:03:26,273
所以 接下来我们要索求
那个后台任务的声明


56
00:03:26,640 --> 00:03:27,774
我们怎样做到这一步？


57
00:03:29,443 --> 00:03:31,678
做到这一步我们需要使用


58
00:03:33,113 --> 00:03:35,449
“合理执行到期活动”


59
00:03:35,883 --> 00:03:38,318
这一NSProcessInfo
上的方法。


60
00:03:39,486 --> 00:03:42,990
这一方法会向系统索求
一个后台任务声明


61
00:03:43,056 --> 00:03:45,926
并说“嘿 我可能仍需做件事情


62
00:03:45,993 --> 00:03:48,228
一旦你要暂停 WatchKit 
扩展程序”


63
00:03:49,329 --> 00:03:53,634
做法是 你向系统
传递一个调试字符串


64
00:03:53,700 --> 00:03:55,302
这里字符串是 networkReq


65
00:03:55,669 --> 00:03:57,771
然后系统就会执行那个程序块


66
00:03:58,505 --> 00:04:02,242
现在 该程序块就会立即被调用


67
00:04:02,342 --> 00:04:05,145
当系统调用
“合理执行到期活动 ”时


68
00:04:05,879 --> 00:04:08,048
现在 有些事情要牢记于心


69
00:04:08,115 --> 00:04:09,650
这些事情实在重要


70
00:04:10,117 --> 00:04:13,854
第一件事情是该程序块的执行


71
00:04:13,921 --> 00:04:15,389
将会在一个异步队列上安排


72
00:04:16,223 --> 00:04:19,392
所以你的主队列依然
会被释放出来用户将能与其界面


73
00:04:19,459 --> 00:04:21,495
进行互动这不会有任何问题


74
00:04:21,762 --> 00:04:25,032
用户不会感觉到有任何不同


75
00:04:25,999 --> 00:04:30,737
如果 “已到期” 变量设置为
“假”那就意味着


76
00:04:30,804 --> 00:04:32,906
我们的时间还没用完


77
00:04:33,173 --> 00:04:36,410
也就是 系统已经给了我们
一个后台任务声明


78
00:04:37,511 --> 00:04:39,713
然而 如果失效了


79
00:04:40,013 --> 00:04:44,151
那么久意味着系统不能给
我们提供一个后台任务中断


80
00:04:44,785 --> 00:04:47,054
这意味着系统不能正常的运行


81
00:04:48,088 --> 00:04:52,192
然而 如果说我们
已经有了一个后台任务中断


82
00:04:52,459 --> 00:04:55,262
这就意味着系统可能已经
觉得我们完全没有时间了


83
00:04:55,429 --> 00:04:59,700
所以便在把失效设定为正确之后


84
00:04:59,766 --> 00:05:01,468
再执行这个模块


85
00:05:02,002 --> 00:05:04,071
将会给你一段时间


86
00:05:04,371 --> 00:05:08,242
来确保你已经删除了
你所拥有的任何状态


87
00:05:08,542 --> 00:05:11,445
或者在WatchKit
扩展完全终止之前


88
00:05:11,512 --> 00:05:13,046
你需要做一些事情


89
00:05:14,448 --> 00:05:19,820
正如我所说的那样最关键的事情就是
这个模块需要用异步序列的方式去执行


90
00:05:21,355 --> 00:05:24,424
第二个很重要的就是一旦这个


91
00:05:24,791 --> 00:05:27,661
模块执行完毕


92
00:05:28,128 --> 00:05:30,197
然后你的时间消失


93
00:05:30,397 --> 00:05:32,599
它放弃了后台的任务中断


94
00:05:33,233 --> 00:05:36,703
因此我们要做的就是确保


95
00:05:36,770 --> 00:05:39,673
我们有足够的时间
去完成我们的网络请求


96
00:05:40,340 --> 00:05:41,808
可能需要两秒


97
00:05:42,042 --> 00:05:43,510
可能需要十秒


98
00:05:43,911 --> 00:05:44,878
可能花更多时间


99
00:05:47,481 --> 00:05:50,284 position:10%
我们将会利用称为调度信号量的东西


100
00:05:51,151 --> 00:05:55,422
调度信号量是中央调度
（GCD)的一部分


101
00:05:55,923 --> 00:06:00,527
这本质上允许我们
用一种异步队列的方式


102
00:06:00,594 --> 00:06:02,296
去暂停执行


103
00:06:03,830 --> 00:06:06,834
所以称之为“调度信号量等待”


104
00:06:07,301 --> 00:06:09,369
与此同时 它将会暂停执行


105
00:06:10,137 --> 00:06:13,507
但是 在你需要再一次重新启动的时候


106
00:06:13,640 --> 00:06:15,976
你可以请求“调度信号量信号”


107
00:06:16,977 --> 00:06:19,413
现在 请注意我已经经过了一段时间


108
00:06:19,713 --> 00:06:21,682
这本质上是一个超时


109
00:06:22,282 --> 00:06:24,251
在这儿我已经把它设置到30秒了


110
00:06:24,318 --> 00:06:25,519
当然也可以是其他数字


111
00:06:25,586 --> 00:06:29,489
然而我想确定的是
你知道一旦它到达30秒


112
00:06:29,923 --> 00:06:33,093
我应当获得我的数据或者报失


113
00:06:36,630 --> 00:06:38,665 position:10%
所以这可能有点抽象


114
00:06:38,999 --> 00:06:41,602
而且是有一点点先进的概念


115
00:06:41,802 --> 00:06:44,371
所以让我们看看实际中真正需要的代码


116
00:06:51,478 --> 00:06:55,816
好的 因此我这里有一个为
watchOS 1建立的


117
00:06:55,883 --> 00:06:57,584
WatchKit 扩充


118
00:06:58,452 --> 00:07:01,955
我面前是一个子集工作界面控制器


119
00:07:02,990 --> 00:07:06,260
您可以看到我做的
第一件事是创建一种属性


120
00:07:06,326 --> 00:07:08,529
用于执行会话数据任务


121
00:07:08,996 --> 00:07:11,331
我们将要用这个数据任务来


122
00:07:11,765 --> 00:07:14,835
从我们的网络服务中提取信息


123
00:07:17,104 --> 00:07:18,972
接下来将激活


124
00:07:19,606 --> 00:07:23,510
并实现您随时随地可以网络编码


125
00:07:23,710 --> 00:07:25,812
就这个例子来说 简而言之


126
00:07:26,046 --> 00:07:27,514
我正在做的就是即将激活


127
00:07:28,682 --> 00:07:31,318
首先我会检查数据任务的状态


128
00:07:31,485 --> 00:07:33,520
我还会看一下它是否已在运行


129
00:07:34,221 --> 00:07:37,858
因为如果用户抬起手腕 开始了互动


130
00:07:37,925 --> 00:07:40,994
开启了网络请求 放低了手腕


131
00:07:41,195 --> 00:07:44,798
启动了后台时间 接着又抬起手腕


132
00:07:44,865 --> 00:07:49,102
但是该请求还没有完成 
那么我不想再次启动网络请求


133
00:07:49,469 --> 00:07:51,772
我只会在当前没有网络请求运行时


134
00:07:51,839 --> 00:07:53,440
再次启动网络请求


135
00:07:56,677 --> 00:07:59,146
因此接下来我将创建一个网址


136
00:07:59,313 --> 00:08:01,748
仅指向我的网络服务


137
00:08:01,815 --> 00:08:04,918
这里它指向了应用商店的元数据


138
00:08:06,119 --> 00:08:09,690
一旦我有了这个网址我就开始创建信号


139
00:08:10,023 --> 00:08:11,992
称为“发送信号创建”


140
00:08:13,994 --> 00:08:17,998
接下来我将使用一种方法 我称之为


141
00:08:18,065 --> 00:08:19,533
“请求确认信号”


142
00:08:19,600 --> 00:08:21,702
来传送这个新创建的信号


143
00:08:23,103 --> 00:08:26,306
因此 如果我们审视使用
这种方法时正在发生的情形


144
00:08:26,440 --> 00:08:30,277
这其实就是我们所说的
“理性执行到期的活动”


145
00:08:30,711 --> 00:08:34,248
我们正在调试字符串传送
如果到期设设定为假


146
00:08:34,313 --> 00:08:37,417
那就意味着我们获得了一些后台时间


147
00:08:37,818 --> 00:08:40,087
而我正在通过我的逾时进行传送


148
00:08:40,386 --> 00:08:42,188
我称之为“发送信号等待”


149
00:08:42,923 --> 00:08:47,494
记住 这将会导致异步队列暂停执行


150
00:08:48,095 --> 00:08:51,665
没问题 用户依然可以与应用进行互动


151
00:08:51,732 --> 00:08:53,300
假如WatchKit
扩充进入了后台


152
00:08:53,367 --> 00:08:55,369
它就保持在那里


153
00:08:55,669 --> 00:08:58,539
确保了我们有足够的时间


154
00:08:58,772 --> 00:09:00,140
完成我们的网络请求


155
00:09:01,675 --> 00:09:04,545
那么 如果到期设定为“真”，


156
00:09:04,778 --> 00:09:07,648
这意味着我们或者没有接收到背景任务


157
00:09:07,714 --> 00:09:09,349
执行或者我们可能接受到了


158
00:09:09,516 --> 00:09:12,886
但是现在系统又再次调用它
说你已经超时


159
00:09:13,253 --> 00:09:15,189 position:10%
那么 我们将调用一个方法


160
00:09:15,255 --> 00:09:18,158
是我创建的称作“用信号释放执行” 


161
00:09:18,258 --> 00:09:20,194
再一次传那个信号


162
00:09:21,195 --> 00:09:25,065
所有这些方法实际上就叫“发送信号”


163
00:09:25,632 --> 00:09:28,502 position:10%
这允许执行恢复 而且它允许完成


164
00:09:28,569 --> 00:09:33,907
阻止 它也对调用非常关键


165
00:09:33,974 --> 00:09:38,545
因为如果我们停止
执行的时间太长 系统会认为


166
00:09:38,612 --> 00:09:41,682
我们的进程已经暂停 这样不好


167
00:09:41,815 --> 00:09:45,185
因为最后它直接停止了进程


168
00:09:45,485 --> 00:09:49,022
所以，我们没有任何
机会保存状态或做任何清理


169
00:09:49,323 --> 00:09:51,425
我们直接就被停止了


170
00:09:53,427 --> 00:09:55,863
好 那么让我们回到“意愿激活”


171
00:09:56,597 --> 00:09:58,632
所以我们被要求执行任务


172
00:09:58,699 --> 00:10:01,935
接下来要做的事情就是我们要使用


173
00:10:02,002 --> 00:10:04,137
我们的URL来创建数据任务


174
00:10:04,905 --> 00:10:07,407
现在 注意到我没有传送它


175
00:10:07,474 --> 00:10:10,844
不管我有没有背景任务执行


176
00:10:11,712 --> 00:10:13,981
背景任务执行技术


177
00:10:14,147 --> 00:10:16,884
是一个获得额外时间的方法 对吧？ 


178
00:10:17,117 --> 00:10:21,288
我的意思是它不能确保
但是我们希望能用此得到更好的体验


179
00:10:21,722 --> 00:10:24,424
所以我就创建我们网络要求


180
00:10:24,491 --> 00:10:28,762
因为可能用户
正在这时用app互动交流


181
00:10:29,196 --> 00:10:33,901 position:10%
网络要求已经开始并且
在很短的时间应答一切都很顺利


182
00:10:35,435 --> 00:10:39,740
你在此还看到有一个
用于数据任务的便利完成处理程序


183
00:10:40,240 --> 00:10:42,142
所以当要求结束时


184
00:10:42,409 --> 00:10:45,379
我将调用“用信号释放执行”


185
00:10:45,612 --> 00:10:47,347
再次传递那一信号


186
00:10:47,748 --> 00:10:51,185
所以我们允许对异步队列执行恢复


187
00:10:51,251 --> 00:10:54,221
这允许阻止完成


188
00:10:54,288 --> 00:10:57,057
然后 WatchKit
扩展可以完全挂起。


189
00:10:57,891 --> 00:11:01,428
这会确保系统不会认为操作进程已挂起


190
00:11:02,996 --> 00:11:06,033
这样 一旦创建数据任务


191
00:11:06,600 --> 00:11:11,271
我们就可以调用恢复来启动
这样它可以去网路


192
00:11:11,338 --> 00:11:15,309
获取信息 我们处理其余工作


193
00:11:19,780 --> 00:11:20,614
现在


194
00:11:22,149 --> 00:11:25,853
你对这项技术有了一些了解


195
00:11:25,919 --> 00:11:28,222
可以使用它尝试并行使


196
00:11:28,288 --> 00:11:32,826
WatchKit
extension内的联网权利


197
00:11:33,393 --> 00:11:37,197
这是非常不错的体验
因为进入到watchOS2


198
00:11:37,698 --> 00:11:40,634
你就会有很多可以利用的东西


199
00:11:40,767 --> 00:11:42,569
我们将对此稍作介绍


200
00:11:42,936 --> 00:11:45,739
但你如果已经联网到


201
00:11:45,873 --> 00:11:47,608
WatchKit
extension


202
00:11:47,674 --> 00:11:51,044
这将会使你做好准备一切都已经就绪


203
00:11:51,411 --> 00:11:56,083
我看到过许多例子在使用打开父代程序


204
00:11:56,350 --> 00:11:59,653
使内置的
iPhone app 完成联网


205
00:11:59,920 --> 00:12:01,722
这会中断桥接


206
00:12:05,826 --> 00:12:10,264
现在 在某些情况下
我们的网络服务不提供数据


207
00:12:10,564 --> 00:12:13,734
数据实际已经在内置的
iPhone app内


208
00:12:14,301 --> 00:12:15,502
如需要得到数据


209
00:12:15,836 --> 00:12:20,007
我们实际需要越过
watchOS 1中的进程


210
00:12:20,073 --> 00:12:22,009
从WatchKit
extension


211
00:12:22,075 --> 00:12:23,577
进入到内置的iPhone app


212
00:12:24,578 --> 00:12:27,748
我们可以使用打开父代程序来完成


213
00:12:27,814 --> 00:12:30,951
这是基于WK界面控制器的方法


214
00:12:31,185 --> 00:12:34,021
可以让我们发送信息词典


215
00:12:34,321 --> 00:12:37,391
到iPhone app
并在后台启动它


216
00:12:37,691 --> 00:12:40,961
让它进行一些处理并发送响应


217
00:12:42,429 --> 00:12:44,398
在UI程序委托上


218
00:12:44,665 --> 00:12:47,835
我们选择‘处理WatchKit 
extension请求响应’


219
00:12:48,502 --> 00:12:51,004
这将会进入信息词典


220
00:12:51,572 --> 00:12:55,008
进行一些处理并发送响应


221
00:12:56,276 --> 00:12:59,012
在使用中还需要考虑一些问题


222
00:13:00,047 --> 00:13:03,584
第一如果在‘处理WatchKit 
extension请求’中


223
00:13:03,650 --> 00:13:07,120
有任何异步操作 你应确保创建了


224
00:13:07,454 --> 00:13:10,457
一个后台任务


225
00:13:11,191 --> 00:13:14,328
你想在进入该方法后立刻完成


226
00:13:14,394 --> 00:13:17,631
原因是如果你离开并决定


227
00:13:17,698 --> 00:13:20,234
完成一些异步操作
那么不管它是多么琐碎


228
00:13:20,567 --> 00:13:22,703
系统会说‘好


229
00:13:22,769 --> 00:13:24,972
我想我们实际并不想做什么


230
00:13:25,038 --> 00:13:28,242
那么我就要去暂停
iPhone app了’


231
00:13:28,709 --> 00:13:31,512
然后 你将失去机会发送响应


232
00:13:33,180 --> 00:13:36,250
另一件事是在你将发送响应时


233
00:13:36,884 --> 00:13:38,752
如果使用定制对象


234
00:13:39,052 --> 00:13:41,255
则应把它们变成NSData


235
00:13:42,089 --> 00:13:45,359
如果使用定制的二元格式


236
00:13:45,425 --> 00:13:47,761
则可以在WatchKit
extension打开


237
00:13:47,928 --> 00:13:50,731
这样更可取因为一个重要的方面


238
00:13:50,797 --> 00:13:55,202
就是使数据尽可能变小这样传输才最快


239
00:13:58,272 --> 00:14:03,110
现在 对于设备对设备的交流
我们已有很多了解


240
00:14:04,278 --> 00:14:08,215
现在，在watchOS 2中
‘打开父代程序’标为不可用


241
00:14:08,649 --> 00:14:10,918
这是因为不再有这个必要


242
00:14:11,151 --> 00:14:12,286
也不再需要


243
00:14:12,853 --> 00:14:15,522
因为现在我们有了
WatchConnectivity


244
00:14:15,589 --> 00:14:16,490
framework


245
00:14:16,924 --> 00:14:20,594
这对我们有很大帮助


246
00:14:21,061 --> 00:14:25,132
我们不仅可以在iPhone
app之间发送信息


247
00:14:25,499 --> 00:14:27,034
而且还可以输送文件


248
00:14:27,334 --> 00:14:29,903
你还可以 也应当利用


249
00:14:30,170 --> 00:14:34,341
应用程序上下文


250
00:14:34,875 --> 00:14:37,678
这样就可以用最新信息


251
00:14:38,011 --> 00:14:40,080
更新该上下文


252
00:14:40,914 --> 00:14:44,151
同时使你可以获得网络上
Watch app内的信息


253
00:14:44,518 --> 00:14:47,487
也许这是提供的最新功能


254
00:14:48,021 --> 00:14:52,526
然后 你会说‘iPhone app
以后会需要这样所以我想终止它’


255
00:14:53,060 --> 00:14:54,494
它将会被转移


256
00:14:54,928 --> 00:14:56,797
但是iPhone app并未被启动


257
00:14:56,864 --> 00:14:59,766
因为它现在实际并不需要处理任何事情


258
00:15:00,267 --> 00:15:02,636
所以在这种情况下 它只是等待


259
00:15:02,803 --> 00:15:04,905
下一次iPhone app的启动


260
00:15:05,305 --> 00:15:10,110
这是在设备之间完成交流的高效方式


261
00:15:11,512 --> 00:15:13,113
这里 有一个精彩的演讲题目为


262
00:15:13,180 --> 00:15:15,516
“Watch 
Connectivity 介绍”


263
00:15:15,582 --> 00:15:18,252
你应当进行了解
如果还没这样做的话


264
00:15:20,821 --> 00:15:24,558
现在 一旦我们获得了数据
就需要进行管理


265
00:15:24,825 --> 00:15:28,428
和维护 然而我们需要
把它存放在硬盘中


266
00:15:29,563 --> 00:15:30,864
在watchOS 1中


267
00:15:30,998 --> 00:15:34,134
使用应用程序组是
做这项工作的一个非常好的方法


268
00:15:34,501 --> 00:15:36,904
你可以使用共享的应用组集合


269
00:15:37,104 --> 00:15:40,574
储存一些模型数据或一些共享资产


270
00:15:40,707 --> 00:15:42,176
内置iPhone app


271
00:15:42,242 --> 00:15:44,278
和WatchKit
extension


272
00:15:44,511 --> 00:15:46,613
可以指向并找到它们


273
00:15:49,216 --> 00:15:53,053
现在 你也可以使用共享的
NSUserdefaults


274
00:15:53,587 --> 00:15:57,191
但应当用于较小的状态数据


275
00:15:57,324 --> 00:15:59,560
比如 Boolean 
configuration


276
00:15:59,626 --> 00:16:01,662
或类似数据它并不适用于模型数据


277
00:16:01,862 --> 00:16:04,398
模型数据一般比较大


278
00:16:04,598 --> 00:16:09,603
应以平面文件保存


279
00:16:09,670 --> 00:16:13,574
在你的共享集合或数据存储中


280
00:16:15,976 --> 00:16:19,680
通常 针对watchOS 1
或watchOS 2


281
00:16:19,913 --> 00:16:23,183
你应考虑简化模型


282
00:16:24,351 --> 00:16:26,920
Apple Watch上的体验与


283
00:16:26,987 --> 00:16:28,422
iPhone是非常不同的


284
00:16:28,856 --> 00:16:34,261
所以你想确保得到信息是你所需要的


285
00:16:35,329 --> 00:16:38,165
这方面的一个例子是WWDC app


286
00:16:38,732 --> 00:16:41,468
多年以来 在WWDC app之中


287
00:16:41,735 --> 00:16:43,971
我们不再把实体增添到


288
00:16:44,037 --> 00:16:45,272
Core Data模型中


289
00:16:46,340 --> 00:16:50,277
当我们去进行Apple 
Watch的体验时


290
00:16:51,044 --> 00:16:52,446
我们看看它然后说


291
00:16:52,913 --> 00:16:55,616
我们实际上不需要
Watch上的这一切


292
00:16:56,183 --> 00:16:59,253
我们对此进行了讨论
并且最终认识到


293
00:16:59,319 --> 00:17:02,556
我们所需要的是数据的简化版


294
00:17:03,524 --> 00:17:06,226
我们仅仅需要这些演讲的简单列表


295
00:17:06,326 --> 00:17:09,863
包括演讲 实验以及收藏


296
00:17:10,964 --> 00:17:15,035
我们需要做的是
创建一个操作在任何时间


297
00:17:15,102 --> 00:17:16,936
内置iPhone app的
数据可以变化


298
00:17:17,304 --> 00:17:20,874
它可以输出一套简化的JSON文件


299
00:17:20,941 --> 00:17:22,675
到共享组集合


300
00:17:23,010 --> 00:17:25,412
WatchKit 
extension可以读取


301
00:17:25,479 --> 00:17:26,547
并予以展示


302
00:17:27,681 --> 00:17:28,749
这是非常棒的体验


303
00:17:31,385 --> 00:17:35,956
设备对应设备交流的最后一种方式是


304
00:17:36,256 --> 00:17:37,591
使用Handoff


305
00:17:38,358 --> 00:17:41,361
Handoff是一种
非常的方式可以让用户


306
00:17:41,428 --> 00:17:44,865
从Apple Watch到
iPhone上继续一项活动


307
00:17:46,099 --> 00:17:48,969
这方面的一个例子是如果你使用


308
00:17:49,036 --> 00:17:51,839
Apple Watch上的
WWDC app


309
00:17:52,573 --> 00:17:55,943
你会注意到iPhone的锁屏上


310
00:17:56,043 --> 00:17:57,578
在要查看的特定区域的左下角


311
00:17:58,111 --> 00:18:02,649
有WWDC app的图标


312
00:18:03,650 --> 00:18:06,320
现在 如果你从左下角向上滑动


313
00:18:06,653 --> 00:18:08,989
就会进入iPhone上
WWDC app 


314
00:18:09,256 --> 00:18:11,692
你想要的位置


315
00:18:12,860 --> 00:18:14,795
这对于用户来说非常有用


316
00:18:16,997 --> 00:18:19,166
使用Handoff非常简单


317
00:18:20,534 --> 00:18:22,569
你可以使用WK界面管理器


318
00:18:22,836 --> 00:18:24,972
更新用户活动


319
00:18:25,539 --> 00:18:30,344
你还可以向用户发送一个NS数据词典


320
00:18:30,711 --> 00:18:32,980
记住该词典应


321
00:18:33,046 --> 00:18:35,282
包括你需要的一切


322
00:18:35,616 --> 00:18:38,685
这样iPhone app
才能使用户到达


323
00:18:38,752 --> 00:18:40,053
他们想去的位置


324
00:18:40,287 --> 00:18:43,357
因此 无论你需要的数据多么琐碎


325
00:18:43,690 --> 00:18:46,159
都需要输入到词典中


326
00:18:48,729 --> 00:18:53,066
这样 系统会自动为你工作


327
00:18:53,433 --> 00:18:58,405
其中之一是自动使用户活动


328
00:18:58,639 --> 00:18:59,973
在一段时间后失效


329
00:19:00,574 --> 00:19:02,843
所以你什么都不用做


330
00:19:02,910 --> 00:19:06,513
给用户足够的时间拿出电话


331
00:19:06,680 --> 00:19:07,915
去他们想去的地方


332
00:19:08,382 --> 00:19:11,418
如果你再次调用‘更新用户活动’


333
00:19:11,652 --> 00:19:14,021
即是目前的活动


334
00:19:14,588 --> 00:19:16,957
如果他们切换到另一应用


335
00:19:17,157 --> 00:19:19,092
而该应用调用‘更新用户活动’


336
00:19:19,193 --> 00:19:20,794
即是目前的活动


337
00:19:22,362 --> 00:19:25,532
现在 如果你
已经调用了‘更新用户活动’


338
00:19:25,766 --> 00:19:28,769
但是当时用户正在与你的应用进行交互


339
00:19:29,136 --> 00:19:31,939
他们轻敲一个按钮
确实可以使背景发生转换


340
00:19:32,673 --> 00:19:36,476
你实际上可自己手动使用户活动无效


341
00:19:37,878 --> 00:19:41,548
如果没有出现这种情况你什么都不用做


342
00:19:44,117 --> 00:19:45,552
因此数据足够


343
00:19:46,753 --> 00:19:51,525
我希望watchOS 1对你有用


344
00:19:51,625 --> 00:19:53,760
尤其是 一旦你开始使用


345
00:19:54,127 --> 00:19:56,797
WatchConnectivity
framework 


346
00:19:56,864 --> 00:19:59,900
它即会帮你
向watchOS 2过渡


347
00:20:01,068 --> 00:20:03,237
现在让我们来谈谈界面组件


348
00:20:04,037 --> 00:20:06,607
在你创造这个世界创建这些数据时


349
00:20:06,940 --> 00:20:11,345
你最不希望给用户的体验


350
00:20:11,612 --> 00:20:13,480
是加载指示条


351
00:20:13,547 --> 00:20:15,983
你所做所有这些是为了一个控制器


352
00:20:16,416 --> 00:20:18,952
每一件东西用户可能都会想要或需要


353
00:20:20,787 --> 00:20:24,625
让我们看看如何能够优化这种体验


354
00:20:25,058 --> 00:20:26,660
我们如何能够加载更快？


355
00:20:28,729 --> 00:20:30,230
其中一种方法是我们可以...


356
00:20:30,397 --> 00:20:34,902
通过优选加载方法和时间来实现


357
00:20:35,402 --> 00:20:37,237
所以你这里可以看到
watchOS 1的


358
00:20:37,371 --> 00:20:38,605
Weather app


359
00:20:39,039 --> 00:20:42,009
而且我们有这个漂亮的大信息环


360
00:20:42,643 --> 00:20:45,946 position:10%
对吗？我们想立刻把它呈现给用户


361
00:20:48,248 --> 00:20:50,484
但是我们还有个10日预报


362
00:20:50,984 --> 00:20:53,987
这个10日预报包括另外一些图像


363
00:20:54,288 --> 00:20:58,458
表格行 数据 而我们也
不一定想要用户


364
00:20:58,525 --> 00:21:01,728
等我们加载所有这些东西


365
00:21:02,963 --> 00:21:04,464
因此我们采用一种技术使得我们在


366
00:21:04,531 --> 00:21:06,433
‘异步分派’内加载10日预报时


367
00:21:06,733 --> 00:21:10,204
call within将激活


368
00:21:11,705 --> 00:21:14,441
现在，这样做可以使得
will activate完成


369
00:21:14,575 --> 00:21:16,009
而一旦我们有了这个图像


370
00:21:16,243 --> 00:21:18,145
则最先显示它


371
00:21:18,412 --> 00:21:21,081
因此我们将其呈现在
will activate即可完成


372
00:21:21,248 --> 00:21:25,519
之后即立刻加载10日预报


373
00:21:26,119 --> 00:21:28,689
而用户实际并未看出有什么不同


374
00:21:28,956 --> 00:21:32,960
当我们向下滚动至10日预报
则它已经在那里了


375
00:21:33,594 --> 00:21:38,065
但是我们已经能够
给大家所有数据立即加载


376
00:21:38,131 --> 00:21:39,867
并且更快的印象了


377
00:21:41,902 --> 00:21:45,305
其他你能够做的就是
少直接加载几个表格单元格


378
00:21:46,039 --> 00:21:50,010
对吗？如果你确实
有带图表和数据的单元格


379
00:21:50,177 --> 00:21:54,515
那么你可能只要四五个这样的单元格


380
00:21:54,581 --> 00:21:56,750
直接显示给用户即可


381
00:21:56,817 --> 00:21:59,620
这些加载之后


382
00:22:00,020 --> 00:22:01,421
你可能希望能够在别处加载


383
00:22:01,822 --> 00:22:03,290
因此看一下


384
00:22:05,692 --> 00:22:09,196
同时 只要更新
实际发生变更的信息即可


385
00:22:09,463 --> 00:22:11,899
我见过许多数据只做了一点小小变更


386
00:22:11,965 --> 00:22:15,002
就全部重新加载的例子


387
00:22:15,636 --> 00:22:16,670
无需如此


388
00:22:16,970 --> 00:22:21,141
只要更新这个屏面实际
需要更新的内容就可以了


389
00:22:23,277 --> 00:22:26,513
现在 我们一旦进入界面
Builder你就能看到


390
00:22:26,580 --> 00:22:29,283
我已经在为控制器创建我的布局了


391
00:22:30,017 --> 00:22:32,519
而我将用到许多不同的群组


392
00:22:32,586 --> 00:22:34,488
我将隐藏和显示许多不同的群组


393
00:22:34,755 --> 00:22:37,591
因为根据某些数据或启发


394
00:22:37,658 --> 00:22:40,827
我只打算一次显示一个
也可能一次两个


395
00:22:42,362 --> 00:22:45,232
但是实际上我已经将所有这些东西


396
00:22:45,299 --> 00:22:50,437
放在我的控制器里了也就是说
系统将会把这些全部实例化


397
00:22:50,938 --> 00:22:55,442
因为我们实际上并不知道你什么
时候会决定隐藏或显示其内容


398
00:22:55,776 --> 00:22:59,313
因此在某些情形下你可以对其稍作优化


399
00:22:59,479 --> 00:23:02,049
方法是将这些分到一些单独的控制器中


400
00:23:02,683 --> 00:23:05,485
如果必要时你能够加载其中某个


401
00:23:05,552 --> 00:23:07,087
你确实会需要的控制器


402
00:23:07,421 --> 00:23:08,922
那么就最好了


403
00:23:12,259 --> 00:23:14,828
现在 穿过我们的界面组件


404
00:23:15,362 --> 00:23:18,799
其中你可能常用的是图像


405
00:23:19,600 --> 00:23:23,537
而图像应该大小合适 来自你的服务器


406
00:23:23,704 --> 00:23:25,172
或所包括的iPhone app


407
00:23:25,906 --> 00:23:30,010
我看到过许多这样的例子图像较大


408
00:23:30,077 --> 00:23:33,413
甚至比42毫米的watch还大


409
00:23:33,780 --> 00:23:36,917
而该图像其实只是
随处被重复使用和重新缩放


410
00:23:37,618 --> 00:23:40,187
我这里的意思是
对于缩放 还有其他性能上的含义


411
00:23:40,254 --> 00:23:43,857
而图像不会像它看起来那么好


412
00:23:43,924 --> 00:23:48,195
因为你没有给它你恰好需要的尺寸


413
00:23:48,729 --> 00:23:51,899
所以要给出正确尺寸的asset


414
00:23:52,232 --> 00:23:56,937
在watchOS 2中
这可能对视频很关键


415
00:23:59,106 --> 00:24:01,909
你也可以优化你的图像


416
00:24:02,242 --> 00:24:06,046
方法是采用‘设定图像数据’
而不只是‘设定图像’


417
00:24:07,114 --> 00:24:09,716
此时‘设定图像’


418
00:24:09,783 --> 00:24:12,886
只是要采用我们所用的默认压缩


419
00:24:13,654 --> 00:24:15,155
通过‘设定图像数据’


420
00:24:15,222 --> 00:24:20,294
你可以得到PNG压缩或JPG压缩


421
00:24:20,694 --> 00:24:23,630
之后转成NS数据blob


422
00:24:24,131 --> 00:24:26,099
以传送至Watch


423
00:24:26,300 --> 00:24:29,770
从而你可以确保其大小符合你的需要


424
00:24:32,172 --> 00:24:35,242
同时 我确信你听人们说过这样的话


425
00:24:35,309 --> 00:24:37,311
你应该用asset catalog


426
00:24:37,978 --> 00:24:42,316
asset catalog不仅是
整理其中内容的好方法


427
00:24:42,783 --> 00:24:45,319
而且还能够为你做很多别的事情


428
00:24:45,385 --> 00:24:50,624
你可以设定该
asset用于哪些具体设备


429
00:24:51,325 --> 00:24:56,129
你可以设定并轻松看到
‘是的 我有了2x asset


430
00:24:56,530 --> 00:25:00,467
38毫米版本和42毫米版本’


431
00:25:02,102 --> 00:25:06,006
目前 许多开发者问我...


432
00:25:06,173 --> 00:25:07,975
这些插槽每一个
都什么时候用以及用在哪


433
00:25:08,041 --> 00:25:09,710
那么让我们一起来看看。


434
00:25:10,777 --> 00:25:13,480
首先是2x asset


435
00:25:13,947 --> 00:25:18,418
这个用于你想要在两台设备


436
00:25:18,552 --> 00:25:20,721
以相同尺寸采用的图像


437
00:25:21,088 --> 00:25:25,292
所以 如果是这样
你可以将它插入2x插槽即可


438
00:25:25,359 --> 00:25:27,094
其他地方用法相同


439
00:25:28,729 --> 00:25:33,267
你还可以针对38毫米
提供具体的asset


440
00:25:34,334 --> 00:25:38,338
现在 这可能就是
你要插入2x插槽的图像


441
00:25:38,739 --> 00:25:39,573
没问题


442
00:25:41,074 --> 00:25:44,444
然后你可以给出
一个具体的asset


443
00:25:44,511 --> 00:25:49,082
针对可能大一些的
42毫米版本会有所不同


444
00:25:49,950 --> 00:25:52,986
现在 如果你既有38毫米


445
00:25:53,053 --> 00:25:57,057
也有42毫米 没问题
也用2xasset


446
00:25:57,124 --> 00:26:00,961
因为我们要回退到该asset


447
00:26:01,361 --> 00:26:06,300
所以 如果我们用
38毫米版本或42毫米版本


448
00:26:06,600 --> 00:26:08,802
我们要回退到2x asset


449
00:26:09,636 --> 00:26:12,606
这样 你的代码库将永不过时


450
00:26:15,375 --> 00:26:19,379
另一项我们发现对WWDC app
确实有用的技术


451
00:26:19,847 --> 00:26:21,315
正在采用PDFs


452
00:26:22,950 --> 00:26:26,720
通过采用PDFs 你可以从各工具中


453
00:26:26,954 --> 00:26:29,122
去除整批free work


454
00:26:30,190 --> 00:26:32,426
首先 你可以设定缩放因子


455
00:26:33,760 --> 00:26:37,497
你还可以设定图像生成的类型


456
00:26:37,698 --> 00:26:40,767
作为模板图像所以如果你要给图像着色


457
00:26:40,934 --> 00:26:43,637
那么去看看PDF的α值


458
00:26:44,905 --> 00:26:48,709
如果你仍然想要你特别放入
你的asset中的这些颜色


459
00:26:48,775 --> 00:26:51,144
你也可以设定为原图


460
00:26:52,312 --> 00:26:57,851
这里所有事情就是当系统为你打包时


461
00:26:57,918 --> 00:27:01,421
当你前去创建它时
我们要剪切这个PDF


462
00:27:01,488 --> 00:27:06,193
所有尺寸及比例按你的需要
用于你支持的设备


463
00:27:07,027 --> 00:27:08,962
免费的资源很多


464
00:27:10,264 --> 00:27:13,534
另一件很酷的事情
是你可以把PDF文件


465
00:27:13,600 --> 00:27:16,036
与位图进行混合和匹配


466
00:27:16,470 --> 00:27:20,674
你可以把这两种格式的文件
组合进一个PDF备用脚本


467
00:27:21,475 --> 00:27:26,046
这样就可以分别得到38毫米


468
00:27:26,113 --> 00:27:27,681
和42毫米版本的位图了


469
00:27:31,084 --> 00:27:35,689
说完图片 我们来说说动画图像


470
00:27:36,223 --> 00:27:41,461
在watchOS 1里 我们提供了
一个你可以大加利用的动画图像序列


471
00:27:41,895 --> 00:27:44,164
在watchOS2里也可以这样做


472
00:27:44,898 --> 00:27:48,001
但是不要忘了如果你的屏幕上


473
00:27:48,068 --> 00:27:50,571
同时有多个动画图像 嗯


474
00:27:50,637 --> 00:27:53,440
你就需要做更多处理和渲染


475
00:27:55,809 --> 00:27:59,346
你需要注意的另外一点是你要尽量控制


476
00:27:59,613 --> 00:28:05,052
自己减少每部动画的帧数


477
00:28:05,819 --> 00:28:09,189
我见过很多的这样的案例
一段只有两秒的动画


478
00:28:09,256 --> 00:28:10,691
里面足足有300帧


479
00:28:11,291 --> 00:28:12,659
似乎有点儿过分了


480
00:28:13,427 --> 00:28:16,363
如果帧数减少了 但是仍然


481
00:28:16,430 --> 00:28:18,732
可以得到你真正想要的效果


482
00:28:18,799 --> 00:28:20,300
你会感到惊喜的


483
00:28:21,969 --> 00:28:26,673
另一项你可以对这些动画图像
进行的操作是逆向播放


484
00:28:27,274 --> 00:28:29,643
你不必另行创建一个全新的图像集


485
00:28:30,077 --> 00:28:32,412
你只需选取一个已有的动画文件


486
00:28:32,579 --> 00:28:35,215
将时间设置为负值


487
00:28:35,949 --> 00:28:39,887
这项操作叫做“用图片启动动画”


488
00:28:40,287 --> 00:28:42,422
你来设定一个负时间值


489
00:28:43,423 --> 00:28:46,560
请注意我的时间范围是正向的


490
00:28:47,094 --> 00:28:50,430
跨度是从0到15


491
00:28:50,497 --> 00:28:51,765
这里我没做改变


492
00:28:52,466 --> 00:28:53,500
只更改了持续时间


493
00:28:55,502 --> 00:29:01,775
现在如果你喜欢动画在watchOS
2环境里 你可以大展拳脚了


494
00:29:02,709 --> 00:29:06,280
在watchOS 2里 我们引入了
一个动画应用程序界面API


495
00:29:06,346 --> 00:29:07,848
它是WatchKit的一个部分


496
00:29:08,048 --> 00:29:11,385
让你可以在你的Watch
app里制作出流畅的


497
00:29:11,451 --> 00:29:12,819
效果强大的动画作品


498
00:29:13,921 --> 00:29:16,857
它与UIView的动画工作原理近似


499
00:29:17,191 --> 00:29:20,460
你可以自行设定时间长度 还一个模块


500
00:29:20,527 --> 00:29:22,829
可以在这个区域重置一些属性


501
00:29:22,896 --> 00:29:24,631
这些最终都将合成在你的动画作品里


502
00:29:25,732 --> 00:29:30,204
你可以设置动画的高度 宽度 通道


503
00:29:30,571 --> 00:29:32,639
内容嵌入以及其他属性


504
00:29:32,806 --> 00:29:36,743
到目前为止 我已经见到了人们用这个
程序制作的一些相当了不起的作品


505
00:29:36,810 --> 00:29:39,680
而且只用到了间隔组和移动项


506
00:29:39,847 --> 00:29:41,014
相当了不起


507
00:29:42,316 --> 00:29:47,588
在“WatchKit布局
和动画技术”中 还有很多有用的工具


508
00:29:48,789 --> 00:29:53,927
关于图像处理 我建议大家


509
00:29:53,994 --> 00:29:57,397
关注今天的讲座中"Apple
Watch设计建议与技巧"这一部分


510
00:29:57,564 --> 00:30:02,636
它将会从设计者心态的
角度涉及很多的相关技巧


511
00:30:02,703 --> 00:30:04,605
还会谈及大量


512
00:30:04,671 --> 00:30:06,273
你可以做和应该了解的操作


513
00:30:06,640 --> 00:30:07,574
所以 一定要关注


514
00:30:09,209 --> 00:30:14,348
配置的最后一块是
文本输入控制器的使用


515
00:30:15,649 --> 00:30:18,719
现在 很多开发人员问我怎样才能


516
00:30:18,785 --> 00:30:23,457
使用户直接从我的UI进入?听写UI


517
00:30:25,592 --> 00:30:27,828
他们不希望自己的用户要经过


518
00:30:27,895 --> 00:30:30,864
中间筛屏幕 并不停地敲击麦克风


519
00:30:30,931 --> 00:30:33,433
这样做相当 相当直接


520
00:30:34,301 --> 00:30:39,940
你只要在调用“目前的文本输入器
与建议”时 把建议设定为零


521
00:30:40,541 --> 00:30:43,777
然后把“允许输入模式”设定为普通


522
00:30:44,611 --> 00:30:47,447
这样就可以把用户从你的app直接


523
00:30:47,514 --> 00:30:51,018
转入听写UI然后再返回你的app


524
00:30:51,451 --> 00:30:52,653
极其简单


525
00:30:56,857 --> 00:30:59,026
现在我们要谈谈通知机制


526
00:30:59,459 --> 00:31:02,896
消息通知是Apple Watch上
一项意义重大的体验


527
00:31:02,963 --> 00:31:05,732
Apple Watch能够如此
操作简便 表现惊人


528
00:31:05,799 --> 00:31:07,935
很大程度上归功于此


529
00:31:10,003 --> 00:31:14,408
让我们看一个远程
通知的有效载荷的例子


530
00:31:14,775 --> 00:31:17,110
让我们浏览一些你应该清楚的


531
00:31:17,177 --> 00:31:20,047
为了让用户的手腕得到最好


532
00:31:20,113 --> 00:31:22,583
最高效的体验而使用的技术


533
00:31:23,984 --> 00:31:29,089
首先要注意的是
你应该正在使用报警键的字典值


534
00:31:29,890 --> 00:31:32,426
这让你可以不仅提供一段正文


535
00:31:32,726 --> 00:31:34,661
还可以设定一个标题


536
00:31:35,629 --> 00:31:38,999
而且这个标题可以被用在
short-look通知里


537
00:31:39,633 --> 00:31:43,437
所以当用户在Apple 
Watch上收到通知时


538
00:31:43,504 --> 00:31:47,374
他们首先看到的就是你的app的又大


539
00:31:47,441 --> 00:31:51,812
又漂亮的图标 然后要看到的
是在屏幕底部的你的app的名字


540
00:31:52,412 --> 00:31:55,315
如果你在有效负荷里提供了一个标题


541
00:31:55,382 --> 00:31:58,986
图标和app名称之间看到那个标题


542
00:31:59,620 --> 00:32:03,557
这样可以使通知的内容大为丰富 


543
00:32:03,924 --> 00:32:07,694
非常了不起 因为那么多的用户 


544
00:32:07,761 --> 00:32:10,397
要看他们的手腕他们会看到那条通知


545
00:32:10,464 --> 00:32:13,467
并根据其信息决定他们是要继续看


546
00:32:13,534 --> 00:32:15,502
long-look 通知


547
00:32:15,903 --> 00:32:19,439
还是把它先放下 
过一段时间再到通知中心查看


548
00:32:20,240 --> 00:32:22,009
所以要好好利用它


549
00:32:23,844 --> 00:32:26,180
另一个要运用的功能
是categary(类别)


550
00:32:26,780 --> 00:32:29,349
Categories（类别）
让你可以指定


551
00:32:29,516 --> 00:32:33,587
使用记事板中的具体哪一种控制器


552
00:32:33,921 --> 00:32:36,089
来发送某种类型的信息


553
00:32:36,823 --> 00:32:40,027
所以如果你点击通知类别对象


554
00:32:40,460 --> 00:32:42,462
你可以在这里看到 你可以给它设置


555
00:32:42,529 --> 00:32:48,168
与在有效负荷中相同的名称
所以你可以给每条通知设置


556
00:32:48,502 --> 00:32:51,271
文本颜色和标题颜色


557
00:32:51,505 --> 00:32:55,542
所以你就有很多办法


558
00:32:55,609 --> 00:32:57,578
可以给通知设置多种属性


559
00:32:57,878 --> 00:32:59,980
给用户更好的体验


560
00:33:02,249 --> 00:33:06,153
现在是最后一步 
如果你想让客户收到通知


561
00:33:06,386 --> 00:33:10,123
听到通知提示音并收到触觉反馈


562
00:33:10,591 --> 00:33:13,894
你需要设置音量值为默认值


563
00:33:15,028 --> 00:33:16,330
这样可以确保


564
00:33:16,597 --> 00:33:19,533
他们收到提示音和反馈


565
00:33:21,134 --> 00:33:26,473
现在 我非常高兴地告诉大家你也
可以用UI本地通知来实现这些效果


566
00:33:26,907 --> 00:33:29,810
所以 这些设置不仅可以用在远程通知


567
00:33:32,913 --> 00:33:36,517
现在 共有两个通知的概念


568
00:33:37,217 --> 00:33:39,620
第一个是动态通知


569
00:33:39,786 --> 00:33:42,189 position:10%
你可能在有效负荷中收到一些信息


570
00:33:42,422 --> 00:33:44,858
你需要处理这些信息
你需要得到一种资产


571
00:33:44,925 --> 00:33:47,528
你需要进行一些操作 然后你要上传


572
00:33:47,828 --> 00:33:50,998 position:10%
更多丰富的内容到你的动态信息中


573
00:33:51,431 --> 00:33:53,467
还有一种静态信息


574
00:33:53,800 --> 00:33:57,070
很多人问过我哪里会用到这种信息


575
00:33:57,804 --> 00:34:03,043
静态信息总是由通知中心发出


576
00:34:03,610 --> 00:34:08,849
所以如果用户点击通知中心发出的信息


577
00:34:08,916 --> 00:34:11,552
他们一定会看到静态界面


578
00:34:11,985 --> 00:34:15,222
所以你要确保这同时是一个很好的体验


579
00:34:16,389 --> 00:34:19,659
使用静态通知的另一种情况


580
00:34:20,027 --> 00:34:23,897
是你的动态通知下载时间过长


581
00:34:24,364 --> 00:34:27,868
你可能正在处理一些数据从网络检索


582
00:34:27,935 --> 00:34:30,670
一些资产 而且需要很长时间


583
00:34:31,004 --> 00:34:33,306
那么我们就要称之为损耗


584
00:34:33,607 --> 00:34:38,545
并以静态信息的方式
立即为客户提供一些有价值的信息


585
00:34:41,547 --> 00:34:44,217
现在我们终于可以聊一聊
Glances


586
00:34:45,918 --> 00:34:49,822
有了Glances就可以为客户提供


587
00:34:49,889 --> 00:34:52,993
有价值的及时信息


588
00:34:54,761 --> 00:34:58,365
你可能见过这样的情况在隔了一会儿


589
00:34:58,432 --> 00:35:01,468
查看Glances时试图显示


590
00:35:01,535 --> 00:35:03,637
内容有了更新


591
00:35:03,704 --> 00:35:07,574
你在页面底部看到
这个更新了的最近的标题字符串


592
00:35:07,875 --> 00:35:11,211
在页面上端右部看到
这个旋转的进度指示器


593
00:35:12,279 --> 00:35:15,115
但是也许你看见它的时候正在下载信息


594
00:35:17,217 --> 00:35:18,352
所以 让我们再看一遍


595
00:35:18,986 --> 00:35:21,555
你正在下载内容一切进展顺利


596
00:35:21,622 --> 00:35:24,791
然后 哦 内容去哪儿了 嘣


597
00:35:24,858 --> 00:35:26,827
更新完全停止了


598
00:35:28,028 --> 00:35:29,196
为什么会发生这种情况?


599
00:35:29,930 --> 00:35:33,534 position:10%
这种情况能够发生
是因为在你的Glance控制器中


600
00:35:33,600 --> 00:35:35,669
对于“将要激活”要采取
稍有不同的处理方式


601
00:35:36,537 --> 00:35:41,909
那么会发生的情况是当“将要激活”
完成的时候这个系统提供的快照


602
00:35:42,176 --> 00:35:44,077
就会从UI上移除


603
00:35:44,778 --> 00:35:49,049
所以与你在Watch app里
的做法稍有不同


604
00:35:49,383 --> 00:35:53,487
你在这里要确保的是
你要在“将要激活”完成之前


605
00:35:53,620 --> 00:35:54,621
选择完全安装


606
00:35:54,988 --> 00:35:56,857
你要得到你需要的所有信息


607
00:35:57,024 --> 00:36:00,527
这样设置 就会完全安装UI


608
00:36:00,594 --> 00:36:03,564
在我们移除那个快照的时候
UI已经安装好了


609
00:36:03,830 --> 00:36:07,367
整个镜像消失没有中间状态


610
00:36:07,634 --> 00:36:10,904
在你的记事本中
可能有你会看到的占位符文本


611
00:36:10,971 --> 00:36:13,273
或者作用近似的文件


612
00:36:13,774 --> 00:36:15,943
这些并不能提供真正好的体验


613
00:36:17,511 --> 00:36:21,281
另一件你应该做的事
是慎重对待重新加载内容


614
00:36:21,682 --> 00:36:24,985
用户在Glances中切换屏幕时


615
00:36:25,853 --> 00:36:28,388
"将要激活" 会出现在你的页面上


616
00:36:28,455 --> 00:36:31,058
所以 如果它出现在你的页面上


617
00:36:31,124 --> 00:36:34,194
而且在 "将要激活"中
你正在下载一大堆东西 


618
00:36:34,261 --> 00:36:37,064
进行文件处理 进行网络请求


619
00:36:37,598 --> 00:36:40,734
恐怕你的效率会大打折扣


620
00:36:40,868 --> 00:36:43,971
所以重新装载时一定要慎重


621
00:36:44,137 --> 00:36:47,074
根据其他情形而不仅仅是 哦


622
00:36:47,140 --> 00:36:48,442
他们看了我的内容


623
00:36:50,077 --> 00:36:52,646
另外 与Watch app一样


624
00:36:52,713 --> 00:36:54,781
要限制比较设计的数量


625
00:36:55,148 --> 00:36:59,353
因为和之前一样我们将需要
在最前面实例化那些对象


626
00:37:02,189 --> 00:37:05,726
最后 如果你要在
Glances中显示时间或日期


627
00:37:06,059 --> 00:37:10,063
你应该使用WK界面的时间标签


628
00:37:10,130 --> 00:37:11,965
或者绝对时间或日期


629
00:37:12,900 --> 00:37:14,868
如果你要这这里找到一个例子


630
00:37:15,002 --> 00:37:18,038
本次讲座在35分钟前开始


631
00:37:18,572 --> 00:37:23,410
那么 如果现在是
下午1:00让人有点糊涂了


632
00:37:23,644 --> 00:37:24,912
我看到讲座在不断进行


633
00:37:24,978 --> 00:37:27,214
我知道 但是它是在35分钟前开始的


634
00:37:27,281 --> 00:37:29,883
让我有种下意识地反应像是 等等


635
00:37:30,150 --> 00:37:31,652
现在究竟是什么时间


636
00:37:32,486 --> 00:37:36,290
这种情况下比较好的做法是
给出一个绝对时间


637
00:37:36,857 --> 00:37:38,625
讲座在10:00开始


638
00:37:38,959 --> 00:37:41,728
这就已经给了我可视性


639
00:37:41,795 --> 00:37:45,098
"哦，既然现在是
1:00 或 3:00"


640
00:37:45,399 --> 00:37:46,466
我并没有糊涂


641
00:37:46,700 --> 00:37:48,869
内容在载入中 进展顺利


642
00:37:50,938 --> 00:37:53,974
我们已经谈到了很多东西


643
00:37:54,741 --> 00:37:56,176
首先 我们谈到过优化


644
00:37:56,243 --> 00:37:59,479
watchOS 1
应用程序的网络的方法


645
00:37:59,546 --> 00:38:02,349
这样要转换为watchOS 2


646
00:38:02,416 --> 00:38:04,451
就更容易了 而且这很有可能


647
00:38:04,751 --> 00:38:08,222
对你的应用程序有帮助


648
00:38:09,723 --> 00:38:12,392
然后 我们谈到过改善


649
00:38:12,459 --> 00:38:17,564
性能布局的方法 以缩短
下载时间 提高运行效率


650
00:38:18,866 --> 00:38:21,134
然后 我们又谈到了如何确保


651
00:38:21,201 --> 00:38:23,370
你的Glances的内容可视


652
00:38:23,704 --> 00:38:26,840
这样就不会让用户看到
面前的镜像一片空白


653
00:38:28,876 --> 00:38:33,380
最后在watchOS 2 还有许多
需要核查的东西


654
00:38:33,747 --> 00:38:37,518
除了在WatchKit中对
watchOS 2的更新


655
00:38:37,584 --> 00:38:39,119
我们还有ClockKit


656
00:38:39,186 --> 00:38:42,155
来为时钟表面进行复杂设计


657
00:38:42,389 --> 00:38:43,223
我们还有


658
00:38:43,290 --> 00:38:45,125
WatchConnectivity
框架


659
00:38:45,192 --> 00:38:48,095
来进行所有设备到设备的交流


660
00:38:48,161 --> 00:38:50,731
你还可以利用WatchKit 


661
00:38:50,797 --> 00:38:52,566
本身的延伸NSURL


662
00:38:54,735 --> 00:38:58,038
如果你想了解更多的信息
可以查看我们的文档


663
00:38:58,172 --> 00:38:59,373
我们有代码样本


664
00:38:59,573 --> 00:39:03,010
如果你有技术问题 可以让论坛咨询


665
00:39:03,243 --> 00:39:06,346
你会得到与开发人员技术支持部
提供的相似的一对一的帮助


666
00:39:07,114 --> 00:39:09,216
最后 如果你有任何问题


667
00:39:09,283 --> 00:39:11,552
请随时与我联系这是我的email


668
00:39:13,020 --> 00:39:17,724
今天我们还有一场关于Apple
Watch 的精彩演讲


669
00:39:17,791 --> 00:39:20,060
题目是 "Apple Watch
设计建议与技巧"


670
00:39:20,460 --> 00:39:23,897 position:10%
演讲会涉及许多很棒的信息


671
00:39:24,097 --> 00:39:26,667
帮助你开发了不起的
Watch app


672
00:39:26,733 --> 00:39:28,702
我们还进行了一场
名为 "Designing


673
00:39:28,769 --> 00:39:30,504
for Apple 
Watch" 的演讲


674
00:39:30,571 --> 00:39:32,606
一场名为"Introduction
to WatchKit


675
00:39:32,673 --> 00:39:34,441
for watchOS 2"
 的演讲 还有其它演讲


676
00:39:34,508 --> 00:39:36,143
总之 非常感谢

