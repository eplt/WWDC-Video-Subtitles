1
00:00:20,487 --> 00:00:25,192
Code Audio新特性


2
00:00:30,898 --> 00:00:33,133
谢谢 大家下午好 


3
00:00:33,867 --> 00:00:36,470
欢迎参加Code Audio
新特性说明会议


4
00:00:37,371 --> 00:00:41,441
我是阿克厦沙·纳格什
本会议第一个发言者


5
00:00:43,310 --> 00:00:47,648
我将谈谈AV音频引擎


6
00:00:48,315 --> 00:00:52,953
及其今年发行的
iOS and OS X的新功能


7
00:00:53,921 --> 00:00:56,456
之后我的同事托里会讲


8
00:00:56,857 --> 00:00:58,926
我们所售产品其他令人兴奋的新功能


9
00:00:58,992 --> 00:01:02,062
像今年的跨设备音频功能


10
00:01:02,529 --> 00:01:05,866
以及AV Audio
Engine的新特点


11
00:01:07,067 --> 00:01:10,337
明天早上我们
有另一场Core Audio说明


12
00:01:10,704 --> 00:01:15,209
又称为Audio Unit 
Extensions是一套新API


13
00:01:15,275 --> 00:01:18,312
我相信你会觉得很有意思


14
00:01:18,745 --> 00:01:20,747
所以请不要错过那个说明会


15
00:01:23,550 --> 00:01:24,384
好吧


16
00:01:24,484 --> 00:01:28,021
我们首先回顾一下
AV Audio Engine


17
00:01:30,657 --> 00:01:33,760
如果你知道Core Audio 
你可能会注意到


18
00:01:33,894 --> 00:01:36,964
我们提供了各种各样的API


19
00:01:37,297 --> 00:01:39,766
来增强音频功能


20
00:01:40,834 --> 00:01:45,272
去年在iOS 8和OS X 
Yosemite系统上


21
00:01:45,772 --> 00:01:47,374
我们引入了一套新的


22
00:01:47,441 --> 00:01:51,812
基于C语言的API 
即AV Audio Engine


23
00:01:51,879 --> 00:01:54,081
是AVFoundation
框架的组成部分


24
00:01:55,482 --> 00:01:58,552
如果您不是很熟悉
AV Audio Engine


25
00:01:58,619 --> 00:02:01,021
我强烈建议你看看


26
00:02:01,321 --> 00:02:06,059
我们去年的WWDC上关于
Audio Engine实操的视频


27
00:02:07,728 --> 00:02:10,364
咱们来看看这项成果
背后要达成的一些目标


28
00:02:12,099 --> 00:02:13,667
有三个重要目标


29
00:02:14,268 --> 00:02:19,339
首先 提供一个强大的
且功能丰富的API组


30
00:02:20,707 --> 00:02:24,811
AV Audio Engine建立
在C语言框架之上 因此


31
00:02:25,512 --> 00:02:30,751
它支持我们的
C语言框架大多数的强大的功能


32
00:02:32,386 --> 00:02:35,289
第二个目标 您在直接使用


33
00:02:35,622 --> 00:02:40,861
C语言框架编写代码时只需少量代码


34
00:02:40,928 --> 00:02:45,132
就能运行简单或复杂的任务


35
00:02:46,266 --> 00:02:50,437
这个任务可以是播放一个音频文件


36
00:02:51,071 --> 00:02:53,006
也可以是运行


37
00:02:53,073 --> 00:02:56,143
整个音频引擎游戏


38
00:02:57,878 --> 00:03:01,715
第三个重要的目标是简化实时音频


39
00:03:03,250 --> 00:03:06,320
AV Audio Engine
是一个实时的音频系统


40
00:03:07,054 --> 00:03:10,757
但同时有一个非实时的交互接口


41
00:03:10,824 --> 00:03:15,896
可在后台处理


42
00:03:15,996 --> 00:03:19,099
实时音频的复杂文件


43
00:03:20,434 --> 00:03:24,738
这再次凸显了
AV Audio Engine可用


44
00:03:27,341 --> 00:03:28,909
谈谈它的一些特性吧


45
00:03:29,910 --> 00:03:32,779
它是个C语言API组 因此


46
00:03:32,980 --> 00:03:35,082
也可以通过Swift运行


47
00:03:36,316 --> 00:03:39,419
它支持低延迟实时音频


48
00:03:40,621 --> 00:03:45,259
使用AV Audio Engine
能够运行各种音频任务


49
00:03:45,759 --> 00:03:47,694
如播放和记录音频


50
00:03:48,762 --> 00:03:51,798
关联音频处理模块


51
00:03:51,999 --> 00:03:53,467
并形成独有的处理链


52
00:03:54,501 --> 00:03:58,405
你可随时捕捉音频处理链


53
00:03:58,572 --> 00:04:00,841
进行分析或调试


54
00:04:01,775 --> 00:04:05,212
而且 你可以安装3D音频游戏


55
00:04:08,215 --> 00:04:10,284
那么 该引擎是由什么构成的呢？


56
00:04:11,618 --> 00:04:14,621
引擎的基本构建块是节点


57
00:04:15,689 --> 00:04:18,858
引擎本身控制一系列


58
00:04:19,026 --> 00:04:20,560
连接在一起的节点


59
00:04:21,962 --> 00:04:24,231
节点有三种类型


60
00:04:25,299 --> 00:04:28,135
源节点提供数据输入


61
00:04:29,002 --> 00:04:31,605
过程节点处理这些数据 


62
00:04:32,372 --> 00:04:37,644
目标节点通常处理终端节点图


63
00:04:37,711 --> 00:04:40,113
并关联输出硬件


64
00:04:40,180 --> 00:04:41,215
和输出节点


65
00:04:42,883 --> 00:04:45,352
现在咱们看一个引擎设置示例


66
00:04:47,087 --> 00:04:49,623
这是一个简单的自动伴奏录音应用


67
00:04:51,225 --> 00:04:53,293
你可以通过隐式连接


68
00:04:53,560 --> 00:04:56,930
输入节点的麦克风捕捉用户的声音


69
00:04:57,931 --> 00:04:59,933
通过有效节点处理


70
00:05:00,000 --> 00:05:01,435
可能是简单的延迟


71
00:05:02,603 --> 00:05:05,873
你也可以通过一个节点块


72
00:05:06,340 --> 00:05:10,344
分析用户声音


73
00:05:10,410 --> 00:05:14,548
确定用户是如何表演的 在此基础上


74
00:05:14,848 --> 00:05:18,085
你可以通过播放器节点增添音效


75
00:05:19,253 --> 00:05:22,089
也可以在你的应用程序中


76
00:05:22,155 --> 00:05:24,224
用另一个播放器点在此播放


77
00:05:24,858 --> 00:05:28,362
所有这些信号可以


78
00:05:28,428 --> 00:05:32,099
使用混合节点混合在一起


79
00:05:32,165 --> 00:05:33,700
最后通过扬声器连接到输出节点


80
00:05:34,334 --> 00:05:37,171
在此设置中您的输入


81
00:05:37,237 --> 00:05:39,439
和播放器形成了源节点


82
00:05:40,874 --> 00:05:44,211
混频器是你处理输入节点


83
00:05:45,078 --> 00:05:47,848
输出节点的目标节点


84
00:05:51,285 --> 00:05:54,755
现在让我们来仔细看看混合节点


85
00:05:55,923 --> 00:05:59,293
引擎中有两类混合节点


86
00:06:00,060 --> 00:06:03,530
第一类是我们前面例子中的


87
00:06:03,597 --> 00:06:04,932
AV音频混合器节点


88
00:06:05,766 --> 00:06:11,171
这类节点主要
用于采样率转换和声道混合


89
00:06:12,339 --> 00:06:15,909
它支持单声道 
立体声和多通道输入


90
00:06:17,211 --> 00:06:20,747
第二类混合器节点被称为环境节点


91
00:06:20,981 --> 00:06:23,517
它主要用于游戏应用程序


92
00:06:24,985 --> 00:06:29,990
通过使用专业隐形侦听器


93
00:06:30,057 --> 00:06:33,460
模拟与资源与环境节点相关


94
00:06:33,527 --> 00:06:34,862
3D环境音效


95
00:06:36,230 --> 00:06:40,033
环境节点支持单声道 立体声输入


96
00:06:40,267 --> 00:06:42,469
和空间化单声道输入


97
00:06:45,906 --> 00:06:49,409
现在 同时使用混频器节点和源节点的


98
00:06:49,676 --> 00:06:52,779
是一种叫做
AV Audio Mixing协议


99
00:06:53,981 --> 00:06:57,985
此协议定义了一组属性


100
00:06:58,051 --> 00:07:00,354
适用于混合节点的输入总线


101
00:07:01,622 --> 00:07:05,692
源节点遵守这个协议


102
00:07:06,193 --> 00:07:08,428
进而控制所连接的


103
00:07:08,529 --> 00:07:09,796
混合器属性


104
00:07:11,732 --> 00:07:15,235
如果你在连接


105
00:07:15,302 --> 00:07:19,106
源节点与混合器节点之前设置这些属性


106
00:07:19,339 --> 00:07:20,541
则属性会缓存到源节点


107
00:07:21,675 --> 00:07:24,311
当你实际连接源节点与混合器节点


108
00:07:24,378 --> 00:07:27,881
该属性会对混合器产生影响


109
00:07:29,750 --> 00:07:32,386
我们看看这些属性的例子


110
00:07:33,587 --> 00:07:35,489
主要有三种类型


111
00:07:35,923 --> 00:07:38,458
常见的混合属性适用于


112
00:07:38,592 --> 00:07:40,060
所有混合节点


113
00:07:40,627 --> 00:07:42,262
这个例子是音量


114
00:07:43,230 --> 00:07:45,032
立体混合属性如全景


115
00:07:45,199 --> 00:07:49,269
只适用于AV音频混合器节点


116
00:07:50,537 --> 00:07:53,273
3D混合属性如位置 干扰


117
00:07:53,340 --> 00:07:57,277
遮挡主要用于游戏


118
00:07:57,511 --> 00:08:00,080
以及适用环境节点


119
00:08:02,916 --> 00:08:04,818
现在 我们再一个设置示范


120
00:08:05,085 --> 00:08:08,722
现在来看看设置的示例


121
00:08:09,022 --> 00:08:11,792
假设您的引擎上有一个播放器节点


122
00:08:13,660 --> 00:08:15,262
混频器节点和环境节点


123
00:08:15,329 --> 00:08:17,431
你在播放器节点上设置了一堆混合属性


124
00:08:19,032 --> 00:08:21,335
现在玩家并没有


125
00:08:21,401 --> 00:08:23,337
连接混频器


126
00:08:23,670 --> 00:08:26,673
这些属性仍缓存在播放器里


127
00:08:28,609 --> 00:08:30,944
现在假设你连接到了混合器节点


128
00:08:31,778 --> 00:08:35,048
现在的属性如音量和全景


129
00:08:35,381 --> 00:08:40,419
对混合器节点产生影响


130
00:08:40,754 --> 00:08:43,289
而3D混合属性如位置
不会影响混合器节点


131
00:08:44,992 --> 00:08:47,561
如果你现在断开混频器


132
00:08:47,628 --> 00:08:48,862
并连接到环境节点


133
00:08:49,396 --> 00:08:53,367
音量和位置对环境节点有影响


134
00:08:53,534 --> 00:08:54,568
而全景则无影响


135
00:08:55,569 --> 00:08:59,106
这样你可以在播放器中
设置一堆混合属性


136
00:08:59,173 --> 00:09:02,910
然后在你的应用程序中将播放器


137
00:09:03,177 --> 00:09:05,512
从一个混频器无损地转移到


138
00:09:05,712 --> 00:09:07,514
其他混频器中


139
00:09:09,049 --> 00:09:12,119
接下来的几分钟我们讨论


140
00:09:12,286 --> 00:09:14,555
今年产品的新特性


141
00:09:14,621 --> 00:09:16,790
将再次访问
AV Audio Mixing协议


142
00:09:19,960 --> 00:09:23,263
我现在想看看另一方面


143
00:09:23,664 --> 00:09:26,500
如何使用
AV Audio Engine处理


144
00:09:26,767 --> 00:09:28,135
多通道音频


145
00:09:29,670 --> 00:09:32,172
这里的设置涉及两部分


146
00:09:32,973 --> 00:09:35,976
首先是配置硬件


147
00:09:36,376 --> 00:09:38,946
能够接收多通道音频


148
00:09:40,013 --> 00:09:42,616
现在的硬件可以是HDMI设备


149
00:09:42,816 --> 00:09:44,751
或USB设备等等


150
00:09:46,053 --> 00:09:49,456
第二部分实际上是设置


151
00:09:49,790 --> 00:09:52,392
引擎本身能够渲染


152
00:09:52,593 --> 00:09:53,460
多通道音频


153
00:09:54,995 --> 00:09:56,897
我们一个一个来看


154
00:09:58,799 --> 00:10:01,635
首先 OSX中的硬件设置


155
00:10:03,370 --> 00:10:08,041
在OS X中 有款内置系统工具
叫音频MIDI设置


156
00:10:08,342 --> 00:10:11,178
用户可使用这个设置


157
00:10:11,245 --> 00:10:12,446
安装多通道硬件


158
00:10:13,380 --> 00:10:15,315
这个工具可用于


159
00:10:15,382 --> 00:10:17,317
设置扬声器配置


160
00:10:17,584 --> 00:10:19,152
频道布局 等等


161
00:10:20,120 --> 00:10:24,157
随后 app可通过
设置AVAudioEngine


162
00:10:24,391 --> 00:10:27,394
使用这个硬件进行多通道渲染


163
00:10:29,763 --> 00:10:34,535
但是在iOS中
为了使用硬件多通道


164
00:10:34,868 --> 00:10:38,071
app需要设置
AVAudioSession


165
00:10:39,606 --> 00:10:41,375
假设我们要播放一个音频


166
00:10:41,508 --> 00:10:43,810
来看看会涉及哪些步骤


167
00:10:45,479 --> 00:10:49,550
首先是激活音频会话


168
00:10:50,450 --> 00:10:52,719
接下来需要查看


169
00:10:53,187 --> 00:10:58,125
适合此会话的通道最大数


170
00:10:59,493 --> 00:11:02,029
随后设置通道的优选数字


171
00:11:02,729 --> 00:11:04,031
最后一步


172
00:11:04,364 --> 00:11:07,601
询问返回输出通道的实际数字


173
00:11:08,135 --> 00:11:12,039
以核实你刚做的请求是否通过


174
00:11:13,707 --> 00:11:14,975
现在 请注意


175
00:11:15,042 --> 00:11:18,645
不管你何时请求
为通道提供某一数字


176
00:11:19,179 --> 00:11:22,516
请求并不一定会被接受


177
00:11:23,183 --> 00:11:24,451
因此 最后一步


178
00:11:24,651 --> 00:11:28,522
有必要核实通道实际输出数字


179
00:11:31,124 --> 00:11:33,293
代码看起来是这样的


180
00:11:34,528 --> 00:11:36,597
假设有一个音频播放案例


181
00:11:36,864 --> 00:11:39,867
假设使用的是5.1渲染


182
00:11:41,335 --> 00:11:42,603
首先要做的是


183
00:11:43,103 --> 00:11:48,775
获得一个音频会话的共享事例设置类别


184
00:11:49,142 --> 00:11:50,978
激活会话


185
00:11:53,347 --> 00:11:56,517
接下来 检查适合会话的


186
00:11:56,583 --> 00:11:58,252
输出通道的最大数


187
00:11:59,786 --> 00:12:00,954
在此基础上


188
00:12:01,021 --> 00:12:04,391
在会话中设置通道的优选数字


189
00:12:06,293 --> 00:12:07,361
最后一步 


190
00:12:07,427 --> 00:12:11,632
询问输出通道的实际数字


191
00:12:11,698 --> 00:12:13,734
使之适应于对应通道计数


192
00:12:16,970 --> 00:12:19,473
好了 以上就是
关于硬件设置的所有内容


193
00:12:20,040 --> 00:12:22,543
现在来看看如何设置引擎


194
00:12:22,609 --> 00:12:24,711
使之能够渲染多通道音频


195
00:12:26,813 --> 00:12:28,615
再举两个使用事例


196
00:12:29,449 --> 00:12:33,287
首先 假设
你有适用的多通道音频内容


197
00:12:33,387 --> 00:12:35,522
且它需要通过多通道硬件


198
00:12:35,656 --> 00:12:37,024
进行重播


199
00:12:37,858 --> 00:12:41,328
在这个案例中
你会用到一个AV混音器节点


200
00:12:42,996 --> 00:12:44,965
第二个事例


201
00:12:45,132 --> 00:12:49,269
有一个游戏场景
你想让其中的内容空间渲染


202
00:12:49,536 --> 00:12:51,972
然后通过多通道硬件播放


203
00:12:52,639 --> 00:12:54,975
这里 你用到一个环境节点


204
00:12:58,111 --> 00:13:01,582
事例一 你有一个多通道音频内容


205
00:13:02,115 --> 00:13:03,650
一个多通道硬件


206
00:13:03,717 --> 00:13:07,154
这个硬件是按照数分钟前
我们所讨论的那样创建的


207
00:13:08,488 --> 00:13:14,494
现在 请注意尽管显示的是
内容格式和硬件格式一样


208
00:13:14,628 --> 00:13:15,896
但他们可能彼此截然不同


209
00:13:17,164 --> 00:13:21,001
这里的混合器节点


210
00:13:21,535 --> 00:13:23,937
将注意到内容格式
和硬件格式间的通道映射


211
00:13:26,473 --> 00:13:28,242
所以 首先你要做的是


212
00:13:29,042 --> 00:13:30,911
传递硬件格式


213
00:13:31,278 --> 00:13:34,615
连接混合器和输出节点


214
00:13:35,616 --> 00:13:38,218
代码层面是这样的


215
00:13:39,253 --> 00:13:43,390
你询问输出节点的输出格式


216
00:13:43,590 --> 00:13:45,092
即硬件格式


217
00:13:46,460 --> 00:13:48,028
然后用那格式


218
00:13:48,295 --> 00:13:52,199
连接混音器节点和输出节点


219
00:13:55,836 --> 00:13:58,605
接下来的内容方面很相似


220
00:13:58,906 --> 00:14:01,141
将内容格式


221
00:14:01,308 --> 00:14:04,378
传播并连接播放器和混音器节点


222
00:14:06,213 --> 00:14:08,882
假设你有一个文件格式的


223
00:14:08,949 --> 00:14:09,950
多通道音频内容


224
00:14:10,584 --> 00:14:12,452
可以打开文件阅读


225
00:14:12,753 --> 00:14:14,955
也可以用它的处理格式


226
00:14:15,289 --> 00:14:18,325
连接播放器和混音器节点


227
00:14:20,894 --> 00:14:23,997
随后将文件安排到播放器中


228
00:14:24,498 --> 00:14:26,767
打开引擎 打开播放器


229
00:14:27,100 --> 00:14:30,070
内容将通过处理链


230
00:14:33,507 --> 00:14:37,778
事例二 这是典型的游戏场景


231
00:14:37,845 --> 00:14:40,881
你想让渲染内容空间


232
00:14:40,948 --> 00:14:42,216
并通过多通道硬件播放


233
00:14:43,517 --> 00:14:46,286
处理步骤极其相似


234
00:14:46,353 --> 00:14:48,822
除了部分细微差别


235
00:14:50,591 --> 00:14:53,160
首先拿到硬件格式


236
00:14:53,360 --> 00:14:55,963
在环境节点和输出节点之间


237
00:14:56,029 --> 00:14:57,531
设置连接


238
00:14:59,333 --> 00:15:04,037
因为环境节点
只支持特别通道布局


239
00:15:04,972 --> 00:15:06,907
所以你需要将硬件格式


240
00:15:07,241 --> 00:15:09,810
映射到一个环境节点支持的格式


241
00:15:10,711 --> 00:15:12,212
这是第一个不同点


242
00:15:12,579 --> 00:15:15,516
假设我们有一个5.1硬件


243
00:15:16,183 --> 00:15:20,020
我们可以选择由音频节点支持的


244
00:15:20,687 --> 00:15:22,723
音频单位5.0布局包


245
00:15:23,557 --> 00:15:25,692
我们可以用这个布局标签


246
00:15:25,859 --> 00:15:27,261
创建一个AV音频通道布局


247
00:15:28,462 --> 00:15:31,765
然后一个AV音频格式使用这个布局


248
00:15:33,934 --> 00:15:36,803
然后你用这个格式


249
00:15:36,904 --> 00:15:39,139
连接环境节点和输出节点


250
00:15:41,575 --> 00:15:43,610
第二步完全相同


251
00:15:43,844 --> 00:15:46,880
传递内容格式


252
00:15:47,481 --> 00:15:49,449
并连接播放器和环境节点


253
00:15:50,551 --> 00:15:54,721
打开并阅读文件用它的处理格式


254
00:15:55,222 --> 00:15:57,991
连接播放器和环境


255
00:15:59,893 --> 00:16:04,464
下一步 在支持多通道渲染的播放器上


256
00:16:05,032 --> 00:16:08,168
设置渲染算法


257
00:16:09,736 --> 00:16:12,139
渲染算法是一种


258
00:16:12,206 --> 00:16:14,374
3D混合协议属性


259
00:16:14,441 --> 00:16:16,310
数分钟前 我们刚看过


260
00:16:17,177 --> 00:16:19,813
它将告诉环境节点


261
00:16:20,147 --> 00:16:22,916
对应的源请求一个


262
00:16:22,983 --> 00:16:24,384
多通道渲染


263
00:16:26,987 --> 00:16:28,722
接下来就是常规的东西了


264
00:16:29,590 --> 00:16:32,626
将文件放到到播放器里


265
00:16:32,693 --> 00:16:35,362
启动引擎 启动播放器


266
00:16:35,429 --> 00:16:37,130
环境节点将对内容进行空间渲染


267
00:16:41,568 --> 00:16:47,608
好了 这就是iOS 8和
OS X Yosemite系统


268
00:16:47,674 --> 00:16:49,510
AV音频引擎


269
00:16:50,711 --> 00:16:52,613
接下来讲讲 让人更兴奋的东西


270
00:16:53,413 --> 00:16:54,915
今年有什么新东西呢


271
00:16:58,819 --> 00:17:00,687
我们有三个主要的新特性


272
00:17:01,688 --> 00:17:04,057
第一个是拆分支持


273
00:17:04,223 --> 00:17:06,760
等下就会讲到


274
00:17:07,627 --> 00:17:10,998
第二是音频格式转换支持


275
00:17:11,198 --> 00:17:13,500
这里有不少的新类


276
00:17:13,834 --> 00:17:16,270
最主要的一个是
AVAudioConverter


277
00:17:17,771 --> 00:17:20,907
最后 另一个新类叫做


278
00:17:20,973 --> 00:17:24,944
AVAudioSequencer 
支持MIDI文件的播放


279
00:17:28,682 --> 00:17:30,250
来讲讲拆分支持


280
00:17:31,985 --> 00:17:34,021
让我们考虑一下这个设置示例


281
00:17:34,788 --> 00:17:37,157
我猜你们应该都很熟悉了


282
00:17:39,626 --> 00:17:42,863
在上周推出的API中


283
00:17:43,564 --> 00:17:47,234
引擎只支持一对一连接


284
00:17:47,968 --> 00:17:51,238
任何节点的输出


285
00:17:51,438 --> 00:17:54,842
只能与引擎中另一个节点连接


286
00:17:56,510 --> 00:18:02,516
现在 我们增加了对这个的支持


287
00:18:03,350 --> 00:18:07,788
它可让你在处理链中


288
00:18:07,888 --> 00:18:11,158
将节点输出分成多个路径


289
00:18:13,060 --> 00:18:14,294
在这个事例中


290
00:18:14,361 --> 00:18:17,764
播放器的输出被分成三个不同路径


291
00:18:18,232 --> 00:18:21,001
最后连接到混音器节点上


292
00:18:22,369 --> 00:18:26,673
拆分在类似下面的用例中很有用


293
00:18:27,040 --> 00:18:32,246
如混频 
需增加一些效果声信号的混频


294
00:18:32,713 --> 00:18:35,983
或者用同一个源驱动的
原始信号对信号进行处理


295
00:18:37,117 --> 00:18:38,318
在这个事例中


296
00:18:38,385 --> 00:18:43,423
播放器和混音器节点的连接
形成了原始信号路径


297
00:18:43,790 --> 00:18:49,062
而经过效果节点的其他两个路径
形成了效果声信号路径


298
00:18:49,630 --> 00:18:52,332
这三个信号通过混音器节点


299
00:18:52,499 --> 00:18:54,835
混合在一起形成混合


300
00:18:56,603 --> 00:18:59,773
现在 请注意当你拆分节点的输出时


301
00:19:00,073 --> 00:19:04,411
事实上 
整个输出通过多路径进行渲染


302
00:19:04,645 --> 00:19:07,614
这其中并未涉及到通道的拆分


303
00:19:10,851 --> 00:19:14,254
现在来看看节点如何设置这些连接


304
00:19:17,090 --> 00:19:18,258
你可以看到


305
00:19:18,525 --> 00:19:21,195
播放器连接到三个不同的节点上


306
00:19:22,496 --> 00:19:25,165
我们将它们叫做连接点


307
00:19:25,499 --> 00:19:28,302
由一个非常简单的新类


308
00:19:28,569 --> 00:19:30,470
叫做AV音频连接点作为其代表


309
00:19:33,674 --> 00:19:34,775
首先要做的是


310
00:19:35,042 --> 00:19:37,744
创建一些连接点


311
00:19:38,011 --> 00:19:40,380
以连接播放器节点


312
00:19:41,148 --> 00:19:45,786
在这个事例中连接是 输入总线


313
00:19:45,853 --> 00:19:51,225
两个效果的0和输入总线
混音器节点的1


314
00:19:53,594 --> 00:19:56,930
然后使用新连接API


315
00:19:57,331 --> 00:20:00,200
我们必须连接播放器和这些连接点


316
00:20:01,468 --> 00:20:04,872
就这样 
你为拆分连接做好准备了


317
00:20:05,272 --> 00:20:09,710
接着  连接引擎中其他所需要的节点


318
00:20:13,647 --> 00:20:15,315
现在再次访问


319
00:20:15,382 --> 00:20:18,185
刚才提到过的
AVAudioMixing协议


320
00:20:18,252 --> 00:20:21,655
看看它如何影响拆分使用事例


321
00:20:22,656 --> 00:20:24,591
假设我们有一个播放器节点


322
00:20:24,725 --> 00:20:27,427
这个播放器节点的输出
被拆分成两个不同路径


323
00:20:27,895 --> 00:20:30,597
通过效果节点到达混音器节点


324
00:20:33,233 --> 00:20:35,769
现在假设在播放器节点上设置了个属性


325
00:20:36,336 --> 00:20:38,805
在这个事例中假设你设置了音量


326
00:20:40,641 --> 00:20:47,247
此刻 属性将在所有现有的混音器
连接上起作用


327
00:20:47,881 --> 00:20:50,684
在这个事例中输入总线 
混音器节点的0输入总线


328
00:20:51,118 --> 00:20:55,355
混音器节点的1得到的音量都是5


329
00:20:58,692 --> 00:21:00,727
如果你想在特别混音器连接数


330
00:21:01,228 --> 00:21:03,030
改变任何属性


331
00:21:03,096 --> 00:21:05,766
这也是可以做到的


332
00:21:06,400 --> 00:21:07,968
方法就是


333
00:21:08,035 --> 00:21:11,939
使用我们的新类
名为AVAudioMixing目标


334
00:21:13,207 --> 00:21:15,008
询问播放器节点


335
00:21:15,342 --> 00:21:18,378
这里提供你想要的与混音器对应的


336
00:21:18,445 --> 00:21:19,947
目标对象


337
00:21:20,747 --> 00:21:23,650
然后 你就可以在对象上设置属性了


338
00:21:24,484 --> 00:21:25,819
这个事例中


339
00:21:26,153 --> 00:21:30,991
我在混音器输入总线0到8中改变音量


340
00:21:33,894 --> 00:21:36,864
好了 同样的


341
00:21:36,930 --> 00:21:41,034
你也可以在其他混音器连接中改变属性


342
00:21:43,670 --> 00:21:45,706
我们来看看 连接断开会发生什么


343
00:21:46,840 --> 00:21:49,676
假设你将效果


344
00:21:49,743 --> 00:21:51,778
从混音器输入总线1连接中断开


345
00:21:52,880 --> 00:21:54,114
请注意 


346
00:21:54,648 --> 00:21:59,152
你在特别混音器连接上改变的设置


347
00:21:59,419 --> 00:22:00,454
将不会被保存


348
00:22:02,389 --> 00:22:05,526
因此 混频设置的状态看起来是这样的


349
00:22:06,026 --> 00:22:09,129
播放器的混频设置仍旧完整


350
00:22:09,663 --> 00:22:11,765
另一个活跃的连接


351
00:22:11,832 --> 00:22:14,735
同样也有完整的混频设置


352
00:22:17,504 --> 00:22:20,541
现在 假设你结束创建连接


353
00:22:20,741 --> 00:22:25,078
重新回到混音器输入总线1
因为先前的设置并未保存


354
00:22:25,179 --> 00:22:28,348
重设播放器节点的基础设置


355
00:22:28,415 --> 00:22:30,851
将在新连接上起作用


356
00:22:32,286 --> 00:22:36,323
因此 根据播放器的混频设置


357
00:22:36,390 --> 00:22:39,426
输入总线音量1将再次被设置成5


358
00:22:42,362 --> 00:22:43,797
总结一下


359
00:22:43,964 --> 00:22:47,334
当一个源节点
被连接到多个混音器上时


360
00:22:48,468 --> 00:22:51,505
你在源节点上设置的属性


361
00:22:51,705 --> 00:22:55,776
将适用于所有现存的混音器连接


362
00:22:56,176 --> 00:22:59,680
同时它也适用于
任何新创建的混音器连接


363
00:23:01,548 --> 00:23:02,850
若有需要


364
00:23:02,916 --> 00:23:06,587
也可以改变写个别混音器连接


365
00:23:06,920 --> 00:23:07,921
但是请记住


366
00:23:07,988 --> 00:23:10,924
无法保存在断开时候保存


367
00:23:14,928 --> 00:23:16,630
最后是关于拆分支持


368
00:23:17,564 --> 00:23:20,801
如果你设置限制条件


369
00:23:21,001 --> 00:23:24,805
引擎就可以支持处理表中


370
00:23:24,905 --> 00:23:26,340
任何节点的拆分


371
00:23:27,441 --> 00:23:30,377
现在 从输出被拆分的节点开始


372
00:23:31,311 --> 00:23:34,381
到所有部分终点的混音器


373
00:23:35,349 --> 00:23:38,185
你无法拥有任何时间效果节点


374
00:23:38,585 --> 00:23:41,822
也就是说 你无法设定速度和时间阶


375
00:23:43,790 --> 00:23:46,159
你也无法进行速度变化


376
00:23:47,227 --> 00:23:48,562
换句话说


377
00:23:49,596 --> 00:23:52,599
基础节点上的所有拆分部分


378
00:23:52,966 --> 00:23:57,404
应用同样的速度加以渲染
直至它们到达通用混音器


379
00:23:59,139 --> 00:24:01,108
倘若你设定限制条件


380
00:24:01,241 --> 00:24:04,211
那么你就可以将引擎上


381
00:24:04,344 --> 00:24:06,813
任何节点的输出拆分成不同部分


382
00:24:10,717 --> 00:24:12,853
好了  现在来说说


383
00:24:12,920 --> 00:24:18,926
今年的第二个新特征音频格式转换支持


384
00:24:20,093 --> 00:24:22,229
这里 我们有一些新类


385
00:24:22,696 --> 00:24:27,100
AVAudioCompressedBuffer
和AV Audio Converter


386
00:24:29,203 --> 00:24:32,039
在上周提到的API中


387
00:24:32,339 --> 00:24:35,943
我们有一个
AVAudioBuffer


388
00:24:36,009 --> 00:24:38,812
和它的一个子类叫做
AVAudioPCMBuffer


389
00:24:39,813 --> 00:24:41,081
从它的名字就可以看出


390
00:24:41,381 --> 00:24:44,518
PCM缓冲器保存未压缩音频数据


391
00:24:45,385 --> 00:24:47,688
而且通过引擎的数据流


392
00:24:47,754 --> 00:24:49,389
是PCM缓冲器格式


393
00:24:51,058 --> 00:24:52,292
今年开始


394
00:24:52,359 --> 00:24:57,598
AVAudioBuffer有另一个子类
叫做AVAudioCompressedBuffer


395
00:24:58,265 --> 00:25:00,701
它保存压缩音频数据


396
00:25:02,035 --> 00:25:06,173
这个可以与新类
AVAudioConverter用


397
00:25:06,240 --> 00:25:09,376
接下来将会讲到
AVAudioConverter


398
00:25:13,213 --> 00:25:16,116
AVAudioConverter
是一个新工具类


399
00:25:16,283 --> 00:25:18,485
它是音频工具箱架构中的


400
00:25:18,552 --> 00:25:22,589
音频转换器升级版本


401
00:25:24,224 --> 00:25:26,326
它支持所有音频格式转化


402
00:25:27,528 --> 00:25:32,933
在你改变 
即整合到浮动位深 抽样率等等时


403
00:25:33,300 --> 00:25:36,036
你可以将PCM转化成PCM格式


404
00:25:37,671 --> 00:25:41,175
或者可以在PCM和压缩格式间转换


405
00:25:41,408 --> 00:25:45,212
就是说 你可以用它来编码和解码


406
00:25:47,014 --> 00:25:50,083
在下面的事例中 你可以看到


407
00:25:50,150 --> 00:25:53,854
AVAudioConverter与
AVAudioEngine配合使用


408
00:25:56,223 --> 00:26:00,761
好了  假设你设置引擎进行播放


409
00:26:01,428 --> 00:26:03,130
因此我们有一个播放器节点 


410
00:26:03,197 --> 00:26:04,998
它连接一个效果节点和一个输出节点


411
00:26:06,366 --> 00:26:08,802
假设有一个压缩音频流


412
00:26:08,869 --> 00:26:10,003
进入到其中


413
00:26:12,105 --> 00:26:15,676
现在 我们知道通过引擎的


414
00:26:15,742 --> 00:26:17,544
数据流的格式是PCM 缓冲器


415
00:26:19,346 --> 00:26:22,382
现在可以使用
AVAudioConverter


416
00:26:22,716 --> 00:26:27,054
将输入压缩流转换成PCM 缓冲器


417
00:26:27,321 --> 00:26:29,456
然后你可以用这些缓冲器


418
00:26:29,523 --> 00:26:31,325
安排播放器节点


419
00:26:31,692 --> 00:26:34,494
因此 通过引擎 就可以播放了


420
00:26:38,165 --> 00:26:40,300
现在来想想代码事例


421
00:26:40,601 --> 00:26:44,671
用AVAudioConverter
如何进行编码


422
00:26:45,906 --> 00:26:48,775
这里 我们想把


423
00:26:49,076 --> 00:26:50,777
一个PCM转换成ASC压缩格式


424
00:26:52,613 --> 00:26:54,081
首先要做的事情是


425
00:26:54,181 --> 00:26:56,750
定义输入格式和输出格式


426
00:26:57,484 --> 00:27:01,255
这里 我有一个PCM格式的输入格式


427
00:27:03,423 --> 00:27:04,958
和一个


428
00:27:05,125 --> 00:27:07,160
压缩ASC格式的输出格式


429
00:27:10,564 --> 00:27:13,500
下一步 创建一个
AVAudioConverter


430
00:27:13,967 --> 00:27:17,871
并将它从输入格式转换成输出格式


431
00:27:20,474 --> 00:27:22,743
然后 创建你的音频缓冲器


432
00:27:23,610 --> 00:27:26,346
此事例中 
输入缓冲器是一个PCM缓冲器


433
00:27:27,314 --> 00:27:31,451
输出缓冲器是新的
AVAudioCompressedBuffer


434
00:27:31,518 --> 00:27:32,886
格式是ASC格式


435
00:27:36,223 --> 00:27:37,724
接下来要做的是


436
00:27:37,791 --> 00:27:41,828
定义输入块
AVAudioConverter


437
00:27:42,963 --> 00:27:44,264
在这个块中


438
00:27:44,331 --> 00:27:47,935
转换器将在需要的是调用输入数据


439
00:27:49,436 --> 00:27:51,872
所以这里你需要做一些事情


440
00:27:53,073 --> 00:27:54,675
首先 你需要告知


441
00:27:54,741 --> 00:27:57,811
转换器输入的状态


442
00:27:58,812 --> 00:28:01,014
假设块被调用时


443
00:28:01,348 --> 00:28:03,584
你并没有任何适用的输入数据


444
00:28:04,384 --> 00:28:07,821
这种情况下 你可以说现在没有数据


445
00:28:08,222 --> 00:28:10,490
并将0缓冲器返回到转化器


446
00:28:12,492 --> 00:28:14,595
假设你到达流的末端


447
00:28:15,128 --> 00:28:18,098
你可以告知转换器 这是流的末端了


448
00:28:18,298 --> 00:28:20,534
再一次返回一个0缓冲器


449
00:28:22,236 --> 00:28:23,971
另外的 在正常情况下


450
00:28:24,171 --> 00:28:26,073
你可以看到数据


451
00:28:26,406 --> 00:28:29,810
进入输入缓冲器 然后返回到转换器


452
00:28:33,180 --> 00:28:35,082
这是主要的转换回路


453
00:28:36,250 --> 00:28:40,053
每次操作回路时 我们都要求转换


454
00:28:40,120 --> 00:28:42,456
以生成一个数据的输出缓冲器


455
00:28:43,223 --> 00:28:46,426
我们也为转换器提供了
刚才所定义的输入块


456
00:28:46,660 --> 00:28:49,963
这样 不管它需要输入多少次


457
00:28:50,264 --> 00:28:52,366
它都可以被转换器调用


458
00:28:54,768 --> 00:28:57,471
转换器也将返回你的状态


459
00:28:57,538 --> 00:29:00,607
这样你就可以查看转换的状态了


460
00:29:01,208 --> 00:29:03,844
这样一来 
倘若转换器说这是流的末端了


461
00:29:04,044 --> 00:29:06,079
或倘若说有错误


462
00:29:06,146 --> 00:29:07,848
你就可以进行相应地处理


463
00:29:09,950 --> 00:29:11,785
另外 在正常情况下


464
00:29:11,852 --> 00:29:15,689
每次迭代都将为你提供
一个数据的输出缓冲器


465
00:29:20,027 --> 00:29:23,063
好的  接下来说说


466
00:29:23,130 --> 00:29:26,500
今年的最后一个新类
AVAudioSequencer


467
00:29:30,370 --> 00:29:33,273
它支持MIDI文件的重播


468
00:29:35,242 --> 00:29:36,910
在例示时


469
00:29:36,977 --> 00:29:41,882
AVAudioSequencer与
AVAudioEngine有关系


470
00:29:44,184 --> 00:29:48,121
定序器负责将MIDI事件


471
00:29:48,522 --> 00:29:52,259
发送到已附在引擎中的工具节点上


472
00:29:52,993 --> 00:29:56,430
工具节点 音频采样器


473
00:29:56,563 --> 00:29:58,198
MIDI事件等等的事例


474
00:30:01,502 --> 00:30:03,470
现在来看看样本设置


475
00:30:04,037 --> 00:30:06,807
假设你有AVAudioEngine


476
00:30:06,940 --> 00:30:08,909
是用连接到混音器节点


477
00:30:08,976 --> 00:30:11,044
和输出节点的工具节点创建的


478
00:30:13,847 --> 00:30:16,517
现在你可以设置一个
AVAudioSequencer


479
00:30:16,583 --> 00:30:19,052
使它与这个引擎相关联


480
00:30:20,854 --> 00:30:24,758
然后 启动定序器和引擎


481
00:30:25,025 --> 00:30:29,563
定序器将自动发现
引擎里的第一个工具节点


482
00:30:29,630 --> 00:30:32,799
然后开始往那个工具节点


483
00:30:32,966 --> 00:30:34,835
发送MIDI事件


484
00:30:37,704 --> 00:30:39,573
代码看起来像这样


485
00:30:40,440 --> 00:30:42,876
因此 第一部分是引擎设置


486
00:30:42,943 --> 00:30:44,945
它位于定序器外面


487
00:30:45,579 --> 00:30:49,550
这里我们有一个工具节点
这是个采样器


488
00:30:50,651 --> 00:30:53,520
你在引擎中创建所需的连接


489
00:30:55,589 --> 00:30:56,890
然后启动引擎


490
00:30:58,025 --> 00:31:01,128
此刻 并没有播放音频


491
00:31:01,261 --> 00:31:02,796
因为并没有东西


492
00:31:02,863 --> 00:31:04,598
在驱动工具节点


493
00:31:06,900 --> 00:31:09,469
下一步 创建定序器


494
00:31:09,703 --> 00:31:12,940
并与你刚配置的引擎相关联


495
00:31:15,242 --> 00:31:17,678
将MIDI文件加载到定序器中


496
00:31:19,446 --> 00:31:21,181
然后就可以启动定序器了


497
00:31:21,682 --> 00:31:23,717
此时 定序器将后台


498
00:31:23,784 --> 00:31:28,789
发现你已附在引擎中的采样器节点


499
00:31:29,022 --> 00:31:31,892
并开始往采样器节点发送MIDI事件


500
00:31:32,292 --> 00:31:34,862
因此 你的音频播放将启动


501
00:31:38,198 --> 00:31:41,602
假设你的MIDI文件中有多重轨道


502
00:31:43,070 --> 00:31:45,806
现在定序器的默认行为是


503
00:31:46,006 --> 00:31:47,941
将所有的轨道发送到


504
00:31:48,275 --> 00:31:51,278
引擎中的第一个工具节点


505
00:31:53,213 --> 00:31:56,283
倘若你想将轨道放到


506
00:31:56,550 --> 00:31:58,452
个别工具节点上


507
00:31:59,386 --> 00:32:02,456
这只需数行代码就可以做到


508
00:32:04,558 --> 00:32:06,927
定序器中引擎的创建和设置


509
00:32:06,994 --> 00:32:09,329
和先前提到的一样


510
00:32:09,730 --> 00:32:12,065
唯一多的步骤是


511
00:32:12,699 --> 00:32:15,636
从定序器上获得轨道


512
00:32:15,769 --> 00:32:18,739
为每个轨道设立目标


513
00:32:19,106 --> 00:32:20,974
到你想要的工具节点上


514
00:32:26,146 --> 00:32:27,848
最后再说说定序器


515
00:32:28,649 --> 00:32:31,919
定序器有自己的传送控制集
用来控制MIDI事件


516
00:32:32,219 --> 00:32:36,123
和引擎上的传送控制不同


517
00:32:36,256 --> 00:32:38,125
它控制音频流


518
00:32:39,259 --> 00:32:42,629
这里 你可以为重播准备定序器


519
00:32:42,763 --> 00:32:44,831
这个定序器基本上是预先运作的


520
00:32:45,632 --> 00:32:47,835
你可以开始 停止MIDI事件


521
00:32:48,869 --> 00:32:51,672
你可以根据秒或节奏


522
00:32:51,738 --> 00:32:53,774
设置MIDI事件的重播位置


523
00:32:54,741 --> 00:32:55,809
当然 你也可以设置


524
00:32:55,876 --> 00:32:58,278
MIDI事件的重播率	


525
00:33:02,516 --> 00:33:04,885
好的 所以我们了解到了


526
00:33:05,152 --> 00:33:10,157
今年IOS和OSX发布的
AVAudioEngine的新特性


527
00:33:10,624 --> 00:33:12,960
现在我想通过一个快速的演示


528
00:33:13,227 --> 00:33:15,629
向你展示如何使用新特性


529
00:33:16,230 --> 00:33:17,264
在此过程


530
00:33:17,331 --> 00:33:20,200
我想邀请托里上台来帮助我演示


531
00:33:32,579 --> 00:33:36,049
好的 在这个演示中 
我们将AVAudioEngine


532
00:33:36,250 --> 00:33:39,853
和AVAudioSequencer
通过引擎相关联


533
00:33:41,021 --> 00:33:45,559
在这个引擎中 最上面有一个工具节点


534
00:33:46,560 --> 00:33:49,463
被分为三种不同路径输出


535
00:33:50,531 --> 00:33:54,968
其中一条路径直接连接到
引擎的主混频器节点


536
00:33:55,969 --> 00:34:00,407
另外两条连接两种不同的特效 


537
00:34:00,774 --> 00:34:02,176
然后才是主混频器


538
00:34:03,877 --> 00:34:07,814
现在 通过使用我
AVAudioMixing协议属性


539
00:34:08,348 --> 00:34:11,217
在每一条混频器输入总线中


540
00:34:11,284 --> 00:34:13,020
进行音量控制


541
00:34:13,786 --> 00:34:16,657
所以 即使是最微小的音量失真


542
00:34:16,757 --> 00:34:20,893
直接音量以及混响都可进行控制


543
00:34:20,960 --> 00:34:22,596
且都是通过混频器协议来控制的


544
00:34:23,996 --> 00:34:28,168
现在 在顶部 这个浅灰色的方框


545
00:34:28,235 --> 00:34:31,672
可以看到定序器的传输控制


546
00:34:32,438 --> 00:34:36,409
你可以看见在定序器上
设有播放和停止键


547
00:34:36,476 --> 00:34:40,179
与此同时还有一个滑动栏


548
00:34:40,581 --> 00:34:43,317
用来设置MIDI的播放位置和速度


549
00:34:44,551 --> 00:34:47,588
在主混频器上还有一个音效开关


550
00:34:47,721 --> 00:34:52,025
用来控制你混音的音量


551
00:34:52,926 --> 00:34:55,395
现在 让我们继续 开启定序器


552
00:34:58,131 --> 00:35:01,935
这个时候 MIDI开始被传送到


553
00:35:02,002 --> 00:35:04,605
引擎中的工具节点


554
00:35:06,039 --> 00:35:07,641
你可以非常灵活地


555
00:35:07,708 --> 00:35:12,079
改变MIDI播放的位置及速度


556
00:35:15,816 --> 00:35:18,085
以及回放键的节奏


557
00:35:22,956 --> 00:35:25,859
通过使用音量控制


558
00:35:25,959 --> 00:35:31,265
你可以将不同的效果加入到混音中


559
00:35:31,765 --> 00:35:34,735
你可以增加失真音量


560
00:35:39,806 --> 00:35:41,308
或是混响音量


561
00:35:46,547 --> 00:35:49,883
所以 你可以通过这些音量


562
00:35:49,983 --> 00:35:52,452
非常方便地打造自己的混音


563
00:35:54,521 --> 00:35:58,325
最后 
通过使用混频器节点上的主音量控制


564
00:35:58,392 --> 00:36:02,129
可以控制整个混频器的音量


565
00:36:09,536 --> 00:36:11,038
好的 这个演示就是


566
00:36:11,405 --> 00:36:13,974
我们刚刚讨论过的新功能


567
00:36:21,048 --> 00:36:22,883
这个演示的演示代码会在


568
00:36:22,950 --> 00:36:24,952
今年年底前推出


569
00:36:27,087 --> 00:36:31,291
现在就AVAudioEngine 
总结一下


570
00:36:32,192 --> 00:36:36,029
我们回顾了如何通过
AVAudioEngine


571
00:36:36,096 --> 00:36:42,102
处理多通道的音频 
然后我们看了今年推出的三个新功能


572
00:36:42,603 --> 00:36:44,137
第一 拆分支持


573
00:36:44,872 --> 00:36:47,441
第二 音频格式转换支持


574
00:36:47,741 --> 00:36:50,777
最主要是
AVAudioConverter


575
00:36:51,778 --> 00:36:56,116
最后是一个新的
AVAudioSequencer


576
00:36:56,183 --> 00:36:58,485
用来支持MIDI文件播放


577
00:36:59,720 --> 00:37:03,123
我希望在你们的应用中


578
00:37:03,190 --> 00:37:06,026
使用这些新功能并给予我们反馈 谢谢


579
00:37:06,660 --> 00:37:08,662
现场交给托里 谢谢 托里


580
00:37:18,705 --> 00:37:19,873
谢谢 阿卡夏莎


581
00:37:20,407 --> 00:37:21,475
大家下午好


582
00:37:21,909 --> 00:37:24,044
我是托里 让我们继续看


583
00:37:24,111 --> 00:37:26,246
IOS系统的跨设备音频模式


584
00:37:26,980 --> 00:37:29,016
毫无疑问iPad是


585
00:37:29,082 --> 00:37:31,885
这个星球上最多功能的音乐工具


586
00:37:31,952 --> 00:37:33,620
这主要要感谢各位


587
00:37:34,254 --> 00:37:37,824
数字音频工作站应用 混音器软件


588
00:37:37,891 --> 00:37:39,893
击鼓软件 声音玩具


589
00:37:39,960 --> 00:37:41,895
用同一个设备你可以


590
00:37:41,962 --> 00:37:43,797
将无数的音频内容混到一起


591
00:37:44,331 --> 00:37:47,367
那么如何把IOS设备中的音频内容


592
00:37:47,434 --> 00:37:50,204
放进MAC上的项目呢


593
00:37:51,104 --> 00:37:55,008
你可以将插入耳机


594
00:37:55,075 --> 00:37:57,544
然后通过音频越狱盒子连接到MAC上


595
00:37:57,611 --> 00:38:00,113
不过是先转换到模拟信号


596
00:38:00,180 --> 00:38:01,448
然后再转为数字信号


597
00:38:01,515 --> 00:38:03,851
我想这并非最完美的方案


598
00:38:04,418 --> 00:38:07,521
所以 
为了从iOS设备上录制数字音频


599
00:38:08,789 --> 00:38:11,458
我们加入闪速USB适配器


600
00:38:11,925 --> 00:38:15,495
我们加入USB音频类兼容接口


601
00:38:15,562 --> 00:38:19,399
使得它能够处理数字音频输出


602
00:38:19,800 --> 00:38:21,535
一个数字音频线


603
00:38:21,602 --> 00:38:23,403
还有一个处理数字音频输入的接口


604
00:38:23,470 --> 00:38:25,305
我们将这些都加入到MAC


605
00:38:26,106 --> 00:38:28,442
非常有效
不过有很多的硬件


606
00:38:29,510 --> 00:38:33,447
还有些第三方软件也试图解决这个问题


607
00:38:33,580 --> 00:38:36,416
如果你的应用或你最喜欢的应用


608
00:38:36,750 --> 00:38:38,752
使用这些让软件 也很好


609
00:38:39,520 --> 00:38:43,223
但是 如果你不想使用额外的硬件


610
00:38:43,290 --> 00:38:45,626
或是安装额外的软件


611
00:38:45,692 --> 00:38:49,496
仅通过补丁就能录制音频


612
00:38:49,763 --> 00:38:51,865
这样不是很棒嘛


613
00:38:53,133 --> 00:38:54,301
那么 请击鼓欢庆吧


614
00:38:58,705 --> 00:39:00,407
噢 很低调嘛


615
00:39:01,175 --> 00:39:04,111
介绍下跨设备音频模式


616
00:39:04,811 --> 00:39:07,581
或者我们直接称之为IDAM


617
00:39:07,714 --> 00:39:13,020
IDAM允许你通过
USB快速连接到设备


618
00:39:13,387 --> 00:39:15,556
并录制数字音频


619
00:39:16,089 --> 00:39:19,259
通过USB 2.0兼容接口


620
00:39:19,326 --> 00:39:22,963
支持双通道24位 


621
00:39:23,397 --> 00:39:27,634
48千赫抽样率硬件


622
00:39:27,701 --> 00:39:28,802
全盘录制音频流格式


623
00:39:29,203 --> 00:39:31,538
MAC系统上又如何呢


624
00:39:31,805 --> 00:39:34,875
如果你使用MAC USB音频驱动


625
00:39:35,075 --> 00:39:36,977
也可以获得同样效果


626
00:39:37,044 --> 00:39:41,181
以及同样的USB音频设备兼容性


627
00:39:41,882 --> 00:39:44,117
不仅如此 iOS系统上


628
00:39:44,184 --> 00:39:48,121
使用的是
USBISOCHRONOUS音频


629
00:39:48,455 --> 00:39:50,824
意味着更省网络了


630
00:39:51,291 --> 00:39:55,128
如果想在MAC上备份120G的数据


631
00:39:55,395 --> 00:39:58,632
你可以边玩音乐边录制


632
00:39:58,699 --> 00:39:59,933
而且大可放心


633
00:40:00,000 --> 00:40:03,437
音频上不会有任何瑕疵


634
00:40:04,805 --> 00:40:07,207
而且 我们无需降低


635
00:40:07,641 --> 00:40:09,543
也不需要额外的硬件


636
00:40:09,610 --> 00:40:11,345
也不需要其他的软件


637
00:40:11,411 --> 00:40:14,114
你不需要更改你的OSX应用


638
00:40:14,181 --> 00:40:16,016
就能享有这功能带来的便捷


639
00:40:16,083 --> 00:40:19,319
如果你的iOS应用已经采用


640
00:40:19,386 --> 00:40:23,590
双通道24位48千赫音频流格式


641
00:40:23,657 --> 00:40:26,360
你无需更改iOS应用


642
00:40:27,127 --> 00:40:29,663
并且 在你制作过程中


643
00:40:29,730 --> 00:40:31,365
突然跳出一个日程警告


644
00:40:31,498 --> 00:40:33,467
警告也通过USB接口传输


645
00:40:33,534 --> 00:40:36,203
而是从扬声器传出


646
00:40:41,742 --> 00:40:44,211
好了 所以跨设备音频模式


647
00:40:44,278 --> 00:40:46,780
你的设备可以在此模式下充电和同步


648
00:40:46,847 --> 00:40:52,052
照片输入数据连线QuickTime
屏幕抓拍将暂时无法使用


649
00:40:52,419 --> 00:40:53,520
如果想要使用这些功能


650
00:40:53,587 --> 00:40:56,190
只需按下按钮 或拔掉设备插头


651
00:40:56,657 --> 00:40:58,959
托里 你也许会问 我该怎么用呢


652
00:40:59,459 --> 00:41:02,863
我们直接支持音频MIDI设置


653
00:41:03,363 --> 00:41:06,033
在下面的窗口菜单 你会发现新的选项


654
00:41:06,767 --> 00:41:10,003
展示iOS设备浏览器 如果你点击它


655
00:41:10,070 --> 00:41:11,672
你会进入到这个高级的界面


656
00:41:12,206 --> 00:41:14,775
它可以展示你所有连接的iOS设备


657
00:41:15,075 --> 00:41:18,178
你想进入或退出IDAM模式


658
00:41:18,278 --> 00:41:19,279
你可以按这个键


659
00:41:20,047 --> 00:41:24,017
你可将这个界面嵌入你的OSX应用了


660
00:41:24,084 --> 00:41:26,653
如果你选择这样做的话 
我将向你展示执行代码


661
00:41:26,720 --> 00:41:29,323
但在那之前


662
00:41:29,389 --> 00:41:31,091
你已经猜到了 演示时间到


663
00:41:36,997 --> 00:41:39,700
我拿了一个iPad 好的


664
00:41:41,935 --> 00:41:45,572
在这个IPad上 
我运行一个合成器应用


665
00:41:45,639 --> 00:41:47,007
叫做Nave


666
00:41:47,074 --> 00:41:49,810
我喜欢这个应用是因为有一些补丁


667
00:41:49,877 --> 00:41:51,445
能使你获得更好的


668
00:41:51,512 --> 00:41:53,013
触摸界面


669
00:41:53,614 --> 00:41:54,748
让你在点击后


670
00:41:54,815 --> 00:41:56,316
系统自动进行操作


671
00:41:56,383 --> 00:41:58,452
很多市面上
的MIDI控制器做不到这点


672
00:41:58,519 --> 00:42:01,622
这正式iPad能成为
优秀的音乐处理器的原因


673
00:42:02,322 --> 00:42:04,925
所以我在这选了一个补丁
 听起来就是这样 


674
00:42:12,065 --> 00:42:14,168
我喜欢那些声音 所以我想录制到


675
00:42:14,234 --> 00:42:16,370
MAC的嘻哈音乐项目里去


676
00:42:16,904 --> 00:42:21,375
所以 让我们转移到Mac 


677
00:42:26,680 --> 00:42:29,583
在Mac上MIDI音频软件在运行了


678
00:42:30,584 --> 00:42:35,455
找到窗口菜单 
打开了iOS浏览器 


679
00:42:36,223 --> 00:42:39,126
然后看到我目前没有连接IOS设备


680
00:42:39,927 --> 00:42:41,528
然后 我插上我的iPad 


681
00:42:44,164 --> 00:42:45,699
它立刻就出现了


682
00:42:46,033 --> 00:42:48,435
瞬间又不见了 
然而只要单击Enable 


683
00:42:48,969 --> 00:42:52,840
现在多一个音频设备了


684
00:42:53,207 --> 00:42:55,108
是的 马上就搞定了


685
00:42:55,809 --> 00:42:58,545
你可以看到这里
有一个双通道输入音频设备


686
00:42:58,612 --> 00:42:59,513
已经添加到这里


687
00:42:59,580 --> 00:43:02,683
所以我想用到我的Logic项目上 


688
00:43:02,749 --> 00:43:04,117
所以我会继续前进 然后说 用吧


689
00:43:08,856 --> 00:43:10,390
让我们回到Logic这里


690
00:43:11,625 --> 00:43:13,627
好吧 这就是我处理好的节奏


691
00:43:21,201 --> 00:43:25,339
我想录制到音轨 所以我要


692
00:43:25,405 --> 00:43:26,974
制作一个新的音轨


693
00:43:29,209 --> 00:43:31,745
启动录音监控程序和录音键


694
00:43:32,779 --> 00:43:36,216
把音量调小一点


695
00:43:39,219 --> 00:43:42,022
现在
我能听到这声音直接录制到音轨里


696
00:43:42,422 --> 00:43:44,358
让我们录上一首吧


697
00:44:02,442 --> 00:44:04,645
如果重新播放


698
00:44:06,547 --> 00:44:09,316
那么就会按我所希望的进行音频捕捉


699
00:44:14,688 --> 00:44:16,023
战斗吧 老兄


700
00:44:24,331 --> 00:44:26,066
现在 简单总结一下我的演示


701
00:44:26,133 --> 00:44:28,268
请在家里试试


702
00:44:28,335 --> 00:44:29,970
现在Beta版已经有了


703
00:44:30,037 --> 00:44:32,306
如果你发现有错误 直接登陆


704
00:44:32,372 --> 00:44:35,409
bugreport.apple.com 
然后提交你的错误给我们


705
00:44:36,977 --> 00:44:39,513
好了 最后讲讲IDAM吧


706
00:44:39,580 --> 00:44:43,016
要求是OS X El 
Capitan系统和iOS9系统


707
00:44:43,650 --> 00:44:45,919
闪存接口就能在iPhone上用了


708
00:44:45,986 --> 00:44:47,421
也可以在iPads上使用


709
00:44:47,487 --> 00:44:51,024
通过闪存接口 
但是早期的iPad mini无法用


710
00:44:51,625 --> 00:44:55,762
如果你有家用iPhone 
工作用iPhone 家用iPad 


711
00:44:55,829 --> 00:44:59,900
工作用iPad和小孩
用的iPad并且有充电器


712
00:44:59,967 --> 00:45:02,302
你可以同时插入使用


713
00:45:02,536 --> 00:45:05,405
然后集合成10通道的输入设备


714
00:45:05,472 --> 00:45:06,573
只要你想 就可以开始录制


715
00:45:07,274 --> 00:45:09,877
如果还有USB端口 


716
00:45:09,943 --> 00:45:13,480
那么请打开Safari浏览器
进入苹果商城网址


717
00:45:20,988 --> 00:45:22,956
好了 我之前说过我会告诉你


718
00:45:23,023 --> 00:45:25,559
如何在OS X
应用里嵌入视图控制器 


719
00:45:25,626 --> 00:45:27,094
如果你要这样做 


720
00:45:27,160 --> 00:45:28,428
我会现在给你展示代码


721
00:45:32,900 --> 00:45:34,401
这个代码是样本的 


722
00:45:34,768 --> 00:45:36,870
我想强调这个部分 


723
00:45:36,937 --> 00:45:39,840
如果你看到黄色文本部分 


724
00:45:39,907 --> 00:45:42,643
你可以看到CA跨设备音频视图控制器


725
00:45:43,076 --> 00:45:46,213
创建一个 然后把这个子视图添加


726
00:45:46,280 --> 00:45:47,381
到你的视图容器里面


727
00:45:49,383 --> 00:45:52,619
我想谈CoreAudioKit中 


728
00:45:52,686 --> 00:45:53,720
新的视图控制器


729
00:45:53,787 --> 00:45:55,689
可能有你感兴趣的


730
00:45:56,356 --> 00:46:00,761
我们也添加了
CABTLEMIDI窗口控制器


731
00:46:01,428 --> 00:46:05,732
这是用于
配置蓝牙低功率MIDI设备的UI


732
00:46:05,799 --> 00:46:07,701
去年这可是个亮点


733
00:46:08,168 --> 00:46:09,937
是NS窗口控制器的子类 


734
00:46:10,304 --> 00:46:13,874
它的视图像这样 所以如果你也想的话


735
00:46:13,941 --> 00:46:16,510
你可以直接把它嵌入OS X应用里 


736
00:46:18,412 --> 00:46:19,746
另外


737
00:46:19,813 --> 00:46:22,816
我们还有CA网络浏览器窗口控制器


738
00:46:22,883 --> 00:46:25,719
这是配置音频视频桥


739
00:46:25,786 --> 00:46:27,821
音频设备的UI


740
00:46:28,155 --> 00:46:30,290
还有一个NS窗口控制器子类


741
00:46:30,757 --> 00:46:32,693
它的视图看起来像这样


742
00:46:37,097 --> 00:46:40,934
好的 让我们启动转换装置


743
00:46:41,001 --> 00:46:43,170
然后继续讨论
  AVAudio有什么新玩意儿


744
00:46:44,037 --> 00:46:46,507
你们中会有
多少人听播客和有声读物 


745
00:46:47,541 --> 00:46:48,675
很好 有许多人


746
00:46:48,742 --> 00:46:50,677
你们中
又有多少人用你的iPhone 


747
00:46:50,744 --> 00:46:52,613
作为私人导航设备


748
00:46:54,248 --> 00:46:55,282
同样也是许多人


749
00:46:55,349 --> 00:46:57,351
好的 你之前可能已经见过这个问题


750
00:46:57,651 --> 00:46:59,553
让我们假设你将去一个你从未去过的


751
00:46:59,620 --> 00:47:01,021
灵魂料理餐厅


752
00:47:01,088 --> 00:47:01,955
你正在导航


753
00:47:02,022 --> 00:47:03,891
然后你正在听一则播客


754
00:47:03,957 --> 00:47:07,194
这则播客由播客名人X主持


755
00:47:07,461 --> 00:47:11,331
他们正在采访你最喜欢的时下


756
00:47:11,398 --> 00:47:14,801
名人Y在采访的中途


757
00:47:15,002 --> 00:47:17,137
对话真的是妙趣横生


758
00:47:17,237 --> 00:47:19,506
这个时候你的导航跳出


759
00:47:19,673 --> 00:47:23,043
告诉你500尺后靠右


760
00:47:24,278 --> 00:47:26,246
在那之后你听见刺耳的笑声


761
00:47:26,313 --> 00:47:28,415
播客讲了很棒的笑话而你正好错过了


762
00:47:28,515 --> 00:47:31,718
因此你返回到音频界面 开始再播放


763
00:47:31,785 --> 00:47:34,154
正当要播到笑话时“靠右行驶” 


764
00:47:36,957 --> 00:47:41,128
握起拳头说 我的用户体验很糟糕


765
00:47:42,196 --> 00:47:44,598
好的 
对此 我们应当有一个解决方法


766
00:47:45,966 --> 00:47:47,367
我对此深感不自由


767
00:47:49,069 --> 00:47:51,238
我们在iOS 9中提供一个解决方法


768
00:47:51,538 --> 00:47:54,174
现在播客
和有声读物应用程序可以用一种新的


769
00:47:54,241 --> 00:47:58,078
AVAudioSession
模式叫模式口语音频


770
00:47:58,879 --> 00:48:00,547
用于导航应用和类似的应用


771
00:48:00,614 --> 00:48:01,815
中断其中一个


772
00:48:01,882 --> 00:48:04,284
就会发出发声提示


773
00:48:04,685 --> 00:48:07,721
新的AVAudioSession
种类选项


774
00:48:07,788 --> 00:48:10,290
叫做混合模式中断口音频


775
00:48:10,691 --> 00:48:12,025
现在 地图已经使用 


776
00:48:12,092 --> 00:48:14,561
混合模式中断口音频以及


777
00:48:14,628 --> 00:48:16,663
而播客和电子读物


778
00:48:16,730 --> 00:48:19,099
已使用AVAudioSession
模式口语音频


779
00:48:19,166 --> 00:48:21,134
你如何在你的应用中使用呢


780
00:48:21,835 --> 00:48:23,170
好的 让我们来看一些代码


781
00:48:23,770 --> 00:48:26,507
我将逐行查看这些代码


782
00:48:26,573 --> 00:48:28,208
以便你能了解我们正在做什么


783
00:48:28,442 --> 00:48:30,744
首先我们将从设置你的音频会话开始


784
00:48:30,978 --> 00:48:33,146
你会得到音频会话的共享实例


785
00:48:33,614 --> 00:48:37,818
设置你的类别为录音在选项中


786
00:48:37,885 --> 00:48:39,653
你选择一项则其他失效


787
00:48:40,587 --> 00:48:42,422
现在我们将用Swift 2的新特性


788
00:48:42,990 --> 00:48:44,725
这个是新的特性


789
00:48:44,791 --> 00:48:48,028
允许你将早些时候iOS的代码


790
00:48:48,095 --> 00:48:50,364
部署到现在使用的iOS系统中


791
00:48:50,864 --> 00:48:53,600
因此只有在iOS 9
或者之后的系统里


792
00:48:53,934 --> 00:48:56,203
你才可以看到这个多出的选项


793
00:48:56,270 --> 00:48:58,372
混合模式中断口语音频


794
00:48:59,039 --> 00:49:00,941
然后设置音频会话种类


795
00:49:02,543 --> 00:49:04,344
好的 让我们来实际看一下导航提示


796
00:49:05,078 --> 00:49:07,281
现在播放导航提示


797
00:49:07,381 --> 00:49:08,515
就像这样


798
00:49:08,849 --> 00:49:11,218
首先获取音频会话的共享实例


799
00:49:11,652 --> 00:49:14,821
接着使用功能原型中的URL


800
00:49:14,888 --> 00:49:16,390
创建一个AV音频播放器


801
00:49:17,324 --> 00:49:19,193
你设置播放器指派给自己


802
00:49:19,726 --> 00:49:22,829
这样做是 当你的音频提示播放完成


803
00:49:22,896 --> 00:49:24,498
它将自动为你


804
00:49:24,565 --> 00:49:26,700
调用指派方法


805
00:49:28,535 --> 00:49:30,237
将音频会话设置为激活


806
00:49:30,437 --> 00:49:31,805
然后运行播放器


807
00:49:33,240 --> 00:49:35,108
现在我们继续


808
00:49:35,175 --> 00:49:37,144
现在 音频已经播放完


809
00:49:37,211 --> 00:49:38,912
因此 指派方法将被调用


810
00:49:38,979 --> 00:49:40,581
音频播放器完成播放


811
00:49:40,981 --> 00:49:42,249
代码是这样的


812
00:49:42,583 --> 00:49:44,418
获取音频会话共享实例


813
00:49:45,185 --> 00:49:47,688
设置音频会话为闲置


814
00:49:47,921 --> 00:49:51,558
使用选项选择通知其他反激活


815
00:49:52,392 --> 00:49:55,262
这意味着任何其它正在播放的其它音频


816
00:49:55,329 --> 00:49:57,331
在中断当前音频之前


817
00:49:57,397 --> 00:49:58,699
会实现进行通知


818
00:50:00,200 --> 00:50:01,468
现在让我们来看看另一方面


819
00:50:01,535 --> 00:50:05,539
让我们到播客或者音频应用


820
00:50:06,573 --> 00:50:08,575
这里是音频会话设置


821
00:50:08,775 --> 00:50:10,511
获取音频会话的共享实例


822
00:50:11,011 --> 00:50:12,746
设置你的种类为录音


823
00:50:12,980 --> 00:50:15,215
当前设置模式为默认


824
00:50:15,616 --> 00:50:19,953
如果是iOS 9或者之后的版本
你可以用这种新的模式


825
00:50:20,187 --> 00:50:22,623
AVAudioSession
模式口语音频


826
00:50:22,756 --> 00:50:24,291
然后设置种类和模式


827
00:50:26,093 --> 00:50:27,528
接下来要做的是


828
00:50:27,594 --> 00:50:28,929
添加中断处理器


829
00:50:28,996 --> 00:50:32,099
我们将添加一个
中断处理器名为处理中断


830
00:50:32,165 --> 00:50:35,903
在响应AVAudioSession
中断通知


831
00:50:36,036 --> 00:50:39,206
后被调用


832
00:50:41,074 --> 00:50:43,644
现在也可以设置好其他的通知


833
00:50:43,710 --> 00:50:46,480
例如 如果媒体服务器停止运行


834
00:50:46,547 --> 00:50:49,016
而你想要被通知
你就可以重设你的音频状态


835
00:50:50,551 --> 00:50:52,686
好的 让我们来看看中断处理器


836
00:50:54,188 --> 00:50:55,322
要做的第一件事情


837
00:50:55,389 --> 00:50:58,525
从功能原型中的NS 通知对象中


838
00:50:58,592 --> 00:50:59,927
获取用户信息字典


839
00:51:00,827 --> 00:51:03,197
从中我们可以看到


840
00:51:03,263 --> 00:51:06,266
关键AVAudioSession
的中断类型密匙


841
00:51:07,801 --> 00:51:09,503
现在我们将选择那种类型


842
00:51:09,870 --> 00:51:12,272
第一部分是当你的音频会话


843
00:51:12,739 --> 00:51:15,542
开始被中断时将会发生什么


844
00:51:15,943 --> 00:51:18,579
然后第二部分将在下一张幻灯片上
这是结束


845
00:51:18,645 --> 00:51:21,281
如果这是开始中断


846
00:51:21,582 --> 00:51:23,584
你想做的第一件事是更新UI 


847
00:51:23,650 --> 00:51:25,652
从而用以提示录音已经被停止


848
00:51:26,320 --> 00:51:29,823
然后如果你的内部状态强制规定播放


849
00:51:29,890 --> 00:51:31,525
然后你可设置为播放


850
00:51:31,592 --> 00:51:35,996
它稍后将告诉你
这个中断什么时候完成


851
00:51:36,063 --> 00:51:39,333
你可以重放音频


852
00:51:39,766 --> 00:51:42,069
如果合适 更新你的内部状态


853
00:51:44,371 --> 00:51:46,106
因此 现在这是结束中断


854
00:51:46,173 --> 00:51:48,408
因此 如果这是结束中断


855
00:51:48,709 --> 00:51:50,944
你将从AVAudioSession


856
00:51:51,011 --> 00:51:53,447
中断选项密匙


857
00:51:54,815 --> 00:51:57,117
用户信息字典中获取标志旗


858
00:51:57,184 --> 00:51:59,520
假如这标志旗是重新开始的选项


859
00:52:00,020 --> 00:52:02,089
稍微回放一下音频


860
00:52:02,155 --> 00:52:04,458
因为你的音频在结束之前已经被暂停


861
00:52:04,892 --> 00:52:06,226
然后你可以在此启动播放器


862
00:52:06,793 --> 00:52:09,830
更新你的内部状态然后更新UI 


863
00:52:09,897 --> 00:52:11,331
从而显示已经重新开始播放


864
00:52:12,766 --> 00:52:14,168
这就是我为你准备的所有代码


865
00:52:15,369 --> 00:52:16,370
快速回顾


866
00:52:16,436 --> 00:52:17,371
今天我已经告诉过你


867
00:52:17,437 --> 00:52:20,274
关于AVAudioEngine里
一些令人兴奋的新增强特性


868
00:52:20,574 --> 00:52:23,010
我们介绍了跨设备音频模式


869
00:52:23,744 --> 00:52:26,046
关于新的
CoreAudioKit视图控制器


870
00:52:26,113 --> 00:52:28,081
你可以将跨设备音频模式


871
00:52:28,482 --> 00:52:31,618
蓝牙 低功率MIDI以及视音频桥


872
00:52:31,685 --> 00:52:33,020
嵌入你的OS X应用


873
00:52:33,787 --> 00:52:36,857
也介绍AVAudioSession
模式口语音频


874
00:52:37,291 --> 00:52:39,593
以及新的
AVAudioSession选项


875
00:52:39,760 --> 00:52:41,895
混合模式终端口语音频


876
00:52:42,663 --> 00:52:43,964
但这不是全部


877
00:52:44,031 --> 00:52:47,434
明天早上11点我们会有另外一个环节


878
00:52:47,701 --> 00:52:50,637
是关于音频单元扩展的的新变化


879
00:52:50,704 --> 00:52:52,472
所以我们希望明天再见到你们所有人


880
00:52:53,140 --> 00:52:55,809
同样还有与
今天早些时候讨论的相关环节


881
00:52:55,876 --> 00:52:57,644
如果你想再次回顾


882
00:52:57,711 --> 00:53:01,381
尤其是游戏音频方面


883
00:53:02,115 --> 00:53:04,585
如果我们不能
在实验室里回答你们的所有问题


884
00:53:04,751 --> 00:53:08,555
这里有非常实用的网站


885
00:53:09,623 --> 00:53:12,693
也可以直接咨询克雷格·吉士利


886
00:53:12,759 --> 00:53:16,430
他的联系方式就在下方 结束了

