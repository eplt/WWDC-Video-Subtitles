1
00:00:16,633 --> 00:00:17,733
女士们先生们


2
00:00:18,033 --> 00:00:23,233
欢迎OS X系统平台副总裁
安卓思·温克尔


3
00:00:31,433 --> 00:00:32,567
安卓思·温克尔:
下午好


4
00:00:33,033 --> 00:00:35,433
欢迎来到2015
全球开发者大会


5
00:00:37,167 --> 00:00:39,700
作为苹果开发者
今年又是一个欣喜之年


6
00:00:39,767 --> 00:00:42,367
加上watchOS
SDK的开发数据包


7
00:00:42,433 --> 00:00:44,867
现在苹果产品有三大主要平台


8
00:00:46,200 --> 00:00:47,800
我们开发这些平台的方法是


9
00:00:47,867 --> 00:00:51,067
将好产品与独特的用户体验
结合在一起


10
00:00:51,567 --> 00:00:54,533
同时使用与苹果系统一样的
优先科技


11
00:00:54,600 --> 00:00:56,733
程序语言设计和编程概念


12
00:00:57,067 --> 00:00:59,900
以便这些平台
之间能够轻易地代码共享


13
00:01:00,267 --> 00:01:02,933
并使平台之间的应用实现协作


14
00:01:03,000 --> 00:01:05,633
但我们也保持
每一个平台的特色


15
00:01:07,600 --> 00:01:09,367
这些平台的数据开发包将会在


16
00:01:09,433 --> 00:01:12,967
今年稍后安装到
Xcode IDE新版本


17
00:01:13,200 --> 00:01:14,300
形成版本7


18
00:01:15,333 --> 00:01:17,233
它包含了很多新的特色


19
00:01:17,300 --> 00:01:19,600
在这里我只想
强调其中一个


20
00:01:20,267 --> 00:01:23,067
那就是
我们允许用户AppleID


21
00:01:23,133 --> 00:01:24,200
下载Xcode


22
00:01:24,267 --> 00:01:26,400
并在他们的设备上运行应用


23
00:01:36,967 --> 00:01:38,733
如果你们真的想让
成为开发者的梦想


24
00:01:38,800 --> 00:01:41,733
更容易
尤其对年轻的学生来说


25
00:01:42,033 --> 00:01:44,500
那么 需要三个平台的协作


26
00:01:46,267 --> 00:01:49,000
如果你习惯使用某个应用
并想进行拓展


27
00:01:49,067 --> 00:01:50,600
我们为你准备了
另外一个好消息


28
00:01:51,067 --> 00:01:54,300
现在 一项单向支付的
开发者计划会员身份


29
00:01:54,367 --> 00:01:58,200
可以让你展开苹果产品中
所有的应用


30
00:01:58,267 --> 00:01:59,600
你不需要注册


31
00:01:59,667 --> 00:02:01,100
且不需要购买支付会员资格


32
00:02:09,733 --> 00:02:11,600
当然
使用一次性支付会员身份的话


33
00:02:11,667 --> 00:02:14,200
你还可以得到其它好处


34
00:02:14,267 --> 00:02:16,033
比如获取预发行版本微软


35
00:02:16,400 --> 00:02:19,267
接入强大的数据库 报表工具


36
00:02:21,133 --> 00:02:22,967
现在
我想说说软件方面的更新


37
00:02:25,700 --> 00:02:29,600
iOS创新曲线一直是
整个行业的骄傲


38
00:02:29,833 --> 00:02:31,767
对美国开发者而言
是巨大的优势


39
00:02:32,233 --> 00:02:34,800
因为你不需要处理来自


40
00:02:34,867 --> 00:02:36,367
其它应用生态系
统的相同数据碎片


41
00:02:38,200 --> 00:02:40,267
但是在iOS8中
我们发现


42
00:02:40,333 --> 00:02:42,567
大量使用者在升级方面有困难


43
00:02:42,633 --> 00:02:43,600
因为安装程序


44
00:02:43,667 --> 00:02:45,733
需要很大的可用空间


45
00:02:46,467 --> 00:02:47,300
我们已经采取措施


46
00:02:47,367 --> 00:02:49,600
在iOS8更新中
减少了占用空间


47
00:02:50,200 --> 00:02:52,200
在iOS9中
我们会继续降低该数值


48
00:02:52,433 --> 00:02:54,067
正如你们今早
在主旨发言中听到的


49
00:02:54,433 --> 00:02:57,533
iOS9只需要
1.3G的可用空间


50
00:02:58,967 --> 00:03:02,200
我们也改变了
软件升级的提醒方式


51
00:03:02,600 --> 00:03:05,633
用户可以选择立即安装
或者在不方便的时候


52
00:03:05,700 --> 00:03:08,300
选择稍后安装


53
00:03:08,367 --> 00:03:11,433
所以 我们认为


54
00:03:11,500 --> 00:03:14,967
这将确保用户快速更新iOS


55
00:03:15,133 --> 00:03:20,467
使用最新版本的iOS


56
00:03:20,667 --> 00:03:22,567
现在 我们还在研究一些技术


57
00:03:22,633 --> 00:03:25,033
我们称为应用瘦身


58
00:03:25,100 --> 00:03:26,933
让用户获得更多可用空间


59
00:03:28,000 --> 00:03:31,167
应用瘦身包括三项技术
应用切割


60
00:03:31,500 --> 00:03:33,700
需加载资源和位码


61
00:03:34,433 --> 00:03:35,900
我们一个一个地看一下


62
00:03:36,000 --> 00:03:36,900
先来看应用切割


63
00:03:39,600 --> 00:03:41,800
为iOS系统开发应用


64
00:03:41,867 --> 00:03:43,500
其实就是开发
同一款应用的不同变体


65
00:03:43,567 --> 00:03:45,167
然后将它们包装在一起


66
00:03:45,233 --> 00:03:46,433
放在一个应用程序包里


67
00:03:47,100 --> 00:03:49,067
所以 如果你打开一个应用
你会发现


68
00:03:49,133 --> 00:03:52,767
有很多相似的其他组件
占用设备的有限空间


69
00:03:53,867 --> 00:03:57,100
这是32位和64位
的处理器结构


70
00:03:58,033 --> 00:04:00,400
不同屏幕尺寸和分辨率的图像


71
00:04:01,500 --> 00:04:03,633
以及工具 比如着色器


72
00:04:03,700 --> 00:04:06,267
用不同语言编写
而成的图形编辑器


73
00:04:07,567 --> 00:04:09,867
但是 要在特定的
设备中运行一款应用


74
00:04:10,300 --> 00:04:12,633
你只需要其中的一个即可


75
00:04:13,933 --> 00:04:15,967
所以为了充分利用储存空间


76
00:04:16,033 --> 00:04:18,466
我们将删除设备中


77
00:04:18,533 --> 00:04:19,632
所有的应用


78
00:04:19,700 --> 00:04:21,166
所不需要的所有组件


79
00:04:22,733 --> 00:04:26,633
所以你可以继续开发
并且使用你已习惯的应用


80
00:04:27,400 --> 00:04:31,967
但是商店只会安装时传输
经过瘦身应用给到用户


81
00:04:41,667 --> 00:04:44,033
这就是大大缩减了空间


82
00:04:44,967 --> 00:04:48,000
正如你们在表格中看到的
一般的应用可以节省


83
00:04:48,067 --> 00:04:49,867
20%到40%的空间


84
00:04:51,100 --> 00:04:53,933
应用瘦身的作用
在一些应用中


85
00:04:54,000 --> 00:04:56,133
体现的尤其明显
比如在安装单元应用中时


86
00:04:56,200 --> 00:04:58,967
经常突然出现游戏下载限制


87
00:04:59,600 --> 00:05:02,867
瘦身版本可以更加容易地
在限制范围内安装完成


88
00:05:03,367 --> 00:05:05,967
所以你可以将更多的特定资源


89
00:05:06,033 --> 00:05:07,633
放到应用中并且提供给用户


90
00:05:07,700 --> 00:05:08,967
提供更加完美的体验


91
00:05:10,567 --> 00:05:13,767
最棒的一点是
在使用Xcode的资产目录


92
00:05:14,000 --> 00:05:15,967
你不需要
改变程序中的任何东西


93
00:05:16,033 --> 00:05:20,033
在你下次登陆的时候
后台将会自动为你备份更新等


94
00:05:21,033 --> 00:05:23,200
如果你在使用
其他自定义数据格式


95
00:05:23,500 --> 00:05:26,967
我们要求你通过
创建资产目录以分成程序片


96
00:05:27,433 --> 00:05:30,333
并且使用我们为你的设备


97
00:05:30,400 --> 00:05:32,700
添加的其所需的新的资产目录


98
00:05:36,367 --> 00:05:39,333
一些应用可以通过使用
更多资源得到好处


99
00:05:39,467 --> 00:05:41,567
因为不需要
同时使用各种程序片


100
00:05:42,200 --> 00:05:44,167
在这种情况下
我们推荐


101
00:05:44,333 --> 00:05:46,900
按需资源 简称ODR


102
00:05:48,467 --> 00:05:51,067
使用ODR按需资源时
储备会将你的资源分为


103
00:05:51,133 --> 00:05:52,933
恰当程序片


104
00:05:53,000 --> 00:05:54,867
然后将它们
放置在苹果服务器中


105
00:05:55,733 --> 00:05:56,800
但是下载过程会被延迟


106
00:05:56,867 --> 00:05:58,833
直到你的应用明确需要他们


107
00:05:59,167 --> 00:06:01,767
然后iOS将释放空间


108
00:06:01,833 --> 00:06:03,800
当你的应用不再需要资源时


109
00:06:05,733 --> 00:06:09,400
按需资源的
典型类型是关卡游戏


110
00:06:09,567 --> 00:06:12,433
但是很多其它应用
也可以在其中得到益处


111
00:06:12,833 --> 00:06:15,667
比如 你可能想要下载教程


112
00:06:16,033 --> 00:06:17,333
到ODR资产中


113
00:06:17,467 --> 00:06:20,900
当用户真正想看
的时候才会开始下载


114
00:06:23,567 --> 00:06:26,100
使用ODR
需要你懂得规划


115
00:06:26,400 --> 00:06:27,500
但重要的是


116
00:06:27,567 --> 00:06:31,600
你可以在不同时间
使用多于4G的资源


117
00:06:33,867 --> 00:06:35,833
因此 应用切割和需加载资源


118
00:06:36,167 --> 00:06:38,700
将会极大地帮助应用节省空间


119
00:06:40,167 --> 00:06:41,833
我们还在研究一项新技术


120
00:06:41,900 --> 00:06:43,200
它是更有远见的技术


121
00:06:43,433 --> 00:06:46,333
我们现在将位码引入到
AppStore提交过程中


122
00:06:47,733 --> 00:06:51,100
位码是二进制中的
一种框架系统中间代码


123
00:06:51,400 --> 00:06:54,633
它可以让商店先
优化你的设备应用


124
00:06:54,700 --> 00:06:58,133
然后再传输给用户


125
00:06:59,200 --> 00:07:01,900
你在Xcode中
正常开发和调试应用


126
00:07:02,533 --> 00:07:03,867
但是商店将会进入一种状态


127
00:07:04,733 --> 00:07:08,833
不断运行
我们更新的编译器优化


128
00:07:09,333 --> 00:07:11,900
这样你的应用能够在
所有的设备中运行顺畅


129
00:07:13,200 --> 00:07:14,467
应用将不断更新


130
00:07:15,300 --> 00:07:18,633
因为App Store
会不断让你的应用


131
00:07:19,100 --> 00:07:22,833
获得也许会加入未来
新处理器的运算优势


132
00:07:23,300 --> 00:07:26,000
所有这一切你都不需要
向AppStore重新提交


133
00:07:35,233 --> 00:07:38,767
所以位码的形成可以
通过Xcode进行设置


134
00:07:39,233 --> 00:07:42,667
从一开始这便强制对
所有watchOS系统执行


135
00:07:43,067 --> 00:07:44,967
对与iOS系统来说
现在属于可选项


136
00:07:45,767 --> 00:07:47,633
尽管我们认为优势很好


137
00:07:47,867 --> 00:07:50,500
因此我们准备默认
对所有项目采用该服务


138
00:07:52,367 --> 00:07:53,533
这就是应用瘦身


139
00:07:54,067 --> 00:07:57,233
它包括了应用切割
按需资源以及位码


140
00:07:57,633 --> 00:07:59,333
这些将会极大地优化应用


141
00:08:00,733 --> 00:08:02,200
尤其是储存空间方面


142
00:08:03,200 --> 00:08:04,567
现在 我们来看一下


143
00:08:04,767 --> 00:08:06,200
应用中的二进制


144
00:08:06,267 --> 00:08:10,333
AppStore目前要求你
应用使用32位和64位版本


145
00:08:11,500 --> 00:08:13,267
在过去的几年中
我们见证了


146
00:08:13,333 --> 00:08:16,567
我们系统设备
在处理器能力上的发展


147
00:08:17,167 --> 00:08:20,000
我们的中央处理器
和图形处理器


148
00:08:20,567 --> 00:08:23,433
以及引入
64位处理器体系结构


149
00:08:23,500 --> 00:08:24,600
之后的所有设备


150
00:08:25,433 --> 00:08:28,300
所以该应用目录


151
00:08:28,733 --> 00:08:30,767
仅仅适用64位处理器


152
00:08:32,033 --> 00:08:33,366
和64位体系结构


153
00:08:33,467 --> 00:08:37,232
因此用户
只可以提交64位应用


154
00:08:37,732 --> 00:08:39,799
这将从今年稍晚
系统9开始使用之后


155
00:08:46,033 --> 00:08:48,333
接着我们来说watchOS
软件开发工具包


156
00:08:48,400 --> 00:08:50,133
为了解说 我想把舞台交给


157
00:08:50,200 --> 00:08:51,800
我的同事：
易丽扎·布洛克


158
00:09:01,500 --> 00:09:02,767
易丽扎·布洛克
谢谢 安卓思


159
00:09:04,833 --> 00:09:07,700
我们很高兴
Watch系统在研发者社区


160
00:09:07,767 --> 00:09:09,000
得到了认可


161
00:09:11,000 --> 00:09:12,467
在苹果商店中很早就已经有


162
00:09:12,533 --> 00:09:15,133
上千种手表的应用


163
00:09:15,667 --> 00:09:17,567
今天 我很高兴地
告诉大家


164
00:09:17,900 --> 00:09:22,267
更多关于WatchOS 2
软件开发工具包的一些新特点


165
00:09:26,767 --> 00:09:30,633
首先我们来讨论一下
watchOS现有构架


166
00:09:32,000 --> 00:09:34,733
应用有个用户界面
你可以将它作为


167
00:09:34,800 --> 00:09:37,333
一个故事版
这会被安装在手表中


168
00:09:38,833 --> 00:09:42,533
点击应用程序扩展
来打开用户界面


169
00:09:42,833 --> 00:09:44,167
它在手机上运行


170
00:09:47,633 --> 00:09:52,467
在watchOS2中我们
在结构上做了一个重大改变


171
00:09:53,667 --> 00:09:56,500
用户界面依旧一样
应用扩展将


172
00:09:56,567 --> 00:09:58,333
在手表中运行


173
00:09:58,700 --> 00:10:00,367
这产生了很多益处


174
00:10:03,233 --> 00:10:05,900
因为这与手表应用
相互作用


175
00:10:05,967 --> 00:10:08,833
不再需要绑定在手机中
使用应用的用户


176
00:10:10,333 --> 00:10:15,367
用户会在速度和应用反应上
感受到实质性的改进


177
00:10:16,500 --> 00:10:18,133
当然 因为同样的原因


178
00:10:18,400 --> 00:10:22,033
你的手表应用
也可以在手机不在的时候运行


179
00:10:23,867 --> 00:10:26,333
由此应用扩展
直接在手表运行


180
00:10:26,600 --> 00:10:28,367
它直接连接手表硬件


181
00:10:28,700 --> 00:10:30,600
这就产生了无数可能性


182
00:10:36,367 --> 00:10:40,167
现在
你编写手表应用时


183
00:10:40,667 --> 00:10:42,200
你会用什么程序设计语言？


184
00:10:43,533 --> 00:10:46,133
好消息是和其他很多框架一样


185
00:10:46,467 --> 00:10:50,133
和你已经非常熟悉
的iOS开发框架一样


186
00:10:54,867 --> 00:10:56,433
还有另外一个重点


187
00:10:58,567 --> 00:11:02,700
手表的连接框架可以使你
与手机应用对接


188
00:11:02,767 --> 00:11:04,767
当然了
现在正在其他设备中运行


189
00:11:08,900 --> 00:11:11,433
另外 你的应用扩展可以直接


190
00:11:11,500 --> 00:11:14,733
与使用网络接口语言程序的
网络服务对接


191
00:11:16,400 --> 00:11:21,133
即使你的手机不在范围内
这种交接也可以进行


192
00:11:34,033 --> 00:11:38,000
在当前watchOS应用中
有三种方法可以查看数据


193
00:11:38,200 --> 00:11:42,233
快捷视图 通知以及应用本身


194
00:11:43,700 --> 00:11:44,733
但是 这样会不会很棒


195
00:11:45,433 --> 00:11:47,533
假设你只要抬起手腕
甚至不需要触碰屏幕


196
00:11:47,600 --> 00:11:50,767
就可以看到你的应用目录


197
00:11:51,967 --> 00:11:54,100
在watchOS 2中
这有可能实现


198
00:11:54,200 --> 00:11:57,167
因为现在你可以
在手表界面创建一个程序


199
00:12:00,967 --> 00:12:04,500
我们为手表设计了
简短对接


200
00:12:04,767 --> 00:12:06,900
并且以最快的方式
看到你的目录


201
00:12:06,967 --> 00:12:09,867
那就是通过程序
快捷视图以及通知


202
00:12:10,433 --> 00:12:11,933
所以 让我们进一步了解一下


203
00:12:18,600 --> 00:12:19,767
不要理会这些名字


204
00:12:19,833 --> 00:12:21,733
程序其实很简单


205
00:12:22,433 --> 00:12:24,400
它们信息片段


206
00:12:24,467 --> 00:12:26,467
出现在你手表界面上而已


207
00:12:28,400 --> 00:12:31,667
因此 如果我们打开
手表界面并去掉时间


208
00:12:32,000 --> 00:12:33,833
就只剩一个程序


209
00:12:35,367 --> 00:12:38,167
现在 你在这里看到的
是OS系统的内部情况


210
00:12:39,367 --> 00:12:40,833
现在你可以自行创建了


211
00:12:43,433 --> 00:12:46,300
现在 你可能还不太了解


212
00:12:46,367 --> 00:12:49,633
比如
旧金山足球俱落部正在举行


213
00:12:49,700 --> 00:12:51,033
2015年锦标赛


214
00:12:52,933 --> 00:12:55,467
所以 我们可以创建一个程序


215
00:12:55,533 --> 00:12:59,433
来模块化提醒我们
接下来是进行哪场比赛


216
00:13:03,233 --> 00:13:05,167
如果我安装到我的手表上


217
00:13:05,933 --> 00:13:09,400
每次抬起手腕我都会看到


218
00:13:10,000 --> 00:13:13,300
这很好
但要做到一个好的体验


219
00:13:13,867 --> 00:13:16,933
很重要的是
随着时间变化以及程序所需


220
00:13:17,000 --> 00:13:19,133
程序需要作出相应变化


221
00:13:19,700 --> 00:13:22,900
一打开屏幕这些就会出现


222
00:13:25,200 --> 00:13:26,467
为了达到这个效果


223
00:13:26,967 --> 00:13:30,833
我们为你的程序
以时间线的方式收集数据


224
00:13:34,733 --> 00:13:37,633
那样 当我那天看看我的手表


225
00:13:38,033 --> 00:13:40,400
程序就会提示信息


226
00:13:40,467 --> 00:13:42,467
告诉我此时此刻的信息


227
00:13:49,000 --> 00:13:51,567
所以在日程中
创建一个时间线


228
00:13:51,800 --> 00:13:54,500
来提示足球比赛非常简单


229
00:13:54,967 --> 00:13:56,900
一方面 我制作一个日程


230
00:13:57,567 --> 00:14:00,433
另一方面 这不太可能改变


231
00:14:01,033 --> 00:14:03,533
但是 这可能不是
你创建程序的理由


232
00:14:05,767 --> 00:14:08,500
世界上事物在变化你可能需要


233
00:14:08,567 --> 00:14:10,400
随时更新你的时间表


234
00:14:11,600 --> 00:14:13,633
我们为此
提供了几种方法


235
00:14:14,667 --> 00:14:16,400
第一种是计划更新


236
00:14:20,767 --> 00:14:21,967
计划更新


237
00:14:23,367 --> 00:14:25,567
对程序而言非常完美
它的数据变化


238
00:14:25,633 --> 00:14:29,600
会根据预测而变化
像天气预报一样


239
00:14:30,933 --> 00:14:33,267
如果你写了天气预报的程序


240
00:14:33,667 --> 00:14:35,533
那么服务器每小时


241
00:14:35,600 --> 00:14:38,633
都会提供更加准确的天气数据


242
00:14:39,433 --> 00:14:41,933
所以你下载时间线时
你可以告诉我们


243
00:14:42,000 --> 00:14:44,567
你下一次更新数据的准确时间


244
00:14:46,467 --> 00:14:48,300
那么应用将在后台


245
00:14:48,367 --> 00:14:49,300
保持运行


246
00:14:49,533 --> 00:14:52,667
你可以点击服务器
更新新的天气数据


247
00:14:53,133 --> 00:14:54,433
重新下载时间线


248
00:14:59,000 --> 00:15:01,067
但是在预计的时间内


249
00:15:01,133 --> 00:15:02,333
并非所有的数据都可以更新


250
00:15:03,300 --> 00:15:06,300
假如我想要在我的足球程序中


251
00:15:07,200 --> 00:15:08,267
加入直播得分


252
00:15:09,067 --> 00:15:10,567
我要是每个小时
或者每十五分钟


253
00:15:10,633 --> 00:15:14,333
都点击服务器以获得目前得分


254
00:15:14,733 --> 00:15:17,433
这么做不方便
因为每一次进球


255
00:15:17,667 --> 00:15:20,467
都需要立即在我的程序中更新


256
00:15:21,733 --> 00:15:24,967
为了解决这种麻烦
接下来介绍一种


257
00:15:25,033 --> 00:15:27,200
新的高优先级的推送通知


258
00:15:30,033 --> 00:15:33,067
如果你为程
提供所需要的数据


259
00:15:33,333 --> 00:15:36,100
你可以发送
推送通知到你的手机


260
00:15:36,167 --> 00:15:38,233
它将会马上被传输


261
00:15:38,300 --> 00:15:39,667
到你手表上的应用扩展中


262
00:15:45,833 --> 00:15:48,433
所以要确定的是


263
00:15:48,500 --> 00:15:50,367
程序目录总是最新的
因此时间线非常重要


264
00:15:50,933 --> 00:15:54,100
而且
这样做还有其他重要目的


265
00:15:54,467 --> 00:15:56,100
如果你看到了今早的主旨发言


266
00:15:57,500 --> 00:16:00,333
你会听到
我们在watchOS2中


267
00:16:00,400 --> 00:16:03,300
介绍的时空之旅
它让你回到数码皇冠时代


268
00:16:03,500 --> 00:16:05,333
可以回顾过去 展望未来


269
00:16:05,400 --> 00:16:07,367
让你看到在一天不同时刻


270
00:16:07,433 --> 00:16:08,533
你的程序将会显示什么


271
00:16:09,700 --> 00:16:11,133
比如 这里


272
00:16:11,500 --> 00:16:14,500
看上去
海洋诺伊谷游戏已经结束


273
00:16:14,667 --> 00:16:17,467
而我错过了
因为我站在台上谈论苹果手表


274
00:16:18,400 --> 00:16:21,900
我可以通过时空之旅
回到当时 看看发生了什么


275
00:16:30,167 --> 00:16:32,667
看起来好像
诺伊谷好像为我暂停了一样


276
00:16:32,733 --> 00:16:34,167
真是激动人心


277
00:16:36,100 --> 00:16:38,133
这就是程序


278
00:16:38,200 --> 00:16:41,033
方便进行快速查看重要数据


279
00:16:41,733 --> 00:16:42,633
小部分数据


280
00:16:43,533 --> 00:16:45,467
但是如果你想要
看到更多信息怎么办


281
00:16:46,233 --> 00:16:47,667
这时候你就可能需要快捷视图


282
00:16:52,000 --> 00:16:54,767
你可以向上移动表盘表面
来获得快捷视图


283
00:16:56,967 --> 00:16:58,833
快捷视图提供了一个机会


284
00:16:58,900 --> 00:17:01,533
让整个屏幕充满用户数据


285
00:17:01,967 --> 00:17:04,599
比如 我的足球俱乐部
快捷视图告诉我


286
00:17:04,700 --> 00:17:07,867
比赛中A队的状况


287
00:17:11,133 --> 00:17:13,200
程序和快捷视图


288
00:17:13,267 --> 00:17:16,067
让我进入计划表中的应用数据


289
00:17:17,833 --> 00:17:20,099
但是 有时候你需要在


290
00:17:20,166 --> 00:17:22,233
用户面前获得信息


291
00:17:22,767 --> 00:17:25,233
这时候你需要一个通知


292
00:17:29,433 --> 00:17:32,167
手表中的通知非常强大


293
00:17:32,667 --> 00:17:35,067
你可以充分利用屏幕


294
00:17:35,833 --> 00:17:37,700
显示整个自定义用户界面


295
00:17:39,333 --> 00:17:41,167
比如 通知我


296
00:17:41,733 --> 00:17:46,467
这是最后机会选出今天下午
在索玛奶牛低地游戏的冠军


297
00:17:48,300 --> 00:17:49,800
除了自定义用户界面外


298
00:17:50,033 --> 00:17:51,667
你还可以添加自定义动作


299
00:17:52,567 --> 00:17:55,233
按下其中一个按钮


300
00:17:55,300 --> 00:17:56,133
则进行应用注册


301
00:17:57,333 --> 00:17:58,167
但这还不是全部


302
00:17:58,700 --> 00:18:00,300
因为watchOS 2系统


303
00:18:00,367 --> 00:18:04,000
我们根据文本回复推送通知


304
00:18:05,367 --> 00:18:07,967
所以我可以在
通知中添加一个按钮


305
00:18:08,033 --> 00:18:10,300
让我能够编辑信息并且发送


306
00:18:10,367 --> 00:18:13,033
我是个真正的索玛迷
我想让全世界都知道


307
00:18:13,300 --> 00:18:14,767
所以我要选择这个按钮


308
00:18:16,567 --> 00:18:20,300
当我选择回复
我得到快速回复表


309
00:18:20,633 --> 00:18:23,400
我甚至可以
使用口述来形成一条信息


310
00:18:23,467 --> 00:18:26,400
这些都在通知内部
形成不需要变换目录


311
00:18:29,467 --> 00:18:31,367
谢谢你们
你们真好


312
00:18:35,633 --> 00:18:37,033
这就是通知


313
00:18:37,967 --> 00:18:41,333
程序快捷视图
以及通知都很简单


314
00:18:41,533 --> 00:18:44,500
这也可能是
你的用户在你的应用中


315
00:18:44,567 --> 00:18:45,533
最常见的交流方式


316
00:18:46,033 --> 00:18:48,033
但有时候你需要更多时间


317
00:18:49,067 --> 00:18:51,767
而且你要一种交互性更好
更加逼真的体验


318
00:18:52,100 --> 00:18:53,967
这时候你需要
启动完整的应用程序


319
00:18:55,167 --> 00:18:59,800
在watchOS 2中
你可以做很多事情


320
00:19:00,900 --> 00:19:04,800
举个例子 既然你可以


321
00:19:04,867 --> 00:19:08,167
使用数码皇冠时代
那么你可以用让屏幕


322
00:19:08,233 --> 00:19:09,633
快速显示全部比赛队伍


323
00:19:10,300 --> 00:19:13,000
可以快速找到你最喜欢的队伍
并且得到他们的信息


324
00:19:15,133 --> 00:19:18,467
然而这只是你
使用watchOS 2之后


325
00:19:18,533 --> 00:19:20,267
带来的诸多优势其中之一


326
00:19:22,067 --> 00:19:24,667
你也可以给你的
用户界面添加动画


327
00:19:25,033 --> 00:19:26,933
你可以使用振动马达


328
00:19:28,333 --> 00:19:30,633
你可以通过手表录音


329
00:19:30,833 --> 00:19:33,667
你可以嵌入
声音信号和回放录像


330
00:19:34,933 --> 00:19:37,133
你可以通过应用打电话


331
00:19:37,700 --> 00:19:39,600
你可以通过直播访问


332
00:19:39,667 --> 00:19:42,067
医疗传感器和加速计获取数据


333
00:19:42,833 --> 00:19:46,633
能够看到你们这么会玩
我们很高兴


334
00:19:46,900 --> 00:19:48,800
现在我想展示
在watchOS 2


335
00:19:48,867 --> 00:19:50,567
安装应用的方法有多简单


336
00:19:50,800 --> 00:19:52,467
让我们邀请乔什·谢弗


337
00:20:00,000 --> 00:20:01,300
乔什·谢弗:
谢谢 易丽扎


338
00:20:02,333 --> 00:20:04,333
我很高兴能够向大家展示


339
00:20:04,400 --> 00:20:09,733
将watchOS 1中应用
升级到watchOS 2中


340
00:20:09,800 --> 00:20:11,133
在手机本机上运行


341
00:20:12,400 --> 00:20:15,133
如果你已经下载过
今年开发者大会上的应用


342
00:20:15,600 --> 00:20:19,167
你可能会注意到
其中有一个手表应用扩展


343
00:20:19,600 --> 00:20:21,600
可以在你手表上安装和运行


344
00:20:22,333 --> 00:20:25,533
所以接下来我们
要看一下怎样升级应用


345
00:20:25,933 --> 00:20:29,433
并且在手表2中运行这些应用


346
00:20:29,500 --> 00:20:32,733
我们在其中会使用一些
易丽扎刚刚介绍的特色


347
00:20:34,267 --> 00:20:37,733
在这里你可以看到


348
00:20:37,800 --> 00:20:41,367
开发者大会应用的Xcode


349
00:20:41,800 --> 00:20:42,833
Xcode会注意到


350
00:20:42,900 --> 00:20:44,967
我有一个watchOS 1
应用扩展


351
00:20:45,033 --> 00:20:47,900
并且主动帮我升级到
watchOS 2应用扩展


352
00:20:48,900 --> 00:20:49,733
我要点击这里


353
00:20:49,800 --> 00:20:51,067
让它执行这些变化


354
00:20:51,700 --> 00:20:53,600
它会注意到所有的目标


355
00:20:53,967 --> 00:20:56,200
并且升级
使原始资料生成代码


356
00:20:56,267 --> 00:21:00,333
将故事版准备就绪
我就可以重新使用所有的应用


357
00:21:02,233 --> 00:21:04,733
我们看一下这里
检验一下控制器内容


358
00:21:05,333 --> 00:21:08,800
首先我们要改变一些代码


359
00:21:08,867 --> 00:21:10,200
来改变我们获取数据的方法


360
00:21:10,767 --> 00:21:12,333
既然我们在不同的设备中运行


361
00:21:12,767 --> 00:21:16,000
我们需要能够将
数据从手机移动到手表


362
00:21:16,233 --> 00:21:18,100
我们可以
使用新的手表连接框架


363
00:21:18,200 --> 00:21:19,033
实现这项功能


364
00:21:19,800 --> 00:21:22,567
所以我要开始
添加手表连接框架


365
00:21:23,300 --> 00:21:25,967
我们要替换开源原应用调用


366
00:21:26,033 --> 00:21:28,067
我曾经在
watchOS 1版本使用


367
00:21:28,433 --> 00:21:31,533
新的手表连接
代码将会要求数据


368
00:21:31,600 --> 00:21:34,067
从手机复制到手表


369
00:21:35,800 --> 00:21:38,633
这样 现在
我们可以添加一些附加功能


370
00:21:39,067 --> 00:21:40,600
比较酷的一项功能是


371
00:21:40,667 --> 00:21:43,233
与数据皇冠时代的交互


372
00:21:44,467 --> 00:21:46,367
现在数据皇冠时代
与手表应用中交互方式


373
00:21:46,433 --> 00:21:50,967
是利用一种
新的界面选择器控制


374
00:21:52,233 --> 00:21:54,667
我们要在一分钟内
将其从故事板中拖出


375
00:21:54,767 --> 00:21:57,000
但首先我们要
添加一些搭建代码


376
00:21:58,100 --> 00:22:01,267
我们要做一些参照
将其连接到故事板中


377
00:22:01,333 --> 00:22:02,733
一旦我们将其拖出


378
00:22:03,467 --> 00:22:05,600
然后你需要对选择器编程


379
00:22:05,667 --> 00:22:07,500
把你想要的项目添加进去


380
00:22:08,000 --> 00:22:10,667
所以我们要追踪的是


381
00:22:10,733 --> 00:22:12,400
一周内存在的所有会话踪迹


382
00:22:12,600 --> 00:22:15,133
并且在每个踪迹
的选择器中添加一个入口


383
00:22:15,400 --> 00:22:17,567
这样 我们
就可以整理会话列表


384
00:22:17,800 --> 00:22:20,267
寻找我们感兴趣的会话踪迹


385
00:22:21,200 --> 00:22:23,767
最后
我们要添加IBAction


386
00:22:23,833 --> 00:22:26,600
连接我们的控制
之后每次变化它都会被调用


387
00:22:27,267 --> 00:22:28,467
所以我们要在那里添加代码


388
00:22:29,133 --> 00:22:33,067
现在我们可以切换到故事板
在应用中找到安置它的地方


389
00:22:34,367 --> 00:22:36,467
所以我在这里
找到新的选择器控制


390
00:22:37,467 --> 00:22:39,700
我们要把它拖出来
并且安置在会话控制器中


391
00:22:40,233 --> 00:22:42,700
会话控制器
可以显示所有的会话


392
00:22:42,767 --> 00:22:45,533
所以通过添加置顶


393
00:22:45,600 --> 00:22:46,967
它会提供过滤会话列表的方法


394
00:22:47,433 --> 00:22:49,400
将它稍微缩短一点
这样它不会那么高


395
00:22:50,033 --> 00:22:51,733
现在 选择器控制真的很灵活


396
00:22:52,067 --> 00:22:53,433
并且有三种不同的形式


397
00:22:53,500 --> 00:22:55,767
可供你选择列表 堆叠和序列


398
00:22:56,100 --> 00:22:57,367
你可以了解整整一周的情况


399
00:22:58,800 --> 00:23:00,800
列表1是一个非常好的选择


400
00:23:00,867 --> 00:23:02,633
因为这里是我们
要在这里做的事情列表


401
00:23:03,133 --> 00:23:04,867
我们要打开一个重点概览


402
00:23:04,933 --> 00:23:07,233
以便我们可以保证用户


403
00:23:07,300 --> 00:23:09,533
在转换到数码皇冠
时代的时候可以区分


404
00:23:11,033 --> 00:23:13,200
因为有了这些变化我们就可以


405
00:23:13,267 --> 00:23:15,033
连接到我们刚刚结束的代码


406
00:23:16,067 --> 00:23:18,100
我们要将连接拖出
到我们的IBOUTLET


407
00:23:18,733 --> 00:23:20,867
并且将一个连接
拖至我们的IBAction


408
00:23:20,933 --> 00:23:22,733
因此每次选择器
变化它都会被调用


409
00:23:24,133 --> 00:23:25,000
就这样


410
00:23:25,200 --> 00:23:26,633
所以 我们要点击构建和运行


411
00:23:27,200 --> 00:23:29,000
然后我们可以
切换到手表模拟器


412
00:23:29,333 --> 00:23:30,567
看到它如何运行


413
00:23:30,967 --> 00:23:33,600
在watchOS 2中关于
手表模拟器很重要的东西是


414
00:23:33,667 --> 00:23:36,000
它是手表中一个完整的模拟器


415
00:23:36,400 --> 00:23:38,400
所以你可以
一起运行你的整个手表


416
00:23:38,667 --> 00:23:41,867
在手机应用中同时调试


417
00:23:42,067 --> 00:23:44,033
并且测试他们之间的连接代码


418
00:23:51,833 --> 00:23:53,033
所以现在我们可以跳过这里


419
00:23:53,100 --> 00:23:56,167
在会话列表中你可以看到
我们可以滚动会话列表


420
00:23:56,600 --> 00:23:59,033
我们也可以根据
我们想看的踪迹进行过滤


421
00:23:59,633 --> 00:24:01,067
我们改变的时候就在升级


422
00:24:02,100 --> 00:24:04,533
现在 我想说的
最后一个特点是


423
00:24:04,933 --> 00:24:07,967
在手表屏幕上展示会话的能力


424
00:24:08,267 --> 00:24:10,800
为了能实现这项功能
我们要在应用中添加一个程序


425
00:24:11,300 --> 00:24:13,367
现在
我提前为此编写了大部分代码


426
00:24:13,533 --> 00:24:15,567
所以我只要将文件拖出去
并且将其添加到


427
00:24:15,633 --> 00:24:16,867
这里我的程序中


428
00:24:18,400 --> 00:24:20,867
我唯一没做的
事情就是添加代码


429
00:24:20,933 --> 00:24:23,500
它会循环访问并且构建时间线


430
00:24:24,000 --> 00:24:25,100
现在 易丽扎刚刚提到的


431
00:24:25,167 --> 00:24:28,300
我们要以时间线
的形式提供数据


432
00:24:28,700 --> 00:24:31,300
所以我们要循环访问


433
00:24:31,400 --> 00:24:32,267
这是我最爱的部分


434
00:24:32,467 --> 00:24:35,400
在手表屏幕上我可以
看到整个星期我喜欢的会话


435
00:24:36,333 --> 00:24:37,633
现在 为了节省时间


436
00:24:37,700 --> 00:24:39,800
今天我提前在
手表上构建且安装了


437
00:24:40,300 --> 00:24:42,833
切换到这里 看一下如何添加


438
00:24:42,900 --> 00:24:44,033
到我们的手表屏幕中


439
00:24:44,900 --> 00:24:46,167
所以开始的时候


440
00:24:46,533 --> 00:24:49,033
我在手表屏幕
上中间配置了日历


441
00:24:49,667 --> 00:24:51,833
但因为我在WWDC
做完了这些


442
00:24:52,300 --> 00:24:54,067
我们只要切换到这里
并且将其自定义


443
00:24:54,433 --> 00:24:57,433
然后我们可以将
其滚动至程序列表的底端


444
00:24:57,800 --> 00:25:01,333
你们可以看到现在大会上
的应用可以通过底部进入


445
00:25:02,067 --> 00:25:03,833
我们可以点击那里打开


446
00:25:04,400 --> 00:25:06,533
然后返回
查看我们的会话列表


447
00:25:06,867 --> 00:25:08,033
现在 很明显美国平台


448
00:25:08,100 --> 00:25:10,233
是我现在喜欢的会话


449
00:25:10,867 --> 00:25:14,167
我们可以毫不费力
地向前进行时空之旅


450
00:25:14,400 --> 00:25:15,967
通过会话列表


451
00:25:16,233 --> 00:25:18,267
接下来看到的是苹果设计奖


452
00:25:18,500 --> 00:25:19,667
这是我绝对不想错过的


453
00:25:20,267 --> 00:25:23,200
往明天继续推进


454
00:25:23,667 --> 00:25:26,300
可以看到早上
watchOS 2的介绍


455
00:25:26,367 --> 00:25:27,633
这也绝对是我想要看的


456
00:25:28,833 --> 00:25:31,467
所以更新你的
手表应用就这么简单


457
00:25:31,867 --> 00:25:34,867
在watchOS上运行就像
本来就是其中的应用


458
00:25:35,467 --> 00:25:37,600
非常好的特色


459
00:25:38,400 --> 00:25:39,233
所以接下来


460
00:25:46,067 --> 00:25:47,967
接下来
塞巴斯蒂安会告诉我们


461
00:25:48,033 --> 00:25:50,133
一些非常好的新的基础技术


462
00:25:50,467 --> 00:25:51,467
塞巴·斯蒂安:
谢谢 乔什


463
00:25:52,500 --> 00:25:53,333
非常好


464
00:25:54,600 --> 00:25:57,600
现在我们来谈论一些基础技术


465
00:25:58,067 --> 00:26:01,367
应用在我们的平台中的技术


466
00:26:01,433 --> 00:26:04,033
我会从第一个性能开始说


467
00:26:04,567 --> 00:26:05,800
和其压缩性


468
00:26:05,867 --> 00:26:07,333
我们将会让压缩变得很有趣


469
00:26:08,167 --> 00:26:11,433
苹果的产品一向使用许多


470
00:26:11,500 --> 00:26:14,967
压缩算法作为
我们核心框架的一部分


471
00:26:15,033 --> 00:26:17,233
优化速度的LZ4


472
00:26:17,300 --> 00:26:21,633
高度的压缩性的LZMA
以及很多人用过的zlib


473
00:26:21,700 --> 00:26:24,833
它可以找到压缩
和速度之间的最优点


474
00:26:25,167 --> 00:26:28,267
我们开始构建
一个更好的压缩算法


475
00:26:28,333 --> 00:26:29,700
使其在压缩库上更加进步


476
00:26:29,900 --> 00:26:32,500
你可能知道
压缩库已经二十多年之久


477
00:26:32,767 --> 00:26:34,800
处理器体系结构
改变之时就需要重建


478
00:26:34,867 --> 00:26:38,000
所以我们认为
可以创建可以优化


479
00:26:38,300 --> 00:26:41,233
现在处理器
和微体系结构的事物


480
00:26:42,100 --> 00:26:44,433
现在 我们称这个新算法为
Lempel Ziv


481
00:26:44,500 --> 00:26:47,367
Finite State
Entropy


482
00:26:47,433 --> 00:26:48,267
你可能知道


483
00:26:48,700 --> 00:26:50,167
他们还是
一个非常好的独立乐队


484
00:26:50,800 --> 00:26:52,400
你应该到
Connect上去找看看


485
00:26:52,700 --> 00:26:56,900
为避免任何困惑
我们简单称其为LZFSE


486
00:27:00,700 --> 00:27:03,800
现在 LZFSE 谢谢


487
00:27:04,400 --> 00:27:07,333
在压缩中 压缩库有所改进
但更重要的是


488
00:27:07,833 --> 00:27:11,133
它比压缩库速度快三倍


489
00:27:11,600 --> 00:27:13,567
这是一次巨大的进步


490
00:27:13,633 --> 00:27:15,967
可以使你的应用更加敏感


491
00:27:16,567 --> 00:27:18,733
另外它还延长电池寿命


492
00:27:19,400 --> 00:27:22,600
在能量消耗
上它可以减少60%


493
00:27:23,067 --> 00:27:24,267
在相同的压缩算法中


494
00:27:24,333 --> 00:27:26,833
它在速度上快了三倍


495
00:27:27,333 --> 00:27:29,833
最后
我们使用起来相当容易


496
00:27:30,033 --> 00:27:31,700
我们已经将其添加
我们的标准框架中


497
00:27:32,100 --> 00:27:35,933
你需要做的就是
改变算法 使用LZFSE


498
00:27:36,167 --> 00:27:38,200
我们已经完成
了所有困难的工作


499
00:27:38,567 --> 00:27:40,200
你和你的用户
可以享用其中的益处


500
00:27:40,467 --> 00:27:44,200
这就是LZFSE
真正重新定义了最优点


501
00:27:44,300 --> 00:27:45,733
在主流压缩中


502
00:27:46,700 --> 00:27:48,833
接下来 我要说一下电池寿命


503
00:27:49,200 --> 00:27:50,767
克雷格
今早提到了电池寿命


504
00:27:52,367 --> 00:27:55,733
现在在这个行业中
我们测试电池寿命时


505
00:27:55,967 --> 00:27:59,100
经常是重复性测试


506
00:27:59,200 --> 00:28:00,767
举个例子
我们测试时在浏览器中


507
00:28:00,833 --> 00:28:04,133
一次又一次的浏览网页


508
00:28:04,500 --> 00:28:05,900
我们知道现实生活中


509
00:28:06,700 --> 00:28:08,600
我们使用这些设备的方法
与这些综合实验测试


510
00:28:08,667 --> 00:28:10,467
的方法不一样 对吗？


511
00:28:10,533 --> 00:28:13,400
我们将设备装进口袋再取出来


512
00:28:13,467 --> 00:28:17,333
我们接收通知和信息
我们可能使用很多应用


513
00:28:17,400 --> 00:28:19,300
我们连接网络 断开网络


514
00:28:19,600 --> 00:28:21,400
所以在iOS 9上做的事


515
00:28:21,700 --> 00:28:25,133
主要集中在最佳化基板组上


516
00:28:25,200 --> 00:28:28,867
这样可以适用
在平台所有最流行的应用


517
00:28:29,867 --> 00:28:31,433
这是第一步
第二步


518
00:28:31,500 --> 00:28:34,000
我们关注
一些基础设施的改善


519
00:28:34,067 --> 00:28:37,500
比如 一些算法
可以增亮背光灯


520
00:28:37,867 --> 00:28:40,800
朝下检测
所以如果你接收到一条通知


521
00:28:41,100 --> 00:28:43,633
当时不能看到它
由于手机屏幕朝下


522
00:28:43,700 --> 00:28:45,433
我们无需让屏幕发亮


523
00:28:45,733 --> 00:28:47,467
还有其它一些优化


524
00:28:47,533 --> 00:28:52,867
比如系统如何进入睡眠状态
如何优化最低电源状态


525
00:28:53,900 --> 00:28:56,467
所有的这些
最优化加起来可增加


526
00:28:56,533 --> 00:29:01,833
一个小时额外使用时间
是针对一般用户的普通使用


527
00:29:02,167 --> 00:29:03,000
真是巨大改善


528
00:29:03,167 --> 00:29:06,267
今早克雷格还提到了省电模式


529
00:29:07,800 --> 00:29:10,167
我们要开启省电模式很简单


530
00:29:10,500 --> 00:29:12,100
只需要进入设置 开启


531
00:29:12,967 --> 00:29:16,267
激活了一部分内部杠杆


532
00:29:16,800 --> 00:29:19,100
比如
保护中央处理器和图形处理器


533
00:29:19,167 --> 00:29:21,133
不受进入最高性能的破坏


534
00:29:21,567 --> 00:29:23,033
除了最耗电的状态


535
00:29:23,567 --> 00:29:26,400
保护应用免受
后台过度运行的影响


536
00:29:26,933 --> 00:29:30,367
阻止它们进行
不必要的网络活动


537
00:29:30,867 --> 00:29:35,067
最后关闭一些耗电的动画


538
00:29:35,433 --> 00:29:36,533
总而言之
当你开始充电时


539
00:29:36,600 --> 00:29:42,133
省电模式将会
为你增加三小时的使用时间


540
00:29:42,367 --> 00:29:43,833
所以再次强调
这是巨大的进步


541
00:29:44,567 --> 00:29:47,200
现在我开始保护客户数据


542
00:29:48,767 --> 00:29:50,700
所以从一开始
苹果系统就真正


543
00:29:50,767 --> 00:29:52,300
关注客户数据的保护


544
00:29:52,367 --> 00:29:56,567
在iOS9中我们采取了
一些重要措施保护数据


545
00:29:56,633 --> 00:29:58,733
包括设备中的和云端的


546
00:29:59,067 --> 00:30:00,067
所以我们从云端说起吧


547
00:30:01,400 --> 00:30:05,100
当然
用你的Apple ID进入


548
00:30:05,167 --> 00:30:07,233
云端的一些服务中 你的照片


549
00:30:07,300 --> 00:30:11,367
可能你有一些文档
存在云端中 你的购买记录


550
00:30:11,633 --> 00:30:13,867
可以利用它在即时通讯和
视频通话中发送信息


551
00:30:14,167 --> 00:30:17,967
云端对你的数据最大的威胁是


552
00:30:18,033 --> 00:30:20,500
有人获得你的密码


553
00:30:21,167 --> 00:30:23,100
可能是因为你在其他共享网站


554
00:30:23,367 --> 00:30:25,167
分享过你的密码


555
00:30:25,700 --> 00:30:28,200
或者可能攻击者
通过捕钓式的攻击


556
00:30:28,367 --> 00:30:30,033
获得密码


557
00:30:30,567 --> 00:30:33,533
这种情况的解决
办法是双因素认证


558
00:30:34,167 --> 00:30:36,333
我们尽量把它做的简单
以使每个人都可以使用


559
00:30:36,733 --> 00:30:38,033
我来向大家展示它如何运作


560
00:30:39,133 --> 00:30:42,433
在iOS9中
当你得到一个新的设备


561
00:30:42,500 --> 00:30:45,067
你就想要在
你的云端账户中登记


562
00:30:45,333 --> 00:30:47,567
你将需要输入密码


563
00:30:47,633 --> 00:30:50,233
此外 你还会输入验证码


564
00:30:51,100 --> 00:30:56,233
同时我们向我们已有的
信任的设备发送通知


565
00:30:56,300 --> 00:31:01,133
通知包括注册新设备的地址


566
00:31:01,767 --> 00:31:03,267
所以如果那是你在注册


567
00:31:03,667 --> 00:31:05,733
你可以输入验证码


568
00:31:06,100 --> 00:31:08,667
如果是攻击者
试图用你的账户注册


569
00:31:09,000 --> 00:31:10,867
你可以凭借踪迹阻止他们


570
00:31:12,233 --> 00:31:14,767
这是关于云端
现在说关于设备上的设备密码


571
00:31:14,833 --> 00:31:16,700
设备密码是保护


572
00:31:16,767 --> 00:31:19,333
私人数据的最后一道防线


573
00:31:20,100 --> 00:31:24,300
在浏览历史中
我们保留四位数密码


574
00:31:24,400 --> 00:31:27,600
因为你每次使用手机
都需要输入


575
00:31:28,433 --> 00:31:30,900
但是当然
我们不会输入密码


576
00:31:30,967 --> 00:31:31,800
太过频繁


577
00:31:32,267 --> 00:31:36,767
我们使用指纹识别
中的指纹完美注册


578
00:31:36,833 --> 00:31:37,833
我们的手机


579
00:31:38,333 --> 00:31:42,900
所以现在在iOS9中
我们可以将密码


580
00:31:42,967 --> 00:31:45,133
由四位数增至六位数


581
00:31:45,200 --> 00:31:48,233
密码强度增至一百倍


582
00:31:48,700 --> 00:31:51,933
不需要缓和设备使用的妥协


583
00:31:53,233 --> 00:31:54,567
既然我们说到设备


584
00:31:55,033 --> 00:31:59,000
我介绍一种用
在所有平台中的新技术


585
00:31:59,067 --> 00:32:00,733
我们称之为苹果安全传输


586
00:32:01,133 --> 00:32:04,267
苹果安全传输是
真正关于所有的安全数据


587
00:32:04,333 --> 00:32:07,500
它从一个设备传输到网络


588
00:32:07,567 --> 00:32:10,133
或者从你的应用传输到
你的终端服务器


589
00:32:11,233 --> 00:32:14,333
因此我们当然想要需要的信息


590
00:32:14,400 --> 00:32:15,700
在网络传输中安全


591
00:32:16,233 --> 00:32:17,767
但是结果证明现在


592
00:32:17,833 --> 00:32:19,333
对大家来说真的很难


593
00:32:19,500 --> 00:32:20,400
很难将其做好


594
00:32:20,900 --> 00:32:21,867
你不能使用传输协议


595
00:32:21,933 --> 00:32:24,667
你必须使用一个安全协议


596
00:32:24,733 --> 00:32:27,600
然后需要担心协议
的版本降级攻击


597
00:32:28,100 --> 00:32:29,733
数据加密 保密性


598
00:32:30,133 --> 00:32:33,367
最佳规范


599
00:32:33,767 --> 00:32:34,833
这些做法非常难


600
00:32:34,900 --> 00:32:39,533
在苹果安全传输中
我们核心框架搭建它


601
00:32:39,967 --> 00:32:43,100
所以现在当你使用我们的
标准网络框架


602
00:32:43,500 --> 00:32:47,500
我们会建立一个最好的
安全实践连接


603
00:32:47,767 --> 00:32:50,533
在你的应用和后台服务器之间


604
00:32:51,367 --> 00:32:55,033
现在最佳实践是安全传输层
协议1.2和正向保密


605
00:32:55,100 --> 00:32:58,767
但是因为标准和
的发展最高技术


606
00:32:59,200 --> 00:33:01,300
框架当然要使用最新技术


607
00:33:01,367 --> 00:33:05,200
并且自动为你执行


608
00:33:13,200 --> 00:33:15,867
所以 要从哪里开始？


609
00:33:16,133 --> 00:33:17,900
如果你用完了标准网络框架


610
00:33:17,967 --> 00:33:20,900
比如 NSURL会话
那么它会被马上创建


611
00:33:21,200 --> 00:33:23,367
这是iOS9默认的


612
00:33:23,433 --> 00:33:25,067
所以你下载开发者系数时


613
00:33:25,133 --> 00:33:27,033
我敢肯定
很多人都已经下载过了


614
00:33:27,800 --> 00:33:29,200
你就会重新编译你的应用


615
00:33:29,267 --> 00:33:31,633
我们会在后台执行
最佳实践


616
00:33:31,700 --> 00:33:32,533
安全连接


617
00:33:32,933 --> 00:33:35,767
可能你
还没与更新你的后台


618
00:33:35,833 --> 00:33:37,433
至最佳实践


619
00:33:37,500 --> 00:33:39,500
或者你在使用
第三方数据库


620
00:33:39,967 --> 00:33:43,167
如果是这样 我们
提供了异常机制


621
00:33:43,233 --> 00:33:47,300
给你时间来通过位置服务平台
更新你的后台


622
00:33:48,300 --> 00:33:50,100
这就是苹果安全传输


623
00:33:50,400 --> 00:33:52,567
让我们转换到计算机


624
00:33:52,900 --> 00:33:54,233
介绍一种新技术


625
00:33:54,300 --> 00:33:56,567
我们称之为
系统完整性保护


626
00:33:57,633 --> 00:34:01,133
在个人消费型电脑中
用户账户有明显的


627
00:34:01,200 --> 00:34:03,733
管理特权
并且这种管理特权是


628
00:34:03,800 --> 00:34:05,500
真的等同于内核访问


629
00:34:05,933 --> 00:34:08,800
这就使保护系统
的完整性变得很难


630
00:34:09,766 --> 00:34:11,300
在系统的完整性保护中


631
00:34:11,667 --> 00:34:13,167
我们破坏了等同的状态


632
00:34:13,632 --> 00:34:17,533
管理级别的访问不再充分


633
00:34:17,600 --> 00:34:19,300
为了在系统中做一些运作


634
00:34:19,367 --> 00:34:20,766
我来举一些例子


635
00:34:21,567 --> 00:34:24,533
比如 如果你有管理级别
访问的特权


636
00:34:24,833 --> 00:34:26,733
你不能梗更改系统文件


637
00:34:27,333 --> 00:34:29,333
你不能将程序安装至
系统的位置


638
00:34:29,833 --> 00:34:33,667
你不能依附系统程序 比如


639
00:34:33,733 --> 00:34:35,699
内省记忆
或者改变控制程序


640
00:34:36,467 --> 00:34:39,132
所以对于现在出现的
数据库 我们希望


641
00:34:39,199 --> 00:34:40,933
大家下载下来 测试你的应用


642
00:34:41,000 --> 00:34:46,400
以确保你基本上可以将其
粘附在所有的规则上


643
00:34:48,632 --> 00:34:50,367
现在 你可能还想知道


644
00:34:50,433 --> 00:34:52,167
这是如何影响我的应用开发


645
00:34:52,233 --> 00:34:54,199
好消息是
我们已经更新了XCode


646
00:34:54,266 --> 00:34:57,633
发展了工具链
对大多数人来说


647
00:34:57,700 --> 00:34:58,800
你们看不出什么不同


648
00:34:59,567 --> 00:35:02,133
对那些有明确
开发要求的人来说


649
00:35:02,200 --> 00:35:05,467
比如 你在开发X系统
的内核功能扩展


650
00:35:05,767 --> 00:35:08,833
我们也提供了一种功用
这也是恢复分区的一部分


651
00:35:09,167 --> 00:35:11,600
它可以让你失去
系统完整性保护的能力


652
00:35:13,367 --> 00:35:16,733
这就指向了我要说的
最后一种技术


653
00:35:16,800 --> 00:35:20,067
一种巩固现代网络的技术
互联网协议6


654
00:35:21,567 --> 00:35:23,067
为什么
互联网协议6这么重要？


655
00:35:23,567 --> 00:35:26,400
我们都听说过
互联网协议4地址的不足


656
00:35:26,833 --> 00:35:27,667
猜猜看


657
00:35:27,967 --> 00:35:28,967
最终在这里


658
00:35:29,233 --> 00:35:31,367
实际上
2011年在中国和亚洲


659
00:35:31,433 --> 00:35:34,633
已经不用互联网协议4地址


660
00:35:34,700 --> 00:35:37,833
在美国 我们也将在
接下来的几个月中放弃


661
00:35:39,067 --> 00:35:41,233
意味着实践中一些


662
00:35:41,300 --> 00:35:44,333
媒介物现在在配置
只用互联网协议6的网络


663
00:35:44,867 --> 00:35:47,933
如果你的应用在互联网
协议6中不能正常运作


664
00:35:48,000 --> 00:35:51,100
它在那些媒介
网络也不会运作


665
00:35:51,167 --> 00:35:52,167
对那些客户也不会运作


666
00:35:52,300 --> 00:35:54,033
所以支持互联网协议6
真的很重要


667
00:35:55,000 --> 00:35:57,833
好消息是
一直以来作为平台的一部分


668
00:35:57,900 --> 00:36:01,300
互联网协议6
已经得到了支持超过了10%


669
00:36:01,833 --> 00:36:03,233
已得到现场证实


670
00:36:03,300 --> 00:36:06,700
很多使用我们的标准
网络框架的人在使用


671
00:36:06,767 --> 00:36:07,833
互联网协议6


672
00:36:08,300 --> 00:36:09,633
但是我们希望得到进一步发展


673
00:36:09,700 --> 00:36:11,500
我们想确保
每个人都创建一款应用


674
00:36:11,867 --> 00:36:13,900
能在互联网协议6网络中运行


675
00:36:14,100 --> 00:36:16,500
所以我们为大家准备了秘诀


676
00:36:17,433 --> 00:36:19,233
使用标准网络框架


677
00:36:19,700 --> 00:36:21,300
我们已经提到过NSUL会话


678
00:36:22,033 --> 00:36:24,700
这真的关系到
获得网络的复杂性


679
00:36:25,300 --> 00:36:28,033
避免使用互联网协议4
的程序语言系统


680
00:36:28,500 --> 00:36:32,600
很多甚至在构思互联网协议6
之前就已经得到发展


681
00:36:33,167 --> 00:36:35,100
最后
不要将地址进行硬式编码


682
00:36:36,000 --> 00:36:38,167
一旦你按照这个秘诀
你会说


683
00:36:38,233 --> 00:36:39,867
我如何测试它是否正常运行


684
00:36:40,400 --> 00:36:43,133
因为并非所有人
都可以进入互联网协议6网络


685
00:36:44,000 --> 00:36:47,033
好消息是大家
为了研发都使用个人电脑


686
00:36:47,500 --> 00:36:48,600
我们正在用最新的数据库


687
00:36:48,667 --> 00:36:52,600
将你们的电脑变为
互联网协议6 网络模拟器


688
00:36:53,600 --> 00:36:55,300
所以你所需要的就是


689
00:36:55,367 --> 00:36:58,267
通过一个新连接分享模式
简历一个个人热点


690
00:36:58,333 --> 00:37:00,900
你只要查看
互联网协议6的盒子


691
00:37:01,233 --> 00:37:04,200
你就可以连接你的测试设备
测试你的应用


692
00:37:04,300 --> 00:37:07,100
确保它们在互联网协议6
中运行很简单


693
00:37:15,633 --> 00:37:18,533
最后因为互联网协议6的
支持很关键


694
00:37:18,600 --> 00:37:21,267
对保证世界上
大家应用的运行来说


695
00:37:21,833 --> 00:37:22,833
对每位客户而言


696
00:37:23,200 --> 00:37:26,567
我们将它作为一个
苹果储备提交要求


697
00:37:26,633 --> 00:37:27,467
从iOS9开始


698
00:37:29,267 --> 00:37:32,200
所以这就是我要说的
基础技术


699
00:37:32,567 --> 00:37:36,000
现在我把它交给我的同伴
加拿大人 托比·帕特森


700
00:37:36,233 --> 00:37:38,033
他将会说到更高水平的
程序语言系统


701
00:37:38,500 --> 00:37:39,333
托比？


702
00:37:47,367 --> 00:37:48,800
托比·帕特森:
我知道大家都来自


703
00:37:48,867 --> 00:37:51,033
世界各地
一些人甚至来自


704
00:37:51,100 --> 00:37:53,300
跟加拿大一样遥远的地方


705
00:37:55,867 --> 00:37:58,500
你们的客户就
像大家一样各种各样


706
00:37:59,467 --> 00:38:02,233
有趣的是 你们可能没注意到


707
00:38:02,733 --> 00:38:05,767
这个表格显示了世界上
苹果专卖店


708
00:38:05,833 --> 00:38:06,767
是按国家划分的


709
00:38:07,367 --> 00:38:09,300
它告诉我们一件有趣的事情


710
00:38:09,533 --> 00:38:11,900
如果你的商店没有
在正确的位置


711
00:38:12,267 --> 00:38:15,467
你就不会得到
除了你的客户之外的


712
00:38:15,533 --> 00:38:16,900
大多数潜在客户


713
00:38:17,733 --> 00:38:19,933
现在 有个好消息
这对大家来说并不难


714
00:38:21,133 --> 00:38:24,267
我们有国际化和地区化指导


715
00:38:24,467 --> 00:38:26,433
它可以告诉你
你想知道的一切


716
00:38:26,767 --> 00:38:28,500
当然
我们已经得到很大的支持


717
00:38:28,567 --> 00:38:30,800
在框架以及微软
软件开发工具包方面


718
00:38:31,567 --> 00:38:33,767
我们有数据
和数字的格式化程序


719
00:38:34,400 --> 00:38:36,800
今年 我们介绍
一种新的格式化程序


720
00:38:37,133 --> 00:38:39,333
来帮助你
正确显示人们的名字


721
00:38:40,567 --> 00:38:42,100
名字是一件很棘手的事情


722
00:38:42,367 --> 00:38:44,000
每个人都有


723
00:38:44,433 --> 00:38:46,767
但不同的文化 有不同的意义


724
00:38:46,833 --> 00:38:49,133
关于他们的用途有不同的习俗


725
00:38:50,233 --> 00:38:53,800
在英语中 我们
先写名字 中间姓 姓氏


726
00:38:54,333 --> 00:38:56,933
在中国 却不一样
先写姓氏


727
00:38:57,033 --> 00:38:59,800
而且根本没有中间字


728
00:39:01,067 --> 00:39:03,867
NSP的名字组成很格式化


729
00:39:04,267 --> 00:39:06,633
我保证看起来
比听起来更像编码


730
00:39:06,700 --> 00:39:07,867
当你大神说出它时


731
00:39:12,500 --> 00:39:14,967
这关系到大家的所有细节


732
00:39:15,400 --> 00:39:17,733
它甚至还有一些文化智慧


733
00:39:17,800 --> 00:39:20,633
所以如果你问一个人
有没有短一点的名字吗


734
00:39:21,000 --> 00:39:24,400
可能不太合适
使用一个人的姓


735
00:39:24,933 --> 00:39:26,033
或者就直接使用它本身


736
00:39:28,133 --> 00:39:32,100
对于阿拉伯和犹太人
我们有一些好消息


737
00:39:32,700 --> 00:39:35,967
我们已经得到了初步的支持
不客气


738
00:39:36,633 --> 00:39:38,633
我们已经得到了初步支持


739
00:39:38,700 --> 00:39:40,200
近年来在这些语言方面


740
00:39:40,267 --> 00:39:43,033
在系统中
文本被严格限制


741
00:39:43,100 --> 00:39:46,000
但是 个人电脑
已经有了更复杂的布局


742
00:39:46,067 --> 00:39:47,300
在用户界面元素中


743
00:39:48,000 --> 00:39:50,433
我很高兴能够
告诉你们在苹果iOS9中


744
00:39:50,500 --> 00:39:54,600
我们已经全面检测了
用户界面对右向语言的支持


745
00:40:00,100 --> 00:40:01,767
这是它在跳板里的样子


746
00:40:03,500 --> 00:40:05,600
现在 我们还未撤销


747
00:40:05,667 --> 00:40:07,367
屏幕上的用户界面元素


748
00:40:07,433 --> 00:40:09,500
这是一种深层次的切换


749
00:40:09,867 --> 00:40:12,767
在视图控制器 用户交互


750
00:40:13,133 --> 00:40:16,233
和系统手势间
进行的程序切换


751
00:40:16,767 --> 00:40:19,800
如果换做希伯来或阿拉伯人


752
00:40:19,867 --> 00:40:22,133
设计的话
用户界面应该是这样


753
00:40:23,167 --> 00:40:25,300
我们来看看它在手机上的样子


754
00:40:25,500 --> 00:40:27,533
我想介绍沙拉·卡迪


755
00:40:27,600 --> 00:40:28,867
你们可以快速地看一下


756
00:40:35,500 --> 00:40:39,067
我们体验一下iOS 9系统
支持的从右到左新式语言


757
00:40:39,567 --> 00:40:41,600
现在
我的手机语言是阿拉伯语


758
00:40:41,667 --> 00:40:44,400
我们先锁屏
从右向左滑屏


759
00:40:44,467 --> 00:40:45,867
解开手机锁


760
00:40:46,433 --> 00:40:50,167
这里
从右向左是应用程序图标


761
00:40:50,900 --> 00:40:52,767
页面视图自然地


762
00:40:52,833 --> 00:40:54,867
从第一页过渡到第二页


763
00:40:56,900 --> 00:41:00,633
整个系统和所有自带软件都支


764
00:41:00,700 --> 00:41:03,733
持用户界面镜像
或从右向左定位


765
00:41:04,100 --> 00:41:06,367
以照片应用程序为例


766
00:41:07,833 --> 00:41:11,867
这些照片是按照我意愿排列的


767
00:41:12,200 --> 00:41:15,967
整个用户界面位于导航栏右侧


768
00:41:16,033 --> 00:41:19,233
而导航栏位于
下方菜单栏的顶部


769
00:41:20,700 --> 00:41:22,200
现在 我们体验一下电子邮件


770
00:41:24,700 --> 00:41:28,233
它的标准布局 导航栏


771
00:41:28,300 --> 00:41:30,833
手势浏览和动画都可随意设置


772
00:41:31,333 --> 00:41:34,033
所以 点击邮件
快速获取信息


773
00:41:34,433 --> 00:41:36,367
从屏幕左侧


774
00:41:36,433 --> 00:41:38,167
拖动至右侧


775
00:41:39,833 --> 00:41:42,933
会出现
表视图单元格的排版流程


776
00:41:44,167 --> 00:41:48,033
手势导航也会


777
00:41:48,333 --> 00:41:49,900
从屏幕右侧进入页面


778
00:41:52,033 --> 00:41:53,433
现在
把手机旋转到竖屏模式


779
00:41:53,533 --> 00:41:55,833
出现的消息窗口


780
00:41:56,300 --> 00:41:59,233
让我这个母语人士感到很自然


781
00:41:59,433 --> 00:42:01,633
因为所有的邮件标题在右侧


782
00:42:02,233 --> 00:42:03,600
而信息详情在左侧


783
00:42:04,400 --> 00:42:07,033
因为所有的Email
都已置入UIKit中


784
00:42:07,367 --> 00:42:10,100
所以您也可免费操作这一流程


785
00:42:10,200 --> 00:42:12,033
进行从右向左定位


786
00:42:13,300 --> 00:42:15,567
接下来
我向您展示一下苹果


787
00:42:15,633 --> 00:42:16,833
软件商店的第三方应用程序


788
00:42:19,167 --> 00:42:21,467
您们一定认为
我们不选择


789
00:42:21,533 --> 00:42:23,433
Kayak
因为它的名字是个回文


790
00:42:23,500 --> 00:42:26,767
或者说您
可以从右向左阅读信息


791
00:42:33,333 --> 00:42:36,233
因其采用自动布局和耗能最小


792
00:42:36,300 --> 00:42:40,267
新式应用程序接口
所以添加上翻译


793
00:42:40,333 --> 00:42:42,300
软件这个程序就能如期运行


794
00:42:43,067 --> 00:42:46,233
所以 在WWDC结束后
我打算去旅行


795
00:42:46,300 --> 00:42:47,533
我来浏览一些消息


796
00:42:49,567 --> 00:42:53,167
所以 拖动第一个滑块
可选择旅游的时间


797
00:42:53,233 --> 00:42:56,700
往右滑动


798
00:42:56,767 --> 00:42:57,800
可减少旅行的天数


799
00:42:57,867 --> 00:43:00,800
它采用了股票用户界面滑块


800
00:43:00,900 --> 00:43:02,267
所以您可免费使用这一软件


801
00:43:03,567 --> 00:43:05,933
因为我只喜欢直达航班


802
00:43:06,000 --> 00:43:09,867
所以
打开下面的按键 你可以看到


803
00:43:09,933 --> 00:43:11,467
它会从右侧移动到左侧


804
00:43:11,700 --> 00:43:15,967
右侧呈现整个用户界面


805
00:43:16,300 --> 00:43:17,733
因为采用的是母语
所以很直观


806
00:43:18,533 --> 00:43:22,333
把从左向右定位
添加到iOS 9


807
00:43:22,400 --> 00:43:23,900
软件是多么容易啊


808
00:43:24,067 --> 00:43:24,900
谢谢大家


809
00:43:27,400 --> 00:43:28,300
现在我们再讲讲托比


810
00:43:30,033 --> 00:43:30,933
托比 帕特森
谢谢 莎拉


811
00:43:33,567 --> 00:43:36,533
正如莎拉所讲
我们全力支持UIKit


812
00:43:36,600 --> 00:43:38,500
和其他系统框架


813
00:43:38,867 --> 00:43:40,700
你的应用程序可以免费安装


814
00:43:40,767 --> 00:43:42,133
这些软件


815
00:43:42,800 --> 00:43:45,333
您如果有自定义
视图或手势识别


816
00:43:45,667 --> 00:43:47,567
您确实该好好考虑


817
00:43:47,733 --> 00:43:49,167
从右向左语言给您带来的好处


818
00:43:50,033 --> 00:43:52,733
我不会向您
展示和推销这里的API


819
00:43:52,800 --> 00:43:55,900
也不会赘述UI的流动方式


820
00:43:55,967 --> 00:43:59,033
您可以为您的
UI做出自己合理的选择


821
00:44:00,700 --> 00:44:02,867
下面我讲讲链接


822
00:44:03,533 --> 00:44:06,400
这里是指您从
朋友信息或邮件里


823
00:44:06,467 --> 00:44:07,667
获得的链接


824
00:44:08,467 --> 00:44:11,533
点击链接
您就会打开一个网页


825
00:44:12,133 --> 00:44:14,333
这正是您想
从电脑上获取的网页


826
00:44:14,400 --> 00:44:17,767
Safari就是为
网站应用程序所开发的


827
00:44:18,933 --> 00:44:21,700
另一方面
IOS是唯一的本地应用程序


828
00:44:21,800 --> 00:44:24,333
在相关应用程序点击同样链接


829
00:44:24,400 --> 00:44:28,333
可以进入同一网页
这不是很棒么


830
00:44:29,833 --> 00:44:33,800
这正是iOS 9做出的突破


831
00:44:34,467 --> 00:44:39,967
点击软件的链接同样可以


832
00:44:41,100 --> 00:44:43,933
打开您想打开的页面


833
00:44:44,000 --> 00:44:45,433
这在您当前的页面操作就可以


834
00:44:45,800 --> 00:44:48,700
电脑的Safari浏览器
或iOS系统的本地应用


835
00:44:49,367 --> 00:44:50,233
这是它的运行过程


836
00:44:51,433 --> 00:44:55,333
将文件托管
到URL服务器的网页


837
00:44:55,400 --> 00:44:57,533
您的应用程序便可本地化处理


838
00:44:58,200 --> 00:45:00,467
当用户点击
其中某一URL服务器时


839
00:45:00,933 --> 00:45:04,333
我们把它包装在NSUser
Activity


840
00:45:04,400 --> 00:45:06,600
以切换的方式交付给应用软件


841
00:45:06,667 --> 00:45:08,967
这就是运行过程


842
00:45:09,033 --> 00:45:09,867
就这样简单


843
00:45:11,833 --> 00:45:14,667
我愿意谈谈
关于iOS 9新奇的事


844
00:45:15,500 --> 00:45:17,300
先从HomeKit智能家居平台说起


845
00:45:18,200 --> 00:45:20,867
今天早晨我们
公布了HomeKit平台


846
00:45:20,933 --> 00:45:22,333
的几个新特点


847
00:45:22,400 --> 00:45:26,200
当然我们将继续
提高HomeKit运营体系


848
00:45:27,933 --> 00:45:29,667
现在 特定级别的配件


849
00:45:30,000 --> 00:45:33,700
可以向你的设备直接推送


850
00:45:34,100 --> 00:45:36,267
门窗及报警系统推送信息


851
00:45:37,033 --> 00:45:38,867
而且 我们的新系统界面


852
00:45:38,933 --> 00:45:41,933
可以和智能家居
网络实现共享管理


853
00:45:42,867 --> 00:45:44,367
在设置中进行设置


854
00:45:44,433 --> 00:45:48,733
另外 你还可以通过
程序编程接口对接自己的应用


855
00:45:50,267 --> 00:45:52,533
不过
我认为真正有趣的事情是


856
00:45:52,600 --> 00:45:53,467
事件触发器


857
00:45:54,200 --> 00:45:58,233
你可以设置
“如果…那么…”的动作程序


858
00:45:58,300 --> 00:46:00,133
这样你可以
设定激活报警系统的时候


859
00:46:00,200 --> 00:46:02,700
选择关闭灯光


860
00:46:02,767 --> 00:46:05,133
或者
可以在早晨的时候开启咖啡机


861
00:46:05,733 --> 00:46:07,567
我认为
这些功能以后将会非常有用


862
00:46:09,267 --> 00:46:10,767
现在我们
在搜索方面也有了新突破


863
00:46:10,833 --> 00:46:12,667
我想大家会感兴趣


864
00:46:13,833 --> 00:46:15,800
当然 重磅消息是


865
00:46:15,867 --> 00:46:18,433
iSO现在可以
对你的应用内容进行搜索了


866
00:46:19,000 --> 00:46:20,300
我们有了丰富的搜索结果


867
00:46:20,367 --> 00:46:22,000
当用户点击时


868
00:46:22,067 --> 00:46:25,033
将直接对应
到应用中的具体位置


869
00:46:26,233 --> 00:46:29,267
对应用数据
进行索引一共有三种方法


870
00:46:29,967 --> 00:46:33,067
核心聚焦可以直接搜索


871
00:46:33,133 --> 00:46:35,300
全部的应用内容


872
00:46:36,033 --> 00:46:39,300
现在 某些数据有时限性


873
00:46:39,767 --> 00:46:43,100
这样你可以选择
对一款应用进行索引扩展


874
00:46:43,500 --> 00:46:45,400
核心聚焦会在特定时间启动


875
00:46:45,467 --> 00:46:49,667
以确保索引更新索引更新


876
00:46:51,200 --> 00:46:55,067
索引数据的另一种方式是
NSUerActivity


877
00:46:55,767 --> 00:46:58,967
NSUerActivity
对应用内的用户所见


878
00:46:59,033 --> 00:47:00,300
及行为进行索引


879
00:47:00,500 --> 00:47:04,167
这样方便循迹并返回应用


880
00:47:05,333 --> 00:47:08,567
最后 如果应用
正在生成网站镜像


881
00:47:08,633 --> 00:47:10,133
你可以对网站进行加示


882
00:47:10,200 --> 00:47:15,300
这样网络爬虫
会找到网站编入索引


883
00:47:15,500 --> 00:47:18,867
之后在设备上进行本地搜索时
则直接提供结果


884
00:47:20,967 --> 00:47:25,367
正如大家今早
看到的新搜索界面


885
00:47:26,000 --> 00:47:28,100
现在我们有了新系列搜索建议


886
00:47:28,167 --> 00:47:29,167
可供使用


887
00:47:29,233 --> 00:47:30,800
这是无需手动输入的


888
00:47:32,000 --> 00:47:34,567
当然
Siri甚至可以在应用内部


889
00:47:34,633 --> 00:47:36,100
进行结果建议


890
00:47:38,167 --> 00:47:40,100
如果您正用NSUser
Activity


891
00:47:40,167 --> 00:47:43,200
进行用户应用行为记录


892
00:47:43,633 --> 00:47:47,900
那么在出现预设建议时
Siri可以对记录进行搜索


893
00:47:48,467 --> 00:47:50,600
会注意到我们在NSUser
Activity


894
00:47:50,667 --> 00:47:52,200
基础上做足了功夫


895
00:47:52,267 --> 00:47:53,667
有Handoff功能


896
00:47:53,967 --> 00:47:57,300
还有通用连接 搜索 建议等


897
00:47:57,733 --> 00:48:02,000
这正是我们在现有基础上
进行开发的绝佳实例


898
00:48:02,067 --> 00:48:04,600
从而让应用和
整个行业系统有更多成果


899
00:48:06,400 --> 00:48:09,667
今天早上的重大消息
是多任务功能


900
00:48:09,767 --> 00:48:12,100
我们很高兴能
在今天和大家分享


901
00:48:13,633 --> 00:48:16,567
有滑屏和拆分视图


902
00:48:17,200 --> 00:48:21,267
这些功能让你在同一时间
进行多任务应用处理


903
00:48:21,733 --> 00:48:24,833
我想大家肯定会有疑问


904
00:48:24,900 --> 00:48:27,000
我该怎么做


905
00:48:27,067 --> 00:48:29,167
才能让好好使用新功能呢


906
00:48:30,200 --> 00:48:33,900
其实 答案不言而喻


907
00:48:34,700 --> 00:48:38,567
大家可能还记得
去年我们推出自适应用户界面


908
00:48:38,633 --> 00:48:40,167
这是一个非常简单的概念


909
00:48:40,633 --> 00:48:42,900
与其设计一种布局


910
00:48:42,967 --> 00:48:45,233
与其设计固
定屏幕尺寸的用户界面的


911
00:48:45,300 --> 00:48:50,067
然后根据
窗口大小进行适应变化


912
00:48:50,733 --> 00:48:53,300
而且我们还
提供了一些工具进行协助


913
00:48:53,833 --> 00:48:56,433
可对文字进行动态布局


914
00:48:56,500 --> 00:49:01,133
以及根据用户界面
的变化进行自动布局


915
00:49:01,867 --> 00:49:03,067
当然 现在我们知道


916
00:49:03,133 --> 00:49:05,233
只有一个布局是无法满足


917
00:49:05,300 --> 00:49:07,433
不同尺寸的屏幕要求


918
00:49:07,733 --> 00:49:11,333
所以我们推出了尺寸分级


919
00:49:11,600 --> 00:49:14,700
就可以选择合适的布局尺寸


920
00:49:14,767 --> 00:49:17,633
无需查看设备


921
00:49:19,067 --> 00:49:23,433
这是通过尺寸分类
屏幕大小实现的


922
00:49:23,500 --> 00:49:26,067
分为两大类
常规级别和压缩级别


923
00:49:26,133 --> 00:49:30,500
在这里你可以看到
iPad屏幕尺寸是常规级别


924
00:49:30,767 --> 00:49:34,100
而iPhone则是紧凑级别


925
00:49:34,800 --> 00:49:37,200
我们使用完全相同的机制


926
00:49:37,267 --> 00:49:38,933
设计多任务用户界面


927
00:49:40,000 --> 00:49:41,833
你可以在这里看到滑屏视图


928
00:49:41,900 --> 00:49:44,600
的尺寸是紧凑级别


929
00:49:44,900 --> 00:49:48,067
当我在分屏视图中
显示两个应用程序


930
00:49:48,967 --> 00:49:52,000
我们调整了
左边的主应用的边界


931
00:49:52,567 --> 00:49:55,567
调整到常规级别


932
00:49:56,233 --> 00:50:00,667
现在 有趣的是
当你平均调整拆分视图


933
00:50:01,167 --> 00:50:03,833
不仅是调整这里的窗口边界


934
00:50:03,900 --> 00:50:07,267
同时也会将左边主应用尺寸


935
00:50:07,333 --> 00:50:09,200
由常规调整好紧凑级别


936
00:50:10,100 --> 00:50:12,200
我们发现在自己的应用中


937
00:50:12,267 --> 00:50:15,533
这样的窗口尺寸是最佳的


938
00:50:16,867 --> 00:50:20,567
所以如果
你已经适应了应用的界面


939
00:50:21,033 --> 00:50:23,400
那么其他的可以交给该功能了


940
00:50:24,900 --> 00:50:26,600
你需要使用分镜功能


941
00:50:26,667 --> 00:50:30,100
用于灵活替代默认ping


942
00:50:31,033 --> 00:50:33,733
然后就可以支持所有其的了


943
00:50:33,900 --> 00:50:34,733
就是这样


944
00:50:35,067 --> 00:50:37,867
克雷格今天上午提到
我们可以在数分钟内转换应用


945
00:50:37,933 --> 00:50:41,200
并启动运行


946
00:50:41,333 --> 00:50:42,200
这真的很棒


947
00:50:43,567 --> 00:50:45,900
今天早上
我们还宣布了画中画功能


948
00:50:46,233 --> 00:50:49,133
让你可以在
不关闭其它应用的情况下


949
00:50:49,200 --> 00:50:50,633
观看视频


950
00:50:51,067 --> 00:50:53,567
如果你开发的是视频应用


951
00:50:53,633 --> 00:50:56,733
那么这项功能
真的是为你量身定制的


952
00:50:57,833 --> 00:50:59,133
当然 你的设备必须


953
00:50:59,200 --> 00:51:01,633
支持背景媒体播放


954
00:51:02,267 --> 00:51:05,933
然后启用画中画功能就可以了


955
00:51:06,700 --> 00:51:10,433
我们将该功能内置到
标准媒体播放控制中


956
00:51:10,933 --> 00:51:15,733
这样图形控制器能对画中画


957
00:51:16,300 --> 00:51:18,467
进行精细控制


958
00:51:20,167 --> 00:51:22,167
接下来我想谈谈Mac系统


959
00:51:23,033 --> 00:51:26,333
当然OS X系统
已经有了多任务


960
00:51:26,400 --> 00:51:28,067
多窗口功能


961
00:51:28,600 --> 00:51:31,667
而且今年我们
还宣布了新的窗口管理功能


962
00:51:31,967 --> 00:51:33,933
这实在让人激动


963
00:51:35,033 --> 00:51:36,367
这里的关键是


964
00:51:36,600 --> 00:51:40,800
在拆分视图里
并排显示两个应用界面


965
00:51:41,267 --> 00:51:43,067
正如这张截图所见


966
00:51:44,767 --> 00:51:47,533
现在 大家都容易适应


967
00:51:48,500 --> 00:51:52,433
另外
可变窗口也可以支持该功能了


968
00:51:52,500 --> 00:51:56,600
你只需要确保你的窗口


969
00:51:56,667 --> 00:51:59,900
形状美观和宽度适中


970
00:52:00,300 --> 00:52:01,833
以便和系统中的其他窗口适应


971
00:52:01,900 --> 00:52:03,800
不会产生不良效果


972
00:52:04,633 --> 00:52:07,933
当然 之前增加的
新程序接口AppKit功能


973
00:52:08,067 --> 00:52:09,567
能够使这项功能更为便利


974
00:52:09,967 --> 00:52:13,733
包括在NS拆分视图控制器
自动隐藏工具条


975
00:52:15,433 --> 00:52:19,033
Mac系统的
另一突破是压力触控


976
00:52:19,433 --> 00:52:22,233
这在几个月前已经发布了


977
00:52:23,267 --> 00:52:26,733
压力触控开辟了
触控的全新领域


978
00:52:27,067 --> 00:52:30,867
有了触控板的
压力感应和触觉反馈


979
00:52:32,000 --> 00:52:33,900
我们在自己的
应用中使用该技术


980
00:52:33,967 --> 00:52:37,167
如文本查找 压感播放控制


981
00:52:37,233 --> 00:52:40,233
同时还有预览
和标记等精确控制


982
00:52:42,567 --> 00:52:45,900
当然
我们还添加了一些程序接口


983
00:52:45,967 --> 00:52:47,467
方便大家的
应用可以使用该功能


984
00:52:48,200 --> 00:52:50,467
你可以设置压力触控


985
00:52:50,533 --> 00:52:51,933
压力配置的预设值


986
00:52:52,267 --> 00:52:55,533
配置触控板的默认触觉反馈


987
00:52:56,067 --> 00:52:58,867
以及视图和手势识别事件


988
00:52:58,933 --> 00:53:00,567le
压力变化


989
00:52:58,933 --> 00:53:00,567
压力变化


990
00:53:01,233 --> 00:53:04,767
我们相信Mac系统的
压力触控新功能会很受欢迎


991
00:53:05,233 --> 00:53:07,167
我们很期待


992
00:53:07,233 --> 00:53:08,367
大家如何充分利用该功能


993
00:53:10,033 --> 00:53:12,567
现在 iCloud也更新了


994
00:53:14,167 --> 00:53:16,333
去年我们推出了
iCloud Drive


995
00:53:16,500 --> 00:53:18,200
极大方便访问移动设备


996
00:53:18,267 --> 00:53:23,300
电脑和网络上的所有文件


997
00:53:25,067 --> 00:53:28,800
现在在iOS系统中
应用能够提供强大功能


998
00:53:28,867 --> 00:53:30,400
用于管理你的文档


999
00:53:30,800 --> 00:53:33,700
并且我们认为
这种简单以应用为中心的模式


1000
00:53:33,767 --> 00:53:35,167
对用户非常有用


1001
00:53:36,100 --> 00:53:38,533
但是 Mac用户习惯


1002
00:53:38,600 --> 00:53:41,733
直接在iCloud
Drive上直接处理文件


1003
00:53:42,767 --> 00:53:45,467
因此我们将新应用
iCloud Drive


1004
00:53:45,533 --> 00:53:48,367
应用添加到iOS系统中


1005
00:53:55,467 --> 00:53:56,533
看起来是这样子的


1006
00:53:56,600 --> 00:53:58,033
现在 你可以方便查看


1007
00:53:58,100 --> 00:54:01,033
iCloud Drive
上的所有文件


1008
00:54:01,667 --> 00:54:05,167
你可以在应用中预览文件


1009
00:54:05,833 --> 00:54:09,667
当然
你可以使用应用打开文件


1010
00:54:11,400 --> 00:54:13,267
在之前的iOS 9系统


1011
00:54:13,333 --> 00:54:18,067
只能将文件复制
到应用程序中才能打开


1012
00:54:18,367 --> 00:54:22,100
这正是用户不想在
iCloudDrive储存


1013
00:54:22,567 --> 00:54:24,633
或者处理文件的原因


1014
00:54:25,700 --> 00:54:29,333
我们真正想要的
是可以对文件进行编辑


1015
00:54:29,400 --> 00:54:31,067
无需移动或者复制就


1016
00:54:31,900 --> 00:54:34,133
因此如果你开发的
是一款基于文件的应用


1017
00:54:34,333 --> 00:54:36,167
这正是你们需要的


1018
00:54:37,300 --> 00:54:38,900
你需要能够进行文件协调


1019
00:54:38,967 --> 00:54:41,633
因为现在有了多进程


1020
00:54:41,700 --> 00:54:43,600
可以同步进行处理


1021
00:54:44,200 --> 00:54:46,833
而你只需要在记录中进行添加


1022
00:54:47,167 --> 00:54:49,700
列出并使用应用打开回调


1023
00:54:50,133 --> 00:54:50,967
就是这样


1024
00:54:52,267 --> 00:54:55,400
iCloud Drive
是基于CloudKit的


1025
00:54:55,867 --> 00:54:59,100
集iCloude服务于一身


1026
00:54:59,633 --> 00:55:02,533
CloudKit是
一个公共接口


1027
00:55:02,833 --> 00:55:04,833
我们开放接口


1028
00:55:04,900 --> 00:55:06,300
现在对所有人都开放了


1029
00:55:06,700 --> 00:55:09,267
那么这实际上有什么用途了


1030
00:55:10,567 --> 00:55:14,433
你可以在iCloud
Drive上免费储存文件


1031
00:55:14,500 --> 00:55:15,567
无需成为用户


1032
00:55:16,200 --> 00:55:18,533
当你的应用用户越来越多


1033
00:55:18,833 --> 00:55:23,400
数据马上就会装满 直到最大限度


1034
00:55:25,100 --> 00:55:27,767
现在 我们搭建了
CloudKitDashboard


1035
00:55:27,833 --> 00:55:31,133
方便向大家介绍这些功能


1036
00:55:31,500 --> 00:55:34,700
其中包括一些免费功能


1037
00:55:35,367 --> 00:55:38,067
我们将在未来
不断增加付费服务


1038
00:55:38,133 --> 00:55:41,067
这样 用户在使用
付费之前也会收到通知


1039
00:55:41,700 --> 00:55:43,233
另外 如果你使用付费服务


1040
00:55:43,700 --> 00:55:47,167
这里有价格单和说明


1041
00:55:48,333 --> 00:55:51,000
你还可以在这里找到
CloudKit其他信息


1042
00:55:51,067 --> 00:55:52,533
新功能的介绍等


1043
00:55:52,600 --> 00:55:56,000
如我们今年推出新功能


1044
00:55:56,800 --> 00:55:58,500
CloudKitWeb服务


1045
00:55:59,267 --> 00:56:03,867
这可以让CloudKit
在网络应用上实现运行


1046
00:56:04,767 --> 00:56:06,067
你可以做的是


1047
00:56:06,467 --> 00:56:10,533
CloudKit接口对接
可以通过JSON实现


1048
00:56:11,067 --> 00:56:14,100
我们提供与CloudKit
接口相当工具


1049
00:56:14,167 --> 00:56:17,000
JavaScript函式库


1050
00:56:17,567 --> 00:56:19,400
我还提供了
Web login flow


1051
00:56:19,467 --> 00:56:21,800
这样可以对用户进行安全验证


1052
00:56:22,567 --> 00:56:24,500
我们认为这会变的很简单


1053
00:56:24,567 --> 00:56:26,900
开发基于CloudKit
的网络应用


1054
00:56:27,200 --> 00:56:30,767
和你的ipadiphone
mac一起运行


1055
00:56:31,967 --> 00:56:34,167
这就是
CloudKit 谢谢


1056
00:56:38,333 --> 00:56:40,433
现在我把现场交给
克里斯·拉特纳


1057
00:56:40,633 --> 00:56:42,500
他将介绍Swift


1058
00:56:42,767 --> 00:56:43,900
克里斯·拉特纳：好的


1059
00:56:43,967 --> 00:56:45,033
谢谢


1060
00:56:50,033 --> 00:56:50,967
谢谢你 托比


1061
00:56:51,267 --> 00:56:53,100
Swift现在
的相应很不可思议


1062
00:56:53,367 --> 00:56:55,533
真的很难想象


1063
00:56:55,600 --> 00:56:57,367
才过了一年的时间


1064
00:56:58,467 --> 00:57:00,400
当我们谈到Swift


1065
00:57:00,467 --> 00:57:01,800
我们会谈到
它的一些主要特征


1066
00:57:01,867 --> 00:57:05,833
如性能 安全性和互动性


1067
00:57:06,500 --> 00:57:10,067
但我们希望每个人
都可以使用Swift


1068
00:57:10,633 --> 00:57:14,200
所以
我们开放编译器和标准库


1069
00:57:14,633 --> 00:57:16,933
甚至
简化Linux board


1070
00:57:25,267 --> 00:57:27,833
将在OSI认证的协议下运行


1071
00:57:28,100 --> 00:57:32,267
今年晚些时候
搭建好的Swift2之后


1072
00:57:33,000 --> 00:57:35,433
我们期待与大家的更多合作


1073
00:57:36,467 --> 00:57:39,633
期待大家的贡献和主意


1074
00:57:41,400 --> 00:57:43,600
现在关于Swift
已经有很多资料


1075
00:57:44,167 --> 00:57:45,800
我们不会一一说明


1076
00:57:46,000 --> 00:57:51,467
最喜欢的是Swift现在
是最佳的栈溢出编程语言


1077
00:57:53,067 --> 00:57:55,067
喜欢Swift的理由很多


1078
00:57:55,900 --> 00:57:58,300
其中之一是它的成功搭建


1079
00:57:58,367 --> 00:57:59,700
能够高速运行应用


1080
00:57:59,767 --> 00:58:02,233
在过去的一年中
Swift代码性突飞猛进


1081
00:58:02,300 --> 00:58:04,367
因为我们已经
在编译器中实现新的优化


1082
00:58:05,500 --> 00:58:07,633
另外
Swift2也有许多新改进


1083
00:58:07,767 --> 00:58:09,667
特别是在基板方面


1084
00:58:11,167 --> 00:58:12,767
现在我们简单谈谈其中几个


1085
00:58:12,967 --> 00:58:15,633
先从最热门的一项开始吧


1086
00:58:15,700 --> 00:58:16,967
新的错误处理模式


1087
00:58:18,867 --> 00:58:21,967
错误处理是非常热门的领域


1088
00:58:22,333 --> 00:58:23,900
已知的方法很多


1089
00:58:24,867 --> 00:58:27,533
但是这些方法也有一些问题


1090
00:58:27,967 --> 00:58:30,700
我们对现行方法并不满意


1091
00:58:30,767 --> 00:58:33,400
因此
我们找到新方法 非常类似


1092
00:58:34,100 --> 00:58:36,633
但是可以处理好这些问题


1093
00:58:37,133 --> 00:58:38,333
我们现在谈谈


1094
00:58:39,633 --> 00:58:40,500
先从简单的说起


1095
00:58:41,333 --> 00:58:44,900
Swift的功能或者方法是
标记错误


1096
00:58:45,800 --> 00:58:48,700
这极大简化了
通用Cocoa API


1097
00:58:49,033 --> 00:58:51,267
以及允许编译器验证错误


1098
00:58:51,333 --> 00:58:53,167
是否得到合适的处理


1099
00:58:54,533 --> 00:58:57,367
Swift现在可以用类似的
catch语法处理错误


1100
00:58:57,767 --> 00:59:01,267
并且
使用功能强大的匹配模式


1101
00:59:01,333 --> 00:59:03,100
表达丰富的cache条件


1102
00:59:04,633 --> 00:59:07,300
Swift独辟蹊径
使用尝试性关键字


1103
00:59:08,267 --> 00:59:10,567
用于标记调用


1104
00:59:10,633 --> 00:59:11,800
产生错误的方法


1105
00:59:12,733 --> 00:59:15,967
这重新对错误类型进行定义


1106
00:59:16,033 --> 00:59:17,800
当发生非预期控制流时


1107
00:59:18,200 --> 00:59:20,133
可以让
该控制流在代码中显现出来


1108
00:59:20,200 --> 00:59:21,633
这样可以对其进行分析处理


1109
00:59:23,000 --> 00:59:25,933
当然
处理错误将预期地简单


1110
00:59:26,533 --> 00:59:30,067
而且Swift在
对用户错误条件类型进行类型


1111
00:59:30,300 --> 00:59:32,900
和分类自定义
方面可谓完美无缺


1112
00:59:33,400 --> 00:59:34,267
真的很棒


1113
00:59:35,467 --> 00:59:36,667
现在 我们认为Swift


1114
00:59:36,933 --> 00:59:40,167
错误处理功能将不再陌生


1115
00:59:40,233 --> 00:59:41,700
很容易接受


1116
00:59:41,767 --> 00:59:43,733
但是这也会极大提高


1117
00:59:43,800 --> 00:59:45,400
Swift代码
在基板中的传输质量


1118
00:59:46,567 --> 00:59:48,467
现在我们可以
继续谈谈下一个重大特色


1119
00:59:48,533 --> 00:59:49,500
接入性检查


1120
00:59:51,400 --> 00:59:55,333
为此 我们增加了全新的接口


1121
00:59:55,867 --> 00:59:58,467
经常我们也会
想要调用新的接口


1122
00:59:58,533 --> 01:00:00,833
增加应用的性能


1123
01:00:01,267 --> 01:00:02,700
但是我们
仍需要支持OS X


1124
01:00:02,767 --> 01:00:05,067
或者iOS的更早版本


1125
01:00:05,967 --> 01:00:07,300
这带来一项挑战


1126
01:00:07,633 --> 01:00:11,600
因为你可以无条件
使用的某些符号


1127
01:00:12,367 --> 01:00:14,567
但是其他符号则对应用运行


1128
01:00:15,133 --> 01:00:18,333
所运行的OS系统
进行了条件限制


1129
01:00:19,467 --> 01:00:21,267
有了Swift 2
解决这问题轻而易举


1130
01:00:22,033 --> 01:00:24,433
现在
如果你想直接使用一个符号


1131
01:00:24,500 --> 01:00:25,367
而不想进行检查


1132
01:00:25,667 --> 01:00:27,233
那么
编译器将产生一条错误信息


1133
01:00:27,833 --> 01:00:28,667
这样方便区分


1134
01:00:29,467 --> 01:00:32,767
另外 Xcode在这方面走得更远
它提供了其他更好的方法


1135
01:00:33,367 --> 01:00:36,467
首次是你可以
使用新的“如有”语句


1136
01:00:36,767 --> 01:00:39,133
在需要的地方进行精确查找


1137
01:00:46,233 --> 01:00:47,867
但我认为比那更好的是


1138
01:00:48,133 --> 01:00:51,500
你也可以标出整个方法


1139
01:00:51,733 --> 01:00:55,567
甚至整个类
根据OS新特征


1140
01:00:55,967 --> 01:00:58,033
可消除在你的代码中将出现的


1141
01:00:58,300 --> 01:01:01,733
细微检查的需求
直接表达多种普通情况


1142
01:01:02,033 --> 01:01:04,133
是一种非常棒的解决方法
可以很好的一起使用


1143
01:01:05,033 --> 01:01:06,433
现在
Swift 2差错处理特征


1144
01:01:06,500 --> 01:01:07,867
和可用性检查特征


1145
01:01:07,933 --> 01:01:10,800
是更容易写出正确代码的


1146
01:01:10,867 --> 01:01:12,000
两大方法


1147
01:01:13,000 --> 01:01:16,167
但 当然
我也想要你的代码也很漂亮


1148
01:01:17,533 --> 01:01:20,633
所以在Swift 2中
我们做了数个大变动


1149
01:01:21,300 --> 01:01:22,400
Swift 1 引入一些


1150
01:01:22,467 --> 01:01:24,700
真正强大的整体通用函数


1151
01:01:25,133 --> 01:01:28,200
用算法做强大的东西


1152
01:01:31,200 --> 01:01:32,467
强大的 极好的


1153
01:01:32,833 --> 01:01:35,567
问题是 这些总是不够用


1154
01:01:36,000 --> 01:01:38,633
比如说 我有一组数据
想按比例增加数字


1155
01:01:38,700 --> 01:01:39,867
并丢掉某些结果


1156
01:01:40,367 --> 01:01:42,267
用Swift 2这很简单


1157
01:01:42,733 --> 01:01:45,300
但写出来需要重排很多代码


1158
01:01:45,900 --> 01:01:48,800
当你考虑时
你必须彻底地阅览


1159
01:01:48,867 --> 01:01:50,367
这使得它很难被推出来


1160
01:01:51,167 --> 01:01:53,300
Swift 2
引进一种新的语言程序


1161
01:01:53,367 --> 01:01:54,300
叫协议扩展


1162
01:01:55,300 --> 01:01:56,600
使用协议扩展


1163
01:01:57,000 --> 01:02:00,233
可通过彻底改动这些
整体通用函数


1164
01:02:00,333 --> 01:02:01,933
让它们至始至终都一样


1165
01:02:03,167 --> 01:02:05,600
意思是说
你写的新代码很漂亮


1166
01:02:05,667 --> 01:02:07,433
很容易写 也很容易读


1167
01:02:15,500 --> 01:02:17,333
让我们谈谈早退出


1168
01:02:18,500 --> 01:02:21,067
经常看到因为某些原因
想要早点退出作用域


1169
01:02:21,200 --> 01:02:23,200
或许你有办法 比如使用参数


1170
01:02:23,467 --> 01:02:26,533
可能是0 如果是0
它不起作用


1171
01:02:26,600 --> 01:02:29,600
好吧 如果让的表述
为你提供一种很熟悉


1172
01:02:29,667 --> 01:02:32,133
很舒服 很棒的方法
来检查这些条件


1173
01:02:32,333 --> 01:02:35,067
但它需要你将所有的代码
缩排成额外行


1174
01:02:36,067 --> 01:02:39,067
为解决这个问题
我们引进了一种新的防护说明


1175
01:02:39,133 --> 01:02:40,467
允许你检查条件


1176
01:02:40,533 --> 01:02:41,833
然后早点将其摆脱


1177
01:02:41,900 --> 01:02:44,433
允许你写出漂亮的直接式程序


1178
01:02:44,500 --> 01:02:45,933
无需额外的缩进


1179
01:02:53,133 --> 01:02:54,967
下一个Swift
如何运作的一个大元件


1180
01:02:55,033 --> 01:02:57,567
和Cocoa配合使用
可达到什么程度


1181
01:02:58,800 --> 01:03:01,100
但对于普通的
Objective-C API


1182
01:03:01,167 --> 01:03:03,367
Swift
编译程序是否有指示器


1183
01:03:03,433 --> 01:03:04,700
毫无影响


1184
01:03:04,767 --> 01:03:06,667
或一个序列的单元类型是什么


1185
01:03:07,333 --> 01:03:09,800
引入new features
subjective C


1186
01:03:09,867 --> 01:03:10,800
来解决这个问题


1187
01:03:10,867 --> 01:03:13,300
包括可以将指针类型
表达为空性的能力


1188
01:03:13,867 --> 01:03:17,867
在Xcode 7
我们引入整个全新的


1189
01:03:17,933 --> 01:03:20,367
一级的基因体系


1190
01:03:20,433 --> 01:03:23,900
可让你在
Objective-C中


1191
01:03:23,967 --> 01:03:24,967
表示单元类型


1192
01:03:25,033 --> 01:03:27,233
和许多其他的事


1193
01:03:34,067 --> 01:03:37,067
尽管采用了这个
和其他整组特征


1194
01:03:37,433 --> 01:03:39,033
Cocoa感觉还是相当快


1195
01:03:40,833 --> 01:03:42,500
最后
让我们来说说Xcode


1196
01:03:43,533 --> 01:03:48,700
Xcode 7引入
修改后的Swift移植器


1197
01:03:49,400 --> 01:03:52,333
它可自动将Swift 1
代码移到Swift 2序列


1198
01:03:52,633 --> 01:03:54,800
包括采用新差错处理模型


1199
01:03:55,567 --> 01:03:58,133
只要Swift语言继
续演变发展


1200
01:03:58,333 --> 01:04:00,500
移植器也将
继续发展与之匹配


1201
01:04:01,967 --> 01:04:04,333
下面 我们谈谈头文件


1202
01:04:06,000 --> 01:04:09,500
但 等一下 有无头文件


1203
01:04:09,567 --> 01:04:11,033
是Swift的明显特征
是吧


1204
01:04:11,533 --> 01:04:13,967
问题是 是否有时候你确实想


1205
01:04:14,033 --> 01:04:16,800
扫一眼一堆的代码
看看它究竟是什么


1206
01:04:17,067 --> 01:04:20,000
并以这种方式获得
所有执行细节


1207
01:04:21,233 --> 01:04:23,167
Xcode
已经解决这个问题


1208
01:04:23,233 --> 01:04:24,967
通过引入新辅助编辑器


1209
01:04:25,267 --> 01:04:26,833
它提供
任意Swift源文件的


1210
01:04:26,900 --> 01:04:28,633
一个类似头文件的意见


1211
01:04:29,367 --> 01:04:32,000
给于你所有头文件略读优势


1212
01:04:32,200 --> 01:04:36,000
没有写保持
以及自己编辑的维护压力


1213
01:04:37,133 --> 01:04:38,000
好极了


1214
01:04:44,433 --> 01:04:45,733
下一个 丰富的注释


1215
01:04:46,867 --> 01:04:48,233
Xcode让你写出


1216
01:04:48,867 --> 01:04:50,833
漂亮的Swift
Playgrounds


1217
01:04:50,900 --> 01:04:54,467
通过
直接向Xcode编辑器


1218
01:04:55,500 --> 01:04:58,833
这些丰富评论使用非常流行的
Markdown syntax


1219
01:04:59,233 --> 01:05:00,833
现在我们已将它
应用到syntax


1220
01:05:00,900 --> 01:05:02,567
用来进行文档注释


1221
01:05:03,533 --> 01:05:06,600
我们也增加对新特征的支持
比如内嵌图像和链接


1222
01:05:06,833 --> 01:05:08,867
提供很棒的
始终如一的体验


1223
01:05:08,933 --> 01:05:10,967
在Playgrounds
和doc注释之间


1224
01:05:11,500 --> 01:05:12,333
最后


1225
01:05:16,567 --> 01:05:18,400
最后
来说Playgrounds


1226
01:05:19,067 --> 01:05:21,100
Playgrounds
对我们来说很重要


1227
01:05:21,300 --> 01:05:23,733
我们知道利用API
是一种很棒的体验


1228
01:05:24,033 --> 01:05:25,867
也和Swift程式语言本身


1229
01:05:26,467 --> 01:05:29,333
认为Playgrounds
也是教和学习


1230
01:05:29,400 --> 01:05:30,767
程序编制的一种好方法


1231
01:05:31,267 --> 01:05:33,467
所以
我们对其增加了一些特征


1232
01:05:33,800 --> 01:05:37,067
包括
为多重页面增加最新的支持


1233
01:05:38,167 --> 01:05:41,433
为了更好地进行展示
我要邀请麦斯·杜克曼上台


1234
01:05:46,767 --> 01:05:48,133
麦斯·杜克曼:
谢谢克里斯


1235
01:05:48,467 --> 01:05:52,533
今天我要展示的是在
Xcode7中教和学习使用


1236
01:05:52,933 --> 01:05:54,800
Playgrounds
多么简单


1237
01:05:57,600 --> 01:06:00,367
让我们从这开始我开发了
一个playground


1238
01:06:00,433 --> 01:06:04,167
关于Apple的制图
API用来教学生


1239
01:06:05,533 --> 01:06:06,967
在这个部分


1240
01:06:07,033 --> 01:06:10,733
我为他们介绍一个全新的
GameplayKit


1241
01:06:12,033 --> 01:06:14,967
如Playground所说
GameplayKit用来


1242
01:06:15,033 --> 01:06:17,267
开发技术以驱动游戏设置


1243
01:06:17,767 --> 01:06:19,600
我们马上就可以看到更多东西


1244
01:06:21,800 --> 01:06:25,267
Playground
使用形象化的飞车追逐


1245
01:06:25,333 --> 01:06:28,100
表现GameplayKit
部分功能


1246
01:06:28,933 --> 01:06:30,567
我创造了这个
Playground


1247
01:06:30,633 --> 01:06:35,467
所以我的学生
可以编辑坏蛋的车辆


1248
01:06:36,500 --> 01:06:39,100
只需调整这三个精灵节点变量
（SpriteNode）


1249
01:06:40,700 --> 01:06:44,567
现在Playgrounds
可以为你


1250
01:06:44,633 --> 01:06:45,900
展示每个代码行的结果


1251
01:06:46,533 --> 01:06:50,367
我们增加了联机的功能


1252
01:06:55,600 --> 01:06:57,600
现在 我可以开始了


1253
01:06:57,667 --> 01:07:00,233
用学生将要用的方式编辑我的
Playground


1254
01:07:01,333 --> 01:07:02,700
通过改变数值


1255
01:07:03,433 --> 01:07:05,333
改变坏蛋的外貌


1256
01:07:06,733 --> 01:07:08,733
你可以看到 在我编辑时


1257
01:07:09,200 --> 01:07:10,700
变化也随之更新


1258
01:07:14,400 --> 01:07:16,033
那是一辆坏蛋的车


1259
01:07:18,133 --> 01:07:19,967
至此 我让我的学生


1260
01:07:20,233 --> 01:07:21,833
写了点代码


1261
01:07:22,367 --> 01:07:26,633
将坏蛋一起放到精灵中


1262
01:07:28,000 --> 01:07:29,767
现在 当我开始写代码


1263
01:07:32,300 --> 01:07:36,900
坏蛋就开始聚集了
我准备好了


1264
01:07:38,000 --> 01:07:39,333
这就是为设置所做的


1265
01:07:39,567 --> 01:07:41,533
是时候开始重要的事情了


1266
01:07:41,900 --> 01:07:43,733
它会让材料移动


1267
01:07:44,367 --> 01:07:46,267
这个我放在了其他页面


1268
01:07:47,333 --> 01:07:50,300
页面是一种好方法


1269
01:07:50,567 --> 01:07:53,000
可将Playgrounds
划分成像书一样的小主题


1270
01:07:53,700 --> 01:07:57,367
你可以使用页面底部的


1271
01:07:57,433 --> 01:07:58,700
手动导航连接转到其他页面


1272
01:07:59,700 --> 01:08:00,900
你也可以使用跳转栏


1273
01:08:02,433 --> 01:08:04,200
当然 还可以使用导航


1274
01:08:05,367 --> 01:08:07,367
这是我Playground
中所有的页面


1275
01:08:08,067 --> 01:08:12,700
每个页面都有软件源和资源


1276
01:08:13,033 --> 01:08:16,433
所以你可以如你所愿启动
你的Playground


1277
01:08:18,300 --> 01:08:19,600
我们来检查下一页


1278
01:08:21,767 --> 01:08:24,533
现在存好导航 放到一边


1279
01:08:26,000 --> 01:08:28,200
这个页面是关于


1280
01:08:28,267 --> 01:08:30,733
GameplayKit
的集群行为


1281
01:08:31,367 --> 01:08:34,033
集群是讲坏蛋聚集在一起


1282
01:08:34,267 --> 01:08:36,200
并使之移动的单位


1283
01:08:38,100 --> 01:08:39,800
现在
不需要进一步的数据对象


1284
01:08:40,167 --> 01:08:43,100
我将
打开Xcode的时间抽助手


1285
01:08:43,832 --> 01:08:46,133
看看聚集者


1286
01:08:48,633 --> 01:08:50,399
好了 这就是所有的罪犯


1287
01:08:50,466 --> 01:08:53,832
各种坏蛋在追踪
英勇无畏的英雄


1288
01:08:54,399 --> 01:08:56,933
但你可以看到 他们四处乱撞


1289
01:08:57,867 --> 01:08:59,300
真是集群灾难


1290
01:09:00,899 --> 01:09:02,033
来看看是否可以修正一下


1291
01:09:04,133 --> 01:09:07,300
这里有数个参数 可以用来


1292
01:09:07,367 --> 01:09:08,899
管理集群行为


1293
01:09:09,500 --> 01:09:11,167
这个有意思 内聚性


1294
01:09:11,800 --> 01:09:15,733
用来控制坏蛋团结一致的程度


1295
01:09:16,233 --> 01:09:17,966
我可以立马试试那个数值


1296
01:09:18,332 --> 01:09:20,399
立刻就可以看到效果


1297
01:09:21,433 --> 01:09:23,332
内聚性有点太大了


1298
01:09:23,399 --> 01:09:24,767
所以 让它稍微小点


1299
01:09:29,933 --> 01:09:31,832
这个间隔好多了


1300
01:09:31,899 --> 01:09:35,466
但仍不是我想要的那种
目标一致


1301
01:09:36,033 --> 01:09:38,567
所以 我要试试寻找参数


1302
01:09:39,899 --> 01:09:42,000
设置一个不同的数值


1303
01:09:42,067 --> 01:09:44,267
看看能不能达到我想要的聚集


1304
01:09:46,633 --> 01:09:47,466
好了


1305
01:09:48,367 --> 01:09:49,367
现在他们聚集在一起了


1306
01:09:50,733 --> 01:09:54,567
现在我知道我想要的数值范围


1307
01:09:54,633 --> 01:09:56,433
就可以告诉我的学生开始玩了


1308
01:09:58,133 --> 01:09:59,633
将助手储存好 放一边


1309
01:10:01,100 --> 01:10:05,433
将编辑器切换到原始标记


1310
01:10:07,467 --> 01:10:10,400
现在使用熟悉的
Markdown syntax


1311
01:10:10,467 --> 01:10:13,367
编辑Playground
的PROSE


1312
01:10:14,600 --> 01:10:18,700
我可以回到寻找参数


1313
01:10:19,333 --> 01:10:22,667
我也可以增加
额外的PROSE


1314
01:10:22,733 --> 01:10:25,300
让我的学生和这些数值玩一玩


1315
01:10:27,400 --> 01:10:29,000
我也可以来到这里


1316
01:10:29,767 --> 01:10:34,000
用图表的形式增加一些品牌


1317
01:10:35,167 --> 01:10:38,433
现在 无论何时
有人问我是否知道聚集


1318
01:10:38,500 --> 01:10:40,600
我就可以说
我写了一本关于聚集的书


1319
01:10:42,967 --> 01:10:44,667
谢谢 你很好


1320
01:10:50,433 --> 01:10:53,400
我们在Xcode 7中的
Playgrounds


1321
01:10:53,467 --> 01:10:55,000
仅加了少数的程序编写特征


1322
01:10:55,500 --> 01:10:57,467
等不及要看看
你们可以用它们做些什么出来


1323
01:10:57,667 --> 01:11:00,667
现在为告诉你一些
非常棒的Xcode特征


1324
01:11:00,900 --> 01:11:02,900
有请马太·菲力克上台


1325
01:11:09,900 --> 01:11:11,400
马太·菲力克：谢谢 麦斯


1326
01:11:13,200 --> 01:11:17,333
伴随着watchOS
iOS和OSX新版本的发布


1327
01:11:17,733 --> 01:11:20,200
我们很兴奋为你
提供Xcode 7


1328
01:11:21,267 --> 01:11:26,067
这个新发布的版本包括特征
并支持所有平台


1329
01:11:26,633 --> 01:11:29,633
且每个平台的独特体验


1330
01:11:29,700 --> 01:11:31,367
已经被合并到工具中


1331
01:11:31,533 --> 01:11:34,533
使你能够锁定和释放你的应用


1332
01:11:34,900 --> 01:11:36,567
到所有设备中


1333
01:11:38,200 --> 01:11:40,167
我今天将从独特的体验开始


1334
01:11:40,467 --> 01:11:42,667
使用设计工具 即界面生成器


1335
01:11:43,433 --> 01:11:47,100
首先是一种
展示你的应用的新方法


1336
01:11:47,200 --> 01:11:48,267
叫做堆栈视图


1337
01:11:53,900 --> 01:11:54,800
对于堆栈视图


1338
01:11:54,867 --> 01:11:58,767
你可以使用水平和垂直堆栈
设计你的应用


1339
01:11:59,467 --> 01:12:01,267
你可以从选择方向开始


1340
01:12:01,600 --> 01:12:02,600
增加你的控制


1341
01:12:03,600 --> 01:12:04,933
每增加一个控制


1342
01:12:05,000 --> 01:12:08,367
堆栈视图
将自动调整大小和定位


1343
01:12:09,067 --> 01:12:10,833
为你提供正确的样子


1344
01:12:12,233 --> 01:12:15,100
堆栈视图出色的嵌套


1345
01:12:15,167 --> 01:12:16,333
可允许你改变方向


1346
01:12:16,400 --> 01:12:19,033
这样 你就可以获得
你完全想要的那个布局


1347
01:12:20,900 --> 01:12:23,300
现在 我们已在自动版面配置
顶端建立堆栈视图


1348
01:12:23,533 --> 01:12:25,867
它为你处理所有的约束


1349
01:12:26,900 --> 01:12:30,533
0约束可以使你控制堆栈的


1350
01:12:30,767 --> 01:12:32,367
队列 空间和分布


1351
01:12:33,900 --> 01:12:36,133
堆栈视图同样灵活


1352
01:12:36,200 --> 01:12:37,833
你可以在界面生成器上


1353
01:12:38,167 --> 01:12:40,533
在运行时 和你的界面玩


1354
01:12:41,833 --> 01:12:44,967
当你在堆栈视图增加控制时
你可对它们重新排序


1355
01:12:45,133 --> 01:12:48,633
尝试不同的布局
或许最好的情况是


1356
01:12:48,967 --> 01:12:50,467
当你在运行时隐藏视图


1357
01:12:51,000 --> 01:12:53,067
堆栈视图将自动调整


1358
01:13:00,533 --> 01:13:03,233
堆栈视图是
界面生成器上的新方法


1359
01:13:03,300 --> 01:13:05,533
可使你完全获得你想要的布局


1360
01:13:06,333 --> 01:13:07,833
下一个是
Storyboard


1361
01:13:07,900 --> 01:13:09,433
references


1362
01:13:10,867 --> 01:13:13,733
使用Storyboard
你可以创造设计场景


1363
01:13:13,800 --> 01:13:15,667
用0代码将他们连接在一起


1364
01:13:15,933 --> 01:13:17,800
以构成完整的用户界面


1365
01:13:19,033 --> 01:13:21,567
现在 你的场景和界面进化了


1366
01:13:21,633 --> 01:13:23,367
变得有点复杂


1367
01:13:23,667 --> 01:13:25,433
你想要更容易的控制它


1368
01:13:26,133 --> 01:13:28,133
Storyboard
references


1369
01:13:28,200 --> 01:13:30,167
允许你截取一部分界面


1370
01:13:30,300 --> 01:13:32,667
并移动以分离
storyboard文件


1371
01:13:33,000 --> 01:13:36,400
保持连接


1372
01:13:43,000 --> 01:13:45,067
storyboard
references


1373
01:13:45,133 --> 01:13:47,533
使你的界面重点突出并模块化


1374
01:13:47,633 --> 01:13:49,600
和你处理应用代码相同的方式


1375
01:13:50,033 --> 01:13:52,867
也可很容易地设计你的应用流


1376
01:13:54,933 --> 01:13:58,200
和应用流
应用布局同样重要的


1377
01:13:58,267 --> 01:14:00,600
是应用外观


1378
01:14:01,333 --> 01:14:04,467
在此次发布我们制作了
值得一看的界面生成器


1379
01:14:06,133 --> 01:14:07,000
在接下来的场景中


1380
01:14:07,067 --> 01:14:11,400
你将看到
更多应用在界面生成器中


1381
01:14:11,467 --> 01:14:12,667
iOS 和OS X的可视化


1382
01:14:13,967 --> 01:14:17,100
画布内将对模糊和阴影着色


1383
01:14:18,600 --> 01:14:21,533
振动则成为展示的标准


1384
01:14:22,900 --> 01:14:26,533
而可设计的控制
可以展示隐蔽和阴影


1385
01:14:26,700 --> 01:14:29,233
组成你的场景中的其他视图


1386
01:14:30,900 --> 01:14:35,233
结合这些可视化
以及先前的编辑器


1387
01:14:35,567 --> 01:14:40,267
可使你进一步
改进特殊界面的外观和布局


1388
01:14:40,833 --> 01:14:42,433
意思是 现在比以往更加可以


1389
01:14:42,800 --> 01:14:45,533
直接在界面生成器中
编辑界面


1390
01:14:45,933 --> 01:14:48,367
看看你的使用者
会在他们的设备上做什么


1391
01:14:56,433 --> 01:15:00,267
创建应用的另一方面是
管理资产


1392
01:15:00,833 --> 01:15:03,100
含有工具的Xcode可与新


1393
01:15:03,333 --> 01:15:04,667
按需资源API配合使用


1394
01:15:07,067 --> 01:15:09,100
使用Xcode 7
你可以连接资产


1395
01:15:09,167 --> 01:15:10,833
发送到整个项目


1396
01:15:11,500 --> 01:15:13,500
以供下载和使用


1397
01:15:14,600 --> 01:15:16,933
每个标签代表一个资源聚集


1398
01:15:17,233 --> 01:15:18,600
我们把它叫做包


1399
01:15:19,700 --> 01:15:23,267
每个单独的资源
可申请多个标签


1400
01:15:23,467 --> 01:15:25,000
这可使你


1401
01:15:25,200 --> 01:15:26,333
在不同的环境中使用资源


1402
01:15:27,533 --> 01:15:29,933
帮助你管理标记的资源


1403
01:15:30,233 --> 01:15:33,267
在项目编辑器中
Xcode包括一个标签概述


1404
01:15:34,267 --> 01:15:37,133
在这里 你可以很容易地增加
移除重命名标签名


1405
01:15:37,767 --> 01:15:39,267
你可以改变包的内容


1406
01:15:39,733 --> 01:15:43,033
你也可以
安装按需资源各个方面


1407
01:15:43,300 --> 01:15:44,500
比如下载命令


1408
01:15:44,833 --> 01:15:46,000
下载优先次序


1409
01:15:47,700 --> 01:15:49,233
当你建立应用时


1410
01:15:49,500 --> 01:15:53,333
你的标记资产
自动集合成资源包


1411
01:15:53,800 --> 01:15:56,467
你只需标记你的资产
然后就可以开始了


1412
01:15:57,867 --> 01:15:59,500
当你配置你的应用时


1413
01:15:59,800 --> 01:16:02,500
你的按需资源
将由App Store主导


1414
01:16:03,500 --> 01:16:05,767
在调试时
Xcode将在你的Mac上


1415
01:16:05,833 --> 01:16:08,667
主导按需资源


1416
01:16:08,733 --> 01:16:10,400
并根据要求输到你的设备中


1417
01:16:10,667 --> 01:16:12,500
以模仿Store的下载行为


1418
01:16:13,833 --> 01:16:16,433
对于使用
Xcode持续集成的人


1419
01:16:16,900 --> 01:16:20,100
程式即将建立
并主导你的按需资源


1420
01:16:20,500 --> 01:16:23,700
所以 你可以在你的团队中
通过无线电进行测试App


1421
01:16:25,233 --> 01:16:29,033
最后 为帮助你追踪包


1422
01:16:29,633 --> 01:16:32,500
在进行调试时
调试计量表将显示


1423
01:16:32,567 --> 01:16:35,167
所有按需资源进度和状态


1424
01:16:36,533 --> 01:16:39,533
所有工具的组合


1425
01:16:39,600 --> 01:16:42,767
将让你很容易的在
App上使用按需资源


1426
01:16:45,467 --> 01:16:49,667
Xcode 7还有很棒的
调试和性能分析工具


1427
01:16:49,733 --> 01:16:53,000
可以帮助你
进一步强化应用的质量


1428
01:16:54,767 --> 01:16:57,767
塞巴斯蒂安刚提到
我们重点放在电池寿命


1429
01:16:58,500 --> 01:17:00,200
摆脱你的大部分设备


1430
01:17:00,300 --> 01:17:03,100
充一次电即可支撑一整天
这很重要


1431
01:17:03,700 --> 01:17:05,067
所以 我们让


1432
01:17:05,133 --> 01:17:07,400
能源使用跟踪应用变得简单


1433
01:17:08,767 --> 01:17:12,300
iOS新能量
计量器将显示CPU使用


1434
01:17:12,767 --> 01:17:15,900
调用API联网
以及定位服务


1435
01:17:16,333 --> 01:17:18,600
还将显示你的App


1436
01:17:18,733 --> 01:17:20,767
从前台到后台的转换


1437
01:17:21,800 --> 01:17:26,267
你可获得应用行为的内部信息
使用其它调试测量表


1438
01:17:26,733 --> 01:17:28,233
当你需要更多信息时


1439
01:17:28,567 --> 01:17:31,567
可通过仪器获取所有细节


1440
01:17:32,800 --> 01:17:35,533
说到设备 设备已经更新


1441
01:17:35,600 --> 01:17:37,000
比以前更好了


1442
01:17:38,033 --> 01:17:39,933
目前 追踪视野更紧凑


1443
01:17:40,000 --> 01:17:44,067
使用流动姿势
可让数据形象化更简单


1444
01:17:45,300 --> 01:17:48,367
我们还有不少更新后的工具
以及新工具


1445
01:17:48,433 --> 01:17:51,367
可供你使用
比如核心位置分析


1446
01:17:51,667 --> 01:17:53,700
新CPU系统追踪


1447
01:17:55,900 --> 01:17:57,433
在次次发布中 我们将


1448
01:17:57,500 --> 01:17:59,833
Clang's Address
Sanitizer


1449
01:17:59,900 --> 01:18:01,133
整合到调试工作流程中


1450
01:18:02,300 --> 01:18:05,267
Address Sanitizer
是C语言的一种


1451
01:18:05,533 --> 01:18:06,767
内存错误检测系统


1452
01:18:07,967 --> 01:18:11,667
一旦激活Xcode将监视应
用的内存使用情况


1453
01:18:11,967 --> 01:18:15,400
检测普通问题 比如缓冲超限


1454
01:18:16,433 --> 01:18:18,533
检测出来时
Xcode将通知你


1455
01:18:18,700 --> 01:18:21,733
并提供基本细节
帮助你进行诊断


1456
01:18:22,033 --> 01:18:23,100
调试问题


1457
01:18:24,100 --> 01:18:26,633
和其他类似的工具不同


1458
01:18:26,833 --> 01:18:28,933
Address
Sanitizer速度很快


1459
01:18:29,300 --> 01:18:32,767
速度快到
你可以在你的交互应用中使用


1460
01:18:35,800 --> 01:18:38,800
但是尽管有
如此出色的调试和分析工具


1461
01:18:39,100 --> 01:18:40,333
有时


1462
01:18:40,800 --> 01:18:43,567
漏洞会泄露 并造成崩溃


1463
01:18:44,300 --> 01:18:45,867
为帮助你尽快解决这个问题


1464
01:18:46,167 --> 01:18:48,733
Xcode
为崩溃日志整合支持


1465
01:18:51,167 --> 01:18:53,533
将你的App提交到
提交到TestFlight


1466
01:18:53,600 --> 01:18:54,433
谢谢


1467
01:18:55,133 --> 01:18:57,733
提交到TestFlight
和app store


1468
01:18:57,800 --> 01:18:58,667
Xcode会提供


1469
01:18:58,733 --> 01:19:00,267
symbolicated
crashes


1470
01:19:00,333 --> 01:19:01,500
服务于每一项任务


1471
01:19:03,267 --> 01:19:05,567
整合后
将为你提供一份更新清单


1472
01:19:05,633 --> 01:19:09,167
关于apps最常见的崩溃
告诉你回溯


1473
01:19:09,767 --> 01:19:13,467
崩溃的细节
以及最近发生崩溃的排行榜


1474
01:19:14,467 --> 01:19:16,700
你可以重新命名崩溃
以方便追踪


1475
01:19:17,267 --> 01:19:18,567
你也可以增加备注


1476
01:19:18,833 --> 01:19:22,000
当你搞定崩溃时
可以对其做记号


1477
01:19:23,533 --> 01:19:26,433
当你回顾回溯时
你想让它变得简单些


1478
01:19:27,033 --> 01:19:29,367
所以Xcode有Open
In Project键


1479
01:19:29,767 --> 01:19:33,367
可使你将回溯
下载到程序中的调试导航


1480
01:19:33,667 --> 01:19:35,367
提供熟悉的工作程序


1481
01:19:35,500 --> 01:19:38,100
为崩溃帧引导源代码


1482
01:19:38,433 --> 01:19:40,033
找出问题 并解决问题


1483
01:19:49,200 --> 01:19:52,933
早春时我们为
你们的iOS应用提供崩溃日志


1484
01:19:53,633 --> 01:19:55,467
今天以Xcode7开头


1485
01:19:55,533 --> 01:19:57,800
你将拿到OS X
应用的崩溃日志


1486
01:19:58,400 --> 01:20:01,700
watchOS
应用的崩溃日志也将很快出来


1487
01:20:02,900 --> 01:20:05,367
这此次发布 我们还将提供


1488
01:20:05,433 --> 01:20:09,033
应用扩展到所有平台的
app的崩溃日志


1489
01:20:09,267 --> 01:20:11,300
你就可以很好的
进行追踪和改善


1490
01:20:17,933 --> 01:20:20,800
另一种改善应用的方法是测试


1491
01:20:21,333 --> 01:20:23,067
我都喜欢测试 对吧


1492
01:20:25,433 --> 01:20:26,267
我再试一下


1493
01:20:26,333 --> 01:20:28,067
我都喜欢测试 对吧


1494
01:20:32,433 --> 01:20:36,800
很好 因为测试
是传送好应用的基本


1495
01:20:37,200 --> 01:20:39,333
今年 你有两个显眼的新添置


1496
01:20:40,900 --> 01:20:43,933
测试方法的核心是
XE测试框架


1497
01:20:44,200 --> 01:20:47,233
和测试导航
这些都将为你进行设计


1498
01:20:47,300 --> 01:20:49,667
组织测试提供不错的方法


1499
01:20:50,800 --> 01:20:53,567
在这之上
Xcode为你提供了不少


1500
01:20:53,633 --> 01:20:54,800
测试应用的方法


1501
01:20:56,400 --> 01:20:58,333
你可以检测你API的正确性


1502
01:20:58,667 --> 01:21:00,833
随时测量追踪它们的性能


1503
01:21:02,167 --> 01:21:05,333
你可以在测试代码评估
代码的同步行为和异步行为


1504
01:21:06,233 --> 01:21:11,267
不断的测试木马集成


1505
01:21:12,567 --> 01:21:14,067
所有这些组合在一起


1506
01:21:14,133 --> 01:21:17,167
可以做出一个
强大的测试解决方案


1507
01:21:18,167 --> 01:21:19,633
但我们
想要启发一个Notch


1508
01:21:19,933 --> 01:21:23,333
所以今年
我们增加了用户界面测试


1509
01:21:31,500 --> 01:21:33,633
这建立在相同的测试基础之上


1510
01:21:33,867 --> 01:21:35,533
现在
你可以进行正确性和性能测试


1511
01:21:35,700 --> 01:21:38,867
这些测试在用户界面上完成


1512
01:21:39,100 --> 01:21:41,433
将进一步扩大测试覆盖


1513
01:21:42,467 --> 01:21:45,800
说到覆盖 我们也增加了


1514
01:21:52,733 --> 01:21:54,500
代码覆盖是一种很棒的新方法


1515
01:21:54,567 --> 01:21:56,267
可用来评估测试进展


1516
01:21:56,500 --> 01:21:58,700
确保你能做所有你想要的测试


1517
01:21:59,667 --> 01:22:01,667
所以 让我们来快速的看一下


1518
01:22:01,733 --> 01:22:05,300
新UI测试和Xcode
7中代码覆盖率特征的演示


1519
01:22:10,033 --> 01:22:12,967
这里有一个
我和我的团队正在做的应用


1520
01:22:13,500 --> 01:22:15,600
是iOS和
iOS X中的一个


1521
01:22:15,667 --> 01:22:18,033
SpriteKit游戏
叫做Demo Bots


1522
01:22:18,967 --> 01:22:22,100
在我们开发应用时
我们同样做了测试


1523
01:22:22,167 --> 01:22:24,067
从这里可以看到
在测试导航中


1524
01:22:24,133 --> 01:22:25,933
有不少测试很有用


1525
01:22:27,167 --> 01:22:31,067
我们可以知道
哪个部分的代码还未进行测试


1526
01:22:31,433 --> 01:22:33,500
或因为我们还未写测试


1527
01:22:33,867 --> 01:22:36,533
或因为目前的测试
并不完整


1528
01:22:38,000 --> 01:22:40,833
对于Xcode 7
这正是可获得的


1529
01:22:40,900 --> 01:22:42,767
带代码覆盖率测试的内部信息


1530
01:22:44,033 --> 01:22:46,533
一测试Xcode
就会收集覆盖率数据


1531
01:22:47,100 --> 01:22:49,167
跳到测试报告


1532
01:22:49,733 --> 01:22:51,633
我们可以
看到有一个新覆盖率部分


1533
01:22:53,167 --> 01:22:54,833
覆盖率部分的内部


1534
01:22:55,133 --> 01:22:57,533
应用中的所有文件被列出


1535
01:22:57,933 --> 01:22:59,300
它们的右边有一个指示器


1536
01:22:59,367 --> 01:23:02,100
显示每个文件的覆盖率百分比


1537
01:23:03,033 --> 01:23:05,900
现在 在这个清单中
我按照从高到低进行分类


1538
01:23:06,200 --> 01:23:07,333
这样看起来好多了


1539
01:23:07,400 --> 01:23:10,533
往下滚动
可以看到这里还有些工作要做


1540
01:23:12,500 --> 01:23:15,600
对于列表中的每个文件
你可以公开内容


1541
01:23:15,667 --> 01:23:17,167
看看方法的覆盖率


1542
01:23:17,233 --> 01:23:19,033
以及此处说包含的功能


1543
01:23:19,767 --> 01:23:21,000
对于这个我已经公开的文件


1544
01:23:21,067 --> 01:23:23,700
前两个功能覆盖率100%


1545
01:23:24,000 --> 01:23:26,233
但其他三个的覆盖率为0


1546
01:23:28,100 --> 01:23:32,067
对于项目 报告为你提供
覆盖率的高度概括


1547
01:23:32,500 --> 01:23:35,033
但是我们想
直接为你提供信息


1548
01:23:35,767 --> 01:23:38,700
看看这里
当我操作一个源文件时


1549
01:23:38,900 --> 01:23:40,567
我们直接将代码覆盖率信息


1550
01:23:40,633 --> 01:23:41,800
带到源编辑器中


1551
01:23:42,500 --> 01:23:43,800
黑色的这部分


1552
01:23:43,867 --> 01:23:46,100
是还未进行测试的代码


1553
01:23:46,967 --> 01:23:49,767
非常好
这样我就知道该关注哪里


1554
01:23:50,600 --> 01:23:52,767
它和助理编辑器也配合得很好


1555
01:23:53,167 --> 01:23:56,367
因为你可以有源代码
并一起进行测试


1556
01:23:56,733 --> 01:23:59,633
一旦测试持续进行
就更新信息


1557
01:24:01,833 --> 01:24:04,467
如果我们回到报告
看看未覆盖的类


1558
01:24:04,533 --> 01:24:07,933
大部分是用户界面类


1559
01:24:08,033 --> 01:24:09,367
它们是视图自控器 等等


1560
01:24:10,200 --> 01:24:11,067
所以 帮我一下


1561
01:24:11,133 --> 01:24:13,100
我要创建一个用户界面测试


1562
01:24:14,700 --> 01:24:18,033
我已经建立一个用户
界面测试bundle和类


1563
01:24:18,600 --> 01:24:19,833
我将从这里挑选


1564
01:24:20,867 --> 01:24:24,233
我想要写的测试程序是
用来测试游戏选择板


1565
01:24:25,433 --> 01:24:30,467
新API和XE测试可使你与
用户转换元件互动


1566
01:24:30,733 --> 01:24:31,967
访问他们的设备


1567
01:24:32,233 --> 01:24:34,933
触发行动
真的很容易写出来


1568
01:24:36,000 --> 01:24:38,967
但比写UI
测试更简单的是什么 知道吗


1569
01:24:39,033 --> 01:24:41,733
记录一个
让我来告诉你怎么做


1570
01:24:43,067 --> 01:24:44,667
我先解除项目导航


1571
01:24:44,733 --> 01:24:46,267
为自己释放一些空间


1572
01:24:46,867 --> 01:24:49,567
以及测试中我想进行的插入点


1573
01:24:50,067 --> 01:24:52,200
我将点击一下编辑器底部的


1574
01:24:52,267 --> 01:24:53,133
小记录按钮


1575
01:24:54,400 --> 01:24:56,767
你可以看到在我操作时
Xcode开始应用


1576
01:24:57,767 --> 01:24:59,400
请注意


1577
01:24:59,467 --> 01:25:01,033
左上角的测试


1578
01:25:01,967 --> 01:25:04,833
首先我想要你点击
应用中的选择按钮


1579
01:25:05,600 --> 01:25:06,467
你可以看到


1580
01:25:06,767 --> 01:25:09,167
Xcode
正在记录测试代码的


1581
01:25:09,233 --> 01:25:10,067
插入对应线


1582
01:25:18,600 --> 01:25:20,200
你可以看到API非常简单


1583
01:25:20,433 --> 01:25:23,033
它正在为窗口和按钮询问应用


1584
01:25:23,333 --> 01:25:24,267
告诉我们点击


1585
01:25:25,833 --> 01:25:27,600
测试的下一步


1586
01:25:27,667 --> 01:25:28,933
我要填上玩家的名字


1587
01:25:29,000 --> 01:25:31,500
我开始在标准玩家把手这打字


1588
01:25:31,667 --> 01:25:34,033
你可以看到这里
两件很酷的事情发生了


1589
01:25:34,533 --> 01:25:36,367
第一 当我在文本域打字时


1590
01:25:36,433 --> 01:25:39,267
编辑器也跟着更新
并展示数值


1591
01:25:39,667 --> 01:25:40,500
非常的酷


1592
01:25:41,400 --> 01:25:42,600
另一个是


1593
01:25:42,667 --> 01:25:44,900
UI记录注意到我正在和


1594
01:25:44,967 --> 01:25:47,767
同一用户的界面因素
进行不止一次的互动


1595
01:25:48,067 --> 01:25:50,633
它重构测试代码
为它创建一个局部变量


1596
01:25:51,400 --> 01:25:54,467
这使得测试可读


1597
01:25:54,533 --> 01:25:56,967
意味着后续很容易
重构并重新使用代码


1598
01:25:58,400 --> 01:26:00,867
我们继续从这挑选一些选择项


1599
01:26:00,933 --> 01:26:02,100
你可以看到测试升级了


1600
01:26:02,833 --> 01:26:05,500
对于最后一个要素
我要从这选一个不同的机器人


1601
01:26:05,833 --> 01:26:08,833
我将按这个按钮
选择蓝色机器人


1602
01:26:10,100 --> 01:26:12,267
点击完成
回去看我的测试


1603
01:26:13,600 --> 01:26:17,233
和记录一样
很容易就可追踪我所有的行动


1604
01:26:18,033 --> 01:26:20,233
测试还可以做更多的事


1605
01:26:20,300 --> 01:26:22,533
我们可验证一些数值


1606
01:26:23,200 --> 01:26:25,867
在点击完成按钮之前
让我们先插入一些代码


1607
01:26:26,100 --> 01:26:27,767
检查设置是否正确


1608
01:26:29,100 --> 01:26:31,267
我将在这插入一些代码


1609
01:26:31,333 --> 01:26:34,067
从界面获取有效机器人的数值


1610
01:26:34,267 --> 01:26:35,100
这是在文本域中


1611
01:26:35,400 --> 01:26:38,600
我将和我预料的数值进行对比
蓝色机器人


1612
01:26:40,067 --> 01:26:42,633
没有进一步的动态数据对象
可以开始测试了


1613
01:26:43,700 --> 01:26:44,600
我不介入


1614
01:26:45,667 --> 01:26:47,233
这里可以看到它正在更新数值


1615
01:26:47,533 --> 01:26:48,500
选择正确的机器人


1616
01:26:48,867 --> 01:26:50,967
验证测试 测试通过了


1617
01:27:00,733 --> 01:27:03,200
所以记录产生编写
UI测试真的很容易


1618
01:27:04,567 --> 01:27:07,433
我们可以看看Xcode
内部的测试并局部运作


1619
01:27:07,767 --> 01:27:10,367
我们也可以
让它在持续集成木马上运作


1620
01:27:11,133 --> 01:27:14,500
我为应用iOS和OSX版本
设置一些木马


1621
01:27:15,200 --> 01:27:19,000
如果选择iOS版本
看看测试


1622
01:27:19,667 --> 01:27:21,033
当我过滤掉失败的测试


1623
01:27:21,100 --> 01:27:22,100
我看到一些有趣的东西


1624
01:27:22,933 --> 01:27:26,167
我有四个界面测试
它们iPhone上通过测试


1625
01:27:26,500 --> 01:27:27,867
但在iPad上 测试失败


1626
01:27:29,567 --> 01:27:31,967
为方便诊断测试失败原因


1627
01:27:32,067 --> 01:27:34,567
每个运行测试包括
所有运行过的测试行为的副本


1628
01:27:34,633 --> 01:27:39,367
看到这些
我可以通过扩展测试


1629
01:27:39,967 --> 01:27:41,667
这是一份清单测试的所有行为


1630
01:27:41,733 --> 01:27:43,200
是关于刚才就开始运行的


1631
01:27:44,767 --> 01:27:46,667
因为可以看到用户界面测试


1632
01:27:46,733 --> 01:27:48,133
我想要更进一步


1633
01:27:48,633 --> 01:27:51,233
每一个行动都包含平面截图


1634
01:27:52,167 --> 01:27:54,800
如果我检查
iPhone上通过的测试


1635
01:27:55,067 --> 01:27:57,433
我可以得到一个平面截图
关于测试如何开始的


1636
01:27:57,700 --> 01:27:58,667
这是我们游戏的开始


1637
01:27:59,400 --> 01:28:01,733
我也可以查看测试的中间部分


1638
01:28:02,100 --> 01:28:03,000
这里 我们用键盘


1639
01:28:03,067 --> 01:28:04,700
在文本域中敲入一个数值


1640
01:28:05,467 --> 01:28:07,333
我同样可以看测试的最后部分


1641
01:28:07,667 --> 01:28:10,633
这是在点击
完成按钮前UI的情形


1642
01:28:11,933 --> 01:28:14,400
如果我将其翻过来
在iPad上看测试


1643
01:28:14,467 --> 01:28:16,733
并一直跳过 直到最后部分


1644
01:28:17,433 --> 01:28:20,433
可看到这是iPad UI
所有设置都正确


1645
01:28:21,033 --> 01:28:21,867
但没有完成按钮


1646
01:28:22,500 --> 01:28:24,500
显然 在UI中
我们错误安装了一些东西


1647
01:28:24,567 --> 01:28:28,033
屏幕截图可以很快地
帮我们缩小范围


1648
01:28:29,533 --> 01:28:31,600
代码覆盖率告诉我
在哪里写测试


1649
01:28:32,067 --> 01:28:33,600
UI测试和记录让我可以


1650
01:28:33,667 --> 01:28:34,867
很容易的获取更多的覆盖率


1651
01:28:34,933 --> 01:28:36,867
新测试记录帮我


1652
01:28:36,933 --> 01:28:37,967
缩小问题范围


1653
01:28:38,733 --> 01:28:40,167
以上是关于Xcode 7


1654
01:28:40,267 --> 01:28:42,233
代码覆盖率和UI
测试的信息


1655
01:28:52,167 --> 01:28:56,400
用户界面测试
使系统可达性的使用与


1656
01:28:56,667 --> 01:28:58,267
UI要素相互作用


1657
01:28:58,967 --> 01:29:02,367
意思是如果你已经
让你的app具有可达性


1658
01:29:02,833 --> 01:29:05,167
那么你也已经
让你的app具有可测试性


1659
01:29:06,633 --> 01:29:11,533
UI测试同样可用于根据尺寸
和定位设计的Uis中


1660
01:29:11,600 --> 01:29:13,133
包括从右到左的支持


1661
01:29:13,600 --> 01:29:14,933
也就是说你的UI测试


1662
01:29:15,000 --> 01:29:18,467
可以
测量你的UI中所有的演示


1663
01:29:20,400 --> 01:29:23,067
新API 是的
你可以为它鼓掌


1664
01:29:27,833 --> 01:29:33,200
新API和XE测试
使用于


1665
01:29:33,267 --> 01:29:34,967
Swift和
Objective-C


1666
01:29:35,267 --> 01:29:37,967
UI记录
将生成你所使用的任何一个


1667
01:29:39,733 --> 01:29:43,000
这些是你在
Xcode7可找到的新特征


1668
01:29:43,067 --> 01:29:47,067
在你为我们平台创建
App时就可以看到


1669
01:29:55,633 --> 01:29:58,733
现在 我们要和你们
分享一些令人兴奋的新技术


1670
01:29:58,800 --> 01:30:00,500
它们可用在游戏和制图中


1671
01:30:00,567 --> 01:30:03,467
我将邀请我的同事
杰夫· 斯特尔上台


1672
01:30:07,233 --> 01:30:08,933
杰夫· 斯特尔：
谢谢你马太·菲力克


1673
01:30:10,100 --> 01:30:11,733
我很激动
Xcode 7实在令人惊讶


1674
01:30:12,800 --> 01:30:15,433
能在
这里和你们谈论游戏和制图


1675
01:30:16,067 --> 01:30:18,533
似乎就在不久前
我们在这里介绍了


1676
01:30:18,600 --> 01:30:22,200
我们首个与游戏有关的
API Game Center


1677
01:30:22,267 --> 01:30:23,633
或社交类游戏网络


1678
01:30:24,667 --> 01:30:28,133
从那之后
我们一直为API的键盘输入


1679
01:30:28,200 --> 01:30:31,600
和制图技术忙碌像
游戏控制器SceneKit


1680
01:30:31,967 --> 01:30:34,100
SpriteKit
以及最近的Metal


1681
01:30:35,567 --> 01:30:39,033
今年我们推出了
不少新游戏技术


1682
01:30:39,767 --> 01:30:43,733
包括使你的绘图
现代化的Model I/O


1683
01:30:44,667 --> 01:30:47,533
ReplayKit用来
拓展游戏的社会范围


1684
01:30:48,333 --> 01:30:52,933
Game Center用来为你的
游戏增加超级厉害的大脑


1685
01:30:53,500 --> 01:30:57,967
而且 我们把所有的这些
都放在GameKit里


1686
01:30:58,833 --> 01:31:02,567
只要有一个GameKit
所有功能均触手可及


1687
01:31:03,233 --> 01:31:04,333
很棒的解决方法


1688
01:31:04,633 --> 01:31:08,000
在我们平台上发展游戏的
极其完整的解决方法


1689
01:31:09,767 --> 01:31:12,467
让我们来看看GameKit
上的某些很酷的新特征


1690
01:31:12,900 --> 01:31:13,767
从Metal开始


1691
01:31:14,933 --> 01:31:16,367
你知道Metal是


1692
01:31:16,433 --> 01:31:19,367
去年我们为
iOS推出的3DAPI


1693
01:31:19,867 --> 01:31:23,467
我们真的很兴奋
今年我们将它引进OS X


1694
01:31:25,000 --> 01:31:28,000
作为翻新产品
让我们来看一个例子


1695
01:31:28,067 --> 01:31:32,167
我们最近从OpenGL移到
Metal的游戏开发


1696
01:31:33,533 --> 01:31:35,900
这里有个游戏 开始时


1697
01:31:36,500 --> 01:31:38,933
是在OpenGL上运行
你可以看到


1698
01:31:39,100 --> 01:31:44,267
OpenGL处理命令使得
一个CPU完全饱和


1699
01:31:44,500 --> 01:31:46,700
这使得游戏
玩法进入第二个CPU


1700
01:31:47,100 --> 01:31:50,600
这个CPU并不繁忙
事实上 在这个例子中


1701
01:31:50,667 --> 01:31:52,900
我们看到CPU有
40%处于闲置状态


1702
01:31:55,400 --> 01:31:56,600
移到Metal


1703
01:31:56,667 --> 01:31:59,533
我们彻底地减少
处理命令的时间


1704
01:31:59,800 --> 01:32:01,067ddle
我们有API


1705
01:31:59,800 --> 01:32:01,067
我们有API


1706
01:32:01,133 --> 01:32:02,900
你可以更直接的为GPU编程


1707
01:32:02,967 --> 01:32:05,533
如果你选择
你可以将处理命令分开


1708
01:32:05,800 --> 01:32:07,033
穿过多重芯部


1709
01:32:07,500 --> 01:32:12,600
在这个例子中
我们释放了GPU的全部性能


1710
01:32:14,667 --> 01:32:18,200
我们和第三方开发人员合作
为OSX开发Metal


1711
01:32:19,467 --> 01:32:20,400
让我们花一分钟


1712
01:32:20,467 --> 01:32:23,667
看看他们在Mac上所做的


1713
01:32:24,933 --> 01:32:27,633
很高兴为你们介绍
大卫·麦克德兰


1714
01:32:27,700 --> 01:32:28,967
他来自
Adobe Systems


1715
01:32:29,033 --> 01:32:30,300
将为我们展示


1716
01:32:30,367 --> 01:32:32,333
他们使用OSX
对Metal做了什么


1717
01:32:38,167 --> 01:32:39,467
大卫·麦克德兰:
非常感谢


1718
01:32:39,533 --> 01:32:42,167
去年春天
Adobe曾很激动


1719
01:32:42,267 --> 01:32:44,533
当Apple把iOS引进
Metal的iOS时


1720
01:32:44,700 --> 01:32:46,933
事实上 我们已经用它来优化


1721
01:32:47,000 --> 01:32:48,267
部分流行的iOS App


1722
01:32:48,333 --> 01:32:50,667
Premier Flip
Photoshop Mix


1723
01:32:50,733 --> 01:32:51,767
而且看到了很好的结果


1724
01:32:52,567 --> 01:32:55,000
当Apple告诉我们
Metal被引入到OSX


1725
01:32:55,067 --> 01:32:56,167
我们非常的激动


1726
01:32:56,867 --> 01:32:59,400
这样一来 我们就可以
在这些平台分享我们的代码


1727
01:33:00,100 --> 01:33:02,467
今天我将展示
我们的一些进展


1728
01:33:02,533 --> 01:33:04,933
Mac OS的两款旗舰产品


1729
01:33:05,000 --> 01:33:06,833
Illustrator
和After Effects


1730
01:33:06,900 --> 01:33:08,267
我们来看一下


1731
01:33:15,300 --> 01:33:18,200
这是当前版本的
Adobe Illustrator


1732
01:33:18,867 --> 01:33:23,033
里面有大量的原图
超过三十万点


1733
01:33:23,500 --> 01:33:25,200
渐变和合成模式


1734
01:33:27,333 --> 01:33:29,800
我将继续
并对这张原图做缩放


1735
01:33:31,667 --> 01:33:33,467
你可以看到


1736
01:33:34,100 --> 01:33:36,233
在处理那张复杂的原图时
速度有点慢


1737
01:33:37,200 --> 01:33:38,767
我真想看看我们能否做些改善


1738
01:33:40,067 --> 01:33:42,567
用这个版本 我们将展示


1739
01:33:42,633 --> 01:33:45,400
在我们用了整个绘制引擎
并将它放到Metal上时


1740
01:33:45,467 --> 01:33:47,000
我们可以用Metal做什么


1741
01:33:47,400 --> 01:33:49,000
事实上 它很好用


1742
01:33:49,067 --> 01:33:54,233
它们将展示出
有不断缩放功能的全新特征


1743
01:33:55,133 --> 01:33:58,467
当你考虑我们可以用
Metal做什么的时候


1744
01:33:59,033 --> 01:34:00,600
你可以看到结果出人意料


1745
01:34:01,400 --> 01:34:05,200
事实上 我可以一直缩放
放大很多


1746
01:34:07,533 --> 01:34:08,967
直到你可以看到文本信息


1747
01:34:17,333 --> 01:34:19,967
这也很大程度上改变了艺术家
使用我们产品时的工作方式


1748
01:34:21,333 --> 01:34:23,100
现在我想谈一下
后遗效应


1749
01:34:23,267 --> 01:34:25,900
这里有一盘录像来自极限运动
团videographer


1750
01:34:25,967 --> 01:34:27,800
Devin
Supertramp


1751
01:34:27,867 --> 01:34:28,867
让我们快速浏览一遍


1752
01:34:42,833 --> 01:34:43,667
十分有趣


1753
01:34:44,133 --> 01:34:46,300
我们要的是
从中选择一个镜头


1754
01:34:46,367 --> 01:34:48,400
用后遗效应进行分析
加入一些效果


1755
01:34:48,467 --> 01:34:49,667
将其制作成商品广告插播


1756
01:34:50,700 --> 01:34:52,267
所以在这里 我将做一些


1757
01:34:52,333 --> 01:34:54,467
色彩校正 波纹特效


1758
01:34:54,800 --> 01:34:56,833
和镜头光斑特效
接下来


1759
01:34:56,900 --> 01:34:58,400
脱离Metal重新播放一遍


1760
01:35:01,167 --> 01:35:03,433
你可以看到它在
中央处理器中运行十分困难


1761
01:35:03,967 --> 01:35:04,833
也不能产生


1762
01:35:04,900 --> 01:35:06,600
我们所倾向的交互性能


1763
01:35:06,667 --> 01:35:08,033
并提供给文字编排人员


1764
01:35:09,233 --> 01:35:11,600
这也是对程序员的一种挑战
他们要时刻注意这一点


1765
01:35:11,667 --> 01:35:13,500
看看
能利用Metal做些什么


1766
01:35:14,167 --> 01:35:15,367
所以短时间内 他们需要


1767
01:35:15,433 --> 01:35:18,333
将这三个
效应转移给Metal之后


1768
01:35:18,400 --> 01:35:20,600
你们会发现
相当惊人的不同


1769
01:35:20,667 --> 01:35:22,867
现在我切换到
相同的编制


1770
01:35:23,167 --> 01:35:24,600
但这次
那些特效将会被替换


1771
01:35:24,667 --> 01:35:26,667
转变为Metal版本
下面我再重播一遍


1772
01:35:27,567 --> 01:35:29,567
你可以马上看到实时运行


1773
01:35:30,300 --> 01:35:33,433
不需要降低框架
我们看到


1774
01:35:33,500 --> 01:35:35,933
这些特效达到
八倍的性能优化


1775
01:35:36,167 --> 01:35:38,700
很大程度上减少
处理器使用量


1776
01:35:39,467 --> 01:35:41,933
因此奥多比公司
致力于将Metal


1777
01:35:42,000 --> 01:35:44,767
引入到Mac操作系统
创新云应用中


1778
01:35:44,833 --> 01:35:47,333
如Illustrator
及我今天为你展示的后遗效应


1779
01:35:47,467 --> 01:35:49,900
当然还有Photoshop
和Premier Pro


1780
01:35:50,067 --> 01:35:51,433
我们很激动看到Metal


1781
01:35:51,500 --> 01:35:52,567
为云用户所做的一切


1782
01:35:52,833 --> 01:35:53,667
非常感谢


1783
01:35:59,800 --> 01:36:01,833
杰夫 斯特尔：
大卫 谢谢你 这不可思议


1784
01:36:01,900 --> 01:36:03,833
我同意克雷格的观点
这十分有趣 因为


1785
01:36:03,900 --> 01:36:07,833
你可以进行
非实时交互作用并转换为


1786
01:36:07,900 --> 01:36:10,433
流畅的用户交互


1787
01:36:11,000 --> 01:36:13,400
但Metal不仅适用于
应用程序


1788
01:36:13,700 --> 01:36:15,067
当我们说到今天早上


1789
01:36:15,633 --> 01:36:19,267
iOS系统中关键的图形技术


1790
01:36:19,500 --> 01:36:22,533
接入就将OS
X系统以及应用程序界面


1791
01:36:23,333 --> 01:36:25,933
直到现在
像核心动画技术


1792
01:36:26,300 --> 01:36:28,133
以及硬件加速的核心图像


1793
01:36:28,433 --> 01:36:31,700
移文档Safari页面显示
都已被置于开放图形语言顶端


1794
01:36:32,433 --> 01:36:36,700
这意味着中央处理器
疲于应对图形处理器的指令


1795
01:36:38,233 --> 01:36:41,667
运用Metal我们
可以提高效率改进性能


1796
01:36:41,900 --> 01:36:43,833
尤其是关键的用户级别任务


1797
01:36:46,300 --> 01:36:48,300
此外 我们不想仅仅


1798
01:36:54,033 --> 01:36:55,467
提升系统性能


1799
01:36:55,567 --> 01:36:59,133
我们真正想做的
是想让所有人可以很轻松地


1800
01:36:59,200 --> 01:37:00,133
使用Metal


1801
01:37:00,400 --> 01:37:01,867
因此
我们引入MetalKit


1802
01:37:02,667 --> 01:37:04,533
通过它可以了解Metal


1803
01:37:04,833 --> 01:37:06,700
这对你来说是一份重担


1804
01:37:07,233 --> 01:37:09,500
MetalKit可以做
很多事从绘制渲染循环


1805
01:37:09,900 --> 01:37:13,367
到通过交互作用加载3D模型


1806
01:37:13,433 --> 01:37:15,133
主要是同艺术家
I/O模式的交互作用


1807
01:37:15,200 --> 01:37:17,633
事实上
MetalKit可以将网格


1808
01:37:17,700 --> 01:37:19,000
直接输入Metal缓冲器


1809
01:37:19,067 --> 01:37:22,500
运用所能做的去渲染场景


1810
01:37:23,767 --> 01:37:24,700
不仅如此


1811
01:37:25,400 --> 01:37:28,333
Metal着色器是高性能


1812
01:37:28,400 --> 01:37:30,633
图像处理着色器主要
应用于Metal应用程序


1813
01:37:31,167 --> 01:37:34,600
这些都是基于图形处理器的
平行计算着色器


1814
01:37:34,667 --> 01:37:39,500
个别再次转变为
我们的图形处理器使我们更易


1815
01:37:39,800 --> 01:37:41,000
使用Metal


1816
01:37:42,367 --> 01:37:44,200
所以现在 你拥有极佳的
渲染管道


1817
01:37:44,267 --> 01:37:46,267
但也需要丰富的储存信息


1818
01:37:46,767 --> 01:37:48,200
因此我们使用I/O模型


1819
01:37:48,767 --> 01:37:51,400
有时使用3D模型
加载和运行比较难处理


1820
01:37:52,733 --> 01:37:54,000
这都多亏了I/O模型


1821
01:37:54,333 --> 01:37:56,633
简化了内容加载


1822
01:37:56,700 --> 01:38:00,167
使不同文件格式的内容
可直接输入SceneKit


1823
01:38:00,233 --> 01:38:02,833
或通过与MetalKit
交互作用输入到Metal中


1824
01:38:02,900 --> 01:38:05,933
但它将自己区分在于
处理光照的方式


1825
01:38:07,400 --> 01:38:12,433
I/O模型向你提供
最先进光线跟踪的


1826
01:38:15,300 --> 01:38:17,567
材料照明方式


1827
01:38:17,833 --> 01:38:20,867
这意味着
它惊人地提供


1828
01:38:20,933 --> 01:38:21,933
纹理映射


1829
01:38:22,067 --> 01:38:22,900
让我们看一下


1830
01:38:23,267 --> 01:38:24,367
从基线开始


1831
01:38:24,700 --> 01:38:27,233
这仅是一个模型
它是通过纹理载入


1832
01:38:28,067 --> 01:38:29,233
这很难让人感兴趣


1833
01:38:29,300 --> 01:38:30,133
事实上 它比较单调


1834
01:38:30,267 --> 01:38:33,400
我认为九零后
希望重新启用该模型


1835
01:38:33,700 --> 01:38:35,200
如果我们除去纹理


1836
01:38:35,267 --> 01:38:37,433
并应用全球
照明方式


1837
01:38:37,500 --> 01:38:38,367
那么我们看到的


1838
01:38:38,433 --> 01:38:40,133
是那些看起来
十分真实的事物


1839
01:38:41,067 --> 01:38:43,200
我们再将纹理添加进来
就会得到一些


1840
01:38:43,267 --> 01:38:44,267
看起来很棒的东西


1841
01:38:44,467 --> 01:38:47,000
最后 当然
即使使用I/O模型


1842
01:38:47,067 --> 01:38:49,000
以及它的照明方式
你也可以添加自定义照明


1843
01:38:49,067 --> 01:38:52,267
和阴影
使事物看起来更加真实


1844
01:38:52,333 --> 01:38:55,033
你可以得到
一些惊人的结论从普通


1845
01:38:55,400 --> 01:38:58,433
到非凡 I/O模型
可以向你提供卓越的解决方案


1846
01:38:58,800 --> 01:39:00,700dle
帮助你的模型和照明


1847
01:38:58,800 --> 01:39:00,700
帮助你的模型和照明


1848
01:39:01,600 --> 01:39:03,433
所以现在
你拥有极佳的渲染管道


1849
01:39:03,867 --> 01:39:05,533
也有极佳的模型和储存信息


1850
01:39:05,767 --> 01:39:06,833
现在只需好的游戏设置


1851
01:39:07,000 --> 01:39:08,767
因此我们有了
GameplayKit


1852
01:39:09,667 --> 01:39:11,900
游戏设置可分为两个领域


1853
01:39:11,967 --> 01:39:14,800
我们有导航
否则你如何在游戏里移动目标


1854
01:39:15,167 --> 01:39:17,833
我们也有策略
否则游戏如何思考


1855
01:39:17,933 --> 01:39:20,133
GameplayKit
对这两方面都有解决方案


1856
01:39:21,000 --> 01:39:24,300
GameplayKit基于
组件的应用程序界面完全保障


1857
01:39:24,533 --> 01:39:25,700
游戏设置的对策


1858
01:39:25,767 --> 01:39:28,333
不论你是想追踪
其他玩家的黄金


1859
01:39:28,800 --> 01:39:31,433
还是想从甲地到乙地追踪敌人


1860
01:39:31,500 --> 01:39:33,100
并且消除途中的障碍


1861
01:39:33,600 --> 01:39:35,800
就需要生成确定随机数


1862
01:39:35,867 --> 01:39:38,100
以便下次进行在线联机游戏


1863
01:39:38,433 --> 01:39:39,833
游戏设置也为你提供解决方案


1864
01:39:39,900 --> 01:39:42,467
从简单游戏到复杂游戏


1865
01:39:42,700 --> 01:39:44,933
我们认为游戏设置
可以有效地帮助你们


1866
01:39:45,000 --> 01:39:45,933
开发游戏


1867
01:39:48,167 --> 01:39:51,833
我们从社会组成开始
即游戏中心


1868
01:39:52,733 --> 01:39:55,333
ReplayKit可以扩展
到社会交互作用


1869
01:39:55,667 --> 01:39:59,800
ReplayKit允许玩家
录制电视节目重播


1870
01:39:59,867 --> 01:40:00,867
主要针对游戏开放


1871
01:40:01,200 --> 01:40:03,400
他们可以保存或分享录像


1872
01:40:03,700 --> 01:40:06,167
它属于硬件加速具有高性能


1873
01:40:06,900 --> 01:40:09,167
十分便于你们操作


1874
01:40:09,533 --> 01:40:11,800
便于将其添加到游戏中
也许


1875
01:40:11,867 --> 01:40:14,200
它可以开展下一次的
病毒式市场营销活动


1876
01:40:14,567 --> 01:40:15,567
来推广游戏项目


1877
01:40:18,100 --> 01:40:20,233
最后是SceneKit
和SpriteKit


1878
01:40:20,600 --> 01:40:22,400
我们对他们进行了一些伟大的更新


1879
01:40:22,467 --> 01:40:25,000
但我觉得最有趣的
或者说最引人注目的


1880
01:40:25,767 --> 01:40:26,933
是我们创建了一些工具


1881
01:40:27,233 --> 01:40:30,667
可以让SceneKit
和SpriteKit


1882
01:40:30,733 --> 01:40:34,400
直接导入Xcode 7系统
接下来由我的同事


1883
01:40:34,467 --> 01:40:36,000
Jacques Gasselin
de Richebourg


1884
01:40:36,067 --> 01:40:38,933
向你们展示Xcode 7
内部工具


1885
01:40:46,567 --> 01:40:49,467
去年的Xcode 6系统
我们引进了视觉场景编辑


1886
01:40:49,533 --> 01:40:51,833
添加进Xcode 系统的
SpriteKit


1887
01:40:51,900 --> 01:40:53,300
今年 我们引进了一个缺口


1888
01:40:53,567 --> 01:40:56,500
并将动画编辑
添加进Xcode系统


1889
01:40:56,800 --> 01:40:59,367
所以在这里
我会做一些场景剪切


1890
01:40:59,667 --> 01:41:03,100
你们会看到可爱的红色小熊
他将往前走


1891
01:41:03,167 --> 01:41:05,233
穿过两条峡谷走到另一边


1892
01:41:05,300 --> 01:41:07,267
这些都是基础的动画技术
我在这里呈现一下


1893
01:41:07,633 --> 01:41:11,333
我想要将此分层导入到动画中


1894
01:41:11,767 --> 01:41:13,933
很明显 我们首先让它运行


1895
01:41:14,633 --> 01:41:16,400
接下来 抓取一个动作


1896
01:41:16,533 --> 01:41:18,600
现在
让我们进行最有趣的操作


1897
01:41:18,800 --> 01:41:19,933
这是一个参考行为


1898
01:41:20,367 --> 01:41:22,733
意味着它实际上
储存在另一个文件里


1899
01:41:22,833 --> 01:41:24,833
即
actions.sks文件


1900
01:41:25,333 --> 01:41:28,133
我在这里进行参考
就可以进行排版操作


1901
01:41:28,733 --> 01:41:29,733
所以我打算抓取下来


1902
01:41:30,100 --> 01:41:32,500
当然
这和复制粘贴或一样简单


1903
01:41:33,067 --> 01:41:36,267
我打算多做几次
它就会很自然地附加


1904
01:41:36,667 --> 01:41:37,600
在相同的轨道后


1905
01:41:38,533 --> 01:41:39,967
让我们看一下
接下来


1906
01:41:40,033 --> 01:41:42,567
这次我们使用清除器
所以它是一个时间线


1907
01:41:42,633 --> 01:41:45,500
一个有清除器的时间线
你可以随时预览


1908
01:41:45,567 --> 01:41:47,367
动画的大致模样


1909
01:41:49,267 --> 01:41:52,067
这不仅
是一个极佳的预览工具


1910
01:41:52,333 --> 01:41:53,867
实际上
它也是不错的编辑工具


1911
01:41:54,367 --> 01:41:56,433
你可以注意到他没有跳过峡谷


1912
01:41:56,500 --> 01:41:59,233
这是个问题 我们将进行调整


1913
01:42:00,133 --> 01:42:02,267
让我们想出 他跳跃的好时机


1914
01:42:03,267 --> 01:42:05,067
看起来这里是最好的


1915
01:42:06,000 --> 01:42:07,567
之后
我们要抓取一个移动瞬间


1916
01:42:08,400 --> 01:42:09,800
让他在这里跳跃


1917
01:42:09,867 --> 01:42:11,533
现在
注意是如何抓取时间线的


1918
01:42:12,233 --> 01:42:15,467
好 下面让它
增长100个单元


1919
01:42:16,467 --> 01:42:18,567
再次使用时间线


1920
01:42:19,267 --> 01:42:20,233
计算出顶点值


1921
01:42:20,300 --> 01:42:21,133
大约在这里


1922
01:42:21,200 --> 01:42:23,433
现在看一下持续时间


1923
01:42:24,200 --> 01:42:25,533
好了吗？这很简单


1924
01:42:26,367 --> 01:42:29,200
很明显 当他跳起来
我想让他减速


1925
01:42:29,267 --> 01:42:31,067
这意味着
在一开始 他速度很快


1926
01:42:31,133 --> 01:42:32,700
在顶点时却很慢


1927
01:42:33,267 --> 01:42:35,467
复制 粘贴 反过来


1928
01:42:36,867 --> 01:42:37,700
达到负100


1929
01:42:38,767 --> 01:42:39,867
然后开始加速


1930
01:42:39,933 --> 01:42:42,067
使他能够在顶点停滞


1931
01:42:42,933 --> 01:42:44,333
好 让我们对此净化


1932
01:42:44,867 --> 01:42:46,167
这是抛物线式跳跃


1933
01:42:46,300 --> 01:42:48,833
完美 现在 可以看到
它有点怪异


1934
01:42:48,900 --> 01:42:52,133
如果他在空中停留的话
所以让我们添加一个动画


1935
01:42:52,733 --> 01:42:55,467
注意 我在每个动画顶端
进行分层


1936
01:42:55,567 --> 01:42:57,467
这次我们使用
SpriteKit进行操作


1937
01:42:57,800 --> 01:43:01,933
现在我要抓取
跳跃长度的动画


1938
01:43:02,600 --> 01:43:04,267
进入媒体库


1939
01:43:04,767 --> 01:43:05,900
取出跳跃画面


1940
01:43:06,633 --> 01:43:10,800
过滤掉跳跃
选中它 就可以选中全部


1941
01:43:11,633 --> 01:43:13,567
拖拽 好的


1942
01:43:14,167 --> 01:43:15,267
很好 现在对此净化


1943
01:43:15,700 --> 01:43:16,867
好 一个完美的跳跃


1944
01:43:18,233 --> 01:43:20,167
现在 这里有两个峡谷


1945
01:43:20,233 --> 01:43:21,500
重复两次操作


1946
01:43:21,767 --> 01:43:24,700
最简单的方式
是将此转变为参考


1947
01:43:25,467 --> 01:43:27,400
选中 点击右键


1948
01:43:28,333 --> 01:43:31,433
转变为参考
将此命名为Jump


1949
01:43:32,233 --> 01:43:34,600
储存进
actions.sks文件


1950
01:43:34,767 --> 01:43:35,967
我之前运行过


1951
01:43:36,733 --> 01:43:37,600
好 很好 这就是跳跃


1952
01:43:37,667 --> 01:43:40,900
再次使用清除器
设置另一次跳跃


1953
01:43:41,100 --> 01:43:42,700
参考最大的用途


1954
01:43:43,033 --> 01:43:45,133
是它们在这里出现
直接显示在目标程序库中


1955
01:43:45,433 --> 01:43:47,367
我只需将它拖拽进来


1956
01:43:48,567 --> 01:43:50,433
现在就完成了
我们的最终剪辑画面


1957
01:43:52,200 --> 01:43:53,633
好 跳跃 再跳跃


1958
01:43:54,133 --> 01:43:57,633
很好 好的 谢谢大家


1959
01:44:02,533 --> 01:44:06,233
最棒的一点 对于参考而言
就是它们不仅帮助你


1960
01:44:06,300 --> 01:44:07,800
设置其他场景 还有编码


1961
01:44:08,400 --> 01:44:11,900
接下来这里我们运用Sk操作


1962
01:44:11,967 --> 01:44:13,833
加载相同的操作过程
将它们连接过去


1963
01:44:13,900 --> 01:44:16,900
连接到左右键
以及空格键来跳跃


1964
01:44:17,433 --> 01:44:18,667
让我们操作一下
看一下过程


1965
01:44:20,500 --> 01:44:22,200
现在利用熊猫进行剪辑场景


1966
01:44:22,667 --> 01:44:24,233
完美 现在我来控制它


1967
01:44:24,300 --> 01:44:25,967
看着 左 右


1968
01:44:26,533 --> 01:44:27,500
跳跃


1969
01:44:29,267 --> 01:44:30,267
很简单


1970
01:44:35,567 --> 01:44:37,867
大家都很忙


1971
01:44:38,567 --> 01:44:41,133
所以转化到下一个动画


1972
01:44:42,500 --> 01:44:45,533
对Xcode 7系统不熟悉
我们拥有完整的视觉场景编辑


1973
01:44:45,900 --> 01:44:47,700
运用SceneKit编辑
3D储存信息


1974
01:44:48,933 --> 01:44:51,433
这个编辑程序很像
SpriteKit2D程序


1975
01:44:51,733 --> 01:44:52,567
同样的工作原理


1976
01:44:52,900 --> 01:44:54,300
拖拉
以添加新信息


1977
01:44:55,100 --> 01:44:57,800
也可以使用3D中的调制器
环绕拖动


1978
01:44:58,367 --> 01:44:59,767
对齐到其他事物


1979
01:45:00,267 --> 01:45:01,300
你甚至可以复制


1980
01:45:03,033 --> 01:45:04,433
还有一些物理过程


1981
01:45:04,567 --> 01:45:07,700
以及编辑器内部的动画


1982
01:45:07,767 --> 01:45:10,467
现在我们进行动画绘制


1983
01:45:11,967 --> 01:45:15,167
很好
让我们与此进行交互作用


1984
01:45:16,300 --> 01:45:17,367
播放


1985
01:45:17,433 --> 01:45:21,433
就可以从之前的演示中
看到同样可爱的熊猫


1986
01:45:25,600 --> 01:45:26,467
让我们试一下


1987
01:45:29,133 --> 01:45:31,800
这是一只红色熊猫
而不是狐狸 是一只红色熊猫


1988
01:45:33,133 --> 01:45:35,633
继续操作接下来


1989
01:45:35,700 --> 01:45:37,600
将其与之前的小资料块
进行交互作用


1990
01:45:38,233 --> 01:45:40,333
好 剔除出去


1991
01:45:40,400 --> 01:45:43,967
很好 在这个游戏中
播放这只小红熊


1992
01:45:44,033 --> 01:45:45,700
它正在采摘花朵和珍珠


1993
01:45:48,533 --> 01:45:49,533
很遗憾


1994
01:45:50,500 --> 01:45:52,900
我承诺
在制作过程中不会伤害到熊猫


1995
01:45:56,833 --> 01:45:58,433
这不仅是对现阶段的演示


1996
01:45:58,767 --> 01:46:00,700
实际上 我们在向你展示


1997
01:46:01,200 --> 01:46:02,233
这是个样本


1998
01:46:02,300 --> 01:46:05,233
你可以设计下一个
3D SceneKit游戏


1999
01:46:06,033 --> 01:46:07,667
使用这个编辑器
SceneKit


2000
01:46:07,733 --> 01:46:09,700
以及Xcode7系统
谢谢大家


2001
01:46:09,767 --> 01:46:11,167
接下来
让我们欢迎安德里亚斯


2002
01:46:17,967 --> 01:46:18,800
好的


2003
01:46:18,967 --> 01:46:22,267
让我们快速回顾一下
我们会上讨论过的技术


2004
01:46:23,267 --> 01:46:25,367
今天
我们宣布了OSs的新版本


2005
01:46:25,433 --> 01:46:27,533
新的本地化watchOS
软体开发套件


2006
01:46:28,633 --> 01:46:32,533
该套件含多个新应用程序界面
你可以充分利用


2007
01:46:32,600 --> 01:46:33,767
尤其是在游戏过程中


2008
01:46:34,733 --> 01:46:37,133
新的最优化技术包括应用瘦身


2009
01:46:37,867 --> 01:46:40,467
转换的新版本让软件运行更快


2010
01:46:40,533 --> 01:46:43,167
同时
可以让你编写更有效的代码


2011
01:46:44,133 --> 01:46:46,600
当然
目前Xcode系统的新版本


2012
01:46:46,667 --> 01:46:49,067
具有用户界面记录和检测


2013
01:46:50,333 --> 01:46:52,867
这些技术有利于你下载


2014
01:46:52,933 --> 01:46:56,100
今天下午全球开发者大会
参与者门户上面的内容


2015
01:46:56,833 --> 01:46:58,500
我们希望你可以很快采用它们


2016
01:46:58,567 --> 01:47:01,533
甚至为用户设计
更具创新性的应用


2017
01:47:02,233 --> 01:47:04,367
请继续载入所有素材


2018
01:47:04,433 --> 01:47:05,867
让我们知道你对它的看法


2019
01:47:07,733 --> 01:47:10,933
此外 我们也进行一些创新
在今年 使用飞行试验服务


2020
01:47:11,000 --> 01:47:14,100
从今天开始 你们可以
对应用进行配置


2021
01:47:14,167 --> 01:47:17,400
适用于飞行测试中
iOS 9软件开发工具包


2022
01:47:17,467 --> 01:47:21,500
接下来的几周里我们会继续加
大支持 尤其是对分层应用


2023
01:47:22,033 --> 01:47:25,033
点播资源以及Bitcodes
所以你可以检测自己的应用


2024
01:47:25,100 --> 01:47:28,433
在我们发行iOS 9之前
运用这些新技术


2025
01:47:28,500 --> 01:47:29,333
预计今年下半年


2026
01:47:30,333 --> 01:47:31,167
超过一百个讲座


2027
01:47:31,233 --> 01:47:33,167
超过一百五十个实验室
超过一个apple工程师


2028
01:47:36,900 --> 01:47:39,167
当然 在这里
我们有很多机会去学习


2029
01:47:39,233 --> 01:47:41,267
在会议上讨论的这些技术


2030
01:47:41,333 --> 01:47:43,300
而且 你还可以参加
一百多次会议


2031
01:47:43,800 --> 01:47:46,833
去众多实验室获取项目帮助


2032
01:47:46,900 --> 01:47:48,867
实际上 有一百多名
苹果公司工程师


2033
01:47:48,933 --> 01:47:51,267
在现场回答你的问题


2034
01:47:51,767 --> 01:47:53,300
所以 我希望
你们可以享受此次会议


2035
01:47:53,367 --> 01:47:54,800
并在此周之后
收到你们的回复

