1
00:00:36,937 --> 00:00:39,473
Core Motion中有什么新料


2
00:00:41,408 --> 00:00:43,143
下午好 欢迎大家


3
00:00:44,144 --> 00:00:47,447
我的名字是阿尼尔·卡南加
今天我要讲一讲


4
00:00:47,514 --> 00:00:49,183
Core Motion中有什么新料


5
00:00:49,616 --> 00:00:51,552
我们能讲的事情比较多


6
00:00:51,618 --> 00:00:53,987
不过今天我们主要讲几个关键点


7
00:00:56,056 --> 00:00:59,693
我们会首先谈一谈
Apple Watch


8
00:00:59,760 --> 00:01:02,596
这是我们的一个新的平台
我们会谈谈怎样把你的


9
00:01:02,663 --> 00:01:05,399
Core Motion apps
弄到Apple Watch上


10
00:01:05,999 --> 00:01:07,935
我们也对计步器做了一些


11
00:01:08,001 --> 00:01:10,571
新的变更
其中包括一些新的APIs


12
00:01:12,039 --> 00:01:17,711
我们还会谈一谈高度表
在Phone 6上引入的一个传感器


13
00:01:18,645 --> 00:01:21,982
然后加布里埃尔就会通过一个
以一个非常有趣的方式


14
00:01:22,049 --> 00:01:25,185
使用了Core Motion的
应用程序来给我们做一个演示


15
00:01:25,519 --> 00:01:26,954
我之前已经看过了 非常棒


16
00:01:27,821 --> 00:01:29,289
让我们开始吧


17
00:01:29,656 --> 00:01:31,592
这并不是一个介绍性的会议


18
00:01:32,025 --> 00:01:35,295
不过我们会涵盖非常多的
Core Motion概念 


19
00:01:35,362 --> 00:01:36,363
你也可以跟得上


20
00:01:36,430 --> 00:01:39,800
即使你不是十分熟悉Motion


21
00:01:40,167 --> 00:01:44,905
不过对于那些来到会场的人来说
我们在会议结束后会立即有一个实验室


22
00:01:45,239 --> 00:01:47,140
请带着你的问题来实验室


23
00:01:47,207 --> 00:01:48,976
我们有工程师以及科学家在场


24
00:01:49,743 --> 00:01:52,045
但是如果你没有问题 那就要恭喜你了


25
00:01:52,713 --> 00:01:54,781
不过还是要请你过来


26
00:01:54,848 --> 00:02:00,053
告诉我们在你的apps中是怎样使用
Core Motion 乐意聆听


27
00:02:00,487 --> 00:02:04,291
在Apple developer
上确实也有一些之前的会议


28
00:02:04,358 --> 00:02:08,061
在那些会议中深入探讨了动作感应、


29
00:02:08,127 --> 00:02:09,763
动作活动性以及计步器


30
00:02:09,830 --> 00:02:11,198
所以请你去看看那些会议


31
00:02:11,265 --> 00:02:12,799
让我们开始吧


32
00:02:13,700 --> 00:02:18,639
一段时间以来
动作感应已经在iOS上取得很大进展


33
00:02:18,705 --> 00:02:24,711
先来看个有关它的工作原理的简短概述


34
00:02:24,778 --> 00:02:27,614
这是一个传统的动作感应的结构


35
00:02:27,681 --> 00:02:30,684
你把一些传感器连接到主处理器


36
00:02:31,118 --> 00:02:32,619
就可以很明显地看到它们的缺点


37
00:02:32,686 --> 00:02:34,922
无论你在什么时候想要访问传感器数据


38
00:02:34,988 --> 00:02:37,291
你都必须让主处理器处于活动状态


39
00:02:37,824 --> 00:02:39,893
这会严重制约你可以编写的


40
00:02:39,960 --> 00:02:42,029
应用程序的种类


41
00:02:42,763 --> 00:02:44,598
所以我们认为 我们能够做得更好


42
00:02:44,932 --> 00:02:49,436
从iPhone 5S开始
我们就引入了一颗协处理器


43
00:02:49,503 --> 00:02:51,605
我们称之为M7


44
00:02:51,772 --> 00:02:54,641
是一颗微型处理器 它唯一的工作就是


45
00:02:54,842 --> 00:02:56,577
对动作数据进行处理


46
00:02:56,643 --> 00:02:59,980
这颗处理器可以全天候运行


47
00:03:00,080 --> 00:03:02,382
且只有在真正必须时才会唤醒主处理器


48
00:03:03,183 --> 00:03:06,286
对于用户的电池寿命来说这是好事


49
00:03:06,820 --> 00:03:10,724
我们在iPhone 6上又引入了
M8处理器以及一个新的


50
00:03:10,791 --> 00:03:13,727
传感器即“高度表”


51
00:03:13,794 --> 00:03:17,731
现在在iOS上
动作感应看起来就是这样的


52
00:03:18,732 --> 00:03:20,234
那么它对你来说有什么用呢？


53
00:03:20,467 --> 00:03:22,269
如果你让传感器


54
00:03:22,636 --> 00:03:28,108
实时访问你获得的数据
实时访问原始传感器数据


55
00:03:28,175 --> 00:03:31,512
以及在传感器上构建的功能特性


56
00:03:31,812 --> 00:03:35,048
如能够给你提供设备的高度的设备动作


57
00:03:35,115 --> 00:03:37,784
比如计步器再比如动作活动性


58
00:03:38,051 --> 00:03:42,523
若是在有高度计平台上 还可访问原始


59
00:03:42,589 --> 00:03:47,628
压力、高度变化以及阶梯步级这些数据


60
00:03:48,795 --> 00:03:51,365
这就是来自传感器的实时数据


61
00:03:51,431 --> 00:03:53,600
但是动作协处理器能让你做的


62
00:03:53,667 --> 00:03:55,402
远远不止这些 没错


63
00:03:55,469 --> 00:03:56,770
远远不止这些


64
00:03:56,837 --> 00:03:59,806
你还可以每周七天、每天
二十四小时访问动作活动性


65
00:04:00,073 --> 00:04:02,309
访问计步器 在有高度计的平台上


66
00:04:02,376 --> 00:04:06,213
你还可以每周七天、每天
二十四小时访问阶梯步级


67
00:04:06,280 --> 00:04:11,318
现在在iOS上 你能用动作感应
做的事情就是这些


68
00:04:12,920 --> 00:04:16,523
那么在Apple Watch上
动作感应看起来是什么样呢？


69
00:04:17,057 --> 00:04:20,293
Apple Watch上
面同样也有一颗协处理器


70
00:04:20,827 --> 00:04:22,062
它上面还有一个加速计


71
00:04:22,729 --> 00:04:27,634
这就意味着你同样可以
每周七天、每天二十四小时


72
00:04:28,302 --> 00:04:31,238
访问动作活动性以及计步器
访问除了这两种数据之外


73
00:04:31,305 --> 00:04:32,940
你获得的实时传感器数据


74
00:04:33,340 --> 00:04:35,776
如果你在想 哎呀！
这个看起来这么眼熟


75
00:04:36,043 --> 00:04:37,744
那么Apple Watch上的动作


76
00:04:37,811 --> 00:04:40,747
你看起来也眼熟 你看的没错


77
00:04:41,448 --> 00:04:46,153
iOS上的Core Motion 
APIs在watchOS上也有了


78
00:04:47,187 --> 00:04:51,191
不仅是动作Core Motion 
API iOS和watchOS部分


79
00:04:51,258 --> 00:04:53,660
Core Motion APIs
都表现得一样


80
00:04:53,727 --> 00:04:56,363
我们就是在两个OSs上沿用了


81
00:04:56,430 --> 00:04:58,065
这个特性


82
00:04:59,199 --> 00:05:02,703
不过Watch基本上就是一个
完全不同的平台了


83
00:05:03,270 --> 00:05:05,506
因此当为Watch构建应用程序时


84
00:05:05,572 --> 00:05:09,209
我们需要知道
一些事情从头到尾给你们讲讲


85
00:05:09,877 --> 00:05:11,945
我们先来讲一下动作活动性


86
00:05:12,446 --> 00:05:15,816
动作活动性
可以给我们提供上下文信息 


87
00:05:15,883 --> 00:05:17,417
告诉我们用户正在做什么


88
00:05:17,484 --> 00:05:19,019
可知用户是否正在走路 


89
00:05:19,086 --> 00:05:21,255
是否正在跑步 
是否潜水 是否正在骑车等


90
00:05:21,421 --> 00:05:25,259
你能够获得的等级非常依赖于平台


91
00:05:25,325 --> 00:05:26,894
非常依赖于它的使用方式


92
00:05:27,361 --> 00:05:31,632
这里简单对你能够在watchOS上
得到的状态进行一个总结


93
00:05:32,032 --> 00:05:33,667
你可以注意到 你可以访问


94
00:05:33,734 --> 00:05:36,803
走路、跑步、骑车以及静止状态


95
00:05:37,471 --> 00:05:40,507
这就是Apple Watch
上的动作活动性


96
00:05:42,376 --> 00:05:46,914
开发者早就想要访问传感器本身


97
00:05:47,414 --> 00:05:49,950
提供通过这个熟悉的
CMAccelerometer


98
00:05:50,017 --> 00:05:52,753
API来访问加速计


99
00:05:53,887 --> 00:05:55,856
那些东西都在加速计上


100
00:05:56,190 --> 00:05:58,458
不过因为它是一个不同的平台


101
00:05:58,525 --> 00:06:00,627
我们还是需要记住一些


102
00:06:00,694 --> 00:06:02,229
应该考虑的事


103
00:06:02,629 --> 00:06:06,166
第一点你的app获得的处理时间


104
00:06:06,233 --> 00:06:07,668
可能是有限的


105
00:06:08,268 --> 00:06:10,904
Watch上并没有真正后台处理方式


106
00:06:10,971 --> 00:06:13,106
因此当你的app显示在屏幕上时


107
00:06:13,173 --> 00:06:14,741
你的app就在高速运行了


108
00:06:16,410 --> 00:06:19,313
屏幕可能会因为多种原因关闭


109
00:06:19,379 --> 00:06:20,414
屏幕可能会超时


110
00:06:21,014 --> 00:06:23,183
不过Apple Watch
的屏幕是设计成了


111
00:06:23,250 --> 00:06:25,419
只有当你在看它的时候屏幕才会开启


112
00:06:25,485 --> 00:06:28,021
因此如果你不想看屏幕了


113
00:06:28,188 --> 00:06:30,757
那么屏幕关闭、
屏幕关闭后你的app得不到


114
00:06:30,824 --> 00:06:34,127
处理时间的可能性就非常大


115
00:06:34,294 --> 00:06:36,463
考虑到这些情况


116
00:06:36,530 --> 00:06:38,732
我想要谈一些


117
00:06:38,799 --> 00:06:40,133
最佳实践


118
00:06:40,334 --> 00:06:45,472
首先要把你的app设计成
只有当app在屏幕上显示时


119
00:06:45,539 --> 00:06:46,807
你的app才会期望数据


120
00:06:47,074 --> 00:06:48,809
我知道说起来容易做起来难


121
00:06:48,876 --> 00:06:50,377
不过还是要记住这一点


122
00:06:51,512 --> 00:06:55,549
其次当你访问一个流的时候
访问一个传感器数据流时


123
00:06:55,983 --> 00:07:00,053
你需要确保当你的任务被挂起时


124
00:07:00,487 --> 00:07:04,024
也可以以一种优雅的方式处理你的任务


125
00:07:04,091 --> 00:07:06,627
幸运的是
可以通过NSProcessInfo


126
00:07:06,693 --> 00:07:08,262
来实现这一点


127
00:07:08,762 --> 00:07:11,431
如果你使用这个API
performExpiring


128
00:07:11,532 --> 00:07:14,835
ActivityWithReason
你就可以在这个API中


129
00:07:14,902 --> 00:07:16,970
把你的传感器数据当成一个块来处理


130
00:07:17,437 --> 00:07:20,674
它就会通知你的块通知你你的任务


131
00:07:20,741 --> 00:07:23,477
就要被挂起了
这样你就可以采取适当行动


132
00:07:24,344 --> 00:07:28,182
那是CMAccelerometer
API


133
00:07:29,049 --> 00:07:32,052
不过你们中有人想要的不仅仅是这些


134
00:07:32,119 --> 00:07:35,055
事实上你想要长期访问


135
00:07:35,122 --> 00:07:36,990
传感器数据


136
00:07:37,457 --> 00:07:39,092
今天我很高兴地告诉大家


137
00:07:39,826 --> 00:07:41,695
有史以来第一次 我们开始提供访问


138
00:07:41,762 --> 00:07:45,999
历史传感器数据 历史加速计数据


139
00:07:47,100 --> 00:07:49,436
那么你现在可以拿它做什么？


140
00:07:49,770 --> 00:07:53,807
它允许你访问很长一段时间内的数据


141
00:07:54,074 --> 00:07:55,242
相当长一段时间


142
00:07:55,976 --> 00:07:57,845
你也可以访问这个数据


143
00:07:58,045 --> 00:07:59,880
即使你的app不是处于运行状态


144
00:08:01,348 --> 00:08:06,653
这样的话 你就可以在这个长长的


145
00:08:06,720 --> 00:08:09,289
传感器数据流上运行你自己的定制算法


146
00:08:09,723 --> 00:08:11,124
这很酷 我们也期待你们用它


147
00:08:11,191 --> 00:08:12,593
来开发出很酷的apps


148
00:08:13,093 --> 00:08:14,428
那么你应该怎么用它呢？


149
00:08:14,795 --> 00:08:17,764
我们有一个新的API叫做
CMSensorRecorder


150
00:08:18,332 --> 00:08:22,803
这个API允许
初始化历史传感器数据录制


151
00:08:23,070 --> 00:08:29,109
记住这点此API和其他的APIs
一个很重要的不同之处


152
00:08:29,176 --> 00:08:31,845
比如计步器以及动作活动性


153
00:08:32,246 --> 00:08:35,015
其他的APIs
并不需要你初始化任何录制


154
00:08:35,749 --> 00:08:38,919
对SensorRecorder说
你确实需要对它进行初始化


155
00:08:39,419 --> 00:08:42,523
数据录制的频率是五十赫兹


156
00:08:42,823 --> 00:08:45,626
你最多可以录制三天的数据


157
00:08:46,994 --> 00:08:50,931
这就是SensorRecorder
的使用方式


158
00:08:51,565 --> 00:08:54,601
提到执行 我们应该这样做


159
00:08:54,735 --> 00:08:58,272
你首先要通过初始化
recordAccelerometerDataFor


160
00:08:58,338 --> 00:09:01,742
录制数据 然后要提供一个


161
00:09:02,075 --> 00:09:03,510
持续时间


162
00:09:04,211 --> 00:09:07,314
一旦你完成这一步
设备可能就会进入睡眠状态


163
00:09:07,681 --> 00:09:09,283
你的app可能会被挂起


164
00:09:09,483 --> 00:09:10,651
没关系


165
00:09:10,717 --> 00:09:14,388
之后 用户可能会回来
并且启动你的app


166
00:09:15,389 --> 00:09:18,792
当用户启动你的app时
你就可以决定是否查询传感器数据


167
00:09:19,826 --> 00:09:23,597
通过查询
accelerometerDataFrom


168
00:09:23,664 --> 00:09:25,799
当然你还需要指定一个时间段


169
00:09:27,801 --> 00:09:30,137
然后指定的时间段的加速计的数据


170
00:09:30,504 --> 00:09:32,739
就会返回回来


171
00:09:32,806 --> 00:09:35,242
很明显 这个时间段可以是


172
00:09:35,742 --> 00:09:37,744
你录制数据的时间的一个子集


173
00:09:38,645 --> 00:09:42,249
好的 数据会被作为一个


174
00:09:42,316 --> 00:09:45,185
CMAccelerometerData
对象序列返回回来


175
00:09:46,987 --> 00:09:49,556
回想一下 我们提到过的


176
00:09:49,623 --> 00:09:52,159
关于优雅地处理任务挂起的内容


177
00:09:52,226 --> 00:09:54,294
你在这里也会遇到同样的问题


178
00:09:54,828 --> 00:09:57,798
因此 当你处理这个很大的


179
00:09:57,865 --> 00:09:59,399
历史数据流的时候


180
00:09:59,867 --> 00:10:03,403
你就需要访问我们的老朋友
NSProcessInfo


181
00:10:04,271 --> 00:10:09,142
当你的任务就要被挂起时它会通知给你


182
00:10:11,144 --> 00:10:12,946
如果你看一下加速计数据对象


183
00:10:13,013 --> 00:10:16,683
它里面不仅包括了你熟悉的加速度部分


184
00:10:17,117 --> 00:10:20,988
而且还包括了一个startDate
你就可以把这个它当做一个定位器


185
00:10:21,455 --> 00:10:24,525
你可以从这个点
开始确保下次你的app启动时


186
00:10:25,225 --> 00:10:26,760
向前进行查询


187
00:10:27,528 --> 00:10:30,264
这就是SensorRecorder
的工作原理


188
00:10:30,998 --> 00:10:34,701
这个很棒 不过正如你看到的
那里有一项需要考虑的事


189
00:10:35,169 --> 00:10:36,870
不是 是两项功率与性能


190
00:10:37,404 --> 00:10:39,873
SensorRecorder
是一个强大的API


191
00:10:39,940 --> 00:10:42,743
但是能力越大 危险性也就越大


192
00:10:42,809 --> 00:10:46,980
这里的危险性就在于
你可能没有足够的时间


193
00:10:47,047 --> 00:10:49,283
来处理传感器数据的大量的字符串


194
00:10:49,850 --> 00:10:52,486
因此我再介绍几个最佳做法


195
00:10:53,020 --> 00:10:57,224
首先是 仅仅录制 查询你的app


196
00:10:57,758 --> 00:11:00,928
需要用到的最短持续时间内的数据


197
00:11:00,994 --> 00:11:04,097
如果app是一款锻炼身体
你大概就不需要十二个小时的数据


198
00:11:04,164 --> 00:11:06,934
你大概需要几个小时的数据就够了


199
00:11:07,000 --> 00:11:09,570
你查询的数据量越少


200
00:11:09,636 --> 00:11:11,605
你的app就越能容易地获取、处理


201
00:11:12,940 --> 00:11:15,976
此外你也应该知道
传感器数据传输率的要求


202
00:11:16,410 --> 00:11:18,579
数据是以五十赫兹的频率提供给你的


203
00:11:19,012 --> 00:11:21,882
但是除非你想要从那些数据中
抽取出特性、需要更高的


204
00:11:22,082 --> 00:11:25,919
传感器数据传输率
那么你最好丢弃一些数据


205
00:11:26,253 --> 00:11:28,222
处理较少的数据


206
00:11:28,288 --> 00:11:30,824
只要采用几项最佳做法
你应该就没问题了


207
00:11:32,659 --> 00:11:35,896
Apple Watch上Core 
Motion的情况就是这些


208
00:11:36,396 --> 00:11:39,600
你已经看过了
我们有很多看起来眼熟的APIs


209
00:11:39,900 --> 00:11:43,237
我们也可以访问历史传感器数据


210
00:11:43,770 --> 00:11:45,105
这个很棒 你们应该可以用它


211
00:11:45,172 --> 00:11:46,940
来开发出很酷的应用程序


212
00:11:47,407 --> 00:11:49,476
提到编写Watch应用程序


213
00:11:49,543 --> 00:11:51,612
我们今天上午确实举办了一个会议


214
00:11:51,979 --> 00:11:53,313
现在就可以看到会议视频了


215
00:11:55,182 --> 00:11:58,218
会议剩余的时间里
我想重点关注iOS 我先来讲讲


216
00:11:58,285 --> 00:11:59,953
计步器上有什么新情况


217
00:12:01,221 --> 00:12:04,191
这就是你属性的计步器


218
00:12:04,424 --> 00:12:05,859
步数、距离


219
00:12:06,627 --> 00:12:07,594
我们来快速回顾下


220
00:12:08,095 --> 00:12:10,063
计步器的设计理念


221
00:12:10,130 --> 00:12:13,600
是持续给你
提供身体各个部位的行为表现


222
00:12:13,667 --> 00:12:16,170
无论是放在你的手中
还是放到你的口袋里


223
00:12:16,270 --> 00:12:18,672
计步器的性能应该是一致的


224
00:12:19,139 --> 00:12:22,509
即使速度不同
计步器的性能也应该是一致的


225
00:12:23,443 --> 00:12:25,946
计步器的一个很棒的特性是


226
00:12:26,013 --> 00:12:27,915
它会适应用户


227
00:12:28,182 --> 00:12:31,485
因此使用计步器的用户人数越多
那么通过自身的校正


228
00:12:31,552 --> 00:12:33,654
它就能更好地理解用户


229
00:12:35,155 --> 00:12:38,559
在iOS 9上我们对计步器
做了一个很大的改进


230
00:12:38,625 --> 00:12:42,462
让它尽可能地合并了GPS


231
00:12:43,730 --> 00:12:44,932
我们为什么要这么做？


232
00:12:45,465 --> 00:12:47,734
原因在于你的app可能


233
00:12:47,835 --> 00:12:50,070
已经订阅了用户的位置


234
00:12:50,137 --> 00:12:52,506
你可能想要在用户进行跑步的时候


235
00:12:52,573 --> 00:12:53,473
绘制用户的运动轨迹


236
00:12:54,208 --> 00:12:56,877
当你这么做的时候计步器检测到


237
00:12:56,944 --> 00:12:58,512
GPS数据可以用了


238
00:12:58,879 --> 00:13:00,981
通过使用GPS数据
就可以让轨迹绘制的更精确


239
00:13:02,850 --> 00:13:05,285
为什么这一点如此关键呢？


240
00:13:05,586 --> 00:13:09,656
看看这个 
这是我的一位同事在旧金山跑的一次步


241
00:13:09,990 --> 00:13:11,491
旧金山是一座“城市峡谷”


242
00:13:11,558 --> 00:13:15,295
有很高的建筑物对任何GPS来说


243
00:13:15,362 --> 00:13:16,730
环境都富有挑战性


244
00:13:17,397 --> 00:13:18,932
如果你看看这里的这一段


245
00:13:19,600 --> 00:13:22,369
GPS在这里看起来非常靠谱


246
00:13:22,603 --> 00:13:27,274
如果你依赖于GPS
我们就可以对距离进行很好的估测


247
00:13:28,041 --> 00:13:28,909
很好


248
00:13:29,843 --> 00:13:31,478
但是如果你再看这里不同的段


249
00:13:31,545 --> 00:13:34,915
你就会发现在用户的轨迹中用户在闲逛


250
00:13:35,382 --> 00:13:38,118
一路上有好几个酒吧 所以...


251
00:13:38,185 --> 00:13:42,289
但是这可能
并不是这位用户真实的跑步轨迹


252
00:13:42,890 --> 00:13:44,324
所以说


253
00:13:44,725 --> 00:13:47,561
计步器非常聪明 它知道在这里


254
00:13:47,995 --> 00:13:50,531
它就不应该继续依赖GPS了


255
00:13:50,931 --> 00:13:53,400
它应该继续借助于自身的基于步幅的


256
00:13:53,467 --> 00:13:54,468
距离估计


257
00:13:54,768 --> 00:13:59,173
如果你使用了计步器
那么你得到的最终结果


258
00:13:59,306 --> 00:14:02,910
就非常一致
这也就是为什么你应该使用


259
00:14:03,911 --> 00:14:05,479
计步器的步数和距离的原因


260
00:14:08,949 --> 00:14:13,420
今年我们对计步器的API
做了一个很大的改进


261
00:14:14,321 --> 00:14:15,255
在我们开始之前


262
00:14:15,322 --> 00:14:17,991
我们先来回顾一个
你们已经知道的特性 这是层数计数


263
00:14:18,559 --> 00:14:21,128
层数计数有
floorsAscended


264
00:14:21,195 --> 00:14:23,063
还有floorsDescended


265
00:14:23,664 --> 00:14:25,599
因为这是计步器的一部分


266
00:14:25,999 --> 00:14:28,335
这就是一个徒步功能 你必须实际迈步


267
00:14:28,402 --> 00:14:29,736
才能把它用起来


268
00:14:30,237 --> 00:14:33,674
也就是说 你需要在这里


269
00:14:33,907 --> 00:14:36,376
赢取授予的层数


270
00:14:37,744 --> 00:14:40,314
让我们更深入地看看 
它到底是如何工作的


271
00:14:41,481 --> 00:14:42,749
它有几项要求


272
00:14:43,383 --> 00:14:46,353
首先是 最低提升速率要求


273
00:14:47,221 --> 00:14:49,590
还有一个步数要求


274
00:14:50,090 --> 00:14:54,394
它们对我们意味着
假如说 如果你进行了一次远足


275
00:14:54,461 --> 00:14:55,562
并且你走的很慢


276
00:14:55,629 --> 00:14:58,465
那么最终你积累的高度就会很多


277
00:14:59,733 --> 00:15:03,537
但是你很有可能达不到提升速率要求


278
00:15:03,604 --> 00:15:04,938
我们就不会授予你层数


279
00:15:05,873 --> 00:15:08,942
但是如果你是在旧金山散步
有一些非常陡峭的丘陵


280
00:15:09,009 --> 00:15:12,746
那么你就有可能达到一些层数


281
00:15:14,147 --> 00:15:16,350
因为步速要求 如果你使用了电梯


282
00:15:17,251 --> 00:15:20,354
或者自动扶梯


283
00:15:20,821 --> 00:15:22,689
你就不大可能会被授予层数


284
00:15:22,789 --> 00:15:25,626
这就是iOS上层数计数的工作原理


285
00:15:28,095 --> 00:15:29,396
现在轮到新的API了


286
00:15:30,264 --> 00:15:32,299
这是“步幅”


287
00:15:33,133 --> 00:15:36,370
长期以来
开发者就要求我们提供“步幅”


288
00:15:36,803 --> 00:15:38,172
我们很高兴现在能提供了


289
00:15:39,039 --> 00:15:42,676
当我们提起“步幅”
我们指的是currentPace


290
00:15:43,210 --> 00:15:45,279
这实际上是瞬时步幅


291
00:15:45,345 --> 00:15:48,148
而不是在跑步一开始就估算出来的步幅


292
00:15:48,882 --> 00:15:52,619
“步幅”是以时间单位内
通过的距离来表示的


293
00:15:53,387 --> 00:15:57,724
如果你想问为什么这样表示
而不是时间单位内的速度


294
00:15:57,824 --> 00:15:59,660
你知道 因为对于跑步者来说


295
00:16:00,194 --> 00:16:03,330
步幅通常
可以被类推为走完一个已知的距离


296
00:16:03,397 --> 00:16:04,932
需要的实际时间


297
00:16:06,200 --> 00:16:08,435
在网站上关注了
Apple Watch的更新情况


298
00:16:08,502 --> 00:16:11,038
那么这个步幅
你看起来就可能很眼熟


299
00:16:12,072 --> 00:16:13,807
这就让我有点 妒忌了


300
00:16:17,211 --> 00:16:18,645
计步器既有实时数据


301
00:16:18,712 --> 00:16:21,648
又有历史数据
但是“步幅”是只有你在进行


302
00:16:21,715 --> 00:16:23,283
实时查询时才有的


303
00:16:23,951 --> 00:16:25,419
别忘了这一点


304
00:16:25,886 --> 00:16:27,821
我们为什么要提供“步幅”？


305
00:16:27,888 --> 00:16:31,425
毕竟我们已经在计步器上
提供了距离和一个时间概念


306
00:16:31,491 --> 00:16:35,596
因此我们可以很容易地计算出步幅


307
00:16:36,363 --> 00:16:38,999
这样得出的步幅健壮性更高


308
00:16:39,800 --> 00:16:42,069
假如说你想要有所区别


309
00:16:42,135 --> 00:16:45,172
想从那些距离组块中估算出步幅


310
00:16:45,806 --> 00:16:49,977
也会向步幅中引入一个可接受的抖动量


311
00:16:50,777 --> 00:16:54,481
计步器就可以对此进行处理 


312
00:16:54,548 --> 00:16:57,117
确保步幅的估算是平滑的


313
00:16:59,453 --> 00:17:02,289
此外你还可以通过回顾历史组块


314
00:17:02,356 --> 00:17:05,726
然后算出步幅的平均数这一方法


315
00:17:05,791 --> 00:17:07,560
尝试获得平滑的步幅


316
00:17:07,627 --> 00:17:11,665
不过你这样做的代价就是
如果用户步幅发生了改变


317
00:17:11,732 --> 00:17:14,701
你就无法很快做出响应


318
00:17:15,169 --> 00:17:18,805
通过CMPedometer得出步幅
能够对变更很快做出响应


319
00:17:18,872 --> 00:17:20,574
响应性也很高


320
00:17:21,508 --> 00:17:24,411
因此平滑性和响应性就
你应该通过CMPedometer


321
00:17:25,012 --> 00:17:26,413
使用步幅的理由所在


322
00:17:27,481 --> 00:17:28,849
这是步幅


323
00:17:28,916 --> 00:17:33,754
步幅有个“近亲”叫做“步调”


324
00:17:34,488 --> 00:17:37,124
我们现在在计步器上有了步调


325
00:17:37,858 --> 00:17:39,426
那么什么是“步调”？


326
00:17:39,493 --> 00:17:43,130
步调指的是你的步行速率
或者换其他话来说


327
00:17:43,197 --> 00:17:46,300
就是你的脚接触地面的频率


328
00:17:46,800 --> 00:17:49,636
对于跑步者来说步调非常重要


329
00:17:49,736 --> 00:17:51,538
现在你就能直接通过计步器


330
00:17:51,605 --> 00:17:53,974
在你的apps内提供步调了


331
00:17:56,076 --> 00:17:56,944
是的！


332
00:17:57,010 --> 00:18:01,315
我们对计步器做的变更就这些


333
00:18:01,381 --> 00:18:05,586
这里快速看看各个平台内的特性


334
00:18:05,652 --> 00:18:08,422
注意看
Apple Watch上也可以用


335
00:18:08,488 --> 00:18:09,590
计步器了


336
00:18:10,991 --> 00:18:13,093
我们接着来谈谈压力感应


337
00:18:13,861 --> 00:18:17,531
通过高度表传感器可以获得压力数据


338
00:18:18,198 --> 00:18:21,602
这是CMAltimeter API
的一个组成部分


339
00:18:21,869 --> 00:18:23,437
它给你提供了两样东西


340
00:18:23,504 --> 00:18:25,873
第一样是原始压力数据
这就是传感器自身获得的压力


341
00:18:25,939 --> 00:18:29,076
然后进行过滤后的数据


342
00:18:29,309 --> 00:18:31,778
第二样就是相对高度


343
00:18:32,246 --> 00:18:34,047
我们来深入谈谈高度


344
00:18:35,315 --> 00:18:37,351
当我们说到“相对”我们指的是相对


345
00:18:37,417 --> 00:18:39,253
提供的第一个样本而言的


346
00:18:40,254 --> 00:18:42,923
这就意味着 你从高度表上获得的


347
00:18:43,156 --> 00:18:47,528
第一个样本的相对高度为零


348
00:18:47,995 --> 00:18:51,231
后续的样本都会以此为基线


349
00:18:53,567 --> 00:18:56,069
那么要使用高度表
我们需要知道些什么呢？


350
00:18:56,603 --> 00:19:02,910
对于层级的变更来说
高度表再合适不过了


351
00:19:02,976 --> 00:19:05,245
而对于人体层级的变更来说
高度表就差强人意了


352
00:19:05,679 --> 00:19:07,648
因此也许你不应该使用高度表来感知


353
00:19:07,714 --> 00:19:09,449
用户是否抬起了他们的胳膊


354
00:19:09,516 --> 00:19:11,185
差错会让你失望的


355
00:19:12,286 --> 00:19:14,555
对于传感器来说
这些情况都非常具有挑战性


356
00:19:14,621 --> 00:19:15,989
这一点不要忘了


357
00:19:16,990 --> 00:19:18,792
其中一项是环境


358
00:19:19,526 --> 00:19:22,529
即使位置不变 
环境也可能随着时间推移发生改变


359
00:19:22,596 --> 00:19:25,232
这样就会让你误以为高度发生了变化


360
00:19:25,899 --> 00:19:28,702
举例来说 旧金山最近的冷锋


361
00:19:28,769 --> 00:19:31,038
就可以让压力发生很大的变化


362
00:19:31,138 --> 00:19:33,073
足以让我们以为
你的高度发生了变化


363
00:19:33,140 --> 00:19:35,142
比如说变化了十五米


364
00:19:35,642 --> 00:19:37,578
建议你不要长时间使用


365
00:19:37,644 --> 00:19:39,680
传感器


366
00:19:41,415 --> 00:19:44,818
你的设备所处的外套也可以影响到压力


367
00:19:44,885 --> 00:19:48,822
如果你给你的
手机使用了刚性密封防水外套


368
00:19:49,189 --> 00:19:50,924
那么你就指望不上压力传感器了


369
00:19:53,060 --> 00:19:56,196
说到API的使用
对你来说它应该很眼熟


370
00:19:56,263 --> 00:19:59,433
API可以给你提供压力和高度


371
00:20:00,000 --> 00:20:03,337
你访问这个传感器的速度能有多快呢？


372
00:20:04,071 --> 00:20:07,574
当你第一次进行请求时
第一个样本需要大约


373
00:20:08,242 --> 00:20:09,910
二点六秒可以得出来


374
00:20:10,177 --> 00:20:13,914
之后的每次样本以步调的形式出现
用时一点三秒


375
00:20:14,214 --> 00:20:16,984
你从高度表上获取数据的速度就这么快


376
00:20:18,752 --> 00:20:25,425
总结一下
Core Motion已经出现在了


377
00:20:25,492 --> 00:20:27,194
多个平台上


378
00:20:27,261 --> 00:20:29,329
iPads上有了 
iPhones有了


379
00:20:29,630 --> 00:20:31,265
Apple Watch上也有了


380
00:20:31,331 --> 00:20:33,200
在Apple Watch
上提供不只那些


381
00:20:33,267 --> 00:20:37,571
看起来眼熟的APIs
我们还提供历史传感器数据


382
00:20:38,205 --> 00:20:41,275
计步器自身也有了一大堆很酷的更新


383
00:20:41,341 --> 00:20:46,480
它的精确度更高了
并且有了两个新的APIs


384
00:20:46,547 --> 00:20:48,215
即步幅和步调


385
00:20:48,282 --> 00:20:51,385
计步器现在是个多面手了
对于你的健身apps来说


386
00:20:51,451 --> 00:20:53,120
这是个好消息


387
00:20:54,221 --> 00:20:56,657
从传统意义上说
Core Motion已经被用于


388
00:20:57,024 --> 00:20:59,359
游戏、手势以及健身


389
00:20:59,426 --> 00:21:02,296
对于Core Motion来说
可用的应用程序有很多


390
00:21:02,696 --> 00:21:08,068
Core Motion也可以被用来
曾强其它的apps的智能


391
00:21:08,402 --> 00:21:12,105
我要把加布里埃尔请上来
请他给你们解释下这个概念


392
00:21:21,381 --> 00:21:22,449
大家好


393
00:21:23,350 --> 00:21:25,085
能到这里我感到十分激动


394
00:21:25,819 --> 00:21:29,089
作为一名开发者 
我之前从未参加过苹果全球开发者大会


395
00:21:29,890 --> 00:21:32,726
但是无论我在哪里工作
我总是在六月份的第一周内


396
00:21:32,993 --> 00:21:37,364
在家里用电脑观看全部会议视频


397
00:21:38,432 --> 00:21:39,933
我了解到了很多信息


398
00:21:40,000 --> 00:21:42,336
但是其中让我头疼的是


399
00:21:42,503 --> 00:21:43,871
信息量太大了


400
00:21:44,805 --> 00:21:48,609
即使在一个会议视频中
要吸收的东西也太多了


401
00:21:48,876 --> 00:21:51,311
当你看完后
你可能把过去的一小时内


402
00:21:51,378 --> 00:21:53,180
学到的东西全都忘光


403
00:21:54,481 --> 00:21:57,317
我在这里要做的
就是把阿尼尔刚刚向你们


404
00:21:57,384 --> 00:21:59,019
提到的事情拿出来


405
00:21:59,553 --> 00:22:01,788
看看你们到底想在你们的
应用程序中把它们用起来


406
00:22:01,855 --> 00:22:04,591
希望能让你记住这些东西


407
00:22:06,293 --> 00:22:10,464
Core Motion非常棒
因为它不仅能够用于


408
00:22:10,531 --> 00:22:12,866
健身语境或者游戏语境


409
00:22:13,433 --> 00:22:16,603
今天我要向你们展示的
是不管你的app属于


410
00:22:16,970 --> 00:22:18,906
什么类别 你都可以把它用起来


411
00:22:20,507 --> 00:22:22,409
Core Motion
能怎样为你效劳呢？


412
00:22:24,077 --> 00:22:27,748
Core Motion
允许你检测用户正在做的事情


413
00:22:29,049 --> 00:22:31,385
你可以知道用户是否正坐在他们的车里


414
00:22:31,652 --> 00:22:34,321
是否在跑步是否在骑自行车


415
00:22:35,022 --> 00:22:37,724
就像我们之前看到的
你可以知道他们的步幅变动


416
00:22:37,791 --> 00:22:39,159
我们可以帮你让它更加平滑


417
00:22:40,127 --> 00:22:42,196
借助这些变动


418
00:22:42,529 --> 00:22:46,400
我们无需给用户发送提示
请他们告诉我们


419
00:22:46,466 --> 00:22:48,202
就可以知道他们所处的语境


420
00:22:48,569 --> 00:22:52,706
这样用户的体验就更加神奇了
我们的apps也就更智能了


421
00:22:54,074 --> 00:22:56,510
其次 我们还能让用户参与进来


422
00:22:57,311 --> 00:23:01,081
因为每隔几秒钟就有更新
我们就可以知道用户的步幅


423
00:23:01,148 --> 00:23:02,449
发生了怎样的变动


424
00:23:02,516 --> 00:23:04,718
我们可以知道
他们高度的发生了怎样的变动


425
00:23:04,785 --> 00:23:08,589
相应地我们可以快速更新
我们的app UI


426
00:23:10,424 --> 00:23:12,359
最后我们还可以“反射返回”


427
00:23:13,460 --> 00:23:15,362
我知道“反射返回”听起来很蹩脚


428
00:23:15,829 --> 00:23:18,432
但是对于Core Motion来说
很棒的一点就在于


429
00:23:18,498 --> 00:23:21,034
通过始终保持它的运行
我们可以让你的app看起来好像


430
00:23:21,101 --> 00:23:24,238
一天二十四小时、
一周七天都在努力工作


431
00:23:24,304 --> 00:23:26,206
实际上工作的是协处理器


432
00:23:27,541 --> 00:23:29,710
我们可以看到过去一周内
你的活动性更新情况


433
00:23:29,776 --> 00:23:32,012
你的计步器更新情况


434
00:23:32,246 --> 00:23:33,447
这一点很赞


435
00:23:35,449 --> 00:23:38,752
我记住了这三点
因此我决定来编写一款


436
00:23:38,819 --> 00:23:40,120
音乐播放器


437
00:23:40,921 --> 00:23:43,857
不是想与Apple
 Music或者类似产品进行竞争


438
00:23:44,291 --> 00:23:47,661
Core Motion怎样可以
让我的app的体验


439
00:23:47,728 --> 00:23:50,264
更加迷人、更有魔力


440
00:23:52,399 --> 00:23:55,969
很多音乐应用程序都有
这个播放列表的概念


441
00:23:56,270 --> 00:23:58,639
我想听到不同的音乐当我在我的车里时


442
00:23:58,705 --> 00:24:02,242
我想听到广播而如果我是在学习或者


443
00:24:02,309 --> 00:24:04,344
正在努力工作
可能就想要听一些古典音乐


444
00:24:04,411 --> 00:24:06,446
锻炼身体时
也有不同的app播放列表


445
00:24:07,381 --> 00:24:10,083
通过检测某个用户正在做什么


446
00:24:10,417 --> 00:24:13,987
我的音乐应用程序就可以
相应地改变我的播放列表


447
00:24:14,121 --> 00:24:15,989
而无需让用户进行选择


448
00:24:16,890 --> 00:24:20,694
类似地我们知道了步幅的变化
我们就可以说


449
00:24:20,761 --> 00:24:24,198
嘿！你正在进行慢跑
可能是因为你刚才跑到太快


450
00:24:24,264 --> 00:24:26,900
并且爬了一座非常高的山
我们就可以给你放一首


451
00:24:26,967 --> 00:24:29,736
让人兴奋的歌曲 让你有一种成就感


452
00:24:29,803 --> 00:24:32,239
或者可以试着与你的步调相匹配


453
00:24:33,674 --> 00:24:35,342
下面就到了“反射”部分


454
00:24:35,876 --> 00:24:37,077
关于“反射”两点很棒


455
00:24:37,144 --> 00:24:39,246
尤其是在我的音乐应用程序


456
00:24:39,313 --> 00:24:40,514
这个语境下


457
00:24:41,882 --> 00:24:45,619
第一件事我可以看看数据
了解用户当前正在做的事情


458
00:24:45,819 --> 00:24:47,554
嘿 你已经有一段时间不跑了


459
00:24:47,888 --> 00:24:50,691
可能你很快就要跑
也可能你想使用我们的


460
00:24:50,757 --> 00:24:52,626
应用程序来跑步


461
00:24:52,826 --> 00:24:54,261
并且听一下你的播放列表


462
00:24:55,128 --> 00:24:57,064
一天结束时 我们想要刺激我们的用户


463
00:24:57,164 --> 00:24:58,332
回到我们的app中来


464
00:24:59,867 --> 00:25:02,469
我想用户可能想要知道他们昨天


465
00:25:03,637 --> 00:25:07,808
在车里听的播放列表是什么
如果我们能实现的话 那就太棒了


466
00:25:08,242 --> 00:25:13,080
通过查看活动性信息
然后把它与我的播放列表信息进行匹配


467
00:25:13,447 --> 00:25:15,115
我就可以把那个信息提供给用户


468
00:25:16,617 --> 00:25:18,986
记住了这三件事


469
00:25:19,419 --> 00:25:22,456
我们来看看我的应用程序
实际是什么样子的


470
00:25:25,459 --> 00:25:27,761
当用户打开app时
我们仅仅想把一个基本的


471
00:25:27,828 --> 00:25:29,563
播放列表展示给他们


472
00:25:29,997 --> 00:25:32,966
对我来说
我现在是站着不动 对吧？


473
00:25:33,333 --> 00:25:35,402
我们来一些低强度的音乐


474
00:25:35,502 --> 00:25:36,470
不要太剧烈


475
00:25:37,571 --> 00:25:39,573
当我们检测到用户正在加速


476
00:25:40,073 --> 00:25:42,009
可能是他们开始进行锻炼了


477
00:25:42,276 --> 00:25:44,011
我们要对播放列表进行变更


478
00:25:44,378 --> 00:25:47,014
给他们一些更加欢快的音乐


479
00:25:48,348 --> 00:25:50,651
就是在这里
app开始与用户接洽起来了


480
00:25:50,717 --> 00:25:53,520
我们看看发生了什么变动
也许是步调发生了变动


481
00:25:53,887 --> 00:25:57,891
也许是高度发生了变动
我们就可以接洽并且跟随


482
00:25:57,958 --> 00:26:01,061
这些变动 这样当用户加速时
我们就可以给他们


483
00:26:01,195 --> 00:26:02,663
一个强度更高的播放列表


484
00:26:04,932 --> 00:26:07,201
然后我们就想要切换环境了


485
00:26:07,267 --> 00:26:10,003
当用户开车时
我就想在他们早晨上班路上


486
00:26:10,070 --> 00:26:14,308
把他们的podcast
或者他们经常听的任何节目


487
00:26:14,374 --> 00:26:15,576
提供给他们


488
00:26:17,644 --> 00:26:21,081
这是“检测”部分
以及“接洽”部分


489
00:26:21,582 --> 00:26:23,483
接下来是“反射”部分


490
00:26:24,651 --> 00:26:27,855
我想把这个信息分成几个有趣的部分


491
00:26:27,921 --> 00:26:30,524
这样用户就可以向后滚动
看看他们的“历史”


492
00:26:30,824 --> 00:26:33,594
我可能想把这个与用户在不同时刻听的


493
00:26:33,660 --> 00:26:36,063
播放列表连接起来


494
00:26:38,298 --> 00:26:41,702
既然我们已经知道了
app会是什么样子的


495
00:26:42,202 --> 00:26:44,872
我们再来看看动作活动性的实际应用


496
00:26:45,272 --> 00:26:48,642
看看要实现这些功能
我们需要什么样的APIs


497
00:26:51,445 --> 00:26:53,080
首先我们有“检测”部分


498
00:26:53,146 --> 00:26:56,149
这个部分是我们希望能够一直运行的


499
00:26:56,683 --> 00:26:59,753
我们想知道用户是否正在开车


500
00:26:59,820 --> 00:27:02,823
用户是否正在走路
用户走路的速度有多快


501
00:27:03,323 --> 00:27:04,825
那么以此我们需要什么？


502
00:27:05,959 --> 00:27:08,295
活动性更新情况以及计步器更新情况


503
00:27:08,729 --> 00:27:12,299
我们想要监控这些情况 让它们更平滑


504
00:27:12,666 --> 00:27:16,737
看看哪个信息可以使得我们判定语境


505
00:27:18,405 --> 00:27:20,307
其次我们有那个“接洽”部分


506
00:27:21,241 --> 00:27:24,144
如果用户正在走路或者跑步对于我来说


507
00:27:24,478 --> 00:27:26,580
我想知道他们的速度有多快


508
00:27:26,847 --> 00:27:31,118
看看步调 我就可以知道他们是否


509
00:27:31,185 --> 00:27:35,222
爬了一座高大的丘陵
这样我就可以给他们播放一首


510
00:27:35,289 --> 00:27:36,690
欢快的歌来庆祝他们的成就


511
00:27:36,957 --> 00:27:39,526
为此 我需要计步器更新情况


512
00:27:39,593 --> 00:27:42,229
这些情况里面包括步幅、步调的变更


513
00:27:42,663 --> 00:27:44,131
以及高度更新情况


514
00:27:45,933 --> 00:27:47,968
然后我们还有“反射”部分


515
00:27:48,602 --> 00:27:50,704
就像我之前说过
Core Motion很棒的是


516
00:27:50,771 --> 00:27:53,407
它们可以一天二十四小时、
一周七天都为我努力工作


517
00:27:53,974 --> 00:27:57,377
因此我就可以进行回顾
获取那些历史活动性查询


518
00:27:57,678 --> 00:28:02,249
以及计步器查询
然后把这个信息分成几个有趣的部分


519
00:28:05,819 --> 00:28:09,690
既然我已经仔细看了
我的app长什么样


520
00:28:09,756 --> 00:28:12,993
看了“检测”、“接洽”
以及“反射”部分


521
00:28:13,060 --> 00:28:16,363
也知道了我需要使用Core 
Motion哪一部分的APIs


522
00:28:16,730 --> 00:28:18,932
我要向你们展示下
我到底是如何编码的


523
00:28:18,999 --> 00:28:21,401
最起码要让你们看看我的
应用程序的数据模型


524
00:28:23,504 --> 00:28:25,372
我要打开Xcode


525
00:28:26,006 --> 00:28:28,308
但是在我走到这边的电脑之前


526
00:28:28,709 --> 00:28:31,645
先提醒你们一下
屏幕上会出现大量的文本


527
00:28:32,212 --> 00:28:33,780
别被吓跑了


528
00:28:34,081 --> 00:28:37,050
示例代码现在已经放到网上了


529
00:28:37,184 --> 00:28:39,620
现在请勿打开


530
00:28:42,122 --> 00:28:43,223
请仅仅关注


531
00:28:43,290 --> 00:28:45,626
我为你们高亮显示的部分


532
00:28:46,093 --> 00:28:48,262
我之前已经说过了那里会有大量的文本


533
00:28:48,495 --> 00:28:52,299
如果仅看那几个东西然后会议结束后


534
00:28:52,366 --> 00:28:54,401
回去看看示例代码


535
00:28:54,701 --> 00:28:57,504
你就能记住我重点讲的东西
而不是想要


536
00:28:57,571 --> 00:28:59,039
一次做太多的事


537
00:29:00,274 --> 00:29:02,242
我已经说过了 文本会很多提醒过了


538
00:29:02,976 --> 00:29:05,078
就像我说过的
屏幕上有大量的文本


539
00:29:05,379 --> 00:29:08,015
我只想让你们记住三个部分


540
00:29:09,616 --> 00:29:11,952
就是“检测”、“接洽”与“反射”


541
00:29:12,019 --> 00:29:13,520
记住了这些事情那么我要仔细看看


542
00:29:13,587 --> 00:29:16,890
我的应用程序的数据模型中的这些东西


543
00:29:17,324 --> 00:29:21,261
这个就是“数据模型”部分


544
00:29:21,328 --> 00:29:23,197
剩下的部分供你以后自己探索


545
00:29:23,564 --> 00:29:26,400
我要做的第一件事是“检测”


546
00:29:26,533 --> 00:29:29,436
这就要求获得活动性更新情况
以及计步器更新情况


547
00:29:29,503 --> 00:29:31,238
我们来看看这些活动性更新情况


548
00:29:36,009 --> 00:29:37,144
很好 文本很多 是吧？


549
00:29:38,579 --> 00:29:40,914
我要做的第一件事
就是校验下看看这个硬件上


550
00:29:40,981 --> 00:29:43,717
能否使用活动性


551
00:29:44,551 --> 00:29:47,454
就像阿尼尔之前提到的
活动性并不总是可用


552
00:29:47,521 --> 00:29:51,725
因此在我们查询任何更新情况之前
我们需要进行这些校验


553
00:29:53,794 --> 00:29:55,062
我们要做的第二件事是 使用


554
00:29:55,128 --> 00:29:58,165
startActivitiesUpdateToQueue


555
00:29:58,232 --> 00:29:59,733
API


556
00:30:00,033 --> 00:30:03,770
对于我而言
我只是进行了一个简单的NS操作查询


557
00:30:04,838 --> 00:30:06,840
然后我要对数据进行处理


558
00:30:09,209 --> 00:30:12,312
动作活动性就频繁显示出来了


559
00:30:12,880 --> 00:30:15,415
你可以自己决定
怎样对数据进行平滑操作


560
00:30:15,949 --> 00:30:18,986
对于我而言当某个用户跑步时


561
00:30:19,253 --> 00:30:22,155
他们可能会遇到红灯停下
处于半静止的状态


562
00:30:22,523 --> 00:30:24,992
我不想从跑步时的播放列表
转移到非常舒缓的播放列表


563
00:30:25,058 --> 00:30:26,493
然后这样 来来回回


564
00:30:26,560 --> 00:30:27,761
往往复复


565
00:30:28,295 --> 00:30:32,499
所以我想做的是自己指定
应用程序的平滑操作至于你的应用程序


566
00:30:32,566 --> 00:30:34,701
最适合什么样的平滑操作
我就交给你来决定了


567
00:30:36,837 --> 00:30:38,839
让我们再来看看
计步器的更新情况


568
00:30:44,344 --> 00:30:47,848
PedometerUpdates
API看起来也非常眼熟 你看到的


569
00:30:48,415 --> 00:30:51,752
我也要校验下 看看计步是否可用


570
00:30:52,486 --> 00:30:54,955
即使我们假定
活动性可能是可以用的


571
00:30:55,022 --> 00:30:57,491
那也并不意味着计步也同样可用


572
00:30:58,959 --> 00:31:02,362
假定计步真的可用 那么我要
startPedometerUpdates


573
00:31:02,729 --> 00:31:05,766
这个API可以允许我们提供一个日期


574
00:31:06,366 --> 00:31:08,635
如果你所处的是一个更日记化的语境
你可能就想


575
00:31:08,702 --> 00:31:10,704
在你的日期一开始 启动这些更新


576
00:31:10,804 --> 00:31:11,738
就我而言


577
00:31:11,805 --> 00:31:14,808
我想在我的应用程序的
生命周期内看到这些更新


578
00:31:14,942 --> 00:31:16,677
因此我现在就要启动这些更新


579
00:31:19,980 --> 00:31:22,749
有一件非常重要的事情我需要指出


580
00:31:24,318 --> 00:31:25,485
我们可能会收到一个错误


581
00:31:27,821 --> 00:31:33,193
关于Core Motion很棒的是


582
00:31:33,794 --> 00:31:38,098
它们会做出这样的事：喂！是否想让此
app使用为你弹出的活动数据？


583
00:31:39,700 --> 00:31:42,169
但是用户可能会第一次
打开你的应用程序


584
00:31:42,236 --> 00:31:46,473
然后允许你访问活动数据
但是他们可以随时回到


585
00:31:46,940 --> 00:31:49,142
“偏好”中把授权删除


586
00:31:49,743 --> 00:31:52,679
在那种情况下
当你试图接受更新情况时


587
00:31:52,746 --> 00:31:54,548
我们就会抛出一个授权错误


588
00:31:54,848 --> 00:31:57,084
那么你就需要平滑地处理这些问题


589
00:31:57,150 --> 00:32:01,321
提示用户进到应用程序设置中


590
00:32:01,522 --> 00:32:04,758
再次对你的应用程序进行授权


591
00:32:06,860 --> 00:32:10,097
我在这里不去设置中了
但是我会弹出一个简单的UI


592
00:32:10,163 --> 00:32:11,798
提醒视图 提示要去设置


593
00:32:13,367 --> 00:32:14,835
这就是“检测”部分


594
00:32:15,202 --> 00:32:18,472
接下来我要做的就是“接洽”部分


595
00:32:20,140 --> 00:32:23,477
就我而言 当我看到活动性更新时


596
00:32:23,877 --> 00:32:27,247
我还想启动、终止高度表的更新


597
00:32:27,981 --> 00:32:29,349
我要在这里这样做


598
00:32:31,118 --> 00:32:34,421
我进行了平滑处理
看看用户什么时候在跑步或者在步行


599
00:32:34,488 --> 00:32:36,890
在那个例子中
我对高度的更新情况很感兴趣


600
00:32:41,595 --> 00:32:43,363
很好现在你可以在这里看到一个主题了


601
00:32:44,031 --> 00:32:45,299
我要做的第一件事


602
00:32:45,365 --> 00:32:47,434
就是校验下 看看高度更新是否可用


603
00:32:48,569 --> 00:32:50,003
假定它是可用的 我会


604
00:32:50,070 --> 00:32:52,940
startRelativeAltitude
UpdatesToQueue


605
00:32:54,675 --> 00:32:56,310
我创建了一个队列


606
00:32:57,010 --> 00:32:58,846
然后我要对数据进行相应的处理


607
00:32:59,546 --> 00:33:01,648
我再校验一次 看看是否有错误


608
00:33:01,982 --> 00:33:04,384
如果没有错误
那么我要在我的应用程序中把那个数据


609
00:33:04,818 --> 00:33:08,455
当成最优服务来处理
至于你的数据该如何进行


610
00:33:08,755 --> 00:33:10,824
最优服务处理 那由你决定


611
00:33:14,061 --> 00:33:16,430
接下来我要做的就是
因为我对持续的高度更新


612
00:33:16,496 --> 00:33:20,834
不感兴趣 因此要确保当我不是处于


613
00:33:21,068 --> 00:33:22,636
跑步或者走路时把它停掉


614
00:33:29,376 --> 00:33:33,580
很好 在这里这个API非常直接


615
00:33:33,647 --> 00:33:35,082
我校验下可用性


616
00:33:35,282 --> 00:33:38,485
我来
stopRelativeAltitudeUpdates


617
00:33:40,754 --> 00:33:42,623
现在我知道了 
当我说我们想要与用户进行


618
00:33:42,689 --> 00:33:44,525
“接洽”时我们也会同时看到


619
00:33:44,591 --> 00:33:46,193
计步器的更新情况


620
00:33:46,860 --> 00:33:49,796
你可能记得
在我的应用程序的生活周期内


621
00:33:49,863 --> 00:33:52,966
我已经看到了计步器的更新情况 因此


622
00:33:53,033 --> 00:33:54,501
我无需再次启动、停止它们


623
00:33:54,801 --> 00:33:57,871
我可以把这些融合到高度更新中来用


624
00:33:57,971 --> 00:34:01,141
给我提供我的应用程序需要的东西


625
00:34:01,208 --> 00:34:03,043
也就是通过音乐来激励用户


626
00:34:04,811 --> 00:34:06,547
这就是“反射”部分


627
00:34:12,252 --> 00:34:15,755
那么在这里
我要看看活动性的更新情况


628
00:34:15,822 --> 00:34:18,792
以便我以有趣的部分的形式
提供这些东西


629
00:34:18,859 --> 00:34:20,159
就像我之前给你们看的那样


630
00:34:27,234 --> 00:34:30,404
很好 我希望你们看的 第一件事


631
00:34:30,771 --> 00:34:33,172
就是我们可以查询日期后的
所有的活动性的更新情况


632
00:34:33,507 --> 00:34:36,243
就我而言
我想看看过去一周的情况


633
00:34:36,643 --> 00:34:38,779
即使我们不看
那一周的应用程序的使用情况


634
00:34:38,978 --> 00:34:41,315
我们也可以获取所有的数据


635
00:34:41,380 --> 00:34:42,850
然后把它们放到一起


636
00:34:46,719 --> 00:34:49,523
就我而言
我对那个数据进行下处理


637
00:34:49,590 --> 00:34:51,225
让它们为我以有趣的部分的形式显示


638
00:34:51,291 --> 00:34:53,560
我等不及想看看你们自己


639
00:34:53,627 --> 00:34:54,828
会怎么做了


640
00:34:55,495 --> 00:34:57,464
又出现了 我知道唱片损坏了 对吧？


641
00:34:57,931 --> 00:35:00,033
我要对这个错误进行相应的处理


642
00:35:01,468 --> 00:35:04,104
就我而言
一旦我找到有趣的步行片段


643
00:35:04,371 --> 00:35:07,908
我就会给出全部的额外的


644
00:35:07,975 --> 00:35:09,910
历史计步器信息


645
00:35:09,977 --> 00:35:12,479
那么我在这里要做的
我要为某个给定的活动性片段


646
00:35:15,015 --> 00:35:20,621
请求计步器的更新情况


647
00:35:26,527 --> 00:35:29,796
第一件事就是
queryPedometerDataFromDate


648
00:35:29,863 --> 00:35:32,132
我提供了一个开始日期
还提供了一个结束日期


649
00:35:32,199 --> 00:35:35,669
就我而言
我已经把数据放到程序段中了


650
00:35:35,736 --> 00:35:38,539
那么我来看看这些段的开始和结束部分


651
00:35:40,073 --> 00:35:42,176
这里我要指出的第二件事是


652
00:35:43,810 --> 00:35:46,346
如果我想要进行任何UI变更


653
00:35:46,413 --> 00:35:49,149
那么我就需要把这些变更发送到主队列


654
00:35:49,550 --> 00:35:51,051
如果你在你自己的应用程序内


655
00:35:51,118 --> 00:35:53,086
不这么做 那么你就会遇到问题


656
00:35:55,189 --> 00:35:56,590
所以请这么做吧


657
00:35:57,257 --> 00:36:01,895
我要向你们展示的就是这些
想你的应用程序添加活动


658
00:36:02,196 --> 00:36:04,298
总共花了我十分钟左右 因此


659
00:36:04,698 --> 00:36:07,601
当你回去后 
给你的应用程序做同样的事


660
00:36:07,668 --> 00:36:09,303
就是这么容易


661
00:36:10,170 --> 00:36:13,540
现在我真的想让你们看看这个app
但是我不会在这里


662
00:36:13,607 --> 00:36:15,108
跑一圈或者开车


663
00:36:15,442 --> 00:36:18,645
我要向你们看看
过去今天内我的历史数据


664
00:36:18,912 --> 00:36:21,515
让你们看看“反射”部分
是怎样以有趣的图段的形式


665
00:36:21,582 --> 00:36:22,783
来组织数据的


666
00:36:28,455 --> 00:36:30,157
但愿这是一台iPhone


667
00:36:33,660 --> 00:36:36,964
太好了！这是我的音乐活动应用程序


668
00:36:37,731 --> 00:36:39,666
你可以看到
我的活动强度不大


669
00:36:39,733 --> 00:36:41,835
因此 我现在处于低强度模式


670
00:36:43,704 --> 00:36:45,672
现在我再来看看我的历史记录情况


671
00:36:46,874 --> 00:36:49,409
我要从昨天早上开始


672
00:36:49,877 --> 00:36:51,211
让你们看看我一天的情况


673
00:36:51,278 --> 00:36:53,580
我昨天所做的
就是围绕莫斯康走路


674
00:36:55,148 --> 00:36:58,252
昨天我醒来后
我决定快速骑行一段时间


675
00:36:58,852 --> 00:37:02,656
我所做的就是...
app已经搞定了


676
00:37:02,723 --> 00:37:04,791
替我把这些放进了一个有趣的图段


677
00:37:06,159 --> 00:37:10,564
然后我朝着公交车走去
意识到有点晚了


678
00:37:10,631 --> 00:37:14,301
于是就开始跑 最终上了公交车


679
00:37:15,169 --> 00:37:19,439
你可以在这里看到
我在这里的就是步行的图段


680
00:37:19,506 --> 00:37:22,709
有英里信息
有步幅信息


681
00:37:23,076 --> 00:37:25,946
层级上升与下降
这些都替我放进了


682
00:37:26,013 --> 00:37:27,381
那些有趣的组块中


683
00:37:28,215 --> 00:37:30,918
如果我是在某个单元上
实际开发一款音乐应用程序


684
00:37:31,251 --> 00:37:34,555
那么我可能会把
当时我听的播放列表


685
00:37:34,621 --> 00:37:36,456
放到那个图块上


686
00:37:37,958 --> 00:37:41,028
有一件事我要指出 话说今天


687
00:37:41,695 --> 00:37:43,564
当我在莫斯康附近 走路的时候


688
00:37:43,964 --> 00:37:46,700
我没有出现任何层级的上升与下降


689
00:37:47,134 --> 00:37:48,235
这是因为我今天比较懒


690
00:37:48,302 --> 00:37:49,870
到处都乘坐了自动扶梯


691
00:37:50,904 --> 00:37:53,040
我希望你们也注意到了这一点


692
00:37:55,175 --> 00:37:57,211
这就是我的
基础的音乐应用程序


693
00:37:57,945 --> 00:37:59,079
我来总结下


694
00:38:03,217 --> 00:38:05,786
我希望你们喜欢这个演示


695
00:38:06,086 --> 00:38:08,322
我尽量把重点放在少数几个事情上


696
00:38:08,689 --> 00:38:11,325
这样你就可以记住
并且用到你的应用程序上记住


697
00:38:11,992 --> 00:38:15,362
这里有“检测”片段 使用活动来检测


698
00:38:15,429 --> 00:38:17,431
某个用户正在做的事情


699
00:38:17,497 --> 00:38:19,366
而不是让用户告诉你
他们正在做什么事情


700
00:38:20,067 --> 00:38:25,172
通过活动性、计步器、高度表
推送更新与用户进行“接洽”


701
00:38:26,206 --> 00:38:28,475
以及“反射回去”


702
00:38:28,642 --> 00:38:33,247
把那些历史查询智慧地运用起来


703
00:38:34,181 --> 00:38:36,350
如果你有更多的问题


704
00:38:36,817 --> 00:38:38,185
请到“开发者论坛”看一看


705
00:38:38,452 --> 00:38:40,888
请务必看看音乐活动


706
00:38:40,954 --> 00:38:42,723
它应该就在开发者入口处


707
00:38:43,156 --> 00:38:46,126
如果是一般的咨询
请联系我们的福音传道者


708
00:38:47,961 --> 00:38:49,863
此外还有一些会议与本次会议相关


709
00:38:49,963 --> 00:38:51,498
它们也值得你去看看


710
00:38:52,299 --> 00:38:53,967
如果你参加了苹果全球开发者大会


711
00:38:54,334 --> 00:38:56,970
你可能已经看过或者
还没有看过HealthKit演示、


712
00:38:57,037 --> 00:38:58,705
Cocoa Touch演示


713
00:38:59,106 --> 00:39:01,475
如果你错过了这些演示或者你现在在家


714
00:39:01,542 --> 00:39:03,177
那么请去网上看看这些视频


715
00:39:03,610 --> 00:39:05,045
同样 我也希望你们去看看


716
00:39:05,112 --> 00:39:07,447
Core Location的演示


717
00:39:08,982 --> 00:39:12,452
如果你能够真正把活动数据、健康数据


718
00:39:12,653 --> 00:39:16,523
位置数据组合起来
那么你就可以创建一些绝妙的语境


719
00:39:16,590 --> 00:39:18,559
来让你的应用程序更上一层楼


720
00:39:19,026 --> 00:39:21,862
我迫不及待想看看你们会在
App Store上何应用程序


721
00:39:31,738 --> 00:39:33,106
谢谢 太谢谢了

