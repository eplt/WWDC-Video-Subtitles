

1
00:00:00.506 --> 00:00:11.516 A:middle
[ Silence ]

2
00:00:12.016 --> 00:00:16.000 A:middle
[ Applause ]

3
00:00:16.516 --> 00:00:16.986 A:middle
&gt;&gt; Welcome.

4
00:00:18.216 --> 00:00:19.176 A:middle
So I'm Doug Gregor.

5
00:00:19.416 --> 00:00:22.656 A:middle
I'm an engineer on the Swift
Compiler Team, and we're here

6
00:00:22.656 --> 00:00:24.976 A:middle
to talk about Swift
Interoperabiity.

7
00:00:28.626 --> 00:00:30.416 A:middle
We're going to talk about a
couple of different things here.

8
00:00:31.166 --> 00:00:33.986 A:middle
So, of course, Swift is
a new language for Cocoa

9
00:00:33.986 --> 00:00:35.526 A:middle
and Cocoa Touch development.

10
00:00:36.856 --> 00:00:38.746 A:middle
Now, Cocoa's not
written in Swift.

11
00:00:38.746 --> 00:00:41.286 A:middle
It's written in Objective-C,
a language you've been using

12
00:00:41.286 --> 00:00:43.526 A:middle
for years and that all of
your apps are written in.

13
00:00:44.276 --> 00:00:47.036 A:middle
So, interoperability between
these two very different

14
00:00:47.036 --> 00:00:49.626 A:middle
programming languages
is absolutely critical.

15
00:00:50.106 --> 00:00:52.636 A:middle
So we're going to talk about
how that interoperating works

16
00:00:53.076 --> 00:00:54.576 A:middle
at the language level.

17
00:00:55.116 --> 00:00:58.786 A:middle
We're going to hit a number
of different topics today.

18
00:00:59.426 --> 00:01:01.336 A:middle
We're going to talk
about working with Cocoa,

19
00:01:01.436 --> 00:01:06.816 A:middle
seeing how the Cocoa APIs or
Objective-C APIs look and feel

20
00:01:06.816 --> 00:01:09.916 A:middle
in Swift and how to work
with them, as well as working

21
00:01:09.916 --> 00:01:13.786 A:middle
with some more Swift concepts
like dealing with AnyObject

22
00:01:13.786 --> 00:01:17.046 A:middle
and doing dynamic
checks on your types.

23
00:01:18.106 --> 00:01:20.206 A:middle
Then we're going to
talk about bridging

24
00:01:20.526 --> 00:01:24.216 A:middle
of the core Cocoa datatypes
and NSArray, NSDictionary,

25
00:01:24.366 --> 00:01:27.386 A:middle
NSString into their
Swift-native equivalents.

26
00:01:28.616 --> 00:01:30.796 A:middle
Then we'll move on
to subclassing,

27
00:01:30.946 --> 00:01:33.946 A:middle
so writing Swift classes that
subclass from Objective-C

28
00:01:34.186 --> 00:01:36.576 A:middle
and how they're mapped
back into Objective-C

29
00:01:36.856 --> 00:01:38.926 A:middle
so that you can use these
two languages together.

30
00:01:40.156 --> 00:01:42.526 A:middle
And, finally, we're going to
talk about Core Foundation

31
00:01:42.526 --> 00:01:44.316 A:middle
and Core Graphics, and
this general notion

32
00:01:44.316 --> 00:01:48.276 A:middle
of CF Interoperability within
the Swift programming language.

33
00:01:48.806 --> 00:01:53.366 A:middle
Let's get started talking
about working with Cocoa.

34
00:01:55.466 --> 00:01:59.616 A:middle
So Swift provides seamless
access to Objective-C APIs

35
00:01:59.916 --> 00:02:03.166 A:middle
through the Objective-C Module
System we introduced last year.

36
00:02:03.796 --> 00:02:06.986 A:middle
So you can pull your Objective-C
APIs whether they be from Cocoa

37
00:02:06.986 --> 00:02:09.826 A:middle
or your own into
Swift and use them.

38
00:02:10.556 --> 00:02:13.206 A:middle
And then Swift maps
those Objective-C APIs

39
00:02:13.306 --> 00:02:15.126 A:middle
into the Swift syntax.

40
00:02:15.836 --> 00:02:19.186 A:middle
This covers both the objective
parts of Objective-C -

41
00:02:19.306 --> 00:02:21.656 A:middle
the classes, protocols,
methods, and so on,

42
00:02:22.116 --> 00:02:24.856 A:middle
as well as the lower level
C things like functions,

43
00:02:24.856 --> 00:02:26.956 A:middle
enumerations, structs, pointers.

44
00:02:27.456 --> 00:02:29.966 A:middle
So you have access to all
of your Objective-C APIs.

45
00:02:31.456 --> 00:02:33.926 A:middle
Now when you look at one of
these Objective-C APIs in Swift,

46
00:02:34.486 --> 00:02:36.366 A:middle
it's going to be
different from Objective-C.

47
00:02:37.316 --> 00:02:39.286 A:middle
There are inherent
syntactic differences

48
00:02:39.336 --> 00:02:41.346 A:middle
between these two
language, of course.

49
00:02:42.426 --> 00:02:46.506 A:middle
Swift also has some
modern features that we use

50
00:02:46.506 --> 00:02:49.266 A:middle
when expressing those
Objective-C APIs in Swift

51
00:02:49.266 --> 00:02:51.196 A:middle
that will make it look
a little bit different,

52
00:02:51.516 --> 00:02:54.066 A:middle
as well as the bridging
of core Cocoa types

53
00:02:54.316 --> 00:02:55.306 A:middle
that I mentioned earlier.

54
00:02:55.926 --> 00:02:59.486 A:middle
Now, despite all of these
differences that you see

55
00:02:59.486 --> 00:03:02.396 A:middle
when looking at the
APIs, it's still Cocoa,

56
00:03:02.586 --> 00:03:04.006 A:middle
it's still Cocoa Touch.

57
00:03:04.236 --> 00:03:07.366 A:middle
And the same conventions
and idioms still apply,

58
00:03:07.766 --> 00:03:10.166 A:middle
so what you know of
Cocoa works in Swift.

59
00:03:10.206 --> 00:03:11.676 A:middle
It's just a different
programming language

60
00:03:11.766 --> 00:03:14.646 A:middle
for the same great platform,
the same great frameworks.

61
00:03:16.136 --> 00:03:19.356 A:middle
So we're going to walk through
part of something we know

62
00:03:19.356 --> 00:03:22.336 A:middle
and love, and that's
the UIDocument class.

63
00:03:23.736 --> 00:03:26.456 A:middle
Here's a tiny slice
of it in Objective-C.

64
00:03:26.846 --> 00:03:30.706 A:middle
We're going to walk through how
and why that maps into Swift.

65
00:03:31.546 --> 00:03:35.656 A:middle
First thing, something simple, a
property: fileModificationDate.

66
00:03:35.656 --> 00:03:36.596 A:middle
It is an NSDate!.

67
00:03:37.826 --> 00:03:40.756 A:middle
This comes into Swift
as a property.

68
00:03:40.986 --> 00:03:41.956 A:middle
It's the var keyword.

69
00:03:42.536 --> 00:03:45.536 A:middle
The NSDate class, of course
just comes into Swift.

70
00:03:45.536 --> 00:03:47.346 A:middle
Nothing interesting there except

71
00:03:47.346 --> 00:03:50.396 A:middle
for this little exclamation
point that you may have noticed.

72
00:03:50.896 --> 00:03:55.966 A:middle
Now that exclamation point is an
Implicitly Unwrapped Optional.

73
00:03:56.486 --> 00:03:58.846 A:middle
What does that mean?

74
00:03:59.156 --> 00:04:01.456 A:middle
Well, let's look at
Swift in Objective-C.

75
00:04:01.456 --> 00:04:03.946 A:middle
They're different languages with
some different ideas in them.

76
00:04:04.456 --> 00:04:06.616 A:middle
So in Swift, when
you have a value

77
00:04:06.616 --> 00:04:09.366 A:middle
of class type, so
I have an NSDate!

78
00:04:09.866 --> 00:04:11.746 A:middle
That can never be nil.

79
00:04:12.466 --> 00:04:13.826 A:middle
So a very strong constraint.

80
00:04:14.566 --> 00:04:16.616 A:middle
And it makes life a bit
simpler when you know

81
00:04:16.616 --> 00:04:17.565 A:middle
that thing is not nil.

82
00:04:19.036 --> 00:04:21.646 A:middle
Now, when you want to deal
with nil, you have an NSDate!

83
00:04:21.646 --> 00:04:25.056 A:middle
that could be nil, you
use an optional type,

84
00:04:25.236 --> 00:04:27.526 A:middle
and optional types are
covered extensively in the

85
00:04:27.526 --> 00:04:29.506 A:middle
"Intermediate Swift" talk.

86
00:04:30.046 --> 00:04:31.526 A:middle
We're going to cover them
a little bit more now.

87
00:04:32.976 --> 00:04:34.546 A:middle
That's the Swift side of things.

88
00:04:34.986 --> 00:04:36.226 A:middle
What about Objective-C?

89
00:04:36.656 --> 00:04:39.756 A:middle
Well, it does not have
the notion of a never

90
00:04:39.756 --> 00:04:42.816 A:middle
"never-nil" pointer
like we have in Swift.

91
00:04:43.356 --> 00:04:45.876 A:middle
And so we have a little
impedance mismatch here.

92
00:04:45.876 --> 00:04:50.256 A:middle
The Objective-C APIs don't have
the notion of this is not nil,

93
00:04:50.256 --> 00:04:52.146 A:middle
but we need to bring
them into Swift.

94
00:04:52.796 --> 00:04:56.066 A:middle
And so, we have the
implicitly unwrapped optional

95
00:04:56.146 --> 00:04:57.486 A:middle
with the exclamation point here.

96
00:04:57.486 --> 00:04:59.916 A:middle
And this gives us
a nice balance.

97
00:04:59.916 --> 00:05:02.336 A:middle
It means that we can
express the notion of nil

98
00:05:03.006 --> 00:05:05.686 A:middle
and you can test it against
nil to do those checks.

99
00:05:06.426 --> 00:05:09.656 A:middle
However, you can also just
directly access properties

100
00:05:09.656 --> 00:05:12.346 A:middle
or directly call a method
on it, or you can convert it

101
00:05:12.346 --> 00:05:14.786 A:middle
down to NSNil, and we'll unwrap

102
00:05:14.936 --> 00:05:17.116 A:middle
that optional object
automatically

103
00:05:17.116 --> 00:05:17.976 A:middle
for you doing the checking.

104
00:05:18.046 --> 00:05:21.976 A:middle
So it's a fairly syntactically
lightweight way of dealing

105
00:05:21.976 --> 00:05:26.786 A:middle
with nil in a language where nil
is a much more explicit entity

106
00:05:27.376 --> 00:05:28.006 A:middle
like in Swift.

107
00:05:29.406 --> 00:05:32.976 A:middle
Let's look at another property.

108
00:05:33.096 --> 00:05:35.396 A:middle
So here we have the fileType
property that's in NSString.

109
00:05:36.676 --> 00:05:42.456 A:middle
This is going to come into
Swift as a native Swift string.

110
00:05:43.196 --> 00:05:45.636 A:middle
Now, again, we have the
implicitly unwrapped optional

111
00:05:45.636 --> 00:05:47.876 A:middle
here so that nil can be passed

112
00:05:47.876 --> 00:05:50.866 A:middle
through since NSString doesn't
have a notion of nil inside it.

113
00:05:52.446 --> 00:05:55.106 A:middle
And there's a number
of Objective-C types

114
00:05:55.286 --> 00:05:58.056 A:middle
that get mapped slightly
differently into Swift.

115
00:05:58.776 --> 00:06:01.846 A:middle
So there's some very, very
fundamental types like BOOL

116
00:06:01.896 --> 00:06:07.036 A:middle
and NSInteger that map into the
Bool and Int types within Swift.

117
00:06:07.256 --> 00:06:08.846 A:middle
So we're working with
all the Swift types.

118
00:06:09.636 --> 00:06:11.606 A:middle
There's id and Class,

119
00:06:11.606 --> 00:06:14.396 A:middle
which we're very familiar
with in Objective-C.

120
00:06:14.676 --> 00:06:16.496 A:middle
These map over to AnyObject!

121
00:06:16.496 --> 00:06:18.396 A:middle
and AnyClass!, something
we're going to talk

122
00:06:18.396 --> 00:06:19.346 A:middle
about in a couple of minutes.

123
00:06:20.366 --> 00:06:22.746 A:middle
And we also have the core
Cocoa types that are bridged,

124
00:06:22.746 --> 00:06:24.066 A:middle
like NSString and NSArray,

125
00:06:24.326 --> 00:06:26.586 A:middle
mapping to their
Swift-native equivalents.

126
00:06:26.776 --> 00:06:28.616 A:middle
Again, we'll talk about
that later in this talk.

127
00:06:29.956 --> 00:06:31.106 A:middle
Let's take a look at methods.

128
00:06:32.346 --> 00:06:34.706 A:middle
There's an Objective-C method
fileNameExtensionForType,

129
00:06:34.776 --> 00:06:35.796 A:middle
saveOperation.

130
00:06:36.356 --> 00:06:39.796 A:middle
It comes into Swift here
as, again, a method.

131
00:06:40.906 --> 00:06:43.946 A:middle
Now, one important thing
to know here is that all

132
00:06:43.946 --> 00:06:47.596 A:middle
of the selector pieces from
the Objective-C method are here

133
00:06:47.666 --> 00:06:49.926 A:middle
in the method's signature
in Swift.

134
00:06:50.556 --> 00:06:53.236 A:middle
The first selector piece has
become the so-called base name

135
00:06:53.236 --> 00:06:53.846 A:middle
of the method.

136
00:06:54.436 --> 00:06:56.816 A:middle
The second selector
piece, SaveOperation,

137
00:06:57.226 --> 00:07:00.576 A:middle
has become a label on
the second argument.

138
00:07:01.966 --> 00:07:05.046 A:middle
A really important thing
here is that these labels

139
00:07:05.306 --> 00:07:08.846 A:middle
and their order are
enforced at the call site.

140
00:07:09.656 --> 00:07:13.026 A:middle
So, you must call it as
fileNameExtensionForType,

141
00:07:13.266 --> 00:07:15.746 A:middle
saveOperation, just
like you do in Cocoa

142
00:07:16.036 --> 00:07:18.236 A:middle
with the exact same
ordering, so to preserve

143
00:07:18.506 --> 00:07:21.416 A:middle
that nice readability from
Cocoa that we all know and love.

144
00:07:23.466 --> 00:07:26.516 A:middle
Now the other thing to note
here is the consistency here

145
00:07:26.516 --> 00:07:27.296 A:middle
on the Swift side.

146
00:07:28.496 --> 00:07:31.106 A:middle
All of the names and the
colons and the parentheses

147
00:07:31.106 --> 00:07:33.586 A:middle
and the commas are in
exactly the same places

148
00:07:34.166 --> 00:07:37.206 A:middle
in the declaration of
the method in the middle

149
00:07:37.676 --> 00:07:39.946 A:middle
and in the call site of
the method at the bottom.

150
00:07:39.946 --> 00:07:41.846 A:middle
So the kind of consistency
we like out

151
00:07:41.846 --> 00:07:43.196 A:middle
of building a new language.

152
00:07:43.196 --> 00:07:47.296 A:middle
Let's look at a little bit
more complicated method here

153
00:07:47.296 --> 00:07:48.646 A:middle
where we have some
blocks going on,

154
00:07:48.646 --> 00:07:51.506 A:middle
some more interesting things,
and map that into Swift.

155
00:07:52.326 --> 00:07:54.556 A:middle
And here there are two different
things I want to talk about.

156
00:07:54.596 --> 00:07:58.496 A:middle
The first thing I want to
talk about is the naming

157
00:07:58.586 --> 00:08:02.096 A:middle
of these argument labels and
the internal parameter names.

158
00:08:02.676 --> 00:08:05.816 A:middle
So here in Objective-C you
always have a selector piece,

159
00:08:06.556 --> 00:08:07.586 A:middle
goes before the colon.

160
00:08:07.976 --> 00:08:10.666 A:middle
And then you have the name of
the - at the internal parameter

161
00:08:10.956 --> 00:08:13.016 A:middle
that you use when you're
defining the method

162
00:08:13.016 --> 00:08:14.196 A:middle
in your .m file.

163
00:08:14.406 --> 00:08:17.416 A:middle
In Objective-C you always
have to write both of these,

164
00:08:17.416 --> 00:08:19.536 A:middle
of course, and many
times they're the same.

165
00:08:19.536 --> 00:08:20.696 A:middle
So you have some redundancy.

166
00:08:21.316 --> 00:08:24.566 A:middle
We do a little bit of syntax
optimization here in Swift,

167
00:08:24.566 --> 00:08:25.866 A:middle
so you just write the name once.

168
00:08:26.236 --> 00:08:28.996 A:middle
It serves both as the label
and the internal name.

169
00:08:29.906 --> 00:08:32.525 A:middle
If you want those names
to be different, fine,

170
00:08:32.525 --> 00:08:33.576 A:middle
we can handle that, too.

171
00:08:33.706 --> 00:08:35.416 A:middle
You just write the two
names next to each other.

172
00:08:35.626 --> 00:08:37.816 A:middle
The first one is the label
because that's what's important

173
00:08:37.816 --> 00:08:38.996 A:middle
for the caller to use.

174
00:08:39.616 --> 00:08:42.376 A:middle
And then the second one is the
internal name that you're going

175
00:08:42.376 --> 00:08:44.896 A:middle
to use within the
implementation of your method.

176
00:08:46.366 --> 00:08:50.106 A:middle
The next thing I want to
point out here is the Block.

177
00:08:51.436 --> 00:08:54.596 A:middle
So here we have a method
that takes a Block,

178
00:08:55.126 --> 00:08:59.716 A:middle
and Blocks in Objective-C get
mapped into Closures in Swift.

179
00:09:00.566 --> 00:09:03.316 A:middle
You see, again, this is an
implicitly unwrapped optional

180
00:09:03.536 --> 00:09:05.936 A:middle
so that you can pass
a nil Block in here.

181
00:09:07.486 --> 00:09:08.806 A:middle
Now the really great thing

182
00:09:09.076 --> 00:09:13.036 A:middle
about getting Objective-C Blocks
mapped into Swift Closures is

183
00:09:13.036 --> 00:09:16.316 A:middle
that we get all of the great
closure syntax that is provided

184
00:09:16.316 --> 00:09:18.766 A:middle
by Swift, including
trailing closures

185
00:09:18.986 --> 00:09:20.826 A:middle
when your block is
the last parameter.

186
00:09:21.356 --> 00:09:23.816 A:middle
So all of your block-based
APIs that you've written,

187
00:09:23.886 --> 00:09:26.526 A:middle
all the ones from Cocoa, when
they're following the convention

188
00:09:26.526 --> 00:09:30.736 A:middle
of putting the block last get
this nice trailing closure

189
00:09:30.736 --> 00:09:31.736 A:middle
syntax in Swift.

190
00:09:32.166 --> 00:09:37.026 A:middle
Let's talk a little
bit about Initializers.

191
00:09:38.626 --> 00:09:41.796 A:middle
So in Objective-C
we have init methods

192
00:09:42.576 --> 00:09:46.506 A:middle
and init methods have a lot of
conventions built around them.

193
00:09:47.036 --> 00:09:48.376 A:middle
They start with the word "init."

194
00:09:49.046 --> 00:09:51.016 A:middle
They should be returning
instance type,

195
00:09:51.546 --> 00:09:52.966 A:middle
although that's a
fairly new invention.

196
00:09:52.966 --> 00:09:54.746 A:middle
So sometimes they're
still returning ID.

197
00:09:56.206 --> 00:09:58.036 A:middle
And when you're implementing
these things,

198
00:09:58.036 --> 00:09:59.356 A:middle
you have a lot of requirements.

199
00:09:59.356 --> 00:09:59.966 A:middle
You need to call "super init."

200
00:10:00.046 --> 00:10:01.896 A:middle
You need to reassign "self."

201
00:10:01.896 --> 00:10:03.996 A:middle
You need to check "self,"
you need to return "self."

202
00:10:05.926 --> 00:10:09.666 A:middle
So all of this screams, we
need something formalized

203
00:10:09.696 --> 00:10:10.506 A:middle
in the language.

204
00:10:10.536 --> 00:10:13.476 A:middle
And so Swift has this
notion of Initializers.

205
00:10:13.906 --> 00:10:18.236 A:middle
And we import Objective-C init
methods as Swift Initializers.

206
00:10:19.206 --> 00:10:21.696 A:middle
How do we get from the
top Objective-C code

207
00:10:21.696 --> 00:10:23.016 A:middle
to the Swift code in the bottom?

208
00:10:23.526 --> 00:10:27.436 A:middle
Well, we find the init,
so we match the init name

209
00:10:27.436 --> 00:10:28.916 A:middle
and the camel-case string here.

210
00:10:28.916 --> 00:10:31.586 A:middle
We actually look forward
a little bit to see

211
00:10:31.586 --> 00:10:34.546 A:middle
if it's really initWith
because that's extremely common.

212
00:10:34.986 --> 00:10:37.756 A:middle
And then we take the
rest of that Selector,

213
00:10:37.846 --> 00:10:39.826 A:middle
and lowercase the
first character in it,

214
00:10:40.146 --> 00:10:43.666 A:middle
and turn that into an argument
label for the Swift Initializer.

215
00:10:44.976 --> 00:10:45.866 A:middle
Now, why do we do this?

216
00:10:45.866 --> 00:10:47.736 A:middle
Well, let's look at
how we build objects

217
00:10:47.736 --> 00:10:49.996 A:middle
in Objective-C versus in Swift.

218
00:10:50.566 --> 00:10:54.196 A:middle
So in Objective-C you do
an alloc on your class

219
00:10:54.386 --> 00:10:58.256 A:middle
and then you immediately
send it an init message

220
00:10:58.386 --> 00:10:59.556 A:middle
to initialize the Object.

221
00:10:59.846 --> 00:11:02.246 A:middle
These two steps are
almost never separated.

222
00:11:02.866 --> 00:11:07.376 A:middle
Now in Swift we have
our Initializers

223
00:11:07.856 --> 00:11:11.116 A:middle
and we use this Unified
Object Construction syntax

224
00:11:11.386 --> 00:11:13.176 A:middle
where we write the
name of the Class

225
00:11:13.536 --> 00:11:16.346 A:middle
and then we pass arguments
directly to the Initializer.

226
00:11:16.916 --> 00:11:20.626 A:middle
And notice here, we're using the
argument label of fileURL to say

227
00:11:20.626 --> 00:11:22.786 A:middle
which Initializer
we're actually using

228
00:11:23.146 --> 00:11:24.316 A:middle
and then give it the argument.

229
00:11:25.046 --> 00:11:27.556 A:middle
And, of course, we folded the
alloc and the init together

230
00:11:27.556 --> 00:11:29.906 A:middle
in this one nice syntax
that also happens to work

231
00:11:29.906 --> 00:11:32.216 A:middle
for all other types of in
Swift whether they be structs

232
00:11:32.216 --> 00:11:32.786 A:middle
or enums.

233
00:11:33.336 --> 00:11:38.186 A:middle
Okay. So let's talk
about factory methods

234
00:11:38.226 --> 00:11:40.026 A:middle
because this is the other way

235
00:11:40.176 --> 00:11:42.376 A:middle
that we build Objects
in Objective-C.

236
00:11:42.816 --> 00:11:44.746 A:middle
So here we have something
from UIColor.

237
00:11:44.746 --> 00:11:46.106 A:middle
I've stepped away
from UIDocument.

238
00:11:46.106 --> 00:11:48.316 A:middle
And they have colorWithRed
blue green alpha.

239
00:11:48.726 --> 00:11:50.366 A:middle
And, of course, we
can go and construct

240
00:11:50.366 --> 00:11:55.366 A:middle
that by calling UIColor
colorWithRed green blue alpha.

241
00:11:55.616 --> 00:11:58.206 A:middle
All of this can be
directly imported in Swift.

242
00:11:58.646 --> 00:12:01.496 A:middle
It would just be a class
method, colorwithRed,

243
00:12:01.496 --> 00:12:04.406 A:middle
and green blue alpha
as argument labels,

244
00:12:04.846 --> 00:12:07.456 A:middle
and we could just
call it on the class.

245
00:12:08.396 --> 00:12:09.286 A:middle
This would be fine.

246
00:12:09.286 --> 00:12:10.876 A:middle
However, we don't really love

247
00:12:10.876 --> 00:12:12.626 A:middle
that they're two
completely different kinds

248
00:12:12.626 --> 00:12:13.626 A:middle
of initialization.

249
00:12:14.916 --> 00:12:19.496 A:middle
So we recognize the
common patterns

250
00:12:19.496 --> 00:12:22.066 A:middle
in how factory methods are
described in Objective-C,

251
00:12:22.236 --> 00:12:24.786 A:middle
and bring them in as
Swift Initializers.

252
00:12:25.976 --> 00:12:27.906 A:middle
And the really great
thing here is we get

253
00:12:27.906 --> 00:12:31.416 A:middle
that common Initialization
syntax for all

254
00:12:31.416 --> 00:12:32.816 A:middle
of these Objective-C APIs.

255
00:12:33.266 --> 00:12:35.396 A:middle
You don't have to think, "Is
there an init method for this?

256
00:12:35.396 --> 00:12:38.156 A:middle
Or is there a class
method for this?"

257
00:12:39.046 --> 00:12:40.486 A:middle
It's there as an Initializer.

258
00:12:43.176 --> 00:12:43.956 A:middle
Do you like that?

259
00:12:44.516 --> 00:12:49.026 A:middle
[ Applause ]

260
00:12:49.526 --> 00:12:51.166 A:middle
Let's go a little
bit down the stack

261
00:12:51.586 --> 00:12:52.856 A:middle
and let's talk about Enums.

262
00:12:54.006 --> 00:12:56.826 A:middle
So here's the
UIDocumentSaveOperation enum

263
00:12:57.186 --> 00:12:58.556 A:middle
as defined in Objective-C.

264
00:12:59.646 --> 00:13:02.666 A:middle
And if we look at this we see
a whole lot of redundancy.

265
00:13:03.416 --> 00:13:06.646 A:middle
This UIDocumentSave
prefix is used for the enum

266
00:13:06.916 --> 00:13:09.136 A:middle
and for both of its enum values.

267
00:13:10.066 --> 00:13:10.986 A:middle
Why is this?

268
00:13:10.986 --> 00:13:12.436 A:middle
Well, this is C.

269
00:13:13.236 --> 00:13:16.896 A:middle
The enum values in C are
in a global namespace.

270
00:13:17.276 --> 00:13:20.386 A:middle
We can't call these enum
values just ForCreating

271
00:13:20.386 --> 00:13:22.456 A:middle
and ForOverwriting because
that's going to stomp

272
00:13:22.456 --> 00:13:25.016 A:middle
on some other completely
different enumeration somewhere

273
00:13:25.016 --> 00:13:27.546 A:middle
else in the system
and cause havoc.

274
00:13:28.396 --> 00:13:31.456 A:middle
So we do this common
prefix by convention.

275
00:13:31.496 --> 00:13:33.506 A:middle
It helps code completion
find the right thing.

276
00:13:33.506 --> 00:13:37.196 A:middle
But when we're talking about
Swift, it's also a great cue

277
00:13:37.196 --> 00:13:38.776 A:middle
for us that we can do better.

278
00:13:39.376 --> 00:13:42.036 A:middle
And so we can import
this NS-ENUM

279
00:13:42.506 --> 00:13:46.876 A:middle
as a Swift enum chopping off
all of those common prefixes

280
00:13:47.116 --> 00:13:49.396 A:middle
to get us nice short
names for the cases.

281
00:13:50.886 --> 00:13:54.126 A:middle
Now the reason we can do this
is because the enum cases

282
00:13:54.126 --> 00:13:57.446 A:middle
in Swift are scoped within
the enum type itself.

283
00:13:58.016 --> 00:14:02.026 A:middle
How does this play
out in actual code?

284
00:14:02.596 --> 00:14:04.656 A:middle
Well, okay, if we call
fileNameExtensionForType

285
00:14:04.656 --> 00:14:08.606 A:middle
saveOperation, we can
refer to, say ForCreating,

286
00:14:09.306 --> 00:14:12.216 A:middle
with its fully dotted
name - class name.enum,

287
00:14:12.216 --> 00:14:13.996 A:middle
the same dotted syntax we use

288
00:14:14.146 --> 00:14:16.686 A:middle
for a number of anything
in Swift.

289
00:14:17.896 --> 00:14:19.626 A:middle
But Swift has type inference.

290
00:14:20.496 --> 00:14:23.426 A:middle
We know that this method takes
the UIDocumentSaveOperation,

291
00:14:23.536 --> 00:14:25.446 A:middle
so there's absolutely
no reason to write that.

292
00:14:25.756 --> 00:14:27.626 A:middle
You can just pass .ForCreating

293
00:14:27.626 --> 00:14:30.546 A:middle
and we will infer the
enum type from that.

294
00:14:36.046 --> 00:14:38.426 A:middle
I'd also like to
talk about NSError.

295
00:14:39.276 --> 00:14:43.086 A:middle
So this is our pattern in
Cocoa for dealing with errors.

296
00:14:43.676 --> 00:14:45.846 A:middle
And so there are many
methods throughout Cocoa

297
00:14:45.846 --> 00:14:48.896 A:middle
and throughout your own
apps that take an NSError ,

298
00:14:49.106 --> 00:14:53.266 A:middle
and that's a C pointer
to an NSError object.

299
00:14:53.896 --> 00:14:57.076 A:middle
We bring this in with a
special type in Swift.

300
00:14:57.166 --> 00:14:58.216 A:middle
In fact, if you type alias

301
00:14:58.216 --> 00:15:01.896 A:middle
for a much longer type
name call NSErrorPointer.

302
00:15:03.026 --> 00:15:03.356 A:middle
We're going

303
00:15:03.356 --> 00:15:05.976 A:middle
to see NSErrorPointer
twice in this talk.

304
00:15:06.826 --> 00:15:08.846 A:middle
For now we're going to
talk about how to use it

305
00:15:09.356 --> 00:15:11.326 A:middle
when we're calling into the API.

306
00:15:13.036 --> 00:15:15.646 A:middle
And it's not actually all that
much different from Objective-C.

307
00:15:16.506 --> 00:15:20.506 A:middle
So, if we bring this up, we
declare a local variable.

308
00:15:20.936 --> 00:15:22.026 A:middle
It's called error.

309
00:15:22.096 --> 00:15:24.036 A:middle
It's a type NSError optional.

310
00:15:24.996 --> 00:15:27.566 A:middle
And we pass its address
in when we're calling

311
00:15:27.566 --> 00:15:28.766 A:middle
contentsForType error.

312
00:15:30.076 --> 00:15:32.816 A:middle
And so in this code we check
whether we're getting back some

313
00:15:32.816 --> 00:15:33.826 A:middle
contents from this.

314
00:15:34.726 --> 00:15:36.106 A:middle
Then we can deal
with those contents.

315
00:15:36.736 --> 00:15:39.446 A:middle
If we fail to find any contents
well, we probably have an error.

316
00:15:39.446 --> 00:15:42.056 A:middle
So we can go unwrap
that optional error

317
00:15:42.356 --> 00:15:43.726 A:middle
and present it to the user.

318
00:15:44.126 --> 00:15:46.626 A:middle
And if we fall through the
else here, now we're in trouble

319
00:15:46.626 --> 00:15:49.256 A:middle
because something failed and we
have nothing we can do about it.

320
00:15:49.906 --> 00:15:52.476 A:middle
We hope that doesn't happen.

321
00:15:52.686 --> 00:15:55.456 A:middle
But this is the pattern
you'll be using when dealing

322
00:15:55.456 --> 00:15:57.026 A:middle
with NSError in Swift.

323
00:15:57.296 --> 00:15:59.036 A:middle
If you truly don't
care about the error,

324
00:15:59.176 --> 00:16:00.176 A:middle
you can also pass nil.

325
00:16:01.656 --> 00:16:04.916 A:middle
So we've walked through
a lot of little pieces

326
00:16:05.356 --> 00:16:08.446 A:middle
of the Objective-C
mapping into Swift.

327
00:16:08.446 --> 00:16:11.306 A:middle
And there are a lot of
rules that we've talked

328
00:16:11.306 --> 00:16:13.016 A:middle
about that you're certainly
not going to remember.

329
00:16:14.166 --> 00:16:15.196 A:middle
That's perfectly fine.

330
00:16:15.366 --> 00:16:16.506 A:middle
Xcode has your back here.

331
00:16:17.226 --> 00:16:18.466 A:middle
Use the tools to help you.

332
00:16:19.026 --> 00:16:21.346 A:middle
So if you're in Xcode,
you're in some Swift Code,

333
00:16:21.346 --> 00:16:23.636 A:middle
you can Command+Click
on a class name.

334
00:16:23.886 --> 00:16:25.956 A:middle
And we'll show you
the Swift projection

335
00:16:26.276 --> 00:16:28.096 A:middle
of the underlying
Objective-C class.

336
00:16:28.896 --> 00:16:31.046 A:middle
So take your favorite
Cocoa class and look

337
00:16:31.046 --> 00:16:33.176 A:middle
at how it maps into Swift.

338
00:16:33.566 --> 00:16:35.616 A:middle
Get a feel for the
language, an intuitive feel

339
00:16:35.616 --> 00:16:38.806 A:middle
for how these languages
work together and you'll get

340
00:16:38.806 --> 00:16:40.336 A:middle
into Swift really fast.

341
00:16:41.126 --> 00:16:43.956 A:middle
And the great thing
is, all of these tools,

342
00:16:44.166 --> 00:16:47.016 A:middle
all the rules I've talked
about, apply equally

343
00:16:47.016 --> 00:16:50.976 A:middle
to any Objective-C API
when it comes into Swift.

344
00:16:51.416 --> 00:16:52.636 A:middle
It doesn't matter if it's Cocoa.

345
00:16:52.636 --> 00:16:53.776 A:middle
It doesn't matter if
it's your own API.

346
00:16:54.256 --> 00:16:58.876 A:middle
The same rules apply, and you
can view your own Objective-C

347
00:16:58.956 --> 00:17:01.186 A:middle
APIs in Swift to get
to know them better.

348
00:17:02.246 --> 00:17:05.146 A:middle
Now this works best
when you're following

349
00:17:05.175 --> 00:17:07.136 A:middle
"modern" Objective-C practices.

350
00:17:07.705 --> 00:17:11.935 A:middle
So these are using features
like Properties, instancetype,

351
00:17:12.726 --> 00:17:15.915 A:middle
marking your enumerations
with NS-ENUM or NS-OPTIONS

352
00:17:15.965 --> 00:17:17.866 A:middle
to describe more
semantic information

353
00:17:17.866 --> 00:17:20.366 A:middle
about what these enums
actually mean in C.

354
00:17:21.616 --> 00:17:24.306 A:middle
We've also introduced
NS-DESIGNATED-INITIALIZER this

355
00:17:24.306 --> 00:17:27.086 A:middle
year to mark your
designated Initializers

356
00:17:27.606 --> 00:17:29.546 A:middle
and formalize a Designated
Initializer pattern,

357
00:17:29.546 --> 00:17:31.676 A:middle
both in Objective-C
through additional warnings,

358
00:17:32.306 --> 00:17:35.486 A:middle
and as the initialization
model for Swift.

359
00:17:36.736 --> 00:17:39.176 A:middle
So, of course, we want
you to follow all of these

360
00:17:39.176 --> 00:17:42.496 A:middle
"modern" Objective-C
practices but we don't want you

361
00:17:42.496 --> 00:17:43.296 A:middle
to have to go it alone.

362
00:17:44.046 --> 00:17:47.316 A:middle
And so this year we introduced
the Objective-C Modernizer

363
00:17:47.776 --> 00:17:50.296 A:middle
that helps find these
cases in your code

364
00:17:50.596 --> 00:17:53.376 A:middle
where we could possibly
modernize them to work

365
00:17:53.376 --> 00:17:55.496 A:middle
with all these "modern"
Objective-C features

366
00:17:55.786 --> 00:17:57.876 A:middle
and give you a better
projection into Swift.

367
00:17:58.426 --> 00:18:00.696 A:middle
And that Modernizer is
discussed in the "What's New

368
00:18:00.696 --> 00:18:02.666 A:middle
in LLVM" talk earlier today.

369
00:18:03.296 --> 00:18:05.686 A:middle
Highly recommend you catch
it on video if you missed it.

370
00:18:08.096 --> 00:18:12.056 A:middle
With that, let's talk about id.

371
00:18:13.766 --> 00:18:15.176 A:middle
What is id in Objective-C?

372
00:18:15.736 --> 00:18:19.576 A:middle
It's kind of a placeholder
in some sense.

373
00:18:19.766 --> 00:18:21.596 A:middle
It means, I have a value.

374
00:18:22.016 --> 00:18:25.066 A:middle
I know it's an object
but I don't know

375
00:18:25.066 --> 00:18:28.686 A:middle
or I don't care what the
static type of that object is.

376
00:18:29.096 --> 00:18:30.996 A:middle
It's going to vary at
runtime most likely.

377
00:18:31.766 --> 00:18:34.026 A:middle
And there's a couple
of core operations

378
00:18:34.026 --> 00:18:35.316 A:middle
that you can perform on id.

379
00:18:35.316 --> 00:18:38.216 A:middle
You can do upcasting on it.

380
00:18:38.296 --> 00:18:41.996 A:middle
So, if I have this
variable object of type id,

381
00:18:42.366 --> 00:18:44.416 A:middle
I can put an NSURL into it.

382
00:18:45.406 --> 00:18:48.326 A:middle
Later I can go reassign it
and I can put a UIView on it.

383
00:18:48.736 --> 00:18:49.646 A:middle
That's perfectly fine.

384
00:18:49.806 --> 00:18:52.626 A:middle
They can both be upcasted
essentially to id.

385
00:18:52.806 --> 00:18:53.596 A:middle
They're both objects.

386
00:18:54.536 --> 00:18:57.796 A:middle
I can do Message sends
to id just directly

387
00:18:57.796 --> 00:18:58.816 A:middle
by doing a Message Send.

388
00:18:59.206 --> 00:19:02.786 A:middle
I can subscript an id
if I really feel like.

389
00:19:03.516 --> 00:19:08.546 A:middle
In Swift, any object is
the equivalent to id.

390
00:19:08.546 --> 00:19:13.376 A:middle
And it provides these same
core operations - Upcasting,

391
00:19:13.796 --> 00:19:15.576 A:middle
Message Sends, Subscripting -

392
00:19:15.876 --> 00:19:17.736 A:middle
that you can do on
id in Objective-C.

393
00:19:17.736 --> 00:19:23.316 A:middle
Now one of the things we know
from using id in Objective-C is

394
00:19:23.316 --> 00:19:25.636 A:middle
that you sometimes have
to be a little bit careful

395
00:19:26.906 --> 00:19:28.816 A:middle
because if you send a
message to an object

396
00:19:29.386 --> 00:19:31.256 A:middle
that doesn't have a
corresponding method,

397
00:19:31.446 --> 00:19:33.036 A:middle
you're going to get
a runtime failure

398
00:19:33.036 --> 00:19:34.866 A:middle
that this is an unrecognized
selector.

399
00:19:35.916 --> 00:19:37.976 A:middle
Now in Objective-C we
have an answer for this.

400
00:19:38.456 --> 00:19:40.476 A:middle
Using this respondsToSelector
idiom.

401
00:19:40.966 --> 00:19:44.186 A:middle
Do an if. Check whether it
respondsToSelector, then do it.

402
00:19:45.356 --> 00:19:47.556 A:middle
In Swift we like to do
a little bit better.

403
00:19:48.556 --> 00:19:49.916 A:middle
So let's take the same call

404
00:19:49.916 --> 00:19:52.466 A:middle
and let's do a
removeFromSuperview() call

405
00:19:52.466 --> 00:19:53.076 A:middle
on this object.

406
00:19:54.506 --> 00:19:59.216 A:middle
And the thing to note here
is that removeFromSuperview()

407
00:19:59.836 --> 00:20:02.576 A:middle
on an object of unknown type,

408
00:20:02.946 --> 00:20:04.976 A:middle
it may be there, it
may not be there.

409
00:20:06.226 --> 00:20:07.876 A:middle
Well, how do we deal with
this notion in Swift?

410
00:20:08.246 --> 00:20:11.406 A:middle
We use an "optional" that says
there may be a value there;

411
00:20:11.496 --> 00:20:12.226 A:middle
there may not be.

412
00:20:12.566 --> 00:20:14.726 A:middle
And so the reference to
removeFromSuperview()

413
00:20:14.726 --> 00:20:17.086 A:middle
on object is in effect,
optional.

414
00:20:17.506 --> 00:20:20.936 A:middle
That means we can use the
optional Chaining Operator here

415
00:20:21.886 --> 00:20:22.026 A:middle
to -

416
00:20:23.516 --> 00:20:29.066 A:middle
[ Applause ]

417
00:20:29.566 --> 00:20:30.616 A:middle
What we're doing, of course,

418
00:20:30.806 --> 00:20:33.266 A:middle
is we're folding the
respondsToSelector check in,

419
00:20:33.696 --> 00:20:36.566 A:middle
so we do the reference, go
look for RemoveFromSuperview.

420
00:20:36.976 --> 00:20:39.126 A:middle
If it's there, go on, call it.

421
00:20:39.886 --> 00:20:42.176 A:middle
If it's not there, stop
evaluating this expression.

422
00:20:42.176 --> 00:20:42.536 A:middle
We're done.

423
00:20:44.276 --> 00:20:47.156 A:middle
Now, something that id does

424
00:20:47.156 --> 00:20:50.496 A:middle
that AnyObject does not
do is implicitly downcast.

425
00:20:50.816 --> 00:20:54.316 A:middle
So I have Object, which is a
type AnyObject, and I'm trying

426
00:20:54.316 --> 00:20:56.486 A:middle
to assign it into a UIView.

427
00:20:57.506 --> 00:20:59.166 A:middle
This is going to
produce a compiler error

428
00:20:59.166 --> 00:21:01.786 A:middle
because this is a
unsafe downcast.

429
00:21:02.276 --> 00:21:05.146 A:middle
How do we deal with this?

430
00:21:05.236 --> 00:21:06.666 A:middle
Well, there's really
two cases here that need

431
00:21:06.666 --> 00:21:07.866 A:middle
that you need to think about.

432
00:21:08.536 --> 00:21:12.796 A:middle
One case is, I know it's a
UIView but for some reason

433
00:21:12.796 --> 00:21:15.496 A:middle
that strong type information
got lost when going

434
00:21:15.496 --> 00:21:16.626 A:middle
through some API somewhere.

435
00:21:17.226 --> 00:21:19.126 A:middle
If I know for sure
it's a UIView,

436
00:21:19.456 --> 00:21:23.086 A:middle
I can use the cast
operator, "as", to say,

437
00:21:23.086 --> 00:21:25.066 A:middle
"Treat this object as a UIView."

438
00:21:26.466 --> 00:21:29.326 A:middle
We're going to do these kind
of class check at runtime

439
00:21:29.326 --> 00:21:31.196 A:middle
to make sure that's
absolutely true.

440
00:21:31.836 --> 00:21:36.336 A:middle
But the type system will
believe you at this point.

441
00:21:36.516 --> 00:21:40.976 A:middle
Now if you don't know whether
this object is a UIView

442
00:21:40.976 --> 00:21:42.906 A:middle
or not, you can use the "as?"

443
00:21:43.036 --> 00:21:45.976 A:middle
to perform a conditional
downcast.

444
00:21:46.516 --> 00:21:52.606 A:middle
[ Applause ]

445
00:21:53.106 --> 00:21:54.286 A:middle
Think you guys have
figured it out?

446
00:21:54.286 --> 00:21:57.476 A:middle
But just to be sure, this is
doing "is kind of" class check.

447
00:21:57.476 --> 00:22:00.936 A:middle
And it's wrapping the result
in an optional UIView.

448
00:22:01.756 --> 00:22:03.336 A:middle
It's nil if the check failed.

449
00:22:03.636 --> 00:22:06.426 A:middle
It has the UIView if
the check succeeded.

450
00:22:06.826 --> 00:22:08.256 A:middle
We can do an if-let here

451
00:22:08.676 --> 00:22:10.986 A:middle
to completely do this
entire thing safely,

452
00:22:11.336 --> 00:22:13.896 A:middle
and view in here is the
UIView we were looking for.

453
00:22:15.276 --> 00:22:17.886 A:middle
So let's take a little
bit of detour and talk

454
00:22:17.886 --> 00:22:19.366 A:middle
about tiny bit of protocols.

455
00:22:19.836 --> 00:22:24.026 A:middle
Here's an Objective-C Protocol
for a UITableViewDataSource

456
00:22:24.536 --> 00:22:27.426 A:middle
and its Swift equivalent.

457
00:22:27.786 --> 00:22:31.496 A:middle
Not a whole lot new here.

458
00:22:31.706 --> 00:22:33.866 A:middle
But there are two things that
I do I want to point out.

459
00:22:33.926 --> 00:22:38.076 A:middle
The first thing I want to point
out is optional and required.

460
00:22:38.546 --> 00:22:39.856 A:middle
So in Objective-C optional

461
00:22:39.856 --> 00:22:42.406 A:middle
and required are essentially
modes in the protocol.

462
00:22:42.916 --> 00:22:44.826 A:middle
You say @optional,
and everything

463
00:22:44.826 --> 00:22:47.636 A:middle
that follows is optional
up until the point

464
00:22:47.636 --> 00:22:50.066 A:middle
where you hit an @required and
then everything is required.

465
00:22:50.836 --> 00:22:54.426 A:middle
And we're not totally thrilled
with this decision now.

466
00:22:54.976 --> 00:22:56.996 A:middle
And the basic reason is
that you can't just look

467
00:22:56.996 --> 00:22:59.126 A:middle
at one single declaration
in the protocol

468
00:22:59.126 --> 00:23:00.846 A:middle
and know whether it's
optional or required.

469
00:23:00.846 --> 00:23:03.636 A:middle
You have to go scan up
your protocol to find it.

470
00:23:04.006 --> 00:23:06.056 A:middle
And so we did something a
little bit different in Swift

471
00:23:06.756 --> 00:23:10.876 A:middle
in that requirements in
protocol are required

472
00:23:10.876 --> 00:23:12.506 A:middle
by default in Swift.

473
00:23:12.806 --> 00:23:15.326 A:middle
If you want to make them
optional, then tag them

474
00:23:15.326 --> 00:23:17.596 A:middle
with the optional attribute
to make them optional.

475
00:23:18.936 --> 00:23:20.696 A:middle
The other thing I want
to point out here.

476
00:23:21.016 --> 00:23:23.216 A:middle
We're doing a little bit
of Protocol Inheritance

477
00:23:23.916 --> 00:23:26.416 A:middle
and we're inheriting
from NSObjectProtocol.

478
00:23:28.196 --> 00:23:31.946 A:middle
So in Objective-C we will
have NSObject the class

479
00:23:32.116 --> 00:23:34.046 A:middle
and NSObject the protocol.

480
00:23:35.216 --> 00:23:38.716 A:middle
And they have the same name so
we have to add the "the class"

481
00:23:38.716 --> 00:23:40.746 A:middle
or "the protocol" at the
end when we talk about it.

482
00:23:41.106 --> 00:23:45.296 A:middle
The language keeps these in
syntactically distinct points

483
00:23:45.736 --> 00:23:47.456 A:middle
so the language isn't confused.

484
00:23:48.086 --> 00:23:50.606 A:middle
But in Swift we wanted
to bring all these things

485
00:23:50.606 --> 00:23:53.476 A:middle
into the same namespace because
that's far more convenient

486
00:23:53.476 --> 00:23:54.476 A:middle
for the general case.

487
00:23:54.876 --> 00:23:56.436 A:middle
And so we needed to
rename something.

488
00:23:57.056 --> 00:23:59.376 A:middle
And essentially when there's a
conflict between a class name

489
00:23:59.376 --> 00:24:01.336 A:middle
and a protocol name,
we'll append protocol

490
00:24:01.336 --> 00:24:03.286 A:middle
to the name of the protocol.

491
00:24:03.846 --> 00:24:06.286 A:middle
Why did we do this?

492
00:24:06.286 --> 00:24:10.766 A:middle
Well, let's take a look at
another use of id that we see

493
00:24:10.846 --> 00:24:14.086 A:middle
in Objective-C, and that's
protocol-qualified id.

494
00:24:15.086 --> 00:24:19.426 A:middle
So this dataSource here is an
object of some unknown type.

495
00:24:20.626 --> 00:24:22.336 A:middle
But we know that
the type conforms

496
00:24:22.336 --> 00:24:24.346 A:middle
to the UITableViewDataSource
protocol.

497
00:24:25.526 --> 00:24:27.416 A:middle
We describe that a
little bit more directly

498
00:24:27.416 --> 00:24:30.056 A:middle
in the Swift language by
just saying the dataSource is

499
00:24:30.056 --> 00:24:31.486 A:middle
a UITableViewDataSource!.

500
00:24:32.146 --> 00:24:33.026 A:middle
That's it.

501
00:24:33.716 --> 00:24:38.006 A:middle
Now some of you here noticed
with protocol-qualified id,

502
00:24:38.256 --> 00:24:40.766 A:middle
you can have many different
protocols if you want.

503
00:24:41.346 --> 00:24:44.836 A:middle
We can use the protocol
keyword with angle brackets

504
00:24:44.996 --> 00:24:46.396 A:middle
to describe more
than one protocol.

505
00:24:46.396 --> 00:24:49.456 A:middle
Now, one of the things we do

506
00:24:49.456 --> 00:24:52.116 A:middle
with Protocol Conformance is we
have an object of unknown type

507
00:24:52.116 --> 00:24:55.266 A:middle
and we want to determine, does
it conform to the protocol?

508
00:24:55.456 --> 00:24:57.606 A:middle
This is the "conforms
to protocol check"

509
00:24:57.606 --> 00:25:00.236 A:middle
in the Objective-C runtime.

510
00:25:00.356 --> 00:25:02.506 A:middle
In Swift, we do this same thing

511
00:25:03.056 --> 00:25:05.276 A:middle
with the conditional
downcast operator.

512
00:25:05.836 --> 00:25:09.106 A:middle
So we can just ask, is my object
the UITableViewDataSource"

513
00:25:09.686 --> 00:25:11.916 A:middle
conforms to protocol check,
happens in the runtime,

514
00:25:12.196 --> 00:25:13.826 A:middle
captures the results
in an optional.

515
00:25:14.216 --> 00:25:17.026 A:middle
Here we can go easily do
that, call one of the methods

516
00:25:17.026 --> 00:25:19.926 A:middle
and compute the number of
rows in the first section

517
00:25:19.976 --> 00:25:21.406 A:middle
of this TableViewDataSource.

518
00:25:21.916 --> 00:25:25.146 A:middle
Let's make our example a
little bit more interesting.

519
00:25:25.766 --> 00:25:28.446 A:middle
Let's compute the number of
rows in the last section.

520
00:25:29.716 --> 00:25:32.446 A:middle
So here we need to compute the
number of sections that exist

521
00:25:32.446 --> 00:25:36.936 A:middle
in the TableView, subtract one
off of it, and then we can ask

522
00:25:36.936 --> 00:25:38.576 A:middle
for the number of
rows in that section.

523
00:25:39.076 --> 00:25:41.506 A:middle
Now there's a problem
with this code.

524
00:25:42.566 --> 00:25:45.226 A:middle
And the problem is the number
of sections in TableView,

525
00:25:45.266 --> 00:25:48.186 A:middle
as you might remember,
is an optional method.

526
00:25:48.766 --> 00:25:50.196 A:middle
It might not be there
at runtime.

527
00:25:50.886 --> 00:25:53.876 A:middle
So we're going to need to
compile error out of this

528
00:25:53.876 --> 00:25:55.706 A:middle
because we need to deal
with the optionality

529
00:25:55.706 --> 00:25:57.006 A:middle
of this protocol method.

530
00:25:57.836 --> 00:25:59.796 A:middle
And we deal with this
the same way we deal

531
00:25:59.796 --> 00:26:02.736 A:middle
with optionality everywhere
else in the Swift language,

532
00:26:03.576 --> 00:26:05.166 A:middle
using the mechanisms we have.

533
00:26:05.166 --> 00:26:07.836 A:middle
So here we're going to
use the chaining "?"

534
00:26:07.836 --> 00:26:11.916 A:middle
operator. We're checking, does
my DataSource have a number

535
00:26:11.916 --> 00:26:13.626 A:middle
of sections in TableView method?

536
00:26:14.066 --> 00:26:16.606 A:middle
If so, call it, given
the TableView,

537
00:26:16.956 --> 00:26:19.156 A:middle
and then we capture the
result in numSections

538
00:26:19.456 --> 00:26:21.226 A:middle
so we can compute the
last section number

539
00:26:21.696 --> 00:26:23.926 A:middle
and get the number of rows

540
00:26:24.026 --> 00:26:28.766 A:middle
in the last section
of our TableView.

541
00:26:29.046 --> 00:26:30.996 A:middle
That's about all we're going to
talk about with Protocols here.

542
00:26:31.716 --> 00:26:33.776 A:middle
If you're interested
in Protocols and some

543
00:26:33.776 --> 00:26:35.196 A:middle
of the amazing things
they can do,

544
00:26:35.586 --> 00:26:37.996 A:middle
there's an "Advanced Swift"
talk tomorrow morning.

545
00:26:38.556 --> 00:26:41.756 A:middle
It goes into more depth on
those and their interaction

546
00:26:42.296 --> 00:26:46.196 A:middle
with the generic system.

547
00:26:46.196 --> 00:26:51.646 A:middle
So, wrapping up here, AnyObject
is Swift's equivalent to id.

548
00:26:52.346 --> 00:26:53.856 A:middle
The functionality is similar.

549
00:26:53.856 --> 00:26:56.386 A:middle
The ideas are similar
and the uses are similar.

550
00:26:56.746 --> 00:26:58.706 A:middle
However, it's more
safe by default.

551
00:26:59.756 --> 00:27:02.826 A:middle
Now we didn't talk about it,
but there's also AnyClass,

552
00:27:02.956 --> 00:27:06.706 A:middle
which is Swift's equivalent
to class and has most

553
00:27:06.706 --> 00:27:07.876 A:middle
of the same behaviors.

554
00:27:08.446 --> 00:27:12.256 A:middle
Now the other thing that we've
seen is how Optionals are used

555
00:27:12.336 --> 00:27:15.656 A:middle
throughout the language to
represent dynamic checks.

556
00:27:16.276 --> 00:27:18.456 A:middle
We've taken "is kind
of" class checks,

557
00:27:18.826 --> 00:27:22.416 A:middle
conforms to protocol checks,
responds to selector checks,

558
00:27:22.706 --> 00:27:25.616 A:middle
and folded them all into
the notion of Optionals

559
00:27:25.616 --> 00:27:28.706 A:middle
within the language with
their optimized syntax

560
00:27:28.746 --> 00:27:31.976 A:middle
to make them easy to use and
easy to do the right thing.

561
00:27:32.526 --> 00:27:38.336 A:middle
With that, let's switch
gears a little bit and talk

562
00:27:38.336 --> 00:27:40.546 A:middle
about Bridging of
Cocoa data types.

563
00:27:41.106 --> 00:27:44.516 A:middle
Now first, let's talk a little
bit about the native Strings,

564
00:27:44.516 --> 00:27:46.736 A:middle
Arrays, and the Dictionaries
within Swift.

565
00:27:47.586 --> 00:27:50.006 A:middle
The goal of Swift
is to have one set

566
00:27:50.006 --> 00:27:53.296 A:middle
of general-purpose native
value types that you use

567
00:27:53.296 --> 00:27:54.456 A:middle
for nearly everything.

568
00:27:55.396 --> 00:27:57.066 A:middle
These need to be
safe by default.

569
00:27:57.066 --> 00:27:58.846 A:middle
This means bounds
restricting for arrays,

570
00:27:58.846 --> 00:28:00.796 A:middle
automatic memory
management, and so on.

571
00:28:01.926 --> 00:28:04.636 A:middle
They need to have predictable
performance so that you can look

572
00:28:04.636 --> 00:28:07.176 A:middle
at code and have a sense
of how it's going to behave

573
00:28:07.176 --> 00:28:09.356 A:middle
with no surprises, how
it's going to perform.

574
00:28:10.746 --> 00:28:13.116 A:middle
And, of course, we want
arrays and dictionaries

575
00:28:13.616 --> 00:28:16.956 A:middle
to be collections and they need
to be strongly typed collections

576
00:28:16.956 --> 00:28:17.946 A:middle
that work with any type.

577
00:28:18.056 --> 00:28:19.886 A:middle
We can't limit them
just to objects

578
00:28:19.926 --> 00:28:22.486 A:middle
because sometimes you need
an array of strings or ints.

579
00:28:23.576 --> 00:28:26.746 A:middle
And we don't have a seed to
fall back to for the cases

580
00:28:26.746 --> 00:28:27.976 A:middle
where the other tools
don't work.

581
00:28:28.416 --> 00:28:31.206 A:middle
This is it.

582
00:28:31.476 --> 00:28:34.776 A:middle
Now, to support having
this one notion of one set

583
00:28:34.776 --> 00:28:37.656 A:middle
of general purpose native value
types, we're going to bridge

584
00:28:37.656 --> 00:28:40.446 A:middle
from Cocoa's NSString,
NSArray, NSDictionary,

585
00:28:40.816 --> 00:28:42.496 A:middle
into the Swift-native
equivalents.

586
00:28:44.616 --> 00:28:46.836 A:middle
So let's first talk a little bit

587
00:28:46.986 --> 00:28:49.226 A:middle
about the native
string type itself.

588
00:28:50.326 --> 00:28:54.146 A:middle
So, String is an efficient,
Unicode-compliant string type.

589
00:28:55.556 --> 00:28:59.356 A:middle
Core string type of Swift
has Unicode built in through

590
00:28:59.356 --> 00:29:01.056 A:middle
and through so it makes
it easy to work with.

591
00:29:01.626 --> 00:29:02.706 A:middle
We provide flexible

592
00:29:02.706 --> 00:29:06.226 A:middle
and efficient high-level
APIs to work with strings.

593
00:29:06.226 --> 00:29:08.696 A:middle
You can easily do
concatenation, searches,

594
00:29:08.816 --> 00:29:11.076 A:middle
prefix matches, sub-strings.

595
00:29:11.516 --> 00:29:14.106 A:middle
And the strings provide
value semantics,

596
00:29:14.206 --> 00:29:15.716 A:middle
which makes them
easier to work with.

597
00:29:16.416 --> 00:29:21.286 A:middle
And value semantics is generally
a fairly simple notion of,

598
00:29:21.606 --> 00:29:23.476 A:middle
you know, if I have two
variables of string type,

599
00:29:24.106 --> 00:29:27.706 A:middle
modifying one of them doesn't
affect the other one, all right.

600
00:29:27.796 --> 00:29:30.436 A:middle
This is very nice for a
fundamental data type.

601
00:29:32.716 --> 00:29:34.976 A:middle
Now, of course, you can also
think of strings as a unit,

602
00:29:34.976 --> 00:29:37.026 A:middle
but you can also think
of them as being composed

603
00:29:37.026 --> 00:29:39.496 A:middle
of characters which,
in fact, they are.

604
00:29:40.476 --> 00:29:44.576 A:middle
And so we can go walk over a
string and using the for loop,

605
00:29:44.816 --> 00:29:47.196 A:middle
and get all of the
characters out of the string.

606
00:29:47.506 --> 00:29:49.596 A:middle
And you get the answer
that you would expect.

607
00:29:49.646 --> 00:29:52.806 A:middle
There are five characters here
even though there's no emoji

608
00:29:53.596 --> 00:29:55.516 A:middle
at the end.

609
00:29:55.516 --> 00:30:01.016 A:middle
So I want to talk a little bit
about characters and code points

610
00:30:02.106 --> 00:30:03.856 A:middle
because the character
that you're getting

611
00:30:03.856 --> 00:30:04.976 A:middle
out of here is a full
Unicode character.

612
00:30:05.236 --> 00:30:09.166 A:middle
It's not a UTF-8 code
point or UTF-16 code point

613
00:30:09.166 --> 00:30:09.936 A:middle
that you have to deal with.

614
00:30:10.376 --> 00:30:12.226 A:middle
It is a Unicode character.

615
00:30:13.386 --> 00:30:16.706 A:middle
And now, one of the challenges
with the Unicode characters is,

616
00:30:16.706 --> 00:30:20.866 A:middle
you really can't encode
them efficiently in a way

617
00:30:20.866 --> 00:30:24.866 A:middle
that treats a string as
just an array of characters.

618
00:30:25.586 --> 00:30:26.456 A:middle
It would be too large.

619
00:30:27.096 --> 00:30:28.946 A:middle
And so what you generally see is

620
00:30:28.946 --> 00:30:33.346 A:middle
that a string is encoded
as, say, UTF-8 or UTF-16.

621
00:30:34.376 --> 00:30:37.446 A:middle
But working with those
UTF-8 or UTF-16 code points,

622
00:30:37.736 --> 00:30:40.556 A:middle
that requires Unicode expertise
to get right all the time.

623
00:30:42.246 --> 00:30:44.126 A:middle
And so we made a really
interesting decision here.

624
00:30:45.336 --> 00:30:49.066 A:middle
We decided not to provide the
super low-level operations

625
00:30:49.066 --> 00:30:52.856 A:middle
like length and characterAtIndex
to let you poke directly

626
00:30:52.856 --> 00:30:55.796 A:middle
at the UTF-16 or UTF-8 code
points, or whatever is stored

627
00:30:55.796 --> 00:30:59.786 A:middle
in the string because doing
so causes big problems.

628
00:30:59.886 --> 00:31:03.876 A:middle
Instead we want you to
use the high-level APIs

629
00:31:04.186 --> 00:31:06.726 A:middle
and let the library do
the hard work of dealing

630
00:31:06.726 --> 00:31:08.516 A:middle
with all the intricacies
of Unicode.

631
00:31:09.086 --> 00:31:13.056 A:middle
Of course, there's still common
operations you want to use.

632
00:31:13.546 --> 00:31:16.836 A:middle
You may want to count the number
of characters in a string,

633
00:31:17.526 --> 00:31:19.946 A:middle
so there's this countElements
algorithm.

634
00:31:19.946 --> 00:31:23.296 A:middle
It works on any sequence
and allows you to, well,

635
00:31:23.366 --> 00:31:25.176 A:middle
just count the number of
characters in a string,

636
00:31:25.546 --> 00:31:27.146 A:middle
and this produces
the right answer,

637
00:31:27.146 --> 00:31:29.566 A:middle
which is there are five
characters in this string.

638
00:31:30.426 --> 00:31:32.846 A:middle
Some of you will want to
work with code points, right.

639
00:31:33.336 --> 00:31:36.006 A:middle
You may be Unicode experts
and that's wonderful.

640
00:31:36.396 --> 00:31:38.206 A:middle
You can get access
to the code points.

641
00:31:38.356 --> 00:31:42.996 A:middle
There's a property UTF-16 that
gives you a lazily computed view

642
00:31:42.996 --> 00:31:46.976 A:middle
on the string producing
the UTF-16 code points

643
00:31:46.976 --> 00:31:47.746 A:middle
in that string.

644
00:31:49.316 --> 00:31:53.216 A:middle
And we can go walk over
the 16-bit unsigned integer

645
00:31:53.546 --> 00:31:54.656 A:middle
code points.

646
00:31:55.096 --> 00:31:58.536 A:middle
We can print out the number of
code points here and, of course,

647
00:31:58.536 --> 00:32:00.836 A:middle
you'll get the answer "6"

648
00:32:01.306 --> 00:32:04.966 A:middle
because there are six UTF-16
code points in this string.

649
00:32:06.056 --> 00:32:06.956 A:middle
The last thing I want to talk

650
00:32:06.956 --> 00:32:09.376 A:middle
about with strings
is the relationship

651
00:32:09.376 --> 00:32:11.466 A:middle
between string and NSSring.

652
00:32:12.726 --> 00:32:14.686 A:middle
So NSString has a wealth

653
00:32:14.926 --> 00:32:17.586 A:middle
of really great text
processing APIs

654
00:32:17.916 --> 00:32:19.856 A:middle
that you've probably
been using for years.

655
00:32:20.376 --> 00:32:23.886 A:middle
So we've made all those
Foundation APIs directly

656
00:32:23.886 --> 00:32:26.846 A:middle
available on the string
type, so the APIs you know

657
00:32:26.846 --> 00:32:29.506 A:middle
and love are there,
and you can use them.

658
00:32:30.716 --> 00:32:33.706 A:middle
Now in doing so, we've made
them a little bit more Swift.

659
00:32:33.706 --> 00:32:35.976 A:middle
We've tightened up the
type signatures so that

660
00:32:35.976 --> 00:32:38.996 A:middle
if you're going to split a
string into its components,

661
00:32:38.996 --> 00:32:41.826 A:middle
well, you're getting it back
an array of strings rather

662
00:32:41.826 --> 00:32:43.726 A:middle
than just an array
of somethings.

663
00:32:45.596 --> 00:32:49.316 A:middle
Now you may have developed
your own categories on NSString

664
00:32:49.566 --> 00:32:51.426 A:middle
with additional functionality
that you use

665
00:32:51.426 --> 00:32:52.896 A:middle
within your own applications.

666
00:32:53.896 --> 00:32:55.946 A:middle
You can get to those
with a simple Cast.

667
00:32:56.086 --> 00:32:59.626 A:middle
So you can take a Swift string,
turn it into an NSString,

668
00:32:59.796 --> 00:33:00.926 A:middle
so this is just a conversion,

669
00:33:01.986 --> 00:33:04.426 A:middle
and then call your
NSStringMethod.

670
00:33:05.636 --> 00:33:07.996 A:middle
If you find yourselves
doing this a lot,

671
00:33:08.696 --> 00:33:10.646 A:middle
feel free to just go ahead

672
00:33:10.646 --> 00:33:12.656 A:middle
and extend the underlying
string type.

673
00:33:12.966 --> 00:33:15.196 A:middle
Add your StringMethod,
make it a little more Swift

674
00:33:15.196 --> 00:33:17.486 A:middle
with strong type signatures,
closures if you'd like.

675
00:33:18.766 --> 00:33:22.146 A:middle
But this should help you feel
at home in Swift fairly quickly

676
00:33:22.376 --> 00:33:24.166 A:middle
and use the String type.

677
00:33:25.476 --> 00:33:29.306 A:middle
Now let's move from
String to a container.

678
00:33:29.566 --> 00:33:31.486 A:middle
Let's talk about Arrays.

679
00:33:32.376 --> 00:33:36.396 A:middle
So here we have toolbar
items that is in an NSArray.

680
00:33:37.036 --> 00:33:43.386 A:middle
That's going to come into
Swift as an array of AnyObject.

681
00:33:44.386 --> 00:33:46.656 A:middle
Now these two types
are fairly similar.

682
00:33:47.346 --> 00:33:49.826 A:middle
You can iterate over them
and what you're going to get

683
00:33:49.826 --> 00:33:52.396 A:middle
out of it are values
of type AnyObject.

684
00:33:52.466 --> 00:33:54.646 A:middle
They're objects but you don't
know what kind of object it is.

685
00:33:55.356 --> 00:33:57.486 A:middle
You can subscript into
them and, of course,

686
00:33:57.486 --> 00:33:58.786 A:middle
you will get an AnyObject.

687
00:34:00.256 --> 00:34:04.976 A:middle
Now, in Swift, you tend to deal
in typed arrays more often.

688
00:34:05.446 --> 00:34:07.906 A:middle
And so there are
some other operations

689
00:34:07.906 --> 00:34:09.846 A:middle
that the core language
needs to provide

690
00:34:09.846 --> 00:34:11.315 A:middle
for you to make this clean.

691
00:34:12.085 --> 00:34:16.696 A:middle
So maybe I'm composing my
toolbar items into a Swift array

692
00:34:17.176 --> 00:34:20.406 A:middle
and that Swift array is going
to contain UIBarButtonItems.

693
00:34:20.926 --> 00:34:24.716 A:middle
That's what actually goes into
the toolbar items property.

694
00:34:25.706 --> 00:34:29.636 A:middle
I can work with that Swift
Array and then I can assign it

695
00:34:29.636 --> 00:34:31.335 A:middle
into the AnyObject array.

696
00:34:31.335 --> 00:34:35.065 A:middle
So this is essentially doing
a safe upcast of any array

697
00:34:35.065 --> 00:34:37.636 A:middle
of ToolbarItems to any
array of AnyObjects.

698
00:34:38.456 --> 00:34:40.906 A:middle
It also happens to be
calling into Objective-C,

699
00:34:41.085 --> 00:34:43.916 A:middle
which we'll get to in a minute.

700
00:34:44.076 --> 00:34:48.025 A:middle
Now we also see the flip side
of this where we want to, say,

701
00:34:48.025 --> 00:34:49.636 A:middle
iterate over all
the ToolbarItems

702
00:34:50.735 --> 00:34:56.295 A:middle
in this particular view
controller and here we're going

703
00:34:56.295 --> 00:34:59.476 A:middle
to get AnyObject values and,
we talked about cast earlier,

704
00:34:59.476 --> 00:35:01.226 A:middle
so we can downcast each of them.

705
00:35:01.756 --> 00:35:04.406 A:middle
This is fine but it's a little
bit on the tedious side.

706
00:35:04.766 --> 00:35:07.076 A:middle
And so we have specialized
syntax here

707
00:35:07.296 --> 00:35:12.836 A:middle
to downcast an entire
array at a time doing the

708
00:35:12.836 --> 00:35:14.656 A:middle
"is kind of" class
checks necessary

709
00:35:14.656 --> 00:35:17.436 A:middle
to make this safe
lazily behind the scenes.

710
00:35:18.596 --> 00:35:19.966 A:middle
And then you can walk
over all with them.

711
00:35:20.516 --> 00:35:26.086 A:middle
[ Applause ]

712
00:35:26.586 --> 00:35:29.646 A:middle
Now, we've seen NSArrays
in the Objective-C side,

713
00:35:30.176 --> 00:35:32.506 A:middle
Swift arrays on the Swift side.

714
00:35:32.946 --> 00:35:35.116 A:middle
Let's take a little bit
of a peek under the hood

715
00:35:35.296 --> 00:35:38.226 A:middle
at how this actually
works because you're going

716
00:35:38.226 --> 00:35:41.526 A:middle
to be writing a lot of Swift
code that interacts with a lot

717
00:35:41.526 --> 00:35:43.626 A:middle
of Objective-C code and we
want this to perform well.

718
00:35:45.456 --> 00:35:48.496 A:middle
So there's a Swift array.

719
00:35:48.536 --> 00:35:52.896 A:middle
And the Swift array actually has
two internal representations.

720
00:35:53.826 --> 00:35:56.726 A:middle
Its first representation is
probably what you'd expect

721
00:35:56.726 --> 00:35:57.286 A:middle
out of Swift.

722
00:35:57.756 --> 00:35:59.206 A:middle
It's a native representation.

723
00:35:59.596 --> 00:36:02.166 A:middle
It has a length, which is the
number of elements in the array.

724
00:36:02.166 --> 00:36:04.316 A:middle
It has a capacity that's used

725
00:36:04.316 --> 00:36:07.026 A:middle
so we can algorithmically
efficiently add things

726
00:36:07.026 --> 00:36:07.556 A:middle
to the array.

727
00:36:09.126 --> 00:36:12.926 A:middle
And then it has the buffer of
elements that are in the array.

728
00:36:14.416 --> 00:36:17.916 A:middle
And, of course, those buffered
elements, whatever kind

729
00:36:17.916 --> 00:36:19.736 A:middle
of array it is, that's how
much storage they take.

730
00:36:19.736 --> 00:36:21.906 A:middle
If we have an array
of 32-bit integers,

731
00:36:21.906 --> 00:36:24.156 A:middle
each element takes
32 bits of storage.

732
00:36:24.156 --> 00:36:25.966 A:middle
There's not extra
boxing going on here,

733
00:36:26.666 --> 00:36:27.776 A:middle
no extra performance loss.

734
00:36:27.946 --> 00:36:30.986 A:middle
It's just a native buffer.

735
00:36:31.166 --> 00:36:33.906 A:middle
Now we also have this
second representation

736
00:36:34.526 --> 00:36:37.446 A:middle
and we do a couple of pointer
tricks so that we can fit it

737
00:36:37.446 --> 00:36:39.546 A:middle
into just a tiny
amount of memory.

738
00:36:40.116 --> 00:36:42.076 A:middle
And that's the Cocoa
representation.

739
00:36:43.236 --> 00:36:49.096 A:middle
So any Swift array can actually
be an NSArray underneath

740
00:36:49.256 --> 00:36:50.346 A:middle
as representation.

741
00:36:50.966 --> 00:36:54.476 A:middle
And all the operations
on an array handle both

742
00:36:54.476 --> 00:36:55.996 A:middle
of these representations.

743
00:36:56.486 --> 00:37:00.386 A:middle
So if I subscript my array and
it happens to be an NSArray,

744
00:37:00.916 --> 00:37:02.886 A:middle
we'll use object and
index behind the scenes.

745
00:37:03.666 --> 00:37:04.926 A:middle
So you get the result
that you want.

746
00:37:05.916 --> 00:37:07.606 A:middle
If we do append to
such an array, well,

747
00:37:07.636 --> 00:37:10.196 A:middle
we can flip the representation
quickly and give you

748
00:37:10.196 --> 00:37:11.566 A:middle
that efficient append operation.

749
00:37:12.166 --> 00:37:16.176 A:middle
So given these two
representations,

750
00:37:16.356 --> 00:37:20.066 A:middle
we can talk about the notion
of bridging, of converting

751
00:37:20.666 --> 00:37:23.746 A:middle
between an NSArray, as
Objective-C would see,

752
00:37:24.786 --> 00:37:26.936 A:middle
and a Swift array that
you use within Swift.

753
00:37:28.256 --> 00:37:29.216 A:middle
There's two directions here:

754
00:37:29.696 --> 00:37:31.686 A:middle
going to Objective-C
and coming back.

755
00:37:32.986 --> 00:37:36.416 A:middle
So first, let's talk
about coming back.

756
00:37:37.196 --> 00:37:39.036 A:middle
So we have an Objective-C
method.

757
00:37:39.036 --> 00:37:41.336 A:middle
In this case, it's the
getter for toolbar items.

758
00:37:41.766 --> 00:37:43.686 A:middle
In Objective-C, that
returns NSArray.

759
00:37:44.406 --> 00:37:47.576 A:middle
In Swift, that's going to come
back as an array of AnyObject.

760
00:37:48.236 --> 00:37:49.136 A:middle
How do we do this?

761
00:37:49.586 --> 00:37:51.406 A:middle
Well, given our two
representations,

762
00:37:51.956 --> 00:37:53.386 A:middle
it's extremely efficient
to do it

763
00:37:53.386 --> 00:37:54.976 A:middle
because we have our
representation

764
00:37:55.266 --> 00:37:57.846 A:middle
that can just take
that NSArray directly.

765
00:37:58.426 --> 00:38:00.616 A:middle
All we need to do is
one copy operation

766
00:38:00.946 --> 00:38:03.256 A:middle
to make sure the contents
don't change underneath us

767
00:38:03.256 --> 00:38:04.616 A:middle
if it's a mutable array.

768
00:38:05.746 --> 00:38:08.206 A:middle
But the common case here is
that it's not a mutable array.

769
00:38:08.336 --> 00:38:12.436 A:middle
It's an immutable NSArray and so
this copy operation is trivial.

770
00:38:12.436 --> 00:38:14.966 A:middle
It's a message send, it's
a retain, and that's it.

771
00:38:15.366 --> 00:38:16.926 A:middle
So its conversion
is extremely fast.

772
00:38:17.746 --> 00:38:20.646 A:middle
Let's talk about
the other direction,

773
00:38:21.576 --> 00:38:23.656 A:middle
going from a Swift
array to an NSArray.

774
00:38:24.146 --> 00:38:27.556 A:middle
So this would happen when we
take, say, our ToolbarItems.

775
00:38:27.556 --> 00:38:28.436 A:middle
It's a Swift array.

776
00:38:28.946 --> 00:38:31.036 A:middle
And we call the Objective-C
setter,

777
00:38:31.446 --> 00:38:32.886 A:middle
which expects an NSArray.

778
00:38:33.586 --> 00:38:36.036 A:middle
Well, now we have an
interesting question

779
00:38:36.906 --> 00:38:38.686 A:middle
because there's two possible
representations here.

780
00:38:39.176 --> 00:38:40.496 A:middle
There's the really easy answer.

781
00:38:41.036 --> 00:38:43.186 A:middle
It's already in the
Cocoa representation

782
00:38:43.386 --> 00:38:46.246 A:middle
and we can just hand off
the NSArray, no work at all.

783
00:38:47.696 --> 00:38:50.546 A:middle
But the native one, that a
different question entirely.

784
00:38:51.406 --> 00:38:55.906 A:middle
We could copy the whole buffer
but that would be awful.

785
00:38:55.906 --> 00:38:59.016 A:middle
We could possibly go
allocate a little shim object.

786
00:38:59.016 --> 00:39:00.636 A:middle
That's also possible.

787
00:39:01.346 --> 00:39:05.096 A:middle
Instead, we decided to make
our native representation

788
00:39:06.016 --> 00:39:08.866 A:middle
into a little bit of an
Objective-C object [laughter].

789
00:39:09.526 --> 00:39:12.376 A:middle
It's already an NSArray.

790
00:39:13.516 --> 00:39:15.986 A:middle
And we've optimized
the allocation here

791
00:39:16.406 --> 00:39:18.656 A:middle
so we can build these
objects super fast

792
00:39:19.476 --> 00:39:21.776 A:middle
and just pass off our
native representation

793
00:39:21.956 --> 00:39:24.826 A:middle
as if it were an NSArray
and it works beautifully

794
00:39:24.826 --> 00:39:26.466 A:middle
on the Objective-C side.

795
00:39:29.516 --> 00:39:33.856 A:middle
[ Applause ]

796
00:39:34.356 --> 00:39:37.216 A:middle
I think that's enough
of Bridging.

797
00:39:37.696 --> 00:39:39.106 A:middle
Let's talk about subclassing.

798
00:39:41.206 --> 00:39:52.556 A:middle
Okay. So, Swift objects are
all Objective-C objects.

799
00:39:53.776 --> 00:39:56.546 A:middle
Now what this means is that,
if you define a class in Swift,

800
00:39:57.456 --> 00:39:59.976 A:middle
it has basic Objective-C
interoperability built in.

801
00:40:00.226 --> 00:40:05.136 A:middle
We use the same layout as an
Objective-C class so there's an

802
00:40:05.136 --> 00:40:06.346 A:middle
"isa" pointer in there.

803
00:40:06.346 --> 00:40:09.366 A:middle
The "isa" pointer points
out to Objective-C metadata.

804
00:40:10.166 --> 00:40:12.306 A:middle
There's the same
underlying infrastructure,

805
00:40:12.306 --> 00:40:15.836 A:middle
the thing that makes "arch" work
and the basic frameworks work

806
00:40:15.836 --> 00:40:16.906 A:middle
with retain and release.

807
00:40:17.116 --> 00:40:18.296 A:middle
You can expect a class.

808
00:40:19.136 --> 00:40:19.786 A:middle
That sort of thing.

809
00:40:20.086 --> 00:40:20.896 A:middle
They're all available.

810
00:40:22.416 --> 00:40:25.376 A:middle
Now, if you really want to
make use of your classes

811
00:40:25.486 --> 00:40:29.386 A:middle
from within your
Objective-C code, well,

812
00:40:29.386 --> 00:40:32.246 A:middle
then you should inherit
from an Objective-C class,

813
00:40:32.616 --> 00:40:35.106 A:middle
whether it's NSObject
or some other class.

814
00:40:35.596 --> 00:40:38.926 A:middle
And this is going to expose your
class to the Objective-C world

815
00:40:38.926 --> 00:40:42.516 A:middle
and make all the things you
write in Swift available also

816
00:40:42.516 --> 00:40:43.606 A:middle
to your Objective-C code.

817
00:40:44.746 --> 00:40:47.226 A:middle
So we're going to continue
with our UIDocument example

818
00:40:47.226 --> 00:40:50.636 A:middle
from earlier and we're going to
create a little MyDocument class

819
00:40:50.676 --> 00:40:52.766 A:middle
that inherits from UIDocument.

820
00:40:53.266 --> 00:40:57.046 A:middle
And we're going to
talk about a couple

821
00:40:57.046 --> 00:40:58.666 A:middle
of the things that
subclasses do.

822
00:40:59.076 --> 00:41:00.266 A:middle
They override methods.

823
00:41:01.276 --> 00:41:03.546 A:middle
So here we're going to
override the handleError,

824
00:41:03.546 --> 00:41:05.566 A:middle
userInteractionPermitted method.

825
00:41:06.636 --> 00:41:09.486 A:middle
And you do this exactly
the same way as you'd do it

826
00:41:09.486 --> 00:41:11.156 A:middle
if you were overriding
a Swift method.

827
00:41:11.426 --> 00:41:12.196 A:middle
It doesn't matter.

828
00:41:12.196 --> 00:41:13.486 A:middle
The syntax is the same.

829
00:41:13.636 --> 00:41:15.856 A:middle
The fact that the super class
is written in Objective-C?

830
00:41:16.116 --> 00:41:18.596 A:middle
Completely irrelevant to
the syntax of the language

831
00:41:18.896 --> 00:41:19.796 A:middle
and how you work with it.

832
00:41:21.856 --> 00:41:23.916 A:middle
Now one thing to note
in Swift is that the

833
00:41:23.916 --> 00:41:26.726 A:middle
"override" keyword is mandatory.

834
00:41:28.146 --> 00:41:28.976 A:middle
Why do we do that?

835
00:41:29.296 --> 00:41:30.656 A:middle
There's a couple of
reasons for doing that.

836
00:41:31.346 --> 00:41:35.136 A:middle
One of the reasons is because
when you look at a method,

837
00:41:35.726 --> 00:41:38.306 A:middle
you probably want to know
if the intention here is

838
00:41:38.306 --> 00:41:41.046 A:middle
to override your
super class's behavior

839
00:41:41.046 --> 00:41:43.906 A:middle
because that's a really
important part of your API.

840
00:41:44.136 --> 00:41:45.136 A:middle
It's a really part

841
00:41:45.136 --> 00:41:48.166 A:middle
of understanding what this
method is supposed to do.

842
00:41:48.766 --> 00:41:54.236 A:middle
Now the other thing it does is
it helps overriding accidents.

843
00:41:55.236 --> 00:41:58.496 A:middle
For example, I meant to override
something from my super class,

844
00:41:59.056 --> 00:42:01.046 A:middle
but I typed part of
the selector wrong

845
00:42:01.796 --> 00:42:04.006 A:middle
and the method name
no longer overrides.

846
00:42:04.286 --> 00:42:06.896 A:middle
My code isn't running
and I have no idea why.

847
00:42:06.896 --> 00:42:09.696 A:middle
Well, with mandatory
override, we catch that.

848
00:42:09.946 --> 00:42:12.286 A:middle
If you didn't override something
and you thought you did,

849
00:42:12.986 --> 00:42:13.826 A:middle
compiler will complain.

850
00:42:15.456 --> 00:42:19.196 A:middle
There's also the real
surprise which is

851
00:42:19.256 --> 00:42:21.916 A:middle
when you override something
from your super class

852
00:42:21.966 --> 00:42:23.786 A:middle
that you didn't even
know existed.

853
00:42:24.386 --> 00:42:30.046 A:middle
And this is the case where you
just wrote a method and maybe

854
00:42:30.046 --> 00:42:32.266 A:middle
in this release that
method happens to exist

855
00:42:32.266 --> 00:42:34.276 A:middle
or maybe it doesn't
exist in this release,

856
00:42:34.736 --> 00:42:37.516 A:middle
but some joker added it to the
next release in the frameworks

857
00:42:37.516 --> 00:42:39.696 A:middle
that you use and now
you're overriding something

858
00:42:39.696 --> 00:42:41.166 A:middle
that you didn't know
existed at the time.

859
00:42:41.996 --> 00:42:44.886 A:middle
We can catch that by
requiring override throughout

860
00:42:45.356 --> 00:42:45.926 A:middle
the language.

861
00:42:46.516 --> 00:42:51.686 A:middle
We could also talk a little bit
about overriding properties.

862
00:42:53.436 --> 00:42:57.406 A:middle
So, in Swift, you don't
override the getter

863
00:42:57.586 --> 00:42:58.926 A:middle
or the setter separately.

864
00:42:59.146 --> 00:43:01.796 A:middle
Instead you override
the property itself

865
00:43:02.396 --> 00:43:06.116 A:middle
and then you provide a getter
or a setter as appropriate.

866
00:43:06.716 --> 00:43:08.276 A:middle
So here we're doing
something very simple.

867
00:43:08.276 --> 00:43:10.476 A:middle
We're overriding the
description property

868
00:43:11.046 --> 00:43:12.616 A:middle
and providing a new
getter for it.

869
00:43:13.806 --> 00:43:16.176 A:middle
Now what this means to
the Objective-C runtime,

870
00:43:16.416 --> 00:43:17.636 A:middle
to your Objective-C code,

871
00:43:17.636 --> 00:43:19.326 A:middle
is that you've overridden
the getter.

872
00:43:20.546 --> 00:43:23.276 A:middle
But the semantic model
in Swift is different.

873
00:43:23.276 --> 00:43:26.386 A:middle
It's based on overriding the
actual thing that was declared.

874
00:43:26.386 --> 00:43:27.646 A:middle
In this case, the property.

875
00:43:28.216 --> 00:43:32.636 A:middle
As I mentioned before,
NSError is going to come back.

876
00:43:33.446 --> 00:43:35.966 A:middle
So we have contentsForType
error we're going

877
00:43:35.966 --> 00:43:37.346 A:middle
to override in our subclass.

878
00:43:37.766 --> 00:43:40.576 A:middle
And remember that the
Objective-C method took NSError,

879
00:43:42.226 --> 00:43:45.806 A:middle
a C pointer to an NSError
which could be nil.

880
00:43:47.346 --> 00:43:49.986 A:middle
The way we work with
these in Swift is

881
00:43:49.986 --> 00:43:53.646 A:middle
that the NSErrorPointer class
provides a couple of operations

882
00:43:53.646 --> 00:43:55.336 A:middle
that you would expect
out of a pointer.

883
00:43:55.736 --> 00:43:58.966 A:middle
You can test it for nil, as
we do in the if check here,

884
00:43:59.396 --> 00:44:02.116 A:middle
to see whether we were actually
given a valid point error

885
00:44:02.116 --> 00:44:04.216 A:middle
where it's being given
nil by our caller.

886
00:44:05.426 --> 00:44:07.596 A:middle
Now, if it's not
nil, we can point

887
00:44:07.596 --> 00:44:10.006 A:middle
at the memory location
associated with that pointer

888
00:44:10.556 --> 00:44:14.756 A:middle
by referring to it as
error.memory and we can read

889
00:44:14.756 --> 00:44:16.846 A:middle
from that memory or
write to that memory

890
00:44:16.846 --> 00:44:18.356 A:middle
by just reading or
signing to it.

891
00:44:19.566 --> 00:44:21.426 A:middle
Now, and this error pointer
is going to take care

892
00:44:21.426 --> 00:44:24.726 A:middle
of the nitty-gritty details
of making this auto-releasing

893
00:44:24.866 --> 00:44:27.146 A:middle
to fit in with the
code conventions

894
00:44:27.146 --> 00:44:29.316 A:middle
of Cocoa NSError handling.

895
00:44:29.316 --> 00:44:33.146 A:middle
So it's actually fairly easy
to deal with the C pointer

896
00:44:33.346 --> 00:44:34.516 A:middle
from within the Swift world.

897
00:44:35.266 --> 00:44:36.626 A:middle
Now let's take a look
at the Swift class

898
00:44:36.626 --> 00:44:37.856 A:middle
that we've been building here.

899
00:44:38.436 --> 00:44:42.266 A:middle
We have MyDocument.

900
00:44:42.266 --> 00:44:43.796 A:middle
It inherits from UIDocument.

901
00:44:44.356 --> 00:44:45.556 A:middle
It has a property in it.

902
00:44:45.556 --> 00:44:47.226 A:middle
It has some method overrides.

903
00:44:47.986 --> 00:44:50.106 A:middle
It's just a Swift class
through and through.

904
00:44:51.256 --> 00:44:54.316 A:middle
But all of this is
accessible directly

905
00:44:54.316 --> 00:44:56.096 A:middle
in your Objective-C code.

906
00:44:57.386 --> 00:44:59.326 A:middle
So if you project
this into Objective-C,

907
00:44:59.886 --> 00:45:01.656 A:middle
it would look like this.

908
00:45:01.656 --> 00:45:04.406 A:middle
All the same elements are there.

909
00:45:04.406 --> 00:45:05.306 A:middle
We have properties.

910
00:45:05.306 --> 00:45:06.166 A:middle
We have methods.

911
00:45:06.686 --> 00:45:08.636 A:middle
Now there's some interesting
things to point out.

912
00:45:09.216 --> 00:45:12.596 A:middle
Well, for one, we have
this item's property

913
00:45:12.596 --> 00:45:13.776 A:middle
that is in an NSArray.

914
00:45:14.866 --> 00:45:16.596 A:middle
Remember, we talked
about bridging here.

915
00:45:17.836 --> 00:45:21.046 A:middle
The original Swift code
had an array of strings.

916
00:45:22.496 --> 00:45:25.416 A:middle
We bridged that seamlessly
over to an NSArray

917
00:45:25.446 --> 00:45:27.666 A:middle
that contains NSString objects

918
00:45:27.866 --> 00:45:29.626 A:middle
for your Objective-C
code to use.

919
00:45:30.146 --> 00:45:35.166 A:middle
So you can use strong typing
in the Swift world and it maps

920
00:45:35.166 --> 00:45:38.606 A:middle
over to the natural thing
within the Objective-C world.

921
00:45:39.746 --> 00:45:43.486 A:middle
The other thing I want to point
out is this really ugly name

922
00:45:43.486 --> 00:45:44.436 A:middle
up top you've noticed.

923
00:45:45.346 --> 00:45:46.466 A:middle
So this is a mangled name.

924
00:45:47.386 --> 00:45:50.986 A:middle
Usually you're going to see
this as MyApp.MyDocument,

925
00:45:51.996 --> 00:45:53.716 A:middle
unless you're poking at
the internal somewhere.

926
00:45:54.306 --> 00:46:00.126 A:middle
And the purpose of this mangled
name is to put everything

927
00:46:00.126 --> 00:46:02.566 A:middle
in a namespace of some
sort so you don't have

928
00:46:02.566 --> 00:46:04.756 A:middle
to prefix all of
your class names.

929
00:46:05.616 --> 00:46:09.436 A:middle
Instead, what Swift does
is it puts the module name,

930
00:46:09.496 --> 00:46:11.786 A:middle
which is your target, your
framework, or your app -

931
00:46:12.886 --> 00:46:16.186 A:middle
that name into the names
of the classes it creates

932
00:46:16.386 --> 00:46:18.956 A:middle
so you can use the
simple names that you want

933
00:46:18.956 --> 00:46:21.486 A:middle
to use throughout your
application and not worry

934
00:46:21.486 --> 00:46:24.246 A:middle
about a conflict with something
else in the system somewhere.

935
00:46:26.516 --> 00:46:32.286 A:middle
[ Applause ]

936
00:46:32.786 --> 00:46:34.106 A:middle
When you're writing
your Swift Classes,

937
00:46:34.326 --> 00:46:36.436 A:middle
you do need to be a
little bit cognizant

938
00:46:37.006 --> 00:46:38.886 A:middle
of the limits of Objective-C.

939
00:46:39.906 --> 00:46:42.286 A:middle
Swift has a lot of cool
features; you might want

940
00:46:42.286 --> 00:46:45.336 A:middle
to use them -Tuples,
Generics and so on.

941
00:46:45.876 --> 00:46:48.426 A:middle
And if you go crazy
in your classes

942
00:46:48.426 --> 00:46:51.526 A:middle
and you use these features,
you might be a little surprised

943
00:46:51.526 --> 00:46:55.966 A:middle
that this generic method that
returns a tuple doesn't show

944
00:46:55.966 --> 00:46:58.576 A:middle
up in your Objective-C code
because Objective-C has no way

945
00:46:58.576 --> 00:46:59.766 A:middle
to express that signature.

946
00:47:00.306 --> 00:47:01.076 A:middle
There's nothing we can do.

947
00:47:01.076 --> 00:47:02.386 A:middle
We don't have tuples
in Objective-C.

948
00:47:04.216 --> 00:47:07.186 A:middle
So if this happens to you
and you're surprised by it,

949
00:47:08.176 --> 00:47:10.046 A:middle
there's an attribute you
can add to your method.

950
00:47:10.716 --> 00:47:12.046 A:middle
It's the objc attribute.

951
00:47:12.596 --> 00:47:16.656 A:middle
And what this does is it
asks the compiler to check

952
00:47:17.166 --> 00:47:22.326 A:middle
and make sure that this method
or property or initializer

953
00:47:22.326 --> 00:47:26.636 A:middle
or whatever is expressible in
Objective-C so it can be used

954
00:47:26.636 --> 00:47:27.856 A:middle
from your Objective-C code.

955
00:47:28.566 --> 00:47:31.566 A:middle
And if it's not expressible in
Objective-C for some reason,

956
00:47:31.896 --> 00:47:33.696 A:middle
the compiler will
give you a hard error

957
00:47:33.696 --> 00:47:36.536 A:middle
to tell you this is not
something you can use

958
00:47:36.536 --> 00:47:37.246 A:middle
from Objective-C.

959
00:47:39.006 --> 00:47:42.676 A:middle
Now the objc attribute
actually has a second purpose.

960
00:47:42.866 --> 00:47:45.626 A:middle
And that's controlling
the names that you see

961
00:47:45.626 --> 00:47:47.386 A:middle
in the Objective-C
side of things.

962
00:47:48.456 --> 00:47:50.096 A:middle
So, here's a property enabled.

963
00:47:50.286 --> 00:47:51.046 A:middle
It has a getter.

964
00:47:51.046 --> 00:47:51.806 A:middle
It has a setter.

965
00:47:53.486 --> 00:47:56.336 A:middle
In Objective-C this is going to
come through as a property named

966
00:47:56.336 --> 00:48:00.216 A:middle
"enabled," a getter named
"enabled," and a setter named

967
00:48:00.216 --> 00:48:04.436 A:middle
"setEnabled:" That's
not Cocoa convention.

968
00:48:04.596 --> 00:48:07.346 A:middle
You'd really rather the call,
the getter, "isEnabled".

969
00:48:08.726 --> 00:48:11.186 A:middle
And so to do that we just
use the objc attribute,

970
00:48:11.946 --> 00:48:13.976 A:middle
provide it with the
selector "isEnabled"

971
00:48:14.346 --> 00:48:17.136 A:middle
so we can control
the mapping ourselves

972
00:48:17.136 --> 00:48:18.746 A:middle
between these two languages.

973
00:48:19.476 --> 00:48:21.206 A:middle
I don't expect you
to do this often,

974
00:48:21.856 --> 00:48:24.866 A:middle
but it's there if you need it.

975
00:48:25.136 --> 00:48:29.746 A:middle
You can also do this
for the name of a class.

976
00:48:29.916 --> 00:48:32.106 A:middle
And what we have here
in the parentheses,

977
00:48:32.326 --> 00:48:36.806 A:middle
in the objc attribute, is the
non-named space name of a class.

978
00:48:37.406 --> 00:48:38.706 A:middle
So why would you do this?

979
00:48:39.206 --> 00:48:42.556 A:middle
Well, perhaps you're porting
part of your application

980
00:48:42.556 --> 00:48:44.496 A:middle
from Objective-C to
Swift for some reason.

981
00:48:45.036 --> 00:48:46.906 A:middle
And so you had ABCMyDocument.

982
00:48:47.226 --> 00:48:48.816 A:middle
Now you just want to
call it MyDocument

983
00:48:48.816 --> 00:48:50.316 A:middle
because you're sick
of typing ABC.

984
00:48:51.346 --> 00:48:53.876 A:middle
However, you have some
archives that you still want

985
00:48:53.876 --> 00:48:55.446 A:middle
to have work, because
this is going

986
00:48:55.446 --> 00:48:57.466 A:middle
to be a drop-in compatible
implementation.

987
00:48:58.316 --> 00:49:00.116 A:middle
In Swift, for your
Objective-C class,

988
00:49:00.476 --> 00:49:01.976 A:middle
you can use the objc attribute

989
00:49:02.116 --> 00:49:06.676 A:middle
to give this class the
runtime name of ABCMyDocument

990
00:49:06.926 --> 00:49:08.526 A:middle
and keep all of your
archives working.

991
00:49:08.526 --> 00:49:11.836 A:middle
One last thing I
promised to talk about,

992
00:49:12.276 --> 00:49:14.246 A:middle
and that's CF Interoperability.

993
00:49:15.286 --> 00:49:20.216 A:middle
So by CF we're referring
to all of the C-like APIs

994
00:49:20.296 --> 00:49:22.686 A:middle
that work with the C objects.

995
00:49:22.966 --> 00:49:24.476 A:middle
So, this is Core Foundation.

996
00:49:24.476 --> 00:49:27.706 A:middle
This is Core Graphics
and other frameworks,

997
00:49:27.706 --> 00:49:29.056 A:middle
maybe some of your
own frameworks.

998
00:49:29.866 --> 00:49:32.976 A:middle
And let's take a
little look at using CF,

999
00:49:33.196 --> 00:49:35.906 A:middle
particularly Core
Graphics in Objective-C.

1000
00:49:36.256 --> 00:49:38.426 A:middle
I'm going to do something
really simple here.

1001
00:49:38.496 --> 00:49:42.806 A:middle
I'm going to draw a gradient in
a rectangle using Core Graphics.

1002
00:49:43.276 --> 00:49:46.686 A:middle
Here's my start.

1003
00:49:47.096 --> 00:49:48.916 A:middle
I need to go build
up the ColorSpace

1004
00:49:49.006 --> 00:49:49.986 A:middle
and build up the Gradient.

1005
00:49:50.036 --> 00:49:54.496 A:middle
Now there's a couple of things
of here that I find non-optimal.

1006
00:49:55.236 --> 00:49:56.956 A:middle
So the one thing
is bridge casts.

1007
00:49:57.916 --> 00:49:58.726 A:middle
So we're in ARC.

1008
00:50:00.056 --> 00:50:00.666 A:middle
It's partly great.

1009
00:50:00.666 --> 00:50:02.366 A:middle
It's handling our
NSArray for us.

1010
00:50:02.366 --> 00:50:04.596 A:middle
We're using the nice
array literal syntax.

1011
00:50:04.846 --> 00:50:09.136 A:middle
But now we need to do bridge
casts between CGColorRef and id

1012
00:50:09.136 --> 00:50:11.296 A:middle
so we can put things
into the NSArray.

1013
00:50:12.866 --> 00:50:15.536 A:middle
And we have this
CFArray cast sort

1014
00:50:15.536 --> 00:50:16.836 A:middle
of doing toll-free
bridging there

1015
00:50:16.996 --> 00:50:19.296 A:middle
between the NSArray
and the CFArray.

1016
00:50:20.666 --> 00:50:24.076 A:middle
And there's also this
semi-amusing thing

1017
00:50:24.076 --> 00:50:26.656 A:middle
that we're using three
different kinds of arrays

1018
00:50:27.186 --> 00:50:28.356 A:middle
in four lines of code.

1019
00:50:28.796 --> 00:50:34.246 A:middle
And you can write this - you
can try to write this better.

1020
00:50:34.246 --> 00:50:37.546 A:middle
I couldn't, actually, find a way
to make it cleaner than this.

1021
00:50:38.216 --> 00:50:40.186 A:middle
And it's really unfortunate

1022
00:50:40.416 --> 00:50:43.236 A:middle
because the NSArray gives
us some useful behavior.

1023
00:50:43.236 --> 00:50:45.056 A:middle
ARC is managing its
lifetime for us.

1024
00:50:45.056 --> 00:50:45.686 A:middle
That's great.

1025
00:50:46.086 --> 00:50:49.676 A:middle
We need the C Array because
we need to put CGFloats in it,

1026
00:50:50.246 --> 00:50:52.166 A:middle
and we can't do that
within NSArray.

1027
00:50:53.596 --> 00:50:56.256 A:middle
And finally, we need to
do the toll-free bridging

1028
00:50:56.256 --> 00:51:00.846 A:middle
over to CFArrayRef
because that's what we use

1029
00:51:00.846 --> 00:51:04.846 A:middle
with Core Graphics APIs.

1030
00:51:05.056 --> 00:51:07.066 A:middle
Now, moving along, we
can create some points

1031
00:51:07.066 --> 00:51:10.696 A:middle
with CGPointMake and, of course,
even though you're under ARC

1032
00:51:10.986 --> 00:51:12.996 A:middle
where memory management
is automatic,

1033
00:51:13.366 --> 00:51:15.556 A:middle
it's not automated
for CF things.

1034
00:51:15.556 --> 00:51:17.796 A:middle
So we have to remember
to release the ColorSpace

1035
00:51:17.896 --> 00:51:18.906 A:middle
and release the Gradient.

1036
00:51:19.636 --> 00:51:21.046 A:middle
We feel like we can
do a little bit better

1037
00:51:21.046 --> 00:51:21.816 A:middle
in the world of Swift.

1038
00:51:23.106 --> 00:51:26.686 A:middle
So let's start again,
this time in Swift.

1039
00:51:27.126 --> 00:51:29.296 A:middle
And first, let's
build our colorSpace.

1040
00:51:30.256 --> 00:51:33.156 A:middle
So here we're just calling
CGColorSpaceCreateDeviceRGB().

1041
00:51:34.746 --> 00:51:35.996 A:middle
Nothing different about that.

1042
00:51:36.856 --> 00:51:39.236 A:middle
However, the type that we infer

1043
00:51:39.236 --> 00:51:43.106 A:middle
for this ColorSpace
variable is CGColorSpace.

1044
00:51:44.016 --> 00:51:46.406 A:middle
Note the lack of a ref
at the end of this.

1045
00:51:46.986 --> 00:51:49.006 A:middle
This isn't some opaque pointer.

1046
00:51:49.686 --> 00:51:54.386 A:middle
This is the CGColorSpace
class that we've created.

1047
00:51:55.866 --> 00:51:57.676 A:middle
What's the nice thing
about being a class?

1048
00:51:57.996 --> 00:52:00.226 A:middle
Well, that means we're in
the ARC model and we're going

1049
00:52:00.226 --> 00:52:02.606 A:middle
to automatically manage
the memory for you.

1050
00:52:04.516 --> 00:52:09.946 A:middle
[ Applause ]

1051
00:52:10.446 --> 00:52:13.166 A:middle
Let's go a little
further and create

1052
00:52:13.166 --> 00:52:14.446 A:middle
that Gradient we talked about.

1053
00:52:15.896 --> 00:52:18.936 A:middle
So here, remember, we need to
pass a couple of arrays through.

1054
00:52:19.816 --> 00:52:23.426 A:middle
We can use this nice
Swift array literal syntax

1055
00:52:23.906 --> 00:52:26.456 A:middle
to form an array containing
startColor and Color.

1056
00:52:27.296 --> 00:52:30.166 A:middle
We're doing all of the bridging
automatically here for you.

1057
00:52:30.426 --> 00:52:32.186 A:middle
So we've created
the NSArray we need.

1058
00:52:32.516 --> 00:52:36.386 A:middle
We've toll-free bridged it to
the CFArray behind the scenes

1059
00:52:36.536 --> 00:52:38.616 A:middle
so you don't have to deal
with the fact that there are

1060
00:52:38.616 --> 00:52:40.106 A:middle
so many array types
running around.

1061
00:52:40.606 --> 00:52:44.606 A:middle
Did the exact same
thing for the C parts.

1062
00:52:45.226 --> 00:52:48.936 A:middle
So here we just have an array
of floating point values.

1063
00:52:49.366 --> 00:52:52.756 A:middle
So it's treated as a native
Swift array of CGFloats

1064
00:52:53.866 --> 00:52:57.516 A:middle
that we bridged seamlessly
to the underlying C array

1065
00:52:57.776 --> 00:52:59.436 A:middle
that this C function expects.

1066
00:52:59.926 --> 00:53:03.136 A:middle
Let's keep going with
our example here.

1067
00:53:04.976 --> 00:53:08.716 A:middle
CGPoint. You can use
CGPointMake if you want.

1068
00:53:09.086 --> 00:53:10.106 A:middle
It's perfectly fine.

1069
00:53:10.106 --> 00:53:13.126 A:middle
It works exactly the same way
as it does in Objective-C.

1070
00:53:14.256 --> 00:53:16.556 A:middle
However, whenever
we import a struct,

1071
00:53:16.726 --> 00:53:20.346 A:middle
like CGPoint is a struct, we
provide it with initializers

1072
00:53:21.126 --> 00:53:22.626 A:middle
that have labeled arguments.

1073
00:53:23.056 --> 00:53:26.256 A:middle
And so a better way to
build CGPoints in Swift is

1074
00:53:26.496 --> 00:53:29.706 A:middle
to just construct a
CGPoint value using

1075
00:53:29.706 --> 00:53:32.046 A:middle
that same construction
syntax we've been talking

1076
00:53:32.046 --> 00:53:33.266 A:middle
about throughout this talk.

1077
00:53:34.726 --> 00:53:37.506 A:middle
And then use the
argument labels x and y

1078
00:53:37.806 --> 00:53:39.926 A:middle
to make it absolutely
clear what you're doing.

1079
00:53:39.926 --> 00:53:42.996 A:middle
And this brings a
little bit of a flavor

1080
00:53:43.146 --> 00:53:46.646 A:middle
of that nice Cocoa readability
using argument labels

1081
00:53:47.036 --> 00:53:48.646 A:middle
into the underlying CF APIs.

1082
00:53:48.646 --> 00:53:52.366 A:middle
And that's it for
our example in Swift.

1083
00:53:52.846 --> 00:53:53.626 A:middle
It's smaller.

1084
00:53:53.626 --> 00:53:54.416 A:middle
It's easier.

1085
00:53:54.416 --> 00:53:56.746 A:middle
There's far fewer concepts
that you have to deal

1086
00:53:56.746 --> 00:53:58.976 A:middle
with because we've automatically
taken over the management.

1087
00:53:59.516 --> 00:54:06.356 A:middle
[ Applause ]

1088
00:54:06.856 --> 00:54:09.086 A:middle
Now you may have some of
your own APIs that we refer

1089
00:54:09.086 --> 00:54:11.066 A:middle
to as explicitly bridged.

1090
00:54:11.726 --> 00:54:14.046 A:middle
So these are CF-like APIs

1091
00:54:14.526 --> 00:54:17.136 A:middle
where we're not quite sure
whether you're following all the

1092
00:54:17.136 --> 00:54:22.066 A:middle
CF memory conventions because,
unlike the world of Cocoa

1093
00:54:22.066 --> 00:54:25.126 A:middle
which is fairly tame, and we've
been following conventions

1094
00:54:25.126 --> 00:54:28.016 A:middle
fairly well for many years,
we haven't been following them

1095
00:54:28.016 --> 00:54:30.056 A:middle
so well in C as a community.

1096
00:54:30.746 --> 00:54:34.356 A:middle
And so we may have this
function GetRandomColor,

1097
00:54:34.696 --> 00:54:35.886 A:middle
produces some random color.

1098
00:54:36.976 --> 00:54:40.836 A:middle
When we pull this in, the Swift
compiler doesn't know whether we

1099
00:54:40.836 --> 00:54:43.886 A:middle
can really trust that this
returns plus zero or not.

1100
00:54:43.956 --> 00:54:46.186 A:middle
It has get in the name
but we're not sure.

1101
00:54:46.686 --> 00:54:49.126 A:middle
And so we do the safe
thing and we import it

1102
00:54:49.126 --> 00:54:51.356 A:middle
as an Unmanaged&lt;CGColor&gt;

1103
00:54:52.546 --> 00:54:55.326 A:middle
which means we can't directly
manage the memory here

1104
00:54:55.326 --> 00:54:57.076 A:middle
because we don't know
what the conventions are.

1105
00:54:58.656 --> 00:55:00.536 A:middle
So what is this Unmanaged thing?

