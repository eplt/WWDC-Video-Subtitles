1
00:00:20,187 --> 00:00:21,154
Apps的安全


2
00:00:21,488 --> 00:00:22,990
你们好 谢谢


3
00:00:26,360 --> 00:00:29,663
我是伊凡是Apple公司安全
及隐私策略小组的负责人


4
00:00:31,098 --> 00:00:32,566
今天我们来谈一谈安全


5
00:00:33,834 --> 00:00:38,639
事实上今天将主要谈的是设备安全


6
00:00:39,439 --> 00:00:43,143
现在你们也知道我们
设备的安全性能非常高


7
00:00:43,310 --> 00:00:47,347
有些安全性能是OSX
或IOS所特有的是两个平台兼有的


8
00:00:48,215 --> 00:00:50,450
我们将继续开发这些性能


9
00:00:50,651 --> 00:00:54,054
你们也将看到我们在
这领域会不断地创新


10
00:00:54,721 --> 00:00:58,492
今天我会抽些时间和
你们简单谈谈网络安全


11
00:01:00,561 --> 00:01:02,696
一谈到网络安全你们大部分人都会想到


12
00:01:02,763 --> 00:01:06,834
HTTPS我们多数也是在浏览器的
锁定图标中见过它


13
00:01:08,502 --> 00:01:13,140
在过去网站会使用HTTPS和TLS


14
00:01:13,207 --> 00:01:15,475
来传输一些敏感信息


15
00:01:17,144 --> 00:01:20,981
在我们看来信用卡信息
已算不上敏感信息


16
00:01:21,782 --> 00:01:25,152
所有的用户信息才是真正的敏感信息


17
00:01:25,219 --> 00:01:29,489
而作为开发者认为不敏感的
信息在用户看来可能就是敏感信息


18
00:01:31,692 --> 00:01:34,595
TLS真正重要的一点
也是我们通常想不到的


19
00:01:34,661 --> 00:01:39,066
就是它不仅会保护网络运行的信息安全


20
00:01:39,666 --> 00:01:42,069
而且还保护连接的完整性


21
00:01:42,769 --> 00:01:44,905
网络面临的威胁已经变了


22
00:01:45,873 --> 00:01:48,842
已不再是戴着黑色面罩躲藏


23
00:01:48,909 --> 00:01:51,345
在网络的某些角落
去窃取你信用卡数字那些人


24
00:01:52,012 --> 00:01:55,182
事实上 用户是想保护自己免受
其他威胁攻击


25
00:01:55,616 --> 00:01:58,151
例如 网络服务供应商


26
00:01:58,218 --> 00:02:00,821
他们向每个应用中插入跟踪标头信息 


27
00:02:01,188 --> 00:02:04,558
或直接记录浏览历史
以进行广告定向投放


28
00:02:06,260 --> 00:02:11,865
所以 我们认为TLS在2015年的
最主要职责就是保护消费者


29
00:02:12,232 --> 00:02:13,066
网络信息安全


30
00:02:15,836 --> 00:02:17,771
但是TLS仍有漏洞


31
00:02:18,539 --> 00:02:20,941
很多服务器仍使用TLS 1版本


32
00:02:21,241 --> 00:02:23,010
这个版本太老了已有16年的历史了


33
00:02:23,377 --> 00:02:26,747
连最新版本TLS 1.2
也已经有7年的历史了


34
00:02:27,080 --> 00:02:31,785
TLS 1.2包含了很多重要的
协议加密升级功能能够抵抗我们


35
00:02:31,852 --> 00:02:35,322
正面临或未来要面临的各种威胁


36
00:02:36,523 --> 00:02:40,027
事实上 连TLS1.2版本也有漏洞


37
00:02:41,562 --> 00:02:43,664
根据TLS的运作方式如果黑客


38
00:02:43,730 --> 00:02:46,200
黑掉一个服务器并窃取你的TLS密钥


39
00:02:46,633 --> 00:02:51,939
那么他们就可以破解服务
器曾经加载过的加密数据


40
00:02:52,439 --> 00:02:53,907
毫无疑问这是非常恐怖的


41
00:02:54,474 --> 00:02:57,411
不过有个正向加密的
软件可解决这一问题


42
00:02:57,511 --> 00:02:59,813
有了正向加密即使黑客黑掉一个


43
00:02:59,880 --> 00:03:03,083
服务器窃取了TLS密钥
他们也只能用密钥


44
00:03:03,150 --> 00:03:04,985
破解服务器未来加密传输的数据


45
00:03:05,152 --> 00:03:07,554
不能破解已加密的历史数据


46
00:03:08,555 --> 00:03:10,824
这样非常棒 因为它能减少庞大的网络


47
00:03:10,891 --> 00:03:11,992
加密数据负荷


48
00:03:13,861 --> 00:03:17,197
TLS支持正向加密正向加密过程通过


49
00:03:17,264 --> 00:03:19,433
使用密码组完成而密码组是由启动


50
00:03:19,499 --> 00:03:22,736
服务器所必须的加密基元组合而成


51
00:03:23,370 --> 00:03:26,773
所以 你们的服务器无需运行TLS
只需运行TLS 1.2


52
00:03:26,840 --> 00:03:31,078
为了获得正向加密
你们必须对其进行设置


53
00:03:32,479 --> 00:03:36,083
我为什么告诉你这些呢
引用蒂姆的话我会让你们读一下


54
00:03:42,789 --> 00:03:44,558
我们必须修正这问题


55
00:03:46,159 --> 00:03:47,594
为了帮助你们不出问题


56
00:03:48,595 --> 00:03:51,265
我们将向你们介绍App
Transport Security


57
00:03:51,832 --> 00:03:52,666
它是这样运行的


58
00:03:53,800 --> 00:03:58,405
在OSX EI Capitan
或ISO9打开你们的应用


59
00:03:59,540 --> 00:04:03,010
默认它这样就不会连接到
不受保护的HTTP链接   


60
00:04:03,076 --> 00:04:05,846
它们会连接失败
而且程序生成的任何TLS连接


61
00:04:05,913 --> 00:04:10,184
也不会按照我刚才描述的最优做法


62
00:04:10,450 --> 00:04:12,452
这就是带有正向加密的TLS 1.2


63
00:04:13,020 --> 00:04:16,190
任何已知的不安全加
密基元均无法被允许


64
00:04:16,490 --> 00:04:18,825
密钥尺寸也有最低要求


65
00:04:19,526 --> 00:04:21,695
现在你可能不会完全按照这些要求去做


66
00:04:21,762 --> 00:04:25,132
立即遵守这些要求不过没关系


67
00:04:25,199 --> 00:04:27,367
你可以在
Info plist中根据每种情况


68
00:04:27,434 --> 00:04:31,872
指定例外情况或进行全局覆盖


69
00:04:32,472 --> 00:04:35,742
但是就整个行业而言我们必须尽快做到


70
00:04:35,809 --> 00:04:38,378
让用户信息无法接触到未加密网络


71
00:04:39,479 --> 00:04:40,380
我们需要你们的帮助


72
00:04:41,682 --> 00:04:43,717
谢谢大家下面由我的
同事皮埃尔给你们谈谈


73
00:04:43,784 --> 00:04:46,486
System Integration
Protection


74
00:04:51,491 --> 00:04:52,326
谢谢伊凡


75
00:04:54,795 --> 00:04:57,464
嗨 大家好 我是
皮埃尔•奥利佛•马特尔


76
00:04:57,798 --> 00:05:01,101
担任Apple公司
沙盒技术部的技术经理


77
00:05:02,402 --> 00:05:05,239
今天我和大家谈谈 System
Integration Protection


78
00:05:05,405 --> 00:05:07,140
这是我们在
El Capitan引进的


79
00:05:07,207 --> 00:05:08,942
新型硬化机理


80
00:05:10,344 --> 00:05:14,114
在探究细节之前我想退一步


81
00:05:14,548 --> 00:05:16,650
给大家说说我们要达成什么目标


82
00:05:17,918 --> 00:05:23,123
在Apple公司 我们团队的使命
是确保用户能享受到


83
00:05:23,190 --> 00:05:25,726
产品带来的极致体验我们相信


84
00:05:25,792 --> 00:05:27,995
我们可以保护他们的


85
00:05:28,061 --> 00:05:32,366
个人资料即使资料被


86
00:05:32,666 --> 00:05:35,602
恶意软件甚至更糟糕的


87
00:05:36,103 --> 00:05:39,206
编写软件攻击伤害也会很小


88
00:05:40,807 --> 00:05:44,244
为了达到这个目的我们已设计和集成


89
00:05:44,378 --> 00:05:47,514
各项安全技术正如伊凡上面所提到的


90
00:05:47,981 --> 00:05:50,217
这些年研发的iOS和 OS X


91
00:05:50,884 --> 00:05:52,553
研发所采用的一种


92
00:05:52,619 --> 00:05:56,456
配额和原则就是深度防御概念


93
00:05:57,724 --> 00:06:00,027
使用的关键原则你可能也


94
00:06:00,093 --> 00:06:03,197
有所耳闻 那就是安全与层有关


95
00:06:04,231 --> 00:06:06,900
你不能把所有鸡蛋都
放在同一个篮子里


96
00:06:06,967 --> 00:06:10,571
不要指望单层保护设备就完事大吉了


97
00:06:10,871 --> 00:06:13,006
因为不管这个保护层


98
00:06:13,774 --> 00:06:18,111
防弹性 防水性 抗震性有多好


99
00:06:18,178 --> 00:06:21,648
一旦坏掉就


100
00:06:22,382 --> 00:06:23,984
功亏一篑


101
00:06:25,652 --> 00:06:28,755
相反 你们应该依靠多层保护


102
00:06:29,456 --> 00:06:32,793
原则上有了多层安全保护


103
00:06:33,293 --> 00:06:35,562
不仅能推迟黑客入侵时间


104
00:06:36,096 --> 00:06:37,564
还能限制被攻击范围


105
00:06:39,132 --> 00:06:41,235
到现在为止 深度预防


106
00:06:41,301 --> 00:06:43,637
这个古老的军事概念被用来捍卫世界


107
00:06:43,937 --> 00:06:47,140
各地城池已有几百年历史了


108
00:06:48,642 --> 00:06:49,977
我知道你们很喜欢琐事


109
00:06:50,344 --> 00:06:52,613
所以 我可以告诉你们这个概念是


110
00:06:52,679 --> 00:06:57,417
塞巴斯蒂安•德•沃邦
在17世纪70年代正式提出的


111
00:06:57,484 --> 00:06:59,052
那时 他受法国国王邀请


112
00:06:59,486 --> 00:07:01,555
在全国建造堡垒


113
00:07:02,155 --> 00:07:04,758
以保卫王国安全


114
00:07:05,692 --> 00:07:08,061
你们可能不熟悉这个人


115
00:07:08,128 --> 00:07:10,130
但你们肯定见过他的作品


116
00:07:11,298 --> 00:07:12,699
这就是他其中的一个城堡设计图


117
00:07:14,034 --> 00:07:15,969
你们可以清楚地看到这几个保护层是


118
00:07:16,036 --> 00:07:17,971
用来抵挡不同的袭击 


119
00:07:19,673 --> 00:07:22,075
它们可以拖住入侵者然后通过


120
00:07:22,309 --> 00:07:26,914
易守难攻的窄道把入侵者抵挡在外面


121
00:07:28,649 --> 00:07:31,685
我们来看看如何
把这个原理用到OS X的安全模型上


122
00:07:32,519 --> 00:07:34,922
我不知道你们是不是这样
反正我是经常梦想着


123
00:07:34,988 --> 00:07:36,523
建造自己的堡垒就是这样


124
00:07:37,824 --> 00:07:40,561
我们在这之上设置自己的安全层


125
00:07:42,062 --> 00:07:44,565
我们从底部的网闸开始


126
00:07:45,732 --> 00:07:49,369
网闸要确保从网上下载到


127
00:07:49,436 --> 00:07:54,041
用户设备上的应用是经开发者签字的


128
00:07:54,341 --> 00:07:58,412
开发者拥有Apple公司发布的
开发者身份证明


129
00:07:59,513 --> 00:08:02,583
否则程序将无法运行


130
00:08:03,884 --> 00:08:06,019
网闸要配合系统的其他机制运行


131
00:08:06,086 --> 00:08:08,856
如恶意软件检测机制


132
00:08:09,323 --> 00:08:11,592
这样才能有效


133
00:08:12,459 --> 00:08:16,096
防止恶意软件大规模地
入侵我们生态系统


134
00:08:18,131 --> 00:08:19,433
第二层是沙盒


135
00:08:20,801 --> 00:08:23,537
回到Lion 我们引入了App沙盒


136
00:08:23,971 --> 00:08:27,207
我们强制性规定所有从App Store
下载的应用都要使用App沙盒


137
00:08:28,909 --> 00:08:32,145
对于从App Store
以外下载的应用


138
00:08:32,212 --> 00:08:35,082
比如开发者ID程序
也强推荐使用App沙盒


139
00:08:36,482 --> 00:08:38,485
沙盒是一种控制机制


140
00:08:39,253 --> 00:08:42,289
它能确保即使你们的程序被入侵了


141
00:08:43,090 --> 00:08:47,160
攻击者也只能访问用户提供的资料


142
00:08:47,794 --> 00:08:50,731
而不能窃取用户资料


143
00:08:51,498 --> 00:08:53,767
也不能破坏其他系统


144
00:08:56,270 --> 00:08:59,640
如果你们成功绕开前两层
那么就来到了第三层


145
00:09:00,307 --> 00:09:02,442
经典的POSIX权限方案


146
00:09:03,210 --> 00:09:05,679
在这里 你们的应用


147
00:09:05,746 --> 00:09:09,216
只能在系统授予用户的权限下运行


148
00:09:10,083 --> 00:09:13,387
所以它既不能访问不同用户资料


149
00:09:14,154 --> 00:09:19,693
也不能修改root用户
对系统进行的配置设置


150
00:09:21,528 --> 00:09:25,365
最后 我们把Keychain 
看成第三层上面的一层


151
00:09:25,432 --> 00:09:28,836
它是用来保护用户密钥的


152
00:09:30,504 --> 00:09:33,674
它通过加密和应用分离


153
00:09:34,274 --> 00:09:37,377
确保只有在第一层存储秘密的应用


154
00:09:37,811 --> 00:09:40,747
才可以返回此层


155
00:09:42,983 --> 00:09:44,351
所以当你们看到整个方案后


156
00:09:45,052 --> 00:09:46,486
你们会明白很多事情


157
00:09:47,588 --> 00:09:54,428
首先 网闸阻止下载到
机器上的不信任代码


158
00:09:55,329 --> 00:09:58,165
但是它还不是真正的控制机制


159
00:09:58,532 --> 00:10:01,502
因为启动网闸不会阻止任何应用运行


160
00:10:02,269 --> 00:10:05,472
而且它也不会保护机器已有代码


161
00:10:05,539 --> 00:10:08,308
例如它不会保护OS自带的代码


162
00:10:10,244 --> 00:10:13,914
所以 虽然它可能是


163
00:10:14,214 --> 00:10:16,149
我们平台最有效的控制机制


164
00:10:17,251 --> 00:10:19,186
但沙盒机制是OS X的唯一选择


165
00:10:19,853 --> 00:10:22,656
我们没有要求规定每个过程都


166
00:10:22,956 --> 00:10:24,525
必须在沙盒中运行


167
00:10:26,593 --> 00:10:30,364
最后当你们看到POSIX层时


168
00:10:31,532 --> 00:10:36,470
会发现大部分的Mac系统 
都是单用户系统


169
00:10:37,070 --> 00:10:40,440
而系统的用户实际上是临时管理员


170
00:10:40,507 --> 00:10:42,109
一直在行使管理特权


171
00:10:44,845 --> 00:10:46,914
root账户通常要么处于保护状态


172
00:10:46,980 --> 00:10:50,450
要么保护密码较弱甚至没有密码


173
00:10:51,852 --> 00:10:55,289
事实上如果真的有
密码而且你想要的话


174
00:10:55,522 --> 00:10:56,957
用户也可能会给你


175
00:10:59,860 --> 00:11:03,530
而且 当你最后root之后
实际上已经能控制


176
00:11:03,997 --> 00:11:07,000
整个机器 因为root文件可以禁用
设备上所有的安全措施


177
00:11:07,701 --> 00:11:10,971
它能替换内核扩展


178
00:11:11,471 --> 00:11:15,275
替代提供其他安全服务


179
00:11:15,809 --> 00:11:18,545
甚至可以扰乱运行中的
Keychain层


180
00:11:20,681 --> 00:11:24,051
所以 事实就是一旦代码在Mac运行


181
00:11:24,551 --> 00:11:26,720
那么很容易进行root


182
00:11:27,187 --> 00:11:29,056
一旦root成功
你就可以完全控制机器


183
00:11:29,590 --> 00:11:30,457
也就是说


184
00:11:31,358 --> 00:11:33,794
任何一段恶意代码实际上就是一个密码


185
00:11:34,127 --> 00:11:35,562
或一个可以完全


186
00:11:35,929 --> 00:11:37,664
控制你机器的漏洞


187
00:11:40,033 --> 00:11:44,338
这表明我们还需要另一个层


188
00:11:45,405 --> 00:11:49,209
一个能消除机器root权限的层


189
00:11:50,110 --> 00:11:52,045
从而在默认情况下保护系统


190
00:11:52,145 --> 00:11:54,515
好像是Apple安装到机器上的一样


191
00:11:55,349 --> 00:11:57,017
硬盘和runtime都进行安装


192
00:11:58,852 --> 00:12:02,589
因为我们现在正讨论限制root权限


193
00:12:03,323 --> 00:12:06,860
所以我们需要提供一套配置机制


194
00:12:07,327 --> 00:12:09,897
防止root被入侵


195
00:12:10,831 --> 00:12:13,500
而且还能重设root权限


196
00:12:15,602 --> 00:12:18,438
这就是System
Integration Protection


197
00:12:18,872 --> 00:12:20,440
这是一个新的安全策略


198
00:12:20,908 --> 00:12:24,011
适用于系统中的每个进程


199
00:12:24,645 --> 00:12:26,680
不管这个进程是否


200
00:12:26,947 --> 00:12:29,716
具备附加特权或者在沙箱外运行


201
00:12:31,785 --> 00:12:33,887
该策略能为磁盘或runtime中的


202
00:12:34,221 --> 00:12:37,925
系统组件提供额外保护


203
00:12:39,126 --> 00:12:43,096
而且系统如果安装
Apple签字安装包


204
00:12:43,163 --> 00:12:46,900
二进制只能被安装程序


205
00:12:48,101 --> 00:12:50,003
或者软件更新机制修改


206
00:12:50,704 --> 00:12:54,308
这样系统二进制文件就能免受


207
00:12:54,374 --> 00:12:58,412
runtime附件和代码注入的风险


208
00:12:59,980 --> 00:13:01,715
在探究细节之前


209
00:13:01,982 --> 00:13:05,285
我们先看一下这是如何影响开发者的


210
00:13:06,420 --> 00:13:09,456
好消息是如果你的应用


211
00:13:09,523 --> 00:13:12,726
是App Store下载的 
那么应用就不会受到此类风险


212
00:13:13,694 --> 00:13:16,496
<br/> 
因为App Store指南


213
00:13:16,630 --> 00:13:18,632
和沙箱策略可以加以保护


214
00:13:18,799 --> 00:13:20,534
阻止此类行为


215
00:13:21,502 --> 00:13:23,604
然而 如果你们的应用
不是来自App Store


216
00:13:24,338 --> 00:13:26,607
而且需要修改系统的二进制文件


217
00:13:27,140 --> 00:13:32,880
或修改磁盘框架
如果需要将储存信息安装到系统位置


218
00:13:34,414 --> 00:13:36,283
那么应用就会受到影响


219
00:13:36,683 --> 00:13:39,019
我将在这里解释一下


220
00:13:39,753 --> 00:13:41,755
什么是系统位置


221
00:13:43,023 --> 00:13:46,894
最后如果你们的
应用需要检查系统进程中


222
00:13:46,960 --> 00:13:49,897
任一进程的的内存状态


223
00:13:50,898 --> 00:13:56,537
或需要在系统运行的进程中或跨进程


224
00:13:56,703 --> 00:13:57,704
插入库或进行调试


225
00:13:59,773 --> 00:14:02,576
那么让我们看看新机制的核心


226
00:14:03,076 --> 00:14:05,679
首先我会了解下新文件系统限制


227
00:14:05,946 --> 00:14:08,582
我们在Capitan系统
引入该文件系统


228
00:14:09,550 --> 00:14:11,018
然后再看一下它是如何扩展到


229
00:14:11,318 --> 00:14:13,420
新runtime保护进程


230
00:14:15,022 --> 00:14:17,090
最后了解一下该系统与


231
00:14:17,157 --> 00:14:20,060
内核扩展开发流程的关系


232
00:14:20,127 --> 00:14:23,530
以及它是如何影响kext开发者的


233
00:14:24,798 --> 00:14:27,334
然后由于这个功能
是能够被完全禁用的


234
00:14:28,001 --> 00:14:29,503
接下来向你们展示一下如何禁用


235
00:14:31,138 --> 00:14:32,539
那就得首先讲讲文件系统


236
00:14:33,974 --> 00:14:39,880
我们想做到的就是
保护系统存储信息不被修改


237
00:14:41,281 --> 00:14:45,986
为达到这一目的 
安装程序会标在文件安装过程中


238
00:14:46,520 --> 00:14:47,855
标记系统内容


239
00:14:48,655 --> 00:14:51,291
我们在Capitan系统中加入了
新的文件系统标记


240
00:14:52,359 --> 00:14:56,530
之后在运行过程中内核能阻止任何


241
00:14:56,830 --> 00:14:58,932
企图篡改受保护文件


242
00:14:58,999 --> 00:15:01,969
或文件夹的行为除非该行为是


243
00:15:02,035 --> 00:15:05,272
特别授权的进程发出的


244
00:15:05,806 --> 00:15:07,908
Capitan系统只有几种此类进程


245
00:15:09,243 --> 00:15:13,881
内核还会防止
储存私密内容的块设备被读写


246
00:15:15,215 --> 00:15:16,783
而且还会阻止


247
00:15:16,950 --> 00:15:18,252
私密内容被篡改


248
00:15:20,187 --> 00:15:22,122
现在 必须记住一点是


249
00:15:22,422 --> 00:15:25,158
这只适用于root文件和


250
00:15:25,592 --> 00:15:26,727
当前运行OS的启动卷


251
00:15:27,995 --> 00:15:30,731
所以你应该把它看成系统运行时的


252
00:15:31,031 --> 00:15:33,066
一种自我保护机制


253
00:15:36,270 --> 00:15:39,206
因为我们现在要
保护磁盘上的系统存储信息


254
00:15:39,273 --> 00:15:41,308
所以你们必须明确区分


255
00:15:41,375 --> 00:15:43,510
系统内容和第三方内容


256
00:15:44,912 --> 00:15:48,849
在Capitan 这张图标左侧


257
00:15:48,916 --> 00:15:51,885
所有位置都被默认为系统位置


258
00:15:52,853 --> 00:15:55,189
这意味着系统会阻止你在那里进行读写


259
00:15:55,923 --> 00:15:57,824
即使是安装程序包下载的也一样


260
00:15:59,493 --> 00:16:01,728
因为多年来我们一直建议你们


261
00:16:02,062 --> 00:16:03,697
不要读写到这些位置


262
00:16:03,964 --> 00:16:05,499
所以你们当中受影响的人应该不多


263
00:16:05,732 --> 00:16:08,535
如果你们的安装包把存储信息放到这里


264
00:16:08,602 --> 00:16:10,671
Capitan应该不会出现大的故障


265
00:16:11,471 --> 00:16:13,674
如果你想把所有的软件都
安装在/System路径下


266
00:16:14,007 --> 00:16:17,010
那么你需要将此存储信息移到
subfolder of /Library下


267
00:16:17,077 --> 00:16:20,681
如果是系统内的
存储信息或(tilde)/Library


268
00:16:21,248 --> 00:16:24,318
如果是用户存储信息


269
00:16:26,119 --> 00:16:29,156
或者如果你想把软件都安装到
/bin或者/sbin


270
00:16:29,923 --> 00:16:32,125
或者/usr目录下


271
00:16:32,192 --> 00:16:35,395
比如/usr/bin, /usr/lib
或者usr/libexec


272
00:16:35,996 --> 00:16:39,266
那么你要把储存信息移到


273
00:16:39,600 --> 00:16:44,271
/usr/文件夹下的
适当位置 因为这里是


274
00:16:44,338 --> 00:16:45,939
第三方唯一可访问的路径


275
00:16:47,574 --> 00:16:48,709
然后需要注意的是


276
00:16:49,676 --> 00:16:52,513
最佳的存储信息位置仍是
/Applications路径


277
00:16:52,646 --> 00:16:55,549
这是因为这个位置是用户可见位置


278
00:16:56,149 --> 00:16:58,752
方便用户把应用拖入


279
00:16:58,819 --> 00:17:00,454
垃圾箱并删除存储信息


280
00:17:01,855 --> 00:17:07,493
要注意的是 当用户升级 


281
00:17:07,694 --> 00:17:10,830
Yosemite install到
Capitan install时


282
00:17:11,431 --> 00:17:14,667
安装程序会会把系统内


283
00:17:14,734 --> 00:17:18,505
发现的第三方存储信息移到系统外


284
00:17:19,640 --> 00:17:23,076
所以为了不影响这些用户


285
00:17:23,143 --> 00:17:26,680
务必确保把存储内容尽快转移出去


286
00:17:29,783 --> 00:17:31,618
现在我们看一下runtime保护


287
00:17:33,086 --> 00:17:35,756
能够改变runtime中的进程行为


288
00:17:35,923 --> 00:17:38,959
就相当于能够改变


289
00:17:39,026 --> 00:17:40,827
改变磁盘上的二进制文件


290
00:17:41,495 --> 00:17:43,263
如果想保护磁盘上的二进制文件


291
00:17:43,530 --> 00:17:46,133
或系统存储信息我们必须保证


292
00:17:46,400 --> 00:17:49,536
不能插入代码或改变


293
00:17:49,603 --> 00:17:51,538
这些系统进程的行为


294
00:17:53,006 --> 00:17:56,710
为了实现该目的我们在进程结构中


295
00:17:57,344 --> 00:18:01,815
引入一种新的限定标记这种标记的
内核适用于每个单一进程


296
00:18:03,050 --> 00:18:06,086
如果磁盘上的


297
00:18:06,854 --> 00:18:09,990
主要可执行文件受程序保护


298
00:18:11,258 --> 00:18:13,193
或写入Apple
特别授权的主要可执行文件


299
00:18:13,260 --> 00:18:14,695
那么内核将在准确时刻做出标记


300
00:18:19,967 --> 00:18:22,536
之后系统将自动区别


301
00:18:22,836 --> 00:18:26,073
该受限进程和常规进程


302
00:18:26,940 --> 00:18:29,476
一方面如果task-for-pid


303
00:18:29,943 --> 00:18:33,747
和processor-set-tasks
SPI需要调用受限进程


304
00:18:34,014 --> 00:18:36,283
那么它们将无法运行


305
00:18:37,251 --> 00:18:39,419
并且会设置EPERM为0


306
00:18:40,621 --> 00:18:44,191
这意味着你的产品需要依靠


307
00:18:44,324 --> 00:18:48,061
系统进程才能运行


308
00:18:48,262 --> 00:18:51,198
例如Finder 你需要
向Finder插入代码


309
00:18:51,265 --> 00:18:53,634
否则它再也无法运行了


310
00:18:56,270 --> 00:19:03,243
如果你插入exec 
那么二进制文件将导致子进程受限


311
00:19:04,611 --> 00:19:07,214
然后系统将自动重新设置


312
00:19:07,281 --> 00:19:08,949
子进程的mach特殊接口


313
00:19:09,650 --> 00:19:11,985
这样意味着你将 


314
00:19:12,352 --> 00:19:13,587
无法控制子进程


315
00:19:14,421 --> 00:19:18,158
如果你插入一个特权工具


316
00:19:18,592 --> 00:19:20,961
然后想要保持控制
那么它也将不能运行


317
00:19:23,263 --> 00:19:29,469
连接器将忽视所有
保护二进制文件的dyld环境变量


318
00:19:30,270 --> 00:19:33,407
所以在执行过程中如果你在进程中


319
00:19:33,574 --> 00:19:35,509
将库插入二进制文件


320
00:19:36,109 --> 00:19:38,745
连接器忽视新库


321
00:19:40,314 --> 00:19:44,384
最终如果使用
dtrace的话所有针对


322
00:19:44,551 --> 00:19:49,189
受限进程的dtrace
探针将无法匹配


323
00:19:49,890 --> 00:19:53,994
这样就无法看到进程和内核的互动过程


324
00:19:54,962 --> 00:19:58,732
你们也将检测不到受限进程存储空间


325
00:19:58,932 --> 00:20:00,968
也就无法检测到内核内存


326
00:20:02,836 --> 00:20:05,472
当然这适用于调试器LLDB


327
00:20:06,106 --> 00:20:09,576
如果你们试图
调用LLDB作为root


328
00:20:09,643 --> 00:20:12,179
并连接到Finder这样也无济于事


329
00:20:15,282 --> 00:20:17,384
现在接下来是kext签字程序


330
00:20:17,751 --> 00:20:21,321
你们肯定也知道所有带
Kexts开发者ID证书的扩展


331
00:20:21,622 --> 00:20:25,359
都是Apple公司发行的


332
00:20:26,527 --> 00:20:31,098
扩展必须安装到
/Library/Extensions路径下


333
00:20:32,866 --> 00:20:37,638
新鲜的是因为我们把
kext签字程序放置在


334
00:20:38,472 --> 00:20:41,909
System Integrity
Protection之下进行保护


335
00:20:42,576 --> 00:20:45,479
所以kext-dev-mode
boot-arg就被淘汰了


336
00:20:46,446 --> 00:20:49,983
如果你是kext开发者你就需要用


337
00:20:50,083 --> 00:20:52,419
未签字的内核扩展进行测试


338
00:20:52,486 --> 00:20:55,589
你需要禁用保护我马上给你们演示一下


339
00:20:56,523 --> 00:20:59,693
这也意味着为了禁用kext签字


340
00:20:59,760 --> 00:21:02,829
你在那里可能也看不到这个注释行 


341
00:21:03,096 --> 00:21:04,198
它已经无法运行了


342
00:21:08,702 --> 00:21:10,337
下面我们来谈一下配置机制


343
00:21:12,573 --> 00:21:17,110
我们坚信这个新机制
对保护对我们的用户至关重要


344
00:21:18,679 --> 00:21:21,815
话虽这么说但我们也意识到


345
00:21:21,882 --> 00:21:24,418
人无法完全操控他们的机器


346
00:21:25,385 --> 00:21:26,620
因为我之前就说过


347
00:21:26,887 --> 00:21:28,422
它保护着磁盘上的内核


348
00:21:28,922 --> 00:21:31,525
需要所有的内核扩展都必须被签字


349
00:21:32,192 --> 00:21:34,494
而且因此kext开发者


350
00:21:34,561 --> 00:21:36,363
也不能如愿以偿地测试未签字kext


351
00:21:38,031 --> 00:21:40,200
正因如此它被完全弃用了


352
00:21:41,301 --> 00:21:44,771
配置存放在NVRAM配置中


353
00:21:45,272 --> 00:21:48,141
这意味着可以适用于整个机器


354
00:21:48,475 --> 00:21:50,410
所以如果你有几个
Capitan安装程序


355
00:21:50,777 --> 00:21:52,513
它们都会有同样的配置 


356
00:21:53,680 --> 00:21:55,516
而且OS安装程序也是如此


357
00:21:55,649 --> 00:21:59,186
所以当你从seed 1升级到
seed 2再升级到GM之后


358
00:21:59,753 --> 00:22:01,321
配置也将保持不变


359
00:22:01,455 --> 00:22:03,257
我们安装时不用每次都进行重新配置


360
00:22:05,359 --> 00:22:08,161
现在 因为root实际上
已经设置了NVRAM


361
00:22:08,262 --> 00:22:10,631
在这里我们不能相信root


362
00:22:11,098 --> 00:22:14,434
也就是我们不能在
OS系统上安装配置机制


363
00:22:15,068 --> 00:22:17,571
我们要进行转移 
把它安装在Recovery OS下


364
00:22:18,305 --> 00:22:21,041
所以NVRAM也就只能在
Recovery下进行配置设置


365
00:22:21,775 --> 00:22:23,010
如果你想改变配置


366
00:22:23,777 --> 00:22:26,346
你需要在机器的
Recovery OS中进行重启


367
00:22:26,413 --> 00:22:29,449
在引导画面下按Command+R键
进行开机启动


368
00:22:30,851 --> 00:22:32,586
然后在Utilities菜单中 


369
00:22:32,653 --> 00:22:35,155
运行安全配置应用


370
00:22:36,323 --> 00:22:38,926
检测System
IntegrityProtection盒


371
00:22:39,359 --> 00:22:40,694
应用 然后重启


372
00:22:42,029 --> 00:22:44,464
记住我刚才描述的那些类型很有可能


373
00:22:44,531 --> 00:22:46,300
在以后的seed版本中会发生变化


374
00:22:46,433 --> 00:22:51,038
所以务必阅读注释了解新的操作步骤


375
00:22:54,007 --> 00:22:55,809
我们总结一下到到目前
为止所谈论的内容


376
00:22:57,277 --> 00:22:59,980
System Integrity 
Protection是一种新的策略


377
00:23:00,047 --> 00:23:01,181
适用于系统的每个进程


378
00:23:02,282 --> 00:23:06,520
Apple公司将其安装
在磁盘和runtime上


379
00:23:06,620 --> 00:23:10,424
通过限制读写系统位置访问权限


380
00:23:10,858 --> 00:23:14,995
以及防止runtime
连接和代码插入


381
00:23:15,963 --> 00:23:18,599
从而保护系统


382
00:23:20,434 --> 00:23:23,203
安装程序能有效地把第三方存储内容


383
00:23:23,337 --> 00:23:25,172
转移到系统位置之外


384
00:23:25,239 --> 00:23:27,474
所以要确保尽快转移你的存储内容


385
00:23:27,908 --> 00:23:30,110
否则 就只能自认倒霉了
因为 你会找不到内容


386
00:23:31,678 --> 00:23:37,918
最后可使用Recovery OS
配置机制禁用该功能


387
00:23:39,720 --> 00:23:41,388
这就是我为大家呈现的内容
谢谢大家


388
00:23:41,655 --> 00:23:42,789
下面我把舞台交给安德鲁


389
00:23:48,996 --> 00:23:49,830
谢谢你 皮埃尔


390
00:23:51,665 --> 00:23:56,970
我是安德鲁·惠利在Core OS
 安全功能组负责管理数据安全组


391
00:23:59,139 --> 00:24:01,475
你可能听过app传输安全


392
00:24:02,142 --> 00:24:04,611
以及app在连接状态下


393
00:24:05,012 --> 00:24:07,014
是它如何保护传输中的数据的


394
00:24:08,015 --> 00:24:11,718
我将会讨论数据安全的不同保护方式


395
00:24:13,187 --> 00:24:16,190
我会点击Keychain
然后存储用户信息


396
00:24:17,491 --> 00:24:21,795
之后看一下Touch ID
看看你是如何权衡


397
00:24:21,862 --> 00:24:23,463
程序安全与程序便捷的


398
00:24:25,532 --> 00:24:28,702
在这个过程中我将体验一下现有的技术


399
00:24:28,936 --> 00:24:32,940
和iOS 9的新功能以及
如何配合使用


400
00:24:33,407 --> 00:24:36,577
从而提供适合你们
app的安全保护等级


401
00:24:40,080 --> 00:24:42,649
我们首先快速
浏览一下Keychain


402
00:24:43,217 --> 00:24:46,587
你可以把它看作是专业的数据库


403
00:24:47,454 --> 00:24:51,425
通过增加行数来储存数据
我们称为Keychain项目


404
00:24:51,892 --> 00:24:54,761
然后通过属性进行查询


405
00:24:56,597 --> 00:25:01,301
为了优化隐私我这里说的隐私包括密码


406
00:25:01,969 --> 00:25:04,771
标记 cookie或秘钥


407
00:25:06,139 --> 00:25:10,511
如果你有成千上万兆字节信息要储存


408
00:25:10,844 --> 00:25:15,549
那么可以考虑使用基于文件的
数据保护或者通过API进行


409
00:25:16,049 --> 00:25:18,318
批量加密方法 
如Common Crypto


410
00:25:18,585 --> 00:25:20,287
然后将密钥存储在Keychain中


411
00:25:25,292 --> 00:25:27,961
尽管这些SecItem API
已经存在很长时间了


412
00:25:28,262 --> 00:25:30,631
但它仍是最好的秘密存储工具


413
00:25:30,931 --> 00:25:33,066
包括新Swift apps中的密码


414
00:25:34,468 --> 00:25:37,838
这里我们这里有个秘密 
想通过SecItemAdd


415
00:25:37,905 --> 00:25:40,574
把它存在Keychain中


416
00:25:42,209 --> 00:25:44,344
为了这么做我们构建了一个字典


417
00:25:44,711 --> 00:25:46,480
这个字典包括秘密信息


418
00:25:46,947 --> 00:25:51,818
还有今后查询所必须的某些属性


419
00:25:52,286 --> 00:25:53,554
和应当采取的保护措施


420
00:25:56,256 --> 00:25:59,560
这种创建包括描述
项目查询方式字典的方式


421
00:25:59,626 --> 00:26:04,865
也可用于查询删除 


422
00:26:05,098 --> 00:26:10,037
更新条目和其他API
我后面会谈到这一点


423
00:26:11,405 --> 00:26:14,074
有关Keychain API的信息


424
00:26:14,141 --> 00:26:17,711
2013年的WWDC
的709会议还有很多


425
00:26:20,314 --> 00:26:25,152
所以在编写访问Keychain
代码的时候你们要注意以下几点


426
00:26:26,987 --> 00:26:30,290
首先处理用户隐私信息
是代码安全信息当中


427
00:26:30,357 --> 00:26:32,326
真正敏感的一个环节


428
00:26:33,093 --> 00:26:37,464
所以你们应该把它分成
小而简单又可测试的小单元


429
00:26:39,499 --> 00:26:42,069
通常可以使用
wrapper class


430
00:26:44,438 --> 00:26:46,573
不管是直接使用
还是使用wrapper


431
00:26:47,107 --> 00:26:49,710
请确保你的应用


432
00:26:50,410 --> 00:26:52,312
受到最高级别的保护


433
00:26:53,680 --> 00:26:56,984
我们描述和讨论的数据保护级别


434
00:26:57,518 --> 00:27:03,790
指的是通过加密访问项目的次数


435
00:27:03,924 --> 00:27:06,360
例如当设备在iOS8系统上


436
00:27:08,562 --> 00:27:12,766
被锁定的时候我们添加了
After First Unlock


437
00:27:14,434 --> 00:27:18,338
再说一遍这功能早就有了
当你必须在背景下


438
00:27:18,572 --> 00:27:20,941
访问这些项目时候你就可以使用它


439
00:27:21,308 --> 00:27:22,876
比例你开发的是一款VoIP应用


440
00:27:27,147 --> 00:27:30,651
iOS 9不支持随时访问


441
00:27:31,051 --> 00:27:34,688
所以你们必须着手
把这些项目移到到更高级别位置


442
00:27:40,527 --> 00:27:44,498
我们已开发出WatchKit 2
所以你的Watch app现在可以


443
00:27:44,565 --> 00:27:48,969
访问SecItem API
虽然在Watch上


444
00:27:49,036 --> 00:27:52,873
输入用户全名和密码的
这种用户体验并非是你想要的


445
00:27:54,408 --> 00:27:58,512
如果你的Watch app
显示的是配对iOS设备的数据


446
00:27:59,079 --> 00:28:01,415
那么你只需发送内容


447
00:28:01,748 --> 00:28:03,750
而无需使用永久证书


448
00:28:05,586 --> 00:28:07,955
如果你的Watch app
确实需要直接访问证书


449
00:28:08,822 --> 00:28:14,461
那么与其保存完整的用户名和密码


450
00:28:15,162 --> 00:28:18,065
不如让服务器发送
一个许可证或cookie


451
00:28:18,365 --> 00:28:22,503
从而获得权限访问


452
00:28:22,669 --> 00:28:26,139
那些Watch app
所需要的主要功能内容


453
00:28:30,143 --> 00:28:33,447
不仅仅在Watch上提示用户名


454
00:28:33,514 --> 00:28:35,716
和密码非常不方便


455
00:28:36,416 --> 00:28:42,823
在过去的几个版本我们引入了几种
技术减少密码提示的频率


456
00:28:44,791 --> 00:28:47,060
第一个就是共享web证书


457
00:28:48,896 --> 00:28:51,999
我们都了解也都喜欢
Safari保存的密码


458
00:28:52,266 --> 00:28:54,868
以及提示和储存密码的方式


459
00:28:56,370 --> 00:29:00,340
有了iCloud Keychain
密码就可以同步 自动保存


460
00:29:00,407 --> 00:29:01,475
到所有设备上


461
00:29:03,844 --> 00:29:05,179
但是 常见的是一个服务器


462
00:29:05,245 --> 00:29:08,182
同时拥有一个
网站和一个iOS app


463
00:29:08,782 --> 00:29:12,619
所以 如果这些程序都能共享


464
00:29:12,753 --> 00:29:14,354
Safari保存密码那就太棒了


465
00:29:15,122 --> 00:29:17,391
有了共享web证书就可以办到


466
00:29:19,693 --> 00:29:22,262
这些是你们在登录


467
00:29:22,362 --> 00:29:24,698
或注册程序要添加的代码


468
00:29:27,634 --> 00:29:30,204
SecCreate Shared
WebCredential Password将


469
00:29:30,270 --> 00:29:33,473
返回一个随机字符串
和Safari保存的密码格式一样


470
00:29:33,574 --> 00:29:34,942
用于提示密码


471
00:29:36,310 --> 00:29:39,046
你们能调用SecAdd
SharedWeb Credential


472
00:29:39,112 --> 00:29:42,382
告知Safari
需要将新用户名和密码


473
00:29:42,649 --> 00:29:44,651
自动输入到特定域中


474
00:29:47,721 --> 00:29:51,091
在iOS 9我们已经实现这个功能


475
00:29:51,491 --> 00:29:53,427
方式是在模拟器上运行时


476
00:29:53,493 --> 00:29:54,928
降低安全检查等级


477
00:29:56,530 --> 00:29:57,364
我们来体验一下


478
00:29:59,199 --> 00:30:02,803
我从注册程序开始


479
00:30:03,237 --> 00:30:06,306
然后添加刚刚展示过的代码


480
00:30:09,109 --> 00:30:12,012
然后进入Safari设置


481
00:30:12,145 --> 00:30:15,749
确保已启用名称和密码自动输入


482
00:30:17,518 --> 00:30:19,419
搜索Safari等待结果


483
00:30:22,356 --> 00:30:25,325
我们回到程序上来


484
00:30:25,826 --> 00:30:27,561
页面上显示用户名称和密码提示


485
00:30:29,229 --> 00:30:32,833
共享网络凭据允许应用


486
00:30:32,900 --> 00:30:36,537
显示一个选择器这个选择器列出了
Safari在这个域中


487
00:30:36,603 --> 00:30:37,704
保存的所有账号


488
00:30:40,507 --> 00:30:43,010
每当用户选择一个账号 用户名


489
00:30:43,076 --> 00:30:46,446
和密码就会根据
Shared Web Credential


490
00:30:46,580 --> 00:30:52,252
返回到已完成处理的
程序中然后就可以登录了


491
00:30:55,989 --> 00:30:58,091
如果你想要在设备上使用这个功能


492
00:30:58,158 --> 00:31:02,262
而不是只在模拟器上使用
你就需要在你的应用上


493
00:31:03,363 --> 00:31:06,099
添加一个授权你可以在
Xcode的权限标签页的


494
00:31:06,233 --> 00:31:08,202
相关域部分中进行该操作


495
00:31:10,938 --> 00:31:14,274
你需要将JSON文件放在服务器中


496
00:31:14,942 --> 00:31:16,376
不过你可能已经有了


497
00:31:16,710 --> 00:31:19,246
毕竟它跟Handoff和
iOS 9应用链接中


498
00:31:20,747 --> 00:31:24,685
所用的是同一个


499
00:31:30,157 --> 00:31:31,658
我们对iOS 9做了一个改变


500
00:31:31,725 --> 00:31:33,126
让适应性更好这个改变是


501
00:31:33,460 --> 00:31:35,996
你不再需要分别签署该文件


502
00:31:36,530 --> 00:31:39,399
它将由安全TLS连接所保护


503
00:31:45,539 --> 00:31:49,243
我提到过Safari通过
iCloud Keychain保存密码


504
00:31:49,643 --> 00:31:52,045
但是你们也可以在
自己的应用中直接使用它


505
00:31:53,146 --> 00:31:55,282
想象你有一个
iOS iPad


506
00:31:55,849 --> 00:31:59,052
iPhone和OS X 
App Store app


507
00:31:59,386 --> 00:32:03,423
你想要只登陆一个
就同时登陆所有这些程序


508
00:32:05,659 --> 00:32:08,028
对于能够用于多种设备的应用密码


509
00:32:08,095 --> 00:32:11,999
你们可以考虑将同步性属性


510
00:32:12,065 --> 00:32:14,034
添加到所有的SecItem调用


511
00:32:15,736 --> 00:32:17,271
你还需要考虑几件事情


512
00:32:17,337 --> 00:32:19,973
比如 删除一个项目
就会将所有位置的该项目同时删除掉


513
00:32:20,107 --> 00:32:22,709
所以请确保你只在正确的
情况下进行该操作


514
00:32:24,578 --> 00:32:28,715
这里还有几个注意事项
你可以在SecItem.h.


515
00:32:30,584 --> 00:32:31,985
查看如果你有兴趣想了解更多


516
00:32:32,052 --> 00:32:34,388
关于iCloud Keychaine
安全性的信息


517
00:32:34,755 --> 00:32:37,925
或者想知道同步的密码如何
保护个人隐私


518
00:32:37,991 --> 00:32:41,128
不被其他用户看到
请查看iOS 安全白皮书


519
00:32:41,528 --> 00:32:43,096
会议结束有个链接


520
00:32:46,700 --> 00:32:51,305
我重申下 
Keychain存着你所有的秘密


521
00:32:51,471 --> 00:32:55,309
而纯文本文件或plist
文件已经没有密码


522
00:32:56,510 --> 00:32:58,979
所有请尽可能保护好它们


523
00:33:00,681 --> 00:33:03,050
并且如果合适的话请使用
SharedWedCredentials


524
00:33:03,116 --> 00:33:06,286
比如我们的Keychain 
以便在用户的设备上将进行同步


525
00:33:06,453 --> 00:33:08,222
同时尽量不用密码提示


526
00:33:13,026 --> 00:33:16,597
所以虽然有些秘密能在
多台设备上同步但你只想它们


527
00:33:17,264 --> 00:33:18,465
在一台设备上安全待着


528
00:33:18,532 --> 00:33:21,535
这时候iCloud
Keychain就派上大用场了


529
00:33:23,337 --> 00:33:25,639
安全通讯应用就是一个例子


530
00:33:26,006 --> 00:33:29,943
这种应用的加密是设备对设备
而不是用户对用户


531
00:33:32,779 --> 00:33:35,082
我已经提到过的不同保护级别中


532
00:33:35,182 --> 00:33:37,251
有一个
ThisDeviceOnly级别


533
00:33:38,118 --> 00:33:40,921
项目会被备份但只能被


534
00:33:41,088 --> 00:33:42,322
恢复到它们最初始的设备中


535
00:33:44,191 --> 00:33:47,794
去年 我们增加了
WhenPassCodeSet级别


536
00:33:48,295 --> 00:33:50,464
确保项目始终处于


537
00:33:50,564 --> 00:33:52,533
本地设备密码保护之下


538
00:33:54,268 --> 00:33:56,069
你可以使用
AccessControl表


539
00:33:56,136 --> 00:33:59,339
以对项目进行更为严密的控制


540
00:34:03,777 --> 00:34:04,711
既然我们在谈论


541
00:34:04,811 --> 00:34:07,447
保护特定设备证书的事情


542
00:34:07,881 --> 00:34:10,918
那么让我们来看一看
iOS设备的安全域


543
00:34:12,319 --> 00:34:14,821
用户空间也就是应用运行的空间


544
00:34:15,889 --> 00:34:19,092
以及皮埃尔提到过的
能够提供进程分离和


545
00:34:19,159 --> 00:34:21,228
其它安全功能的内核


546
00:34:22,563 --> 00:34:25,831
不过它也提供了很多很多其它OS工具


547
00:34:26,033 --> 00:34:28,335
这意味着它有着
一个相当强大的防攻击服务


548
00:34:29,036 --> 00:34:32,306
我们在iPhone 5s中
加入了Secure Enclave


549
00:34:35,475 --> 00:34:40,681
Secure Enclave
是独立运行的在设计之时


550
00:34:40,813 --> 00:34:42,850
始终将安全性视为最高原则


551
00:34:44,484 --> 00:34:48,222
我们在其中放置了
Touch ID来保护隐私


552
00:34:48,288 --> 00:34:50,924
以及你的指纹信息的安全


553
00:34:52,626 --> 00:34:55,661
我们将KeyStore从内核


554
00:34:55,728 --> 00:34:58,532
移进
Secure Enclave就是它


555
00:34:58,866 --> 00:35:02,069
控制着Keychain项目的密码


556
00:35:02,169 --> 00:35:03,070
以及数据保护


557
00:35:07,374 --> 00:35:09,409
所以让我们现在
着重了解一下Touch ID


558
00:35:11,311 --> 00:35:13,547
我们把它视为一种安全技术


559
00:35:13,947 --> 00:35:16,350
但它真正出色的是它的便利性


560
00:35:17,150 --> 00:35:20,320
你可以不用总是输入密码
就可以解锁你的设备


561
00:35:21,788 --> 00:35:24,458
不过它本身也可以带给我们
一些安全上面的好处


562
00:35:25,125 --> 00:35:29,029
比如如今拥有复杂的长密码
变得更加容易了


563
00:35:29,897 --> 00:35:32,132
它能够提高数据保护的安全性


564
00:35:33,467 --> 00:35:37,871
或者现在你的手机能够立即上锁


565
00:35:38,038 --> 00:35:40,707
从而减少被攻击和解锁状态的时间


566
00:35:44,745 --> 00:35:48,649
在iOS 8我们提供了一些API
所以当你在安全性和便利性之间


567
00:35:48,715 --> 00:35:52,486
做权衡的时候你可以使用
应用里的Touch ID


568
00:35:53,187 --> 00:35:55,556
但为何是这两者它们如何不同？


569
00:35:56,890 --> 00:35:59,393
若想知道首先
你得了解Touch ID


570
00:35:59,459 --> 00:36:01,495
和生物特征识别的工作机制


571
00:36:01,862 --> 00:36:05,365
幸运的是 这很简单
它可以归结为一个条件句


572
00:36:06,300 --> 00:36:10,003
如果伸出的手指和登记的手指相匹配


573
00:36:10,537 --> 00:36:11,772
就要做出反应


574
00:36:13,173 --> 00:36:16,376
造成差别的原因是这种反应是什么


575
00:36:16,944 --> 00:36:17,845
以及反应在哪里发生


576
00:36:21,148 --> 00:36:22,816
让我们从Local
Authentication开始谈起


577
00:36:24,785 --> 00:36:27,287
当一根手指被放在
Touch ID感应器下


578
00:36:27,654 --> 00:36:29,556
在Secure Enclave
里得到匹配


579
00:36:32,059 --> 00:36:33,227
匹配的消息


580
00:36:33,327 --> 00:36:36,730
会通过Local Authentication
发送到你的应用


581
00:36:37,297 --> 00:36:38,298
从而成功计算出布尔值 


582
00:36:40,067 --> 00:36:43,770
你的应用就是这样
对那条信息的做出反应的


583
00:36:46,740 --> 00:36:50,143
进程虽然在Secure 
Enclave开始


584
00:36:50,911 --> 00:36:54,982
但最终安全决策却是


585
00:36:55,449 --> 00:36:58,352
用户空间里的应用做出


586
00:37:01,355 --> 00:37:03,323
所以你什么时候可能想要通过
Local Authentication


587
00:37:03,390 --> 00:37:04,391
使用Touch ID呢


588
00:37:05,826 --> 00:37:09,062
想想你的应用如果你有任何安全障碍


589
00:37:09,530 --> 00:37:12,799
比如输入密码来确认一项操作


590
00:37:13,333 --> 00:37:15,335
即使用户已经登录了


591
00:37:17,004 --> 00:37:19,239
使用Touch ID会更容易


592
00:37:21,108 --> 00:37:23,944
或者你可能不想要总是
使用Touch ID 


593
00:37:24,511 --> 00:37:30,484
但在验证过程中采取额外的
措施这会是一个大障碍


594
00:37:34,188 --> 00:37:36,890
比如你可以在查看敏感数据前


595
00:37:37,057 --> 00:37:38,458
做出提示


596
00:37:40,160 --> 00:37:45,766
或者在某个操作之前做出提示
比如永久性删除账户


597
00:37:49,770 --> 00:37:52,372
一种模式是在你的应用流中


598
00:37:52,472 --> 00:37:53,774
做出一个Touch ID提示


599
00:37:55,042 --> 00:37:59,012
但这可能导致这种情况发生
那就是 用户刚刚用Touch ID解锁


600
00:37:59,446 --> 00:38:02,549
但没过多久应用又会发来提示


601
00:38:04,785 --> 00:38:09,089
在iOS9 我们添加了
TouchIDAuthentication


602
00:38:09,223 --> 00:38:12,726
AllowableReuseDuration
这是在Local Authentication


603
00:38:12,793 --> 00:38:13,694
环境下的一项属性


604
00:38:14,962 --> 00:38:16,630
你可以使用它来指定一个窗口


605
00:38:17,297 --> 00:38:19,600
如果用户最近刚用Touch ID


606
00:38:20,100 --> 00:38:22,369
来解锁他们的设备在期间


607
00:38:22,536 --> 00:38:23,437
你就不需要再次提示


608
00:38:25,138 --> 00:38:27,875
那是让你的策略宽松一些的一种办法


609
00:38:29,676 --> 00:38:32,379
但或许你想让你的策略在某些情况下


610
00:38:32,513 --> 00:38:33,514
更严格一些


611
00:38:33,580 --> 00:38:37,017
比如 对一个新登记的指纹做出反应


612
00:38:40,420 --> 00:38:44,625
同样也是一项新技术我们有
evaluatedPolicyDomainState属性


613
00:38:46,326 --> 00:38:47,828
这是一个完全隐秘的值


614
00:38:48,262 --> 00:38:51,064
代表了已登记指纹的当前情况


615
00:38:52,833 --> 00:38:55,636
你真正能做的是实时做一下比较


616
00:38:56,403 --> 00:39:00,574
如果它改变了
那就是设置里的已登记指纹中


617
00:39:00,741 --> 00:39:02,409
有一个指纹信息已经被添加或移除


618
00:39:04,912 --> 00:39:07,047
如果你察觉到并且它适合


619
00:39:07,147 --> 00:39:11,251
你的应用或许你可以再次提示


620
00:39:11,318 --> 00:39:14,054
看看用户是否还想
使用应用上的Touch ID


621
00:39:14,555 --> 00:39:16,623
或者输入一个密码来重新启动它


622
00:39:19,693 --> 00:39:22,863
那么我们来看看iOS 9的本地授权
有哪些新功能


623
00:39:24,731 --> 00:39:27,267
我已经提到了
AllowableReuseDuration


624
00:39:27,334 --> 00:39:29,136
和
PolicyDomainState


625
00:39:30,637 --> 00:39:34,408
另外你可以取消本地授权功能 


626
00:39:34,908 --> 00:39:38,812
并且如果用户现在会收到
Touch ID提示 


627
00:39:38,879 --> 00:39:42,749
那么取消后系统会自动为用户选择取消


628
00:39:43,183 --> 00:39:44,284
并关闭对话框


629
00:39:46,220 --> 00:39:50,190
evaluateAccessControl
让本地授权可以


630
00:39:50,257 --> 00:39:56,129
和Keychain Access Control
Lists一同使用我将稍后介绍 


631
00:39:56,230 --> 00:39:59,566
也会给出很多示例和示例代码


632
00:40:02,302 --> 00:40:05,305
所以说起Keychain Access
Control Lists


633
00:40:05,639 --> 00:40:07,941
这是第二种方式你可以
在应用内使用Touch ID


634
00:40:08,208 --> 00:40:10,978
然后用来保护特定的
Keychain项目


635
00:40:12,312 --> 00:40:13,947
这是我们的结构图


636
00:40:15,382 --> 00:40:18,919
和之前一样 Touch ID
在安全区域内发生匹配


637
00:40:19,653 --> 00:40:22,623
但是这次匹配信息会从安全区域内


638
00:40:23,156 --> 00:40:25,659
发送到Keystore


639
00:40:27,327 --> 00:40:32,499
只有在此之后
你的Keychain项目才会


640
00:40:32,933 --> 00:40:33,767
被释放回到应用中


641
00:40:37,504 --> 00:40:39,840
所以如果你想要对特定的
文件进行保护的话


642
00:40:39,907 --> 00:40:41,808
这么这种方式非常有用


643
00:40:43,477 --> 00:40:46,280
另外这也充分利用了安全区域的


644
00:40:46,680 --> 00:40:48,615
额外保护功能


645
00:40:50,617 --> 00:40:55,522
也许有时候你在权衡应用的安全性


646
00:40:55,789 --> 00:40:58,125
然后你发现有些东西你实在不想要保留


647
00:40:58,192 --> 00:41:00,394
不要每次或者经常收到提示


648
00:41:01,862 --> 00:41:04,298
你可以使用Access
Control Lists进行保存


649
00:41:04,398 --> 00:41:07,901
然后使用Touch ID进行保护
从而提供更好的用户体验


650
00:41:09,670 --> 00:41:12,406
或者你可以将其用来


651
00:41:12,673 --> 00:41:14,641
增加已经保存的项目的安全性


652
00:41:18,011 --> 00:41:21,682
你可以通过指定两项安全属性
创建访问控制列表


653
00:41:23,250 --> 00:41:25,886
第一是数据有效保护类型


654
00:41:26,653 --> 00:41:30,290
指的是需要使用密码


655
00:41:32,860 --> 00:41:35,329
才能访问安全区域里的数据
接下来你可以制定一项策略


656
00:41:36,697 --> 00:41:38,999
该策略指定了一种情况 


657
00:41:39,600 --> 00:41:42,002
只有这种情况满足后
安全区域才会释放项目


658
00:41:42,135 --> 00:41:44,137
单单访问密码是无法查阅的


659
00:41:47,608 --> 00:41:50,177
因此我们来看看策略类型


660
00:41:51,979 --> 00:41:53,580
第一种是UserPresence


661
00:41:54,047 --> 00:41:56,083
这种策略会提示需要
Touch ID匹配 


662
00:41:56,149 --> 00:41:58,252
然后返回到设备密码


663
00:41:59,486 --> 00:42:02,389
另外你也可以直接
跳转到DevicePasscode


664
00:42:04,791 --> 00:42:06,994
iOS 9的新功能是
TouchIDAny


665
00:42:08,395 --> 00:42:12,165
这种策略需要Touch Id匹配
但是不会有反馈


666
00:42:13,800 --> 00:42:18,138
另外更为严格的新策略是
TouchIDCurrentSet


667
00:42:19,173 --> 00:42:22,442
使用该策略只有在保存项目
时候使用的登记指纹组


668
00:42:22,509 --> 00:42:24,611
不发生变化的情况下


669
00:42:24,912 --> 00:42:26,346
项目才会释放


670
00:42:28,282 --> 00:42:29,483
我想要详细谈谈这种策略


671
00:42:29,850 --> 00:42:33,353
因为你的应用可能用得着


672
00:42:33,487 --> 00:42:36,423
因为这种策略提供多要素授权


673
00:42:38,492 --> 00:42:40,727
当谈到多要素的时候
你可能经常会想到


674
00:42:40,861 --> 00:42:46,066
比如像是密码还有其他一些
你可以想到的东西


675
00:42:46,133 --> 00:42:49,770
比如物理标记智能卡


676
00:42:50,804 --> 00:42:54,041
或者是iOS设备的安全区域
和Touch ID


677
00:42:56,910 --> 00:42:59,079
如果你保存一个文件 


678
00:42:59,179 --> 00:43:03,016
然后使用TouchIDCurrentSet
策略进行保护 


679
00:43:03,083 --> 00:43:06,253
如果无法成功进行Touch ID
匹配那么是无法访问文件的


680
00:43:07,688 --> 00:43:08,922
而且没有其他方式可以访问


681
00:43:09,323 --> 00:43:13,961
另外如果对手有设备密码 


682
00:43:14,628 --> 00:43:17,331
他们无法访问设置登记指纹 


683
00:43:17,831 --> 00:43:19,199
这样对手就无法访问文件了


684
00:43:24,705 --> 00:43:27,274
最后的两种策略
ApplicationPassword


685
00:43:27,341 --> 00:43:28,876
和
PrivateKeyUsage


686
00:43:29,376 --> 00:43:32,946
让你可以执行高级功能
这是Touch ID之上的高级功能


687
00:43:34,815 --> 00:43:36,850
第一个是
ApplicationPassword


688
00:43:37,818 --> 00:43:41,822
为了说明让我们看看
WhenUnlocked类别的项目


689
00:43:41,922 --> 00:43:43,156
是如何被加密保护的


690
00:43:45,025 --> 00:43:49,096
同样的即使是最好的门锁
如果你忘带钥匙还是白塔


691
00:43:49,596 --> 00:43:52,032
因此如果加密数据
和秘钥保存在同一个地方


692
00:43:52,466 --> 00:43:54,101
那么数据实际上没有得到保护


693
00:43:56,036 --> 00:43:58,872
数据保护和Keychain
安全实质上是使用设备密码保护


694
00:43:59,373 --> 00:44:01,008
而且密码已经保存在我们已知的


695
00:44:02,042 --> 00:44:06,180
最为复杂的系统之中即用户的大脑


696
00:44:08,549 --> 00:44:10,584
用户记得密码
可以使用密码访问设备


697
00:44:11,151 --> 00:44:14,054
在我们输入密码然后
会生成一把密码钥匙


698
00:44:14,521 --> 00:44:16,690
这把秘钥能破解项目密码


699
00:44:19,993 --> 00:44:23,730
现在让我们看看受
ApplicationPassword保护的项目


700
00:44:28,502 --> 00:44:32,072
只有设备密码往往是不够的


701
00:44:33,640 --> 00:44:36,510
你的应用还必须有自己的密码


702
00:44:37,578 --> 00:44:40,314
因此我们生成了密码钥匙


703
00:44:40,881 --> 00:44:45,352
而且只有在设备密码
和应用密码都正确后


704
00:44:45,953 --> 00:44:48,822
密码钥匙才会授权给
Keychain访问项目


705
00:44:51,825 --> 00:44:55,863
正如我提到的如果
你将密码保存到设备上或者应用中


706
00:44:56,530 --> 00:44:58,732
这实际上并没有提供额外的保护功能


707
00:44:59,600 --> 00:45:02,903
因此你必须考虑除了设备
你还可以将密码保存在哪里


708
00:45:04,404 --> 00:45:07,407
也许是服务器服务器
可以执行自己的策略


709
00:45:07,474 --> 00:45:09,076
决定何时反馈密码到你的应用上


710
00:45:11,111 --> 00:45:15,182
或者也许你有物理配件
而且你也觉得用户有物理配件


711
00:45:16,483 --> 00:45:19,520
如果配件无法向你的应用提供密码 


712
00:45:20,387 --> 00:45:22,656
那么就无法破解Keychain项目


713
00:45:23,123 --> 00:45:24,858
而你也无法访问数据


714
00:45:28,996 --> 00:45:34,067
如要使用ApplicationPasswords 
你需要创建AccessControl列表


715
00:45:34,668 --> 00:45:36,537
和本地授权指令


716
00:45:37,638 --> 00:45:40,407
第一个列表会要求你使用应用密码


717
00:45:40,874 --> 00:45:43,177
第二指令会自行设定密码


718
00:45:44,978 --> 00:45:47,247
然后你可以取下这二者然后添加到


719
00:45:47,314 --> 00:45:49,449
Secltem Call字典之中


720
00:45:51,218 --> 00:45:56,757
这是使用本地授权指令


721
00:45:56,957 --> 00:45:59,092
和Keychain项目的例子


722
00:46:01,862 --> 00:46:03,130
那么这就是
ApplicationPassword


723
00:46:04,431 --> 00:46:07,034
最后的新策略指的是私人秘钥用途


724
00:46:09,369 --> 00:46:10,637
这是比较早的表格 


725
00:46:11,238 --> 00:46:14,308
在这里我们可以看到一个Keychain
项目从安全区域内的KeyStore


726
00:46:14,374 --> 00:46:16,710
被释放出来返回到了应用中


727
00:46:18,445 --> 00:46:22,983
很明显如果你将密码
用于登录服务器的话就需要它了 


728
00:46:23,550 --> 00:46:26,987
但是这暴露了你的密码
让用户空间存在潜在危险


729
00:46:28,989 --> 00:46:30,791
所以如果有办法在安全区域内 


730
00:46:30,924 --> 00:46:33,460
保存密码的话就不妙了


731
00:46:33,894 --> 00:46:35,095
那么这还有用吗？ 


732
00:46:35,929 --> 00:46:38,131
而且这里使用的是不对称加密技术 


733
00:46:39,499 --> 00:46:43,036
这里我们有的不仅仅是
单一的秘钥 而是一组秘钥


734
00:46:44,671 --> 00:46:47,307
公共秘钥并不需要任何保护 


735
00:46:47,841 --> 00:46:49,877
但是私人秘钥就必须要好好保护了


736
00:46:54,114 --> 00:46:57,518
使用这种策略会用到
SecKey APi 


737
00:46:57,885 --> 00:47:00,254
而且具体说的话几分钟说不完 


738
00:47:00,320 --> 00:47:03,924
这里就略过了但是这里
有概括图可以看看流程


739
00:47:05,492 --> 00:47:09,429
如果你设定某些新的额外参数的话 


740
00:47:09,796 --> 00:47:12,065
调用SecKeyGeneratePair会让


741
00:47:12,165 --> 00:47:14,568
私人秘钥保存到安全区域中


742
00:47:15,802 --> 00:47:19,673
但是公共秘钥仍会返回到应用中保存


743
00:47:23,977 --> 00:47:26,613
如果你尝试检索使用
SecItemCopyMatching的私人秘钥 


744
00:47:26,680 --> 00:47:28,615
那么你会得到一个参数 


745
00:47:30,083 --> 00:47:35,222
但是无法在安全区域之外
获得实际的数据


746
00:47:37,658 --> 00:47:38,926
因此实际上该如何使用呢？


747
00:47:39,726 --> 00:47:42,563
好 你也许有一些数据是需要保留的


748
00:47:43,197 --> 00:47:48,802
因此你可以调用SecKeyRawSign
然后将数据传输到安全区域


749
00:47:50,137 --> 00:47:52,606
如果你已经设置了使用
Touch ID保护私人秘钥


750
00:47:52,673 --> 00:47:53,907
那么只有在成功指纹匹配后


751
00:47:54,875 --> 00:47:59,246
私人秘钥才能用于访问数据


752
00:47:59,413 --> 00:48:02,950
之后再返回到应用中


753
00:48:09,356 --> 00:48:13,727
因此也许你会想使用该策略作为第二
要素加强Touch ID的安全性


754
00:48:15,429 --> 00:48:18,532
我会给你看个示例流程但是请注意


755
00:48:18,832 --> 00:48:22,469
在编写加密协议的时候
这里有很多复杂的细节


756
00:48:22,903 --> 00:48:24,738
所以请别把这个示例当成标准


757
00:48:26,907 --> 00:48:28,675
首先在登记流程中


758
00:48:29,076 --> 00:48:30,377
你会生产一个密钥对


759
00:48:32,646 --> 00:48:37,751
然后将公共秘钥和用户
一般登录信息发送到服务器上


760
00:48:39,953 --> 00:48:43,790
服务器会将公共秘钥
和用户信息相关联并记录


761
00:48:43,857 --> 00:48:47,194
这就是登录流程


762
00:48:49,429 --> 00:48:52,199
之后当服务器想要验证你是


763
00:48:52,266 --> 00:48:55,135
从同一台物理设备登录的 


764
00:48:56,937 --> 00:48:59,039
服务器会向应用发送一个挑战 


765
00:48:59,940 --> 00:49:02,342
挑战反过来会调用
SecKeyRawSign


766
00:49:04,878 --> 00:49:06,713
用户这时候会进行指纹识别 


767
00:49:07,147 --> 00:49:08,348
然后匹配Touch ID


768
00:49:10,717 --> 00:49:14,121
这样挑战就通过了
然后应用会将挑战返回到服务器


769
00:49:16,256 --> 00:49:19,459
之后服务器会使用之前保存的公共秘钥


770
00:49:19,993 --> 00:49:21,061
进行验证签字


771
00:49:25,032 --> 00:49:27,167
再具体展开看一下细节


772
00:49:27,701 --> 00:49:30,571
通过验证的秘钥是
Elliptic Curve P256


773
00:49:31,738 --> 00:49:35,142
私人秘钥则无法提取
即使在保护情况下亦不可


774
00:49:35,709 --> 00:49:38,579
然后应用是RawSign
和RawVerify


775
00:49:43,016 --> 00:49:46,620
总结一下 我已经大概讲解了
Keychain的情况


776
00:49:47,621 --> 00:49:50,057
以及大家可能会用到
Keychain的情况


777
00:49:52,359 --> 00:49:56,396
我谈论的技术是我们应当避免
让用户被密码提示反复骚扰


778
00:49:58,465 --> 00:50:02,336
看看这两个Touch
ID API 本地授权


779
00:50:02,736 --> 00:50:04,705
和Keychain
Access Controls


780
00:50:06,340 --> 00:50:10,043
另外之前说的新的高级功能
大家可以开发出新的东西


781
00:50:10,244 --> 00:50:13,547
我们已经添加到
iOS 9的新API之中了


782
00:50:17,751 --> 00:50:22,289
App密码以及安全区
域保护的私人秘钥


783
00:50:24,391 --> 00:50:25,659
我总是非常期待


784
00:50:25,959 --> 00:50:28,862
看看大家会如何利用新的API


785
00:50:28,929 --> 00:50:30,731
开发出什么更好玩的


786
00:50:31,164 --> 00:50:36,103
也想看看大家是如何在应用中
权衡安全性和便捷性的


787
00:50:39,173 --> 00:50:41,642
另外线上还有其他更多的资料


788
00:50:43,677 --> 00:50:46,213
包括我之前提到的iOS安全白皮书


789
00:50:49,383 --> 00:50:51,919
周四的NSURL网络会议上
还会有更多的关于


790
00:50:52,352 --> 00:50:55,189
应用传输安全的内容


791
00:50:59,593 --> 00:51:02,262
另外欢迎明早和周四上午来到


792
00:51:02,663 --> 00:51:04,398
安全私人实验室会见我们


793
00:51:05,098 --> 00:51:06,066
非常感谢大家

