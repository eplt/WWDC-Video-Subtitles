1
00:00:20,554 --> 00:00:23,757
隐私安全和App


2
00:00:31,765 --> 00:00:35,569
大家好 我是姬蒂·斯金纳
今天下午我将要和傑森·諾瓦克


3
00:00:36,136 --> 00:00:39,373
一起谈论一下
关于你们app中隐私安全的问题


4
00:00:40,374 --> 00:00:43,510
我们都是苹果产品
安全及隐私团队中的成员


5
00:00:44,545 --> 00:00:47,581
这意味着我们需要
和苹果公司里所有的团队打交道


6
00:00:47,981 --> 00:00:50,684
来在我们的app
和服务中实现隐私安全


7
00:00:51,885 --> 00:00:53,854
在工作中和我联系最紧密的团队包括


8
00:00:54,388 --> 00:00:58,358
Apple Pay,Siri,Proactive 
Assistant,Health


9
00:00:59,359 --> 00:01:01,528
以及我们最新发布的操作系统
watch OS


10
00:01:02,729 --> 00:01:08,335
首先我想讲一点关于隐私安全的
意义以及我们是如何看待它的


11
00:01:10,404 --> 00:01:14,508
在苹果我们把隐私
视作人的一项基本权利


12
00:01:15,475 --> 00:01:18,111
这也是我们每天工作的首要原则


13
00:01:18,178 --> 00:01:23,584
当我们在设计app
服务以及发行新版本


14
00:01:23,650 --> 00:01:26,720
也就是IOS, OSX, watch OS的时候
我们会牢记这一点


15
00:01:28,188 --> 00:01:30,257
用户希望当他们使用我们的产品时


16
00:01:30,324 --> 00:01:33,861
他们的隐私得到尊重而对所有的开发者


17
00:01:33,927 --> 00:01:36,230
在座的每一个人来说
这是我们的共同责任


18
00:01:37,564 --> 00:01:38,932
所以当你们在开发app时


19
00:01:39,032 --> 00:01:44,805
要留心对用户隐私的保护
并将其在你们的app中实现


20
00:01:46,740 --> 00:01:50,244
在苹果我们不仅致力于做出伟大的产品


21
00:01:50,611 --> 00:01:54,715
也致力于做出伟大的工具


22
00:01:55,482 --> 00:01:58,552
面向开发团队为你们提供更多的便利


23
00:01:58,619 --> 00:02:02,923
让你们尊重用户隐私并在
你们的app和服务中实现隐私安全


24
00:02:04,591 --> 00:02:09,530
到目前为止我们所有的成功
都依赖于我们和用户之间的良好关系


25
00:02:10,864 --> 00:02:14,168
而信任是维系这段关系的关键


26
00:02:15,636 --> 00:02:18,939
我们都看过一些 关于违背隐私安全


27
00:02:19,740 --> 00:02:23,977
泄露用户信息的新闻
在座的各位都不想看到这种事情发生


28
00:02:24,044 --> 00:02:26,246
不希望苹果成为下一个此类新闻的焦点


29
00:02:28,782 --> 00:02:31,018
我们提供了这样一个平台


30
00:02:31,084 --> 00:02:33,120
让用户为新的体验感到兴奋


31
00:02:33,187 --> 00:02:35,756
兴奋于下载新的app


32
00:02:36,957 --> 00:02:41,261
这些使得我们的app
生态系统得以运转


33
00:02:41,461 --> 00:02:46,567
并且繁荣而用户对
你们的信赖是其中重要的一环


34
00:02:47,634 --> 00:02:49,703
所以我们要值得让用户信赖


35
00:02:52,906 --> 00:02:56,677
如今用户因信任而提供了许多敏感数据


36
00:02:58,011 --> 00:03:00,414
我们要成为优秀的数据管家


37
00:03:01,348 --> 00:03:05,319
隐私安全的构建是个好的入手点


38
00:03:06,820 --> 00:03:09,823
现在所有的数据都需要一份保存策略


39
00:03:10,791 --> 00:03:12,993
你们对此有什么好的想法吗？


40
00:03:13,493 --> 00:03:16,563
我们可以从如何使用这些数据入手


41
00:03:17,764 --> 00:03:20,934
对于一些你们再也用不到的数据


42
00:03:21,401 --> 00:03:23,337
不会再用它们来为用户提供服务


43
00:03:24,238 --> 00:03:25,706
那就应该把它们删掉


44
00:03:27,708 --> 00:03:30,711
对于你存储的所有数据而言


45
00:03:30,777 --> 00:03:34,715
你存储的数据越多
你对攻击者就越具有吸引力


46
00:03:35,282 --> 00:03:36,650
就越有价值


47
00:03:37,951 --> 00:03:40,654
所以要做到只保存你们需要的数据


48
00:03:42,523 --> 00:03:45,759
我认为我们收集到的
所有数据都具有风险


49
00:03:46,927 --> 00:03:51,398
所以你需要在为用户提供的价值


50
00:03:52,065 --> 00:03:56,003
和收集与存储数据本身存
在的风险之间做出权衡


51
00:03:57,938 --> 00:04:03,010
现在你可以通过把数据减到
最少的技术来降低这种风险


52
00:04:04,645 --> 00:04:08,782
为了学习这类技术以及具体应用的事例


53
00:04:08,849 --> 00:04:15,556
你们可以找找去年的WWDC演讲


54
00:04:15,656 --> 00:04:17,724
看一下IOS和OS X中的
用户隐私安全部分


55
00:04:19,726 --> 00:04:22,796
如数据聚合 分辨率降低


56
00:04:23,297 --> 00:04:27,601
这些都是减轻持有数据的风险的方法


57
00:04:29,002 --> 00:04:30,504
但具体你应该选择哪种方法呢？


58
00:04:32,105 --> 00:04:35,776
为了回答这个问题
我们可以从数据的用途入手


59
00:04:36,043 --> 00:04:37,344
你将用这些数据来做些什么？


60
00:04:37,945 --> 00:04:39,980
你想解决一些什么问题？


61
00:04:40,781 --> 00:04:42,816
它们可以辅助做出什么决策？


62
00:04:44,251 --> 00:04:48,322
如果你回答不出以上问题
你就什么都想不出来


63
00:04:48,789 --> 00:04:52,326
那么保存这些数据对你一点用都没有


64
00:04:53,193 --> 00:04:57,097
那可以使用列表中的
最后一项技术数据最小化


65
00:04:57,531 --> 00:04:59,967
你根本就不需要收集和传输这些数据


66
00:05:02,269 --> 00:05:05,873
如果你觉得可以用这些数据来做些什么


67
00:05:06,707 --> 00:05:10,010
那么在转出过程中
所有数据都应该得到保护


68
00:05:11,378 --> 00:05:14,147
一会儿傑森将要讲讲关于
app传输安全的问题


69
00:05:14,481 --> 00:05:17,584
这是我们在IOS 9中
采用的一个新方法


70
00:05:18,018 --> 00:05:21,588
来改进服务过程中的安全传输


71
00:05:23,023 --> 00:05:26,527
为了降低风险
尽可能地避免在设备中输出数据


72
00:05:26,593 --> 00:05:29,363
尤其是对于敏感的数据类别


73
00:05:29,696 --> 00:05:31,565
更要慎之又慎


74
00:05:32,099 --> 00:05:34,001
这包括一些像健康情况的数据


75
00:05:35,269 --> 00:05:37,704
举个例子在
cycling Workout中


76
00:05:38,372 --> 00:05:42,442
我们可以得到一些
诸如用户的心率和运动距离的数据


77
00:05:42,709 --> 00:05:45,512
而用户的身高 体重和校正数据


78
00:05:46,146 --> 00:05:49,650
都可能在配对设备中获取


79
00:05:50,250 --> 00:05:52,719
可以计算出在运动过程中
卡路里消耗的情况


80
00:05:53,787 --> 00:05:56,423
这些数据都不会反馈到
服务器中处理分析


81
00:05:58,692 --> 00:06:02,262
现在我们不仅需要
在传输过程中保护数据


82
00:06:02,462 --> 00:06:03,830
在存储过程中也是一样


83
00:06:05,332 --> 00:06:08,535
首先考虑一下是否需要存储这些数据？


84
00:06:10,137 --> 00:06:11,305
是否只是需要短期保存？


85
00:06:11,572 --> 00:06:13,574
能不能只在内存中存储呢？


86
00:06:14,174 --> 00:06:15,776
或者说它需要被写进盘里吗？


87
00:06:17,077 --> 00:06:19,980
IOS和watch OS
平台受益于数据保护


88
00:06:20,380 --> 00:06:22,282
我将一会儿再谈论这个


89
00:06:23,817 --> 00:06:25,385
如果你在服务端存储数据


90
00:06:25,485 --> 00:06:27,688
要保证在空闲时段能对数据加密


91
00:06:28,455 --> 00:06:30,891
使用CloudKit我们就
能很容易得实现这一点


92
00:06:32,392 --> 00:06:35,729
思考一下在你的数据传输
和存储时应该用什么样的标识符呢


93
00:06:36,163 --> 00:06:40,734
一会儿傑森将会深入介绍一下
如何选择合适的标识符的问题


94
00:06:43,170 --> 00:06:45,906
现在你需要让用户明白


95
00:06:45,973 --> 00:06:48,809
你将用你的这些数据
这些来源于用户的数据做些什么


96
00:06:48,876 --> 00:06:51,378
你将如何使用它们
如果你将要和第三方分享数据


97
00:06:51,445 --> 00:06:53,180
这些都需要保持透明


98
00:06:53,647 --> 00:06:55,883
要确保用户可以理解你在做什么


99
00:06:56,917 --> 00:06:58,952
避免用户产生任何的恐慌


100
00:07:01,121 --> 00:07:03,757
这里有一种好的解决方式


101
00:07:04,224 --> 00:07:07,828
让用户明白他们的数据
是如何被收集和存储的


102
00:07:08,262 --> 00:07:10,264
那就是给用户检查他们数据的权利


103
00:07:11,798 --> 00:07:14,501
而且在你收集数据的时候


104
00:07:14,568 --> 00:07:18,539
或者说当你提供给用户选择权时


105
00:07:18,605 --> 00:07:20,641
你希望通过透露一些信息


106
00:07:21,108 --> 00:07:22,409
来帮助用户做出更好的选择


107
00:07:23,143 --> 00:07:25,012
你可以通过采用目的字符串等解决方案


108
00:07:25,612 --> 00:07:29,016
当用户在考虑他们是否要给你们
提供照片等信息的权限的同时


109
00:07:30,250 --> 00:07:32,052
你也希望用户能掌握主控权


110
00:07:32,886 --> 00:07:35,255
要给他们更改决定的权利


111
00:07:35,422 --> 00:07:39,259
如果稍后他们的决定变得和先前不同


112
00:07:39,860 --> 00:07:44,798
那时要给他们一个机会
对你已经存储的信息进行重置甚至删除


113
00:07:47,935 --> 00:07:50,904
现在我要谈一些关于我们的平台


114
00:07:50,971 --> 00:07:52,840
在提高用户隐私安全
方面做出的一些更新


115
00:07:54,908 --> 00:07:58,478
我想讲一下在IOS,OS X
平台中发生的一些改变


116
00:07:59,279 --> 00:08:02,149
还有一些在watch OS
平台中的基础的东西


117
00:08:03,750 --> 00:08:06,587
首先说到IOS平台的发展
我们可以追溯到去年


118
00:08:07,521 --> 00:08:11,225
在去年我们开始配置加密的MAC地址


119
00:08:11,558 --> 00:08:13,460
来应对几种特定的wifi扫描方式


120
00:08:14,661 --> 00:08:17,331
在ios 9平台里
我们增加了扫描方式的数目


121
00:08:17,598 --> 00:08:19,766
对其MAC地址进行加密


122
00:08:20,601 --> 00:08:24,271
值得注意的是
如果你的功能是基于外设的


123
00:08:24,338 --> 00:08:28,175
一定要先在IOS 9中
对MAC地址做测试确认


124
00:08:28,942 --> 00:08:32,513
因为在正式使用之前
你不能保证MAC地址的可用性


125
00:08:34,948 --> 00:08:38,519
简单来说我们认为想在手机上


126
00:08:38,919 --> 00:08:42,322
安什么软件是由用户决定的


127
00:08:43,890 --> 00:08:46,693
用户可以用他们的手机做许多事


128
00:08:47,628 --> 00:08:50,564
他们也有各种各样的理由
来安装自己喜欢的app


129
00:08:51,398 --> 00:08:54,334
健康养生 金融理财
居家生活等 不胜枚举


130
00:08:55,569 --> 00:08:58,305
就目前来说用户安装了哪些app


131
00:08:58,705 --> 00:09:01,875
以及那些app从用户身上获取了些
什么信息已经变成了非常敏感的事


132
00:09:03,143 --> 00:09:06,079
所以要尝试着检测出
用户安装了什么app


133
00:09:06,680 --> 00:09:10,717
通过直接进行识别
或者收集相关信息来辅助判断


134
00:09:10,951 --> 00:09:13,620
来找出一些违反IOS的
安全模型的内容


135
00:09:15,656 --> 00:09:19,860
最终IOS安全系统会对确定
出来的app进行建模分析


136
00:09:20,928 --> 00:09:23,530
它们仅在自己的沙箱中存活


137
00:09:23,697 --> 00:09:25,599
这可以保护它们不被
其他的app和进程侵害


138
00:09:27,100 --> 00:09:30,771
尝试确定用户在手机上安装了什么app


139
00:09:31,638 --> 00:09:33,807
是IOS安全模型的一项颠覆性成果


140
00:09:36,310 --> 00:09:40,414
现在与之相伴的是
canOpenURL今年也在改变


141
00:09:43,050 --> 00:09:45,652
canOpenURL存在的意义


142
00:09:45,886 --> 00:09:49,990
是为了确认一个app
能否打开指定的URL资源


143
00:09:51,158 --> 00:09:54,428
这可以为一些功能提供支持


144
00:09:54,828 --> 00:09:57,664
比如当手机里安装一个新的app时


145
00:09:58,432 --> 00:10:00,234
它会提示用户可以实现
一些什么新的操作


146
00:10:02,269 --> 00:10:07,741
有两个新方向你们可以了解一下


147
00:10:08,442 --> 00:10:09,610
菜单和通用链接


148
00:10:09,910 --> 00:10:11,979
他们支持一些和URL方案相同的功能


149
00:10:12,045 --> 00:10:13,680
我希望你们可以多关注一下那些方面


150
00:10:14,481 --> 00:10:17,985
但是如果你想继续使用URL方案


151
00:10:18,051 --> 00:10:21,021
在IOS 9里开发你的app
并且想要调用URL方案


152
00:10:21,288 --> 00:10:24,758
你需要知道的是你得先在app中的
Info.plist文件中声明它们


153
00:10:25,359 --> 00:10:28,762
这里有个新增索引键叫
LSApplicationQueriesSchemes


154
00:10:29,363 --> 00:10:32,266
在这里你需要把canOpenURL


155
00:10:32,499 --> 00:10:35,435
添加进方案列表


156
00:10:37,871 --> 00:10:40,707
现在你不用改变对
canOpenURL的调用方式


157
00:10:41,074 --> 00:10:43,043
当前API也不会发生改变


158
00:10:43,810 --> 00:10:46,346
但是一旦你调用了
canOpenURL


159
00:10:46,713 --> 00:10:49,049
它就会检查你app中的
Info.plist文件


160
00:10:49,683 --> 00:10:54,087
看看你所调用的方案是否已经被声明


161
00:10:55,489 --> 00:10:58,859
所以说你需要先对其进行声明


162
00:10:59,026 --> 00:11:05,232
当你在那个方案中调用
canOpenURL时 


163
00:11:05,699 --> 00:11:08,302
如果安装的app支持这个方案
那么返回值为真


164
00:11:09,303 --> 00:11:13,540
如果并没有安装任何app
那么返回值为无


165
00:11:16,210 --> 00:11:18,745
所以如果你没有声明URL方案
会发生些什么呢


166
00:11:19,346 --> 00:11:22,149
不管这里是否有一个支持它的app


167
00:11:22,349 --> 00:11:25,085
你收到的返回值始终为无


168
00:11:28,255 --> 00:11:32,559
所以对于那些在IOS 9
之前版本被链接


169
00:11:33,460 --> 00:11:35,362
以及在IOS 9中运行的app来说


170
00:11:35,462 --> 00:11:39,566
只给它们50个独立的URL方案


171
00:11:41,101 --> 00:11:43,403
一旦你连续调用到第51个方案的时候


172
00:11:43,937 --> 00:11:45,506
你将会收到的返回值为无


173
00:11:46,673 --> 00:11:49,576
即使当用户重启手机的时候


174
00:11:49,643 --> 00:11:51,979
这50个URL方案也不会被重启


175
00:11:54,381 --> 00:11:58,252
我之前提到的今年新出的
一种可替代方案是通用链接


176
00:11:58,886 --> 00:12:03,023
通用链接的厉害之处就在于
如果用户已安装某个app


177
00:12:03,190 --> 00:12:04,258
链接将会开启


178
00:12:05,025 --> 00:12:06,960
同时也会发送一个反馈信息


179
00:12:07,294 --> 00:12:11,098
如果没有安装这个app
链接将只会在app的网页端开启


180
00:12:12,366 --> 00:12:15,335
Sysctl命令今年
也发生了一些变化


181
00:12:16,270 --> 00:12:20,340
Sysctl是一种低水平的API


182
00:12:20,607 --> 00:12:22,242
用以询问和设置系统信息


183
00:12:24,044 --> 00:12:28,115
它涉及的初衷就是允许具
有合适权限的进程来浏览信息


184
00:12:29,750 --> 00:12:34,588
但正如我之前所说


185
00:12:35,088 --> 00:12:38,759
IOS中的app并没有浏览
其他app的信息的权限


186
00:12:39,860 --> 00:12:43,130
所以IOS沙箱今年发生了一个变化


187
00:12:44,598 --> 00:12:51,271
那就是它再也不能通过调用kern.proc
kern.procargs


188
00:12:51,772 --> 00:12:56,243
和kern.procargs2来看到


189
00:12:56,543 --> 00:12:58,779
来自其他任何进程的数据


190
00:13:00,814 --> 00:13:04,484
今年在IOS和OS X这两个平台上


191
00:13:06,053 --> 00:13:09,323
我们即将引入内容过滤
方面的新的延伸点


192
00:13:11,124 --> 00:13:14,194
你的分程序表将能适
用于Safari


193
00:13:15,028 --> 00:13:18,532
以及所有使用
SafariViewController的app 


194
00:13:20,501 --> 00:13:23,070
你应该去测试一下
非常受欢迎的扩展功能


195
00:13:23,136 --> 00:13:24,938
来了解它将为你的应用或网页


196
00:13:25,205 --> 00:13:27,741
带来怎样的影响


197
00:13:30,277 --> 00:13:33,380
你应该时刻做好心理准备
你的页面中的某一部分


198
00:13:33,447 --> 00:13:35,883
会在加载和处理它时遇到些问题


199
00:13:38,852 --> 00:13:43,423
接下来要说的是在OS X平台上
我们正在尝试改变cookie策略


200
00:13:45,125 --> 00:13:48,028
自从产生了可以在所有应用和进程中


201
00:13:48,095 --> 00:13:50,297
分享cookie的
Yosemite系统之后


202
00:13:51,064 --> 00:13:53,901
Cookie如今已变成了本地所有


203
00:13:54,701 --> 00:13:57,371
它们对于单一进程来说是
属于本地的并且不可共享


204
00:13:58,172 --> 00:14:02,409
注意如果你已经在
App Store中运行过你的应用


205
00:14:03,076 --> 00:14:04,478
那对你来说就不会发生任何改变


206
00:14:05,312 --> 00:14:06,547
因为你已经在这种状态中了


207
00:14:08,081 --> 00:14:11,485
如果你使用了Web Clips
或者Dashboard小工具


208
00:14:11,785 --> 00:14:14,521
请注意要在OS X
EI Capitan中进行测试


209
00:14:17,991 --> 00:14:20,494
现在我要讲一些关于
我们最新平台的内容


210
00:14:21,962 --> 00:14:27,401
在这些年里我们看着IOS
和OS X系统一步步得发展成熟


211
00:14:28,368 --> 00:14:30,437
正是这些经历让我们从一开始就确信


212
00:14:31,071 --> 00:14:35,375
对于在新平台中建设好隐私和安全问题


213
00:14:36,109 --> 00:14:38,679
我们已经有不错的基础了


214
00:14:40,380 --> 00:14:42,249
我们的优势包括一些已有的技术


215
00:14:42,482 --> 00:14:45,352
比如数据保护和我们的即时预警技术


216
00:14:46,320 --> 00:14:49,223
我们认为这些装置是紧密相关的


217
00:14:50,524 --> 00:14:53,627
对于用户来说只需要与这
两个装置中的其一建立联系就行


218
00:14:54,428 --> 00:14:57,130
这也是为什么许多设置可以通用的原因


219
00:14:58,465 --> 00:15:01,034
这同时也包括


220
00:15:02,002 --> 00:15:03,770
你在本地WatchKit app
中的隐私设置


221
00:15:03,837 --> 00:15:07,107
所以不管用户是和你的
IOS中的app进行交互


222
00:15:07,608 --> 00:15:12,212
还是和Glance
或者其他第三方进行交互


223
00:15:13,213 --> 00:15:15,816
在隐私安全方面的设置都是相同的


224
00:15:17,050 --> 00:15:21,088
我们相信如果用户对于
开发者是无条件信任的


225
00:15:22,089 --> 00:15:23,457
他们就不会产生这样一些异议


226
00:15:23,524 --> 00:15:26,627
比如想“能不能给他们权限
来访问我Glance中的照片呢？”


227
00:15:26,960 --> 00:15:28,662
用户有着很单一的信任方式


228
00:15:29,162 --> 00:15:33,433
他们因信任而允许你访问数据
并且对数据提供保护或者相反


229
00:15:36,270 --> 00:15:39,473
所以我们认为


230
00:15:39,940 --> 00:15:43,977
从一开始就把关注点放在
做好隐私保护工作是非常重要的


231
00:15:44,711 --> 00:15:50,250
因为你的Glance可能成为
用户与你的app交互最多的一个地方


232
00:15:53,020 --> 00:15:57,057
并且，在watchOS 2平台上
把钥匙串系统引进到Watch中


233
00:15:59,426 --> 00:16:03,397
接下来将由Jason负责主讲他将
涉及更多关于如何选择标识符的问题


234
00:16:10,604 --> 00:16:13,173
感谢姬蒂 现在我将讲一下


235
00:16:13,340 --> 00:16:15,843
关于在IOS和watchOS中的
标识符的问题


236
00:16:16,176 --> 00:16:18,145
这是我们在之前的演讲中


237
00:16:18,212 --> 00:16:19,546
就谈到过的一个问题


238
00:16:19,613 --> 00:16:22,616
你们可以回顾一下去年的WWDC演讲


239
00:16:22,683 --> 00:16:24,284
来进行一下更加深入的了解


240
00:16:25,018 --> 00:16:27,654
但是我认为
在讲watchOS中的标识符之前


241
00:16:27,721 --> 00:16:31,692
回顾一下之前在IOS系统中
学过的一些知识也是非常必要的


242
00:16:33,126 --> 00:16:34,494
标识符是具有很大作用的


243
00:16:34,928 --> 00:16:36,830
它们的厉害之处就在于


244
00:16:36,897 --> 00:16:39,666
如果你使用一些用户
相关的内容来鉴别他们


245
00:16:39,900 --> 00:16:43,871
比如用户的姓名 电话号码
邮箱等 可以从中披露出许多信息


246
00:16:45,072 --> 00:16:47,341
你可以建立更注重隐私安全的标识符


247
00:16:47,474 --> 00:16:53,547
通过生成随机数来实现或者如果要求
随机数的结构规整你可以使用UUID


248
00:16:54,515 --> 00:16:57,918
当一个随机数或者UUID
不能够鉴别用户


249
00:16:58,118 --> 00:16:59,653
那就取决于你记录了什么信息


250
00:17:00,220 --> 00:17:01,922
你以怎样的频率来切换标识符


251
00:17:01,989 --> 00:17:03,690
以及用户掌控着些什么


252
00:17:03,857 --> 00:17:06,326
超过规定时间标识符就会解除匿名


253
00:17:06,660 --> 00:17:08,962
由于你记录着许多种不同的信息


254
00:17:09,329 --> 00:17:12,499
那些信息可能识别具体用户
比如app动态


255
00:17:13,032 --> 00:17:16,537
搜索词条 消息或者位置信息


256
00:17:16,603 --> 00:17:19,106
这些都取决于你的app的行为


257
00:17:20,040 --> 00:17:22,542
那就意味着所有标识符都携带有风险


258
00:17:23,042 --> 00:17:25,145
即使标识符本身是可以匿名的


259
00:17:25,412 --> 00:17:27,047
如果你持有的数据不能匿名


260
00:17:27,614 --> 00:17:30,050
一旦其中一个数据违反了这一规则


261
00:17:30,117 --> 00:17:31,718
你将担起危害用户隐私安全的后果


262
00:17:32,486 --> 00:17:34,087
紧接着就是名誉受损


263
00:17:34,421 --> 00:17:35,822
你会失去用户的信任


264
00:17:36,490 --> 00:17:38,725
当我提及数据泄露你可能会想到黑客


265
00:17:38,792 --> 00:17:40,727
或者其他不法势力


266
00:17:41,228 --> 00:17:45,032
但那其实就像从把一个
未设密的笔记本从车的后备箱偷出来


267
00:17:45,199 --> 00:17:47,367
或者备份文件从卡车上掉下来那么简单


268
00:17:48,702 --> 00:17:51,572
正因为标识符的力量是如此强大


269
00:17:51,638 --> 00:17:53,807
苹果花费了大量的时间
来研究标识符该如何运作


270
00:17:54,007 --> 00:17:55,209
以及筛选一些最优方案


271
00:17:56,577 --> 00:17:59,146
所以首先在你使用标识符之前


272
00:17:59,246 --> 00:18:01,215
问一下你自己 你真的需要吗?


273
00:18:01,715 --> 00:18:03,884
你是否用以下方式收集数据呢？


274
00:18:04,251 --> 00:18:07,287
通过一个存储到服务器端的
数据库或者字典值


275
00:18:07,354 --> 00:18:11,525
由客户端向服务器发送信息


276
00:18:11,992 --> 00:18:14,995
而你只需记录服务器的增量数据？


277
00:18:16,663 --> 00:18:18,899
如果你确定了自己真的需要使用标识符


278
00:18:19,233 --> 00:18:20,801
考虑一下你想用它来标识什么


279
00:18:21,001 --> 00:18:22,870
你需要使用多长时间


280
00:18:23,637 --> 00:18:25,739
你只是想识别一个会话


281
00:18:25,806 --> 00:18:28,742
通过简单得在app中
发送标识符来为不同进程取得关联？


282
00:18:29,309 --> 00:18:30,244
你是否在尝试...


283
00:18:30,310 --> 00:18:33,080
以及能不能在每次开启和
关闭app的时候都切换标识符呢？


284
00:18:33,947 --> 00:18:35,716
你是否只着眼于暂时性的活动


285
00:18:35,916 --> 00:18:39,820
每隔5,10或者15分钟
都会切换标识符？


286
00:18:40,854 --> 00:18:43,991
我们知道切换标识符因其
可以降低数据相关性


287
00:18:44,057 --> 00:18:47,160
而能起到隐私保护的作用


288
00:18:47,561 --> 00:18:49,563
我们一会儿将要通过
一个例子来说明具体情况


289
00:18:50,864 --> 00:18:52,533
如果你要标识一个用户


290
00:18:53,400 --> 00:18:56,003
你要怎样同用户解释


291
00:18:56,170 --> 00:18:58,472
为何拒绝他们安装一些
同样需要标识用户的应用呢？


292
00:18:59,206 --> 00:19:02,142
你使他们通过你的服务建立了账户吗？


293
00:19:02,242 --> 00:19:03,710
你是否要求他们登录？


294
00:19:04,211 --> 00:19:06,680
你能在UI界面中用语言描述清楚


295
00:19:06,747 --> 00:19:09,149
你之所以这样做
是为了让他们获得更好的用户体验吗？


296
00:19:09,883 --> 00:19:13,353
当你想清楚如何向用户
解释这些之后你真的考虑好


297
00:19:13,620 --> 00:19:19,560
在收集数据的同时要承担的
用户标识方面的风险了吗？


298
00:19:21,495 --> 00:19:24,164
最后如果你想收集


299
00:19:24,331 --> 00:19:28,769
关于手机上app安装的信息在避免
触及用户的其他信息或者会话的情况下


300
00:19:29,369 --> 00:19:31,338
你是否设计出了合适的度量方法


301
00:19:31,405 --> 00:19:34,074
来统计计算用户在
设备上的一些操作实例


302
00:19:34,141 --> 00:19:36,910
比如用户在第二个手机上
卸载或下载一个app


303
00:19:36,977 --> 00:19:40,714
或者备份数据以及进行设备间存储呢？


304
00:19:41,114 --> 00:19:45,419
在那些过程中关于用户的隐私保护方面


305
00:19:45,485 --> 00:19:49,957
标识符的重置和不变是否能在你的
度量体系中有合理的解释？


306
00:19:52,593 --> 00:19:55,062
最后你该考虑一下关于
标识符范围的问题


307
00:19:55,629 --> 00:19:56,930
通过一个固定不变的标识符


308
00:19:56,997 --> 00:20:01,869
利用它属性上的特征来
跟踪用户的一切行为是非常容易的


309
00:20:02,503 --> 00:20:04,738
但用户的隐私安全也被极大降低了


310
00:20:05,072 --> 00:20:09,510
许多数据是通过单一标识符被收集的
当环境发生变化


311
00:20:09,576 --> 00:20:11,778
内容发生变化时标识符却不会发生变化


312
00:20:12,880 --> 00:20:16,783
而且用户也不希望用同一个
标识被跟踪所有的内容


313
00:20:17,284 --> 00:20:18,919
审视标识符的作用域


314
00:20:18,986 --> 00:20:23,290
你将会得到针对不同目的
针对和不同数据关联的


315
00:20:23,357 --> 00:20:25,192
针对不同存活期的不同标识符


316
00:20:26,894 --> 00:20:28,762
现在我要举一个例子


317
00:20:28,929 --> 00:20:32,933
描述一种可以增加你
隐私安全的特殊的标识符


318
00:20:32,999 --> 00:20:34,601
它把可能面临的风险降到最低


319
00:20:35,002 --> 00:20:37,905
设计出用同一标识符搜索
所有信息的服务是非常简单的


320
00:20:37,971 --> 00:20:40,707
可一旦发生了数据泄露


321
00:20:41,141 --> 00:20:43,110
即使标识符是匿名的


322
00:20:43,777 --> 00:20:45,779
也能通过已有信息来识别出用户


323
00:20:46,079 --> 00:20:48,482
因为除了别的东西之外
用户还会搜索与自己相关的内容


324
00:20:48,849 --> 00:20:51,852
这种情况将会造成用户对我们丧失信任


325
00:20:52,920 --> 00:20:55,556
比如在这个例子中标识符是匿名的


326
00:20:55,622 --> 00:20:58,926
它是123.但是我们可以
从中看出许多事实


327
00:20:59,359 --> 00:21:02,229
用户123正在考虑订婚


328
00:21:02,596 --> 00:21:04,031
可能在过去的周六


329
00:21:04,531 --> 00:21:06,867
他们可能并不是来自圣弗朗西斯科


330
00:21:06,934 --> 00:21:08,735
因为他们在寻找来自
圣弗朗西斯科的航班


331
00:21:09,069 --> 00:21:10,237
他们可能要去WWDC


332
00:21:10,404 --> 00:21:14,041
他们可能是
John Appleseed


333
00:21:14,241 --> 00:21:16,143
他们可能对
John Appleseed很感兴趣


334
00:21:16,210 --> 00:21:19,012
我们并不能确定但一旦知道了更多信息


335
00:21:19,079 --> 00:21:21,215
我们能清晰得判断出真相


336
00:21:21,648 --> 00:21:25,819
另一方面如果你的搜索服务
使用了可切换标识符


337
00:21:26,119 --> 00:21:27,487
即使数据泄露了


338
00:21:27,721 --> 00:21:30,424
对用户隐私安全的损害也被最小化


339
00:21:30,824 --> 00:21:32,392
因为标识符在不断改变


340
00:21:32,860 --> 00:21:35,829
在这个例子中
如果标识符每15分钟变换一次


341
00:21:36,296 --> 00:21:40,167
我们就不能确定用户
123和用户456或者用户789


342
00:21:40,901 --> 00:21:42,069
其实是同一个人


343
00:21:45,138 --> 00:21:47,474
所以我要谈论一下固定标识符


344
00:21:48,041 --> 00:21:51,144
由于他们能对用户提供长期跟踪


345
00:21:51,211 --> 00:21:53,080
危害了用户隐私安全


346
00:21:53,714 --> 00:21:56,817
所以它们在IOS和
watchOS中不再被设计使用


347
00:21:58,619 --> 00:22:00,721
苹果想为用户提供惊喜和愉悦的体验


348
00:22:00,921 --> 00:22:03,557
但如果不经过用户的同意而追踪他们
用户不会感到开心


349
00:22:04,024 --> 00:22:05,859
这并不符合用户的心理预期


350
00:22:05,993 --> 00:22:08,629
如果他们在同一标识符下
被一个app追踪


351
00:22:09,229 --> 00:22:11,565
即使当他们卸载了
app并进行重新配置


352
00:22:11,632 --> 00:22:13,267
或者采用其它更具破坏力的操作行为


353
00:22:13,734 --> 00:22:14,835
比如擦除手机记录


354
00:22:16,570 --> 00:22:19,306
但最终因为固定标识符是永久不变的


355
00:22:19,806 --> 00:22:21,341
用户并不能对此进行改变


356
00:22:21,942 --> 00:22:23,277
就像姬蒂之前说过的


357
00:22:23,343 --> 00:22:26,580
我们认为让用户拥有更多的控制权
对隐私安全是非常重要的


358
00:22:29,016 --> 00:22:31,985
为了在开发者对标识数据的需求


359
00:22:32,519 --> 00:22:34,354
同保护用户隐私之间做权衡


360
00:22:34,788 --> 00:22:37,658
我们在IOS平台建立了
一系列有目的作用域的标识符


361
00:22:37,891 --> 00:22:39,993
让开发者可以收集他们需要的数据


362
00:22:40,294 --> 00:22:42,496
投入进分析和智能广告环境中


363
00:22:42,696 --> 00:22:46,600
同时用户也可以通过控制标识符的重置


364
00:22:46,900 --> 00:22:49,703
来打破他们当前的行为记录


365
00:22:50,037 --> 00:22:51,338
和被收集的历史数据


366
00:22:51,839 --> 00:22:53,307
之间的关联


367
00:22:54,341 --> 00:22:55,876
在app层级上


368
00:22:56,076 --> 00:22:59,079
在用户从某个给定
team ID卸载了所有app之后


369
00:22:59,513 --> 00:23:03,083
我们可以通过重置vendor
标识符和IDFV来实现


370
00:23:04,284 --> 00:23:08,722
在广告环境中我们给用户
重置广告标识符的权利


371
00:23:09,156 --> 00:23:11,925
可以通过依次选择“Settings”
“Privacy”和“Advertising”


372
00:23:11,992 --> 00:23:14,995
再点击
“Reset Advertisement Identifier”


373
00:23:15,062 --> 00:23:18,632
来重置广告标识符
因此用户可以轻易重置手机中的标识符


374
00:23:18,899 --> 00:23:23,904
不用擦除任何数据就可以打破
和被收集的历史数据之间的联系


375
00:23:25,739 --> 00:23:27,140
在watchOS 1中


376
00:23:28,108 --> 00:23:30,177
vendor ID和广告ID


377
00:23:30,477 --> 00:23:35,182
在iPhone中是作为
WatchKit运行的扩展而存在的


378
00:23:35,782 --> 00:23:36,950
在watchOS 2中


379
00:23:37,217 --> 00:23:41,121
你需要从iPhone中
把vendor ID和广告ID


380
00:23:41,555 --> 00:23:42,956
同步到Watch上使用


381
00:23:43,323 --> 00:23:47,094
你需要维持vendor ID
和广告ID的同步更新


382
00:23:49,162 --> 00:23:50,797
所以现在我将要回顾一些最佳方法


383
00:23:51,798 --> 00:23:53,400
确定你需要一个标识符


384
00:23:53,934 --> 00:23:56,570
你可以只发送一个值
然后在服务器端记录增量吗？


385
00:23:57,137 --> 00:24:00,307
通过标识符来收集信息带来责任的同时


386
00:24:00,374 --> 00:24:01,308
也带来了风险


387
00:24:01,875 --> 00:24:03,777
如果你可以仅在增量数据中收集值


388
00:24:03,844 --> 00:24:06,113
那么就增加了用户隐私安全


389
00:24:06,446 --> 00:24:08,081
也为你自己的数据收集降低了风险


390
00:24:09,316 --> 00:24:11,485
使用合适的标识符作用范围


391
00:24:11,985 --> 00:24:14,955
确定当你真的需要
标识一个会话一个用户


392
00:24:15,322 --> 00:24:19,193
或者一个设备就根据你app的目的
来选择标识符作用范围


393
00:24:20,961 --> 00:24:22,996
iOS 和 watchOS
提供了一些标识符


394
00:24:23,063 --> 00:24:25,532
所以可以直接使用它们
不用新建你自己的标识符


395
00:24:26,333 --> 00:24:28,035
试着建立一个永久标识符


396
00:24:28,535 --> 00:24:31,405
它的值不因手机重置
或者其他毁灭性的操作


397
00:24:31,471 --> 00:24:32,439
比如移除你的app


398
00:24:32,739 --> 00:24:35,409
而改变这既不利于保护
用户隐私也不利于你的app运行


399
00:24:35,809 --> 00:24:39,513
如果你在使用私有API
来建立一个永久标识符


400
00:24:39,746 --> 00:24:41,615
你已违反了APP Store的条例


401
00:24:41,748 --> 00:24:43,116
这将带来许多不良后果


402
00:24:44,551 --> 00:24:47,821
最后要遵循设计标识符的基本原则


403
00:24:47,888 --> 00:24:51,825
其中你该遵循的最重要的原则之一就是


404
00:24:52,192 --> 00:24:55,128
在你调用广告标识符之前


405
00:24:55,195 --> 00:24:57,865
检查一下Limit
Ad Tracking的值


406
00:24:57,931 --> 00:25:00,067
同时要时刻跟踪广告标识符的当前值


407
00:25:00,834 --> 00:25:04,338
用户可以在任意时间
重置广告标识符的值


408
00:25:04,771 --> 00:25:10,611
此外授权广告跟踪的操作
也造成了广告标识符的重置


409
00:25:11,245 --> 00:25:16,617
正因为这个你需要保证自己知晓当前值
并且不要把它存在cache里


410
00:25:17,684 --> 00:25:19,419
最后我们谈一点报告相关的问题


411
00:25:19,953 --> 00:25:22,389
我们知道在座许多都有
给合作伙伴提供报告的义务


412
00:25:22,623 --> 00:25:24,525
但是我们认为在给第三方提供报告时


413
00:25:24,591 --> 00:25:27,261
维护用户隐私是非常重要的


414
00:25:27,961 --> 00:25:30,063
我们考虑了许多如何做
和用户有关的报告的问题


415
00:25:30,130 --> 00:25:33,800
你们也能看到我们把许多机器学习的
部分嵌入到了App Analytics中


416
00:25:34,935 --> 00:25:38,272
在提供报告的过程中
主要有三种重要的思想


417
00:25:38,805 --> 00:25:40,908
和用户相关的报告所处的视野


418
00:25:41,074 --> 00:25:42,176
报告的聚合


419
00:25:42,543 --> 00:25:43,377
以及设定一个阈值


420
00:25:44,178 --> 00:25:45,812
我所说的报告的视野是什么意思呢？


421
00:25:46,513 --> 00:25:49,850
对于合作伙伴来说比起想了解


422
00:25:50,417 --> 00:25:52,853
是哪些人在频繁得使用你的app


423
00:25:52,920 --> 00:25:56,690
以及提供所有关于app
用量的数据来让他们计算


424
00:25:57,157 --> 00:26:00,694
他们更想在确定计算方式定义的基础上


425
00:26:01,161 --> 00:26:03,897
让我们基于数据进行计算


426
00:26:04,398 --> 00:26:07,401
提供计算结果而不是递过去原始数据


427
00:26:08,569 --> 00:26:11,705
保护用户隐私的下一步是做聚合


428
00:26:12,072 --> 00:26:14,975
比起说出哪些用户是重度用户


429
00:26:15,042 --> 00:26:17,177
不如说出你有多少个重度用户


430
00:26:17,244 --> 00:26:18,912
他们在整个群体中占多大比例


431
00:26:19,646 --> 00:26:22,182
最后报告中需要设定阈值


432
00:26:22,749 --> 00:26:25,052
如果你要在报告中写你有一个重度用户


433
00:26:25,319 --> 00:26:27,087
而你的app只有一个用户


434
00:26:27,287 --> 00:26:29,389
如果你以对待群体用户的
方式来提供用户信息


435
00:26:29,456 --> 00:26:31,491
比如提供邮政编码


436
00:26:32,059 --> 00:26:34,027
那你就暴露了你的用户


437
00:26:34,194 --> 00:26:36,029
在你提供用户信息之前要设置一个阈值


438
00:26:36,597 --> 00:26:40,400
确定你不会暴露用户隐私
应该让他们以群体的形式出现


439
00:26:42,669 --> 00:26:46,507
我将会讲一些关于如何
提示用户数据的最优方法


440
00:26:46,573 --> 00:26:51,178
先讲在Watch平台的给大家提提神
再延伸到IOS和OS X中


441
00:26:51,512 --> 00:26:53,413
当你想要接触到数据类的时候


442
00:26:53,847 --> 00:26:56,316
操作系统不会直接提供给你数据


443
00:26:56,717 --> 00:26:59,386
直到用户选择了是否能


444
00:26:59,853 --> 00:27:01,622
让你的app获取接收数据的权限才行


445
00:27:03,323 --> 00:27:06,293
所以用户可以知道
app用这些数据做些什么


446
00:27:06,360 --> 00:27:09,329
因此你对数据的收集和使用
对用户来说就变成了透明的过程


447
00:27:09,663 --> 00:27:11,498
因此我们在提示中提供了这样一个空间


448
00:27:11,565 --> 00:27:12,966
你可以在这里向用户解释说明


449
00:27:13,667 --> 00:27:14,902
这就叫做目的字符串


450
00:27:15,202 --> 00:27:17,538
你可以针对多种受保护的数据类


451
00:27:17,604 --> 00:27:20,274
把他们设置进你的app
和Info.plist中


452
00:27:20,340 --> 00:27:23,443
我们认为如果用户理解
为什么你们想获得数据访问权限


453
00:27:23,710 --> 00:27:26,146
他们就更有可能做出正确的选择


454
00:27:28,916 --> 00:27:32,553
就像姬蒂之前说过的那样
提防着有限的“不动产”的可用性


455
00:27:33,120 --> 00:27:35,589
让我们的意图变得透明增加用户控制


456
00:27:36,023 --> 00:27:38,926
我们考虑过Watch上的app
如何获取用户数据的问题


457
00:27:39,860 --> 00:27:42,829
首先就像在IOS和OS X中那样


458
00:27:43,597 --> 00:27:46,300
watchOS上的app
并不能直接获取用户数据


459
00:27:46,600 --> 00:27:48,001
直到获得用户的允许


460
00:27:49,536 --> 00:27:52,706
然而和IOS和OS X
不同的是在watchOS上


461
00:27:52,773 --> 00:27:56,376
用户不能选择接受
或拒绝设备本身发出的即时提示


462
00:27:57,244 --> 00:27:59,012
或者说那些是指向iPhone的


463
00:27:59,379 --> 00:28:03,350
正如姬蒂所说我们可以把
iPhone和与其配对的Watch


464
00:28:03,750 --> 00:28:07,020
视作紧密相连的用户
在其中一个平台上做出的


465
00:28:07,087 --> 00:28:09,590
关于隐私处理的决策将会
影响到另一个设备


466
00:28:10,190 --> 00:28:11,959
在watch中限定“不动产”


467
00:28:12,092 --> 00:28:14,962
我们认为比起在
iPhone上面做要更有意义


468
00:28:15,729 --> 00:28:18,632
在iPhone端用户在更大的
屏幕上看到提示信息


469
00:28:18,932 --> 00:28:20,234
其中包括目的字符串


470
00:28:20,300 --> 00:28:24,771
它可以清楚得说明为何你的iPhone app
和Watch app想要获得访问数据的权限


471
00:28:25,706 --> 00:28:27,908
不像在IOS端你可以选择是或者否


472
00:28:28,342 --> 00:28:30,244
你可以选择提示或者解散


473
00:28:30,377 --> 00:28:33,347
当你做提示设置时
用户不能在watch中做出选择


474
00:28:33,614 --> 00:28:35,782
因此会停留在一种未设置的状态


475
00:28:36,517 --> 00:28:39,520
在这种未设置的状态
你将会稍后进行提示


476
00:28:40,654 --> 00:28:43,123
举一个未设置状态的例子吧


477
00:28:43,557 --> 00:28:46,293
用户可以带着Watch
去跑步而不是Phone


478
00:28:46,894 --> 00:28:48,595
所以把你的app安装在Watch上


479
00:28:48,962 --> 00:28:49,963
你的app将会提示


480
00:28:50,464 --> 00:28:51,665
这种提示将会被消除


481
00:28:52,032 --> 00:28:53,867
而你的应用将会


482
00:28:54,101 --> 00:28:55,802
在没有数据访问权限的
情况下继续运行


483
00:28:56,336 --> 00:29:00,374
但是在下一个时间节点
你的app将会再次提示


484
00:29:02,376 --> 00:29:06,547
现在如姬蒂之前说的
这些设置包括你的隐私设置


485
00:29:07,080 --> 00:29:09,316
都是在Watch和iPhone上共享的


486
00:29:10,117 --> 00:29:12,419
我们认为用户和你的
应用之间有单一的联系


487
00:29:12,786 --> 00:29:14,621
与iPhone之间有单一的联系


488
00:29:14,688 --> 00:29:16,256
与Watch之间有单一的联系


489
00:29:16,323 --> 00:29:18,325
因此我们可以把
这些单一的联系组合起来


490
00:29:18,392 --> 00:29:21,328
变成一种在iPhone
在watch在你的app中的设置


491
00:29:22,229 --> 00:29:24,698
而这存在于我们平台里的其他地方


492
00:29:24,898 --> 00:29:27,935
在IOS端如果用户对你的
app做出了关于隐私处理的决定


493
00:29:28,302 --> 00:29:30,637
使得你的app的所有
进程都有获取那些数据的权限


494
00:29:31,171 --> 00:29:32,673
如果你在app中提示了地理位置


495
00:29:33,173 --> 00:29:36,844
你的扩展应用也可以使用它


496
00:29:36,910 --> 00:29:40,480
如果用户是在app
扩展中首次进行提示


497
00:29:40,814 --> 00:29:42,950
那么整个app
也将获得访问数据的权限


498
00:29:44,384 --> 00:29:48,689
在Watch平台上用户做出的决定


499
00:29:48,989 --> 00:29:52,659
对所有的watch中的app
对原有app以及你的Glance


500
00:29:53,126 --> 00:29:54,728
还有你的Complication
来说都是有效的


501
00:29:55,229 --> 00:29:57,631
当用户给你app的一部分提供许可


502
00:29:57,698 --> 00:29:59,900
就相当于对你app的所有
部分都给予了许可


503
00:30:01,635 --> 00:30:05,772
现在你知道在IOS,OS X和watchOS中
我们对什么数据有访问权限了


504
00:30:05,839 --> 00:30:07,975
以及我们该如何提示它们


505
00:30:08,041 --> 00:30:11,345
我们认为一旦用户在这些
平台上提供了数据访问权限


506
00:30:12,579 --> 00:30:14,648
考虑如何保护它们是非常重要的


507
00:30:15,015 --> 00:30:17,484
这里有一些你应该利用
和清楚的一些新的安全功能


508
00:30:17,985 --> 00:30:20,521
第一个就是App传输安全


509
00:30:20,988 --> 00:30:23,056
为了在默认情况下保证用户交流的安全


510
00:30:23,457 --> 00:30:25,392
我们引入了App传输安全体系


511
00:30:25,759 --> 00:30:28,295
在IOS 9和OS X
EI Capitan平台应用


512
00:30:28,896 --> 00:30:32,299
在默认情况下你们在更高
层级的API中的交流


513
00:30:32,366 --> 00:30:35,669
会需要用TLS 1.2版的
加密方式来实现保密性


514
00:30:36,170 --> 00:30:40,741
如果你尝试进行的连接违反了这些要求


515
00:30:41,175 --> 00:30:42,276
将会出现报错


516
00:30:43,877 --> 00:30:46,547
如果你的app需要
向非安全域发送请求


517
00:30:46,780 --> 00:30:49,750
你必须在你app中的
Info.plist中指定这个区域


518
00:30:50,384 --> 00:30:52,486
如果想了解一下细节


519
00:30:52,553 --> 00:30:57,491
可以关注一下明天上午9点的
NSURL会话与网络方面的演讲


520
00:30:57,558 --> 00:30:59,426
或者关注今天下午的安全性演讲


521
00:31:01,728 --> 00:31:04,031
如果你真的想在APP
传输安全体系中声明一个特例


522
00:31:04,097 --> 00:31:07,134
你需要在你app中的
Info.plist中声明然后随意


523
00:31:07,201 --> 00:31:09,236
设置一个或更多的这种密钥


524
00:31:12,773 --> 00:31:15,142
现在我要谈论一下奖励卡的问题


525
00:31:15,943 --> 00:31:19,713
在IOS 9系统奖励卡可以
出现在联系人列表中


526
00:31:20,047 --> 00:31:22,616
我们知道有些奖励卡使用了
用户的电话号码


527
00:31:22,683 --> 00:31:25,052
邮箱地址或者其他
个人指向性明显的数据


528
00:31:25,419 --> 00:31:27,221
来作为奖励卡的标识符


529
00:31:27,821 --> 00:31:32,226
所以为了在奖励卡以及联系
人列表的传输中保护用户的隐私


530
00:31:33,060 --> 00:31:35,963
我们给开发者提供了一种简单的方式


531
00:31:36,230 --> 00:31:38,332
在遍历联系人列表时加密数据


532
00:31:39,333 --> 00:31:42,135
你所要做的就是修改你的
pass.json


533
00:31:42,202 --> 00:31:45,806
用这个新的nfc字典


534
00:31:46,340 --> 00:31:49,109
你可以指定信息标识符和你的公钥


535
00:31:49,576 --> 00:31:53,313
从这开始当在非
接触支付中用到奖励卡时


536
00:31:53,614 --> 00:31:56,817
IOS会谨慎得为你加密信息


537
00:31:58,352 --> 00:32:01,622
随着IOS9中App搜索App历史
记录和App链接的应用


538
00:32:01,722 --> 00:32:05,292
这意味着你可以存储一些和你的app
有关以及在你app之外的信息


539
00:32:05,726 --> 00:32:07,861
因此你需要做一个好管家


540
00:32:07,928 --> 00:32:11,598
为用户保护好数据
这不仅包括位于你app里的数据


541
00:32:12,032 --> 00:32:14,168
还包括在你app之外存储的数据


542
00:32:15,736 --> 00:32:18,672
在星期三上午11点会有
一个很不错的演讲介绍这方面


543
00:32:18,739 --> 00:32:21,308
到时候可以去听一下
他们讲的要比我更深入些


544
00:32:21,375 --> 00:32:23,744
我将简单得讲一下
app的两种数据索引方式


545
00:32:23,977 --> 00:32:26,413
以及它们在隐私保护方面所起到的作用


546
00:32:28,015 --> 00:32:29,816
第一个是
NSUserActivity


547
00:32:29,883 --> 00:32:32,886
它是一个为了支持
Handoff而被引入IOS8平台中的API


548
00:32:33,420 --> 00:32:36,657
在IOS 9中我们对其进行了扩展


549
00:32:36,757 --> 00:32:39,326
所以你可以使用
NSUserActivity在你的app中


550
00:32:39,393 --> 00:32:41,295
建立索引视图让用户可以
回到那个地方搜索


551
00:32:41,662 --> 00:32:43,564
比如在你的食谱app中


552
00:32:43,897 --> 00:32:47,301
当用户看到一个干酪浇肉汁
土豆条的食谱时


553
00:32:47,367 --> 00:32:49,903
你可以在视图中建立一个
NSUserActivity并将其索引


554
00:32:49,970 --> 00:32:53,373
然后用户再次在手机里
搜索干酪浇肉汁土豆条的时候


555
00:32:53,640 --> 00:32:54,942
显示出来的结果就包括


556
00:32:55,008 --> 00:32:56,677
他们曾经看到过的这个链接


557
00:32:57,511 --> 00:33:01,515
在未来它可以帮助我们解放双手
而不需要其他机器


558
00:33:03,817 --> 00:33:06,386
我们从最开始就思考
如何让搜索变得更注重保护隐私


559
00:33:07,588 --> 00:33:11,191
我们之前所做的包括
把默认设置为非索引数据


560
00:33:12,159 --> 00:33:12,993
这是非常正确的


561
00:33:13,060 --> 00:33:16,330
在默认情况下NSUserActivity
将继续为Handoff提供支持


562
00:33:16,396 --> 00:33:18,232
如果你想制作可搜索的视图


563
00:33:18,665 --> 00:33:21,802
你必须得把eligibleForSearch
属性设置为真


564
00:33:22,469 --> 00:33:25,038
如果你想把那个
视图变成公开索引...


565
00:33:25,105 --> 00:33:26,507
那个我们一会儿将要提到...


566
00:33:27,241 --> 00:33:31,345
你需要做的也是把
eligibleForPublicIndexing


567
00:33:31,411 --> 00:33:32,246
值设置为真


568
00:33:33,413 --> 00:33:34,982
此外还有一个你需要设置的值


569
00:33:35,048 --> 00:33:38,018
如果你想把数据变成可变址的
需要用到expirationDate


570
00:33:38,085 --> 00:33:39,620
正如姬蒂之前提到的那样


571
00:33:40,153 --> 00:33:42,556
保护用户数据是保护
用户隐私的重要组成部分


572
00:33:42,623 --> 00:33:45,459
这可以通过删除数据与用户
之间的关联来完成


573
00:33:49,663 --> 00:33:52,900
现在我将要谈一点关于
NSUserActivity和公开索引的问题


574
00:33:53,567 --> 00:33:56,270
NSUserActivity
是一种很好用的简单方式


575
00:33:56,336 --> 00:33:57,671
它让你的app变得可以搜索


576
00:33:58,205 --> 00:34:01,742
我们提高索引方面的隐私安全
就是通过在默认情况下不进行索引


577
00:34:01,808 --> 00:34:06,647
让开发者来决定是否要在
特定视图中添加索引


578
00:34:08,681 --> 00:34:12,719
但是我们知道许多开发者想要添加一些


579
00:34:13,053 --> 00:34:15,289
在所有设备中都能搜索到的公开内容


580
00:34:16,389 --> 00:34:19,126
为了实现这一点
我们想出了这样一种方法


581
00:34:19,193 --> 00:34:22,161
就是在保护用户安全的同时
为附加数据提供索引


582
00:34:23,597 --> 00:34:26,500
当你创建了一个可搜索视图


583
00:34:26,934 --> 00:34:28,969
把它标记为公共索引


584
00:34:29,335 --> 00:34:31,605
如果它只包含可公开内容的话


585
00:34:32,505 --> 00:34:35,876
然后当用户搜索这一视图并且使用它时


586
00:34:36,143 --> 00:34:38,011
这一视图的散表
就被发送到Apple中


587
00:34:39,580 --> 00:34:41,181
在经过多重设备之后


588
00:34:41,581 --> 00:34:44,217
创建视图的散表并发到Apple里


589
00:34:45,252 --> 00:34:47,588
最后当超过阈值时


590
00:34:48,889 --> 00:34:51,225
真实视图将会被发送到Apple里


591
00:34:51,958 --> 00:34:57,063
正是因为这个原因偶然被标记为公开的
视图并不会无意间被发送出去


592
00:34:59,032 --> 00:35:00,300
这就是NSUserActivity


593
00:35:00,367 --> 00:35:02,870
现在我要讲一点关于
CoreSpotlight的内容


594
00:35:03,036 --> 00:35:05,973
CoreSpotlight是
IOS 9中新增的一种API


595
00:35:06,039 --> 00:35:08,308
它使得你的app中的用户内容可搜索


596
00:35:08,609 --> 00:35:10,978
比如邮箱 联系人 日历等


597
00:35:11,411 --> 00:35:12,980
这些是派生数据


598
00:35:13,313 --> 00:35:16,884
你需要像保护你app中的
基础数据那样保护它们


599
00:35:17,651 --> 00:35:20,187
首先是要加入数据保护类


600
00:35:20,587 --> 00:35:22,389
就像你对app中的数据所做的那样


601
00:35:23,690 --> 00:35:27,060
接下来要用索引中的派生数据


602
00:35:27,127 --> 00:35:28,795
来实现数据管理


603
00:35:29,229 --> 00:35:31,865
你可以存储--首先你
应该存储相关的用户数据


604
00:35:32,232 --> 00:35:35,602
比如有没有人需要
看草稿或者删除文档？


605
00:35:37,738 --> 00:35:39,773
当用户在你的app中更新文档的时候


606
00:35:39,840 --> 00:35:42,176
你应该在索引中更新
这些文档的拷贝文件


607
00:35:43,010 --> 00:35:44,811
在用户在你的app中
删除文档的时候


608
00:35:44,912 --> 00:35:46,747
你应该在索引中也删除文档


609
00:35:46,813 --> 00:35:49,183
由于用户有多种在app中
删除文档的方式


610
00:35:49,249 --> 00:35:51,018
像是删除所有类型的文件


611
00:35:51,251 --> 00:35:53,987
或者一个我们把它的
多种条目变得易于删除的文件夹


612
00:35:54,054 --> 00:35:57,324
直接删除或者先搜索再删除


613
00:35:58,425 --> 00:36:03,030
这是一个简要的概述
介绍了IOS 9中新的隐私保护特性


614
00:36:03,163 --> 00:36:05,199
接下来再由姬蒂介绍


615
00:36:05,265 --> 00:36:08,368
一些你们如果没有用过
可以去尝试一下的已有技术


616
00:36:15,442 --> 00:36:16,276
感谢傑森


617
00:36:16,977 --> 00:36:19,413
我想强调几个已有的技术


618
00:36:19,479 --> 00:36:22,282
它们让保护用户信息变得容易


619
00:36:22,616 --> 00:36:24,451
你不需要自己去写一些


620
00:36:24,952 --> 00:36:26,486
基本的东西


621
00:36:28,989 --> 00:36:31,425
Touch Id是用来保护你的
app的一种很好的方式


622
00:36:31,491 --> 00:36:33,393
它也能保护你app中的数据


623
00:36:34,228 --> 00:36:38,165
你可以使用app中的
Apple Pay来实现它


624
00:36:38,265 --> 00:36:40,367
而不需要创建或者接收


625
00:36:40,434 --> 00:36:43,337
用户的一些基本信息以及信用卡信息


626
00:36:44,505 --> 00:36:46,073
现在我要深入得讲一下


627
00:36:46,340 --> 00:36:48,742
隐私策略和数据保护方面的内容


628
00:36:49,610 --> 00:36:53,514
在研究保护你的用户信息的技术之外


629
00:36:54,047 --> 00:36:56,583
向用户解释你对他们的数据做了什么


630
00:36:56,650 --> 00:36:59,920
也是非常重要的
如果你想和第三方分享数据的话


631
00:37:01,154 --> 00:37:04,958
我们实际上需要对几种固定
类型的应用实施隐私保护策略


632
00:37:05,526 --> 00:37:07,628
其中包括和
HealthKit相连接的app


633
00:37:08,228 --> 00:37:11,331
我们把引入隐私策略变得非常容易


634
00:37:12,165 --> 00:37:14,535
在iTunes连接中你只需要输入URL


635
00:37:14,835 --> 00:37:18,205
它就会在你所有的
App Store中显示


636
00:37:18,305 --> 00:37:20,908
它给用户一个在做购买决策之前


637
00:37:21,308 --> 00:37:23,010
阅读隐私策略的机会


638
00:37:23,544 --> 00:37:27,014
你可以使用IOS中的创建数据保护类


639
00:37:27,181 --> 00:37:30,551
来为你的数据进行加密
其密钥源于用户的登录密码


640
00:37:31,585 --> 00:37:33,520
这种加密技术有着惊人的力量


641
00:37:34,121 --> 00:37:38,091
你可以轻松得利用它的优势
不需要自己写任何加密码


642
00:37:39,893 --> 00:37:42,596
现在 每个IOS设备


643
00:37:43,397 --> 00:37:48,001
都通过密钥层级管理来实施数据保护


644
00:37:49,002 --> 00:37:50,704
它建立在硬件加密的基础上


645
00:37:50,871 --> 00:37:53,841
应用于所有的IOS
和watchOS设备


646
00:37:54,942 --> 00:37:57,744
数据保护是由每个基础文件来控制的


647
00:37:58,245 --> 00:38:00,113
每个文件都被赋予一个类


648
00:38:01,348 --> 00:38:06,119
这些类是否被解锁
决定了访问权限是否开启


649
00:38:07,888 --> 00:38:11,291
这里有四种数据类我将依次进行介绍


650
00:38:11,892 --> 00:38:13,994
但是你最要清楚的一点是


651
00:38:14,061 --> 00:38:17,998
Ns文件保护直到出现
第一个认证时才完成


652
00:38:18,632 --> 00:38:19,967
在IOS 7中


653
00:38:20,667 --> 00:38:24,404
所有的第三方app
数据都默认成这种数据类


654
00:38:25,305 --> 00:38:29,243
如今你的app
在启动之前是不能运行的


655
00:38:29,309 --> 00:38:31,411
直到用户输入他们的密码


656
00:38:32,179 --> 00:38:35,115
所以至少你的数据会
经过以上过程的保护


657
00:38:36,183 --> 00:38:39,353
我们知道有些开发者
并没有使用任何数据保护措施


658
00:38:39,753 --> 00:38:42,789
因为那样做是没有任何理由
也没有任何价值的


659
00:38:45,792 --> 00:38:48,862
所以我要迅速得介绍一下
这种模式中的几种不同的数据类


660
00:38:48,962 --> 00:38:50,831
正如你所见在没有任何保护的情况下


661
00:38:51,265 --> 00:38:53,333
即使用户输入了密码或者没有输入


662
00:38:53,800 --> 00:38:56,904
数据都是没被上锁的数据很容易被获取


663
00:38:57,871 --> 00:39:01,775
最后直到出现第一个认证
之前它们被保护的


664
00:39:02,209 --> 00:39:05,512
这就是你的默认类


665
00:39:06,580 --> 00:39:09,149
现在这在启动中是不可访问的


666
00:39:09,616 --> 00:39:11,785
但是一旦用户输入密码


667
00:39:12,085 --> 00:39:16,089
所有数据都变得可用
即使设备加锁了数据依旧可用


668
00:39:18,025 --> 00:39:20,227
下一个数据就会一直
被保护只到开放为止


669
00:39:20,594 --> 00:39:25,699
这种设计面向的对象是
对设备上锁敏感的数据


670
00:39:26,466 --> 00:39:30,003
所以这里有两种操作类型读和写


671
00:39:30,771 --> 00:39:34,074
一旦设备启动了就关闭了数据访问权限


672
00:39:34,441 --> 00:39:35,809
用户输入了密码后


673
00:39:36,243 --> 00:39:38,212
你可以同时读写


674
00:39:38,846 --> 00:39:40,047
当设备再次上锁


675
00:39:40,681 --> 00:39:43,817
你不能读数据但你依旧可以写数据


676
00:39:45,219 --> 00:39:46,987
最后我们完成了保护工作


677
00:39:47,287 --> 00:39:49,590
现在对于所有的敏感数据


678
00:39:49,890 --> 00:39:52,392
包括健康数据金融信息


679
00:39:53,627 --> 00:39:56,930
在设备启动之后它们变得不可用


680
00:39:57,931 --> 00:40:01,235
当用户输入了密码数据就变得可用


681
00:40:02,202 --> 00:40:05,038
当设备上锁数据就不能用了


682
00:40:06,907 --> 00:40:08,842
这将带来一个很大的工作量


683
00:40:09,109 --> 00:40:11,912
来思考你要应用哪种数据保护类


684
00:40:12,980 --> 00:40:15,782
最后确认你已测试过数据保护是可用的


685
00:40:16,149 --> 00:40:19,620
你可以通过这些内容来核查
Settings, Touch ID和Passcode


686
00:40:19,820 --> 00:40:22,689
向下滑动看看你是否启动了数据保护


687
00:40:24,424 --> 00:40:27,127
我们今天讲了许多东西


688
00:40:27,528 --> 00:40:32,533
你需要在IOS
和OS X上测试你的app


689
00:40:32,833 --> 00:40:34,935
你希望理解这些改变所带来的影响


690
00:40:35,202 --> 00:40:38,872
来保证你依旧可以
为用户提供优秀的体验


691
00:40:39,806 --> 00:40:40,974
有目的地提示


692
00:40:42,276 --> 00:40:45,179
确保让数据最小化 保持更新


693
00:40:46,180 --> 00:40:49,216
从一些我们今天讲过的
平台中的技术中获益


694
00:40:50,184 --> 00:40:54,288
最后用户隐私安全是我们共同的责任


695
00:40:55,189 --> 00:40:58,625
我们必须携起手来


696
00:40:59,193 --> 00:41:02,996
我们应该保护用户的隐私权


697
00:41:04,031 --> 00:41:05,165
谢谢大家

