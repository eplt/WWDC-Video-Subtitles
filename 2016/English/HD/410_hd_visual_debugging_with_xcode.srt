1
00:00:07,516 --> 00:00:18,500
[ Music ]


2
00:00:27,016 --> 00:00:27,236
[ Applause ]


3
00:00:27,236 --> 00:00:30,866
>> Good afternoon, everyone.


4
00:00:31,776 --> 00:00:34,206
And welcome to Visual
Debugging with Xcode.


5
00:00:35,226 --> 00:00:38,106
I'm Chris, and I work
on Xcode's debugger UI.


6
00:00:39,426 --> 00:00:43,136
You know, debugging tools
have come a long way.


7
00:00:44,676 --> 00:00:46,076
It wasn't all that long ago


8
00:00:46,306 --> 00:00:48,766
when our debugging tools
looked something like this.


9
00:00:50,436 --> 00:00:53,356
A little while later,
with advancements in UI,


10
00:00:53,356 --> 00:00:56,826
our debugging tools began
to look more like this.


11
00:00:58,976 --> 00:01:00,386
But fast-forward to today,


12
00:01:00,386 --> 00:01:03,866
and our debugging tools have
become much more powerful while


13
00:01:03,866 --> 00:01:06,136
at the same time becoming
much easier to use.


14
00:01:06,626 --> 00:01:08,876
A big part of this is because
the tools are becoming more


15
00:01:08,876 --> 00:01:11,626
visual, which helps us
to solve problems faster


16
00:01:11,976 --> 00:01:12,936
and more intuitively.


17
00:01:13,966 --> 00:01:16,196
Today, my colleagues and
I are going to tell you


18
00:01:16,196 --> 00:01:18,866
about the latest in Xcode's
visual debugging tools.


19
00:01:21,496 --> 00:01:24,156
First, a quick overview
of what we'll cover.


20
00:01:24,926 --> 00:01:27,746
We're going to tell you about a
new feature of Xcode to be able


21
00:01:27,746 --> 00:01:31,396
to report on issues detected
by the tools at runtime.


22
00:01:32,226 --> 00:01:35,356
We're going to tell you
about the latest enhancements


23
00:01:35,356 --> 00:01:36,926
that we've made to
Xcode's view debugger


24
00:01:37,256 --> 00:01:39,746
and how we've made auto
layout debugging easier


25
00:01:39,746 --> 00:01:40,486
than ever before.


26
00:01:41,366 --> 00:01:43,706
We're going to tell you about
a new feature to be able


27
00:01:43,706 --> 00:01:47,816
to visually debug state machines
and enhancements we've made


28
00:01:47,816 --> 00:01:51,896
to the FPS performance gauge to
help with debugging SpriteKit


29
00:01:51,956 --> 00:01:53,586
and SceneKit frame rate issues.


30
00:01:54,606 --> 00:01:58,076
Finally, we're going to tell you
about a new feature of Xcode --


31
00:01:58,306 --> 00:01:59,826
a visual memory graph debugger.


32
00:02:03,916 --> 00:02:05,936
Let's get started by
talking about issues.


33
00:02:08,936 --> 00:02:10,765
We all know that
build time issues


34
00:02:10,765 --> 00:02:12,456
such as compiler
warnings, errors,


35
00:02:12,456 --> 00:02:15,456
and static analysis
issues are well-supported


36
00:02:15,606 --> 00:02:18,086
by Xcode's user interface
similarly


37
00:02:18,246 --> 00:02:20,286
for our issues detected
while testing.


38
00:02:21,466 --> 00:02:24,216
However, the same can't be
said for issues detected


39
00:02:24,216 --> 00:02:25,596
by our expanding suite


40
00:02:25,596 --> 00:02:27,756
of runtime debugging
and analysis tools.


41
00:02:28,406 --> 00:02:32,256
These tools have
been left behind


42
00:02:32,596 --> 00:02:36,836
with their best option being to
log their output to the console.


43
00:02:37,176 --> 00:02:38,346
Not the best experience.


44
00:02:38,856 --> 00:02:40,506
We thought we could
do much better.


45
00:02:42,446 --> 00:02:45,126
In Xcode 8, we're
introducing runtime issues.


46
00:02:46,516 --> 00:02:51,796
[ Applause ]


47
00:02:52,296 --> 00:02:55,316
Runtime issues elevates the
issues detected by the tools


48
00:02:55,316 --> 00:02:58,276
at runtime to the
same status in the UI


49
00:02:58,276 --> 00:03:00,576
as traditional build
time issues.


50
00:03:03,016 --> 00:03:05,346
The Activity Viewer will
display this indicator


51
00:03:05,346 --> 00:03:07,356
when any runtime
issues are detected,


52
00:03:07,686 --> 00:03:09,586
along with the number
of issues reported.


53
00:03:10,836 --> 00:03:13,496
We've enhanced the
Issue Navigator


54
00:03:13,496 --> 00:03:15,146
with a new runtime scope.


55
00:03:15,426 --> 00:03:17,726
This separates the
issues detected at runtime


56
00:03:17,786 --> 00:03:19,546
from the traditional
build time issues


57
00:03:19,676 --> 00:03:21,216
such as compiler
warnings, errors,


58
00:03:21,216 --> 00:03:22,696
and static analysis issues.


59
00:03:26,496 --> 00:03:29,876
So what issues will you expect
to see reported at runtime?


60
00:03:30,546 --> 00:03:33,026
In Xcode 8, we're
tackling three areas.


61
00:03:33,656 --> 00:03:36,396
The first -- threading issues.


62
00:03:37,096 --> 00:03:39,466
Our brand-new Thread
Sanitizer is able


63
00:03:39,466 --> 00:03:43,316
to detect threading issues in
your application at runtime.


64
00:03:45,756 --> 00:03:46,946
UI layout issues.


65
00:03:47,046 --> 00:03:49,516
We've expanded Xcode's
view debugger to be able


66
00:03:49,516 --> 00:03:52,166
to automatically detect
ambiguous layout issues


67
00:03:52,346 --> 00:03:53,606
in your app at runtime.


68
00:03:55,966 --> 00:03:56,616
And memory.


69
00:03:57,316 --> 00:03:59,256
Our brand-new memory
graph debugger,


70
00:03:59,256 --> 00:04:01,146
which we'll talk a lot more
about in a few moments,


71
00:04:01,146 --> 00:04:03,916
is able to automatically
detect leaked memory


72
00:04:04,126 --> 00:04:05,446
in your application at runtime.


73
00:04:10,046 --> 00:04:11,286
So, as you heard
about on Monday,


74
00:04:11,286 --> 00:04:14,486
Xcode's latest runtime sanitizer
is the Thread Sanitizer.


75
00:04:15,486 --> 00:04:17,906
Thread Sanitizer
helps us to detect


76
00:04:17,906 --> 00:04:19,986
and better understand
threading issues


77
00:04:20,026 --> 00:04:21,676
in your applications at runtime.


78
00:04:22,696 --> 00:04:24,776
It can detect such
issues as data races,


79
00:04:25,176 --> 00:04:28,426
uses of uninitialized mutexes,
unlocks from the wrong thread,


80
00:04:28,896 --> 00:04:31,286
thread leaks, and unsafe
calls in signal handlers.


81
00:04:32,226 --> 00:04:33,736
If any of these issues
are detected,


82
00:04:33,966 --> 00:04:36,076
they'll be reported
as runtime issues.


83
00:04:37,336 --> 00:04:39,906
Thread Sanitizer is a powerful
new runtime analysis tool.


84
00:04:40,316 --> 00:04:43,096
You can learn all about it by
watching the Thread Sanitizer


85
00:04:43,186 --> 00:04:44,606
and Static Analysis session.


86
00:04:51,056 --> 00:04:52,686
View debugging is
a great example


87
00:04:52,686 --> 00:04:55,476
of Xcode's debugging tools
becoming more visual.


88
00:04:56,146 --> 00:05:01,046
Only in the last couple of
years for debugging UI issues,


89
00:05:01,046 --> 00:05:04,196
we've gone from having
to read debug output


90
00:05:04,196 --> 00:05:07,676
in a console like this to this.


91
00:05:08,086 --> 00:05:11,296
Xcode's visual view debugger
is a much better experience


92
00:05:11,526 --> 00:05:14,496
for debugging and
understanding visual UI issues.


93
00:05:15,506 --> 00:05:16,866
If you haven't used it before,


94
00:05:17,546 --> 00:05:19,176
while Xcode is running
your application,


95
00:05:20,106 --> 00:05:22,616
just tap the Debug
View Hierarchy button


96
00:05:22,946 --> 00:05:24,466
down in the Debug Bar.


97
00:05:25,486 --> 00:05:27,506
Xcode will snapshot
your application,


98
00:05:28,356 --> 00:05:30,676
snapshot your view
hierarchy, and explode it


99
00:05:30,676 --> 00:05:32,826
out in an interactive 3D scene.


100
00:05:33,656 --> 00:05:36,926
From there, you can inspect the
structure of the view hierarchy


101
00:05:36,986 --> 00:05:40,556
in the 3D canvas and
in the outline view.


102
00:05:40,906 --> 00:05:43,506
And you can inspect the
properties of all of the views


103
00:05:43,506 --> 00:05:45,746
and constraints using
the inspectors.


104
00:05:48,966 --> 00:05:54,316
In Xcode 8, we've made view
debugging -- can you guess?


105
00:05:54,316 --> 00:05:54,756
Better than ever.


106
00:05:55,516 --> 00:06:02,546
[ Applause ]


107
00:06:03,046 --> 00:06:05,226
Snapshots are now
up to 70% faster.


108
00:06:05,226 --> 00:06:07,086
So you can go from
running your application


109
00:06:07,376 --> 00:06:08,976
to debugging UI issues
quicker than ever before.


110
00:06:09,516 --> 00:06:14,656
[ Applause ]


111
00:06:15,156 --> 00:06:17,246
The rendering of complex layouts


112
00:06:17,246 --> 00:06:20,256
and transformed views is much
more accurate in Xcode 8.


113
00:06:20,256 --> 00:06:24,316
And speaking of accuracy, Xcode
can now render blurred view,


114
00:06:24,316 --> 00:06:27,066
such as visual effect views with
high fidelity in the canvas.


115
00:06:27,696 --> 00:06:30,506
So what you see in Xcode's
view debugger more accurately


116
00:06:30,506 --> 00:06:32,786
reflects what you see on device.


117
00:06:33,106 --> 00:06:35,206
You'll see the blur rendering
improvement land in beta 2.


118
00:06:36,986 --> 00:06:39,266
We've added conveniences, such
as being able to jump directly


119
00:06:39,266 --> 00:06:40,906
to the source code
from a view class.


120
00:06:40,906 --> 00:06:43,576
Just tap the Jump button
in the Object Inspector.


121
00:06:44,496 --> 00:06:48,506
And navigator filtering is
much more powerful, too.


122
00:06:48,916 --> 00:06:50,936
You can filter by
any text in a label


123
00:06:51,336 --> 00:06:53,586
or text in a button's title.


124
00:06:54,506 --> 00:06:56,656
Or you can filter
by class names,


125
00:06:56,656 --> 00:06:58,786
and that will include
super class names.


126
00:06:58,916 --> 00:07:02,796
For example, if you filter by
UI label, you'll get back all


127
00:07:02,796 --> 00:07:05,616
of the subclasses of UI
label in your view hierarchy.


128
00:07:06,296 --> 00:07:07,856
You can even filter
by memory address.


129
00:07:08,146 --> 00:07:10,576
So you can quickly find
that particular view just


130
00:07:10,576 --> 00:07:11,936
by knowing its address
and memory.


131
00:07:17,316 --> 00:07:18,586
We've got some great
improvements


132
00:07:18,586 --> 00:07:20,236
for auto layout debugging
as well.


133
00:07:20,806 --> 00:07:23,486
We show many more properties
related to auto layout


134
00:07:23,486 --> 00:07:24,366
in the inspectors,


135
00:07:25,146 --> 00:07:27,906
and constraints are better
represented in the canvas.


136
00:07:28,656 --> 00:07:30,596
We now render badges
on constraints


137
00:07:30,626 --> 00:07:33,716
to represent inequality or
aspect ratio relationships.


138
00:07:34,096 --> 00:07:36,936
And we render non-required
constraints with dash lines


139
00:07:36,936 --> 00:07:39,246
so you can easily
differentiate between required


140
00:07:39,406 --> 00:07:41,256
and non-required
constraints in the canvas.


141
00:07:42,776 --> 00:07:45,716
But my favorite new feature
for auto layout debugging is


142
00:07:45,716 --> 00:07:47,546
in conjunction with
runtime issues.


143
00:07:49,506 --> 00:07:50,556
Xcode is now able


144
00:07:50,556 --> 00:07:52,916
to automatically detect
ambiguous layout issues


145
00:07:52,916 --> 00:07:54,876
in your view hierarchy
at runtime.


146
00:07:57,516 --> 00:08:01,636dle
[ Applause ]


147
00:07:57,516 --> 00:08:01,636
[ Applause ]


148
00:08:02,136 --> 00:08:03,266
So how does this work?


149
00:08:03,266 --> 00:08:05,156
While snapshotting
your view hierarchy,


150
00:08:05,156 --> 00:08:07,576
Xcode will inspect every
single view and is able


151
00:08:07,576 --> 00:08:09,846
to accurately determine if any


152
00:08:09,846 --> 00:08:11,736
of those views have
ambiguous layouts,


153
00:08:11,896 --> 00:08:13,816
along with the reason
for the ambiguity.


154
00:08:14,666 --> 00:08:16,846
If any layout issues
are detected,


155
00:08:16,846 --> 00:08:20,496
they'll be reported
as runtime issues.


156
00:08:21,186 --> 00:08:23,056
So you'll see them indicated
in the Activity Viewer,


157
00:08:23,186 --> 00:08:24,636
and you'll see them listed


158
00:08:24,636 --> 00:08:26,436
in the Issue Navigator
under runtime.


159
00:08:28,156 --> 00:08:31,716
Furthermore, the view hierarchy
outline will badge any views


160
00:08:31,766 --> 00:08:34,926
that have layout issues,
so you can easily spot them


161
00:08:34,966 --> 00:08:36,996
in the context of the
whole view hierarchy.


162
00:08:39,376 --> 00:08:43,096
For a selected view, the Size
Inspector will contain details


163
00:08:43,096 --> 00:08:46,456
of any layout issues, along
with all of the constraints


164
00:08:46,456 --> 00:08:48,586
that participated in the
layout for that view.


165
00:08:49,906 --> 00:08:52,126
We're really excited about
Xcode's new ability to be able


166
00:08:52,126 --> 00:08:54,366
to automatically detect
ambiguous layout issues


167
00:08:54,366 --> 00:08:54,776
at runtime.


168
00:08:54,776 --> 00:08:56,266
And I'd love to give you a demo.


169
00:08:59,416 --> 00:09:00,636
So I have an iPhone here,


170
00:09:00,876 --> 00:09:02,386
and I've got it connected
to this Mac.


171
00:09:02,386 --> 00:09:05,736
We've got Xcode up and running
a project called DemoBots.


172
00:09:06,176 --> 00:09:07,816
That's one of our
sample code projects


173
00:09:07,816 --> 00:09:10,456
that we've updated
to Swift 3 this year.


174
00:09:11,456 --> 00:09:13,186
On the right, I'm just
using QuickTime Player


175
00:09:13,436 --> 00:09:14,946
to stream the device's
screen back


176
00:09:14,946 --> 00:09:16,246
to the desktop so
we can all see it.


177
00:09:16,246 --> 00:09:20,146
Our team was tasked with adding
an in-game instruction manual


178
00:09:20,146 --> 00:09:22,696
to DemoBots, so we implemented
a How To Play screen.


179
00:09:23,276 --> 00:09:26,366
However, we had some issues that
we found before the session.


180
00:09:26,456 --> 00:09:28,926
So now is a great opportunity
to debug those issues.


181
00:09:29,686 --> 00:09:30,456
I'll tap How To Play.


182
00:09:30,496 --> 00:09:32,246
And this is our How
To Play screen.


183
00:09:32,886 --> 00:09:33,686
Not so great is it?


184
00:09:34,426 --> 00:09:36,726
Obviously, we have some
issues, so let's take a look.


185
00:09:36,726 --> 00:09:40,196
We can see the DemoBots logo at
the back, and there's some sort


186
00:09:40,196 --> 00:09:41,666
of mangled text rendered on top.


187
00:09:42,056 --> 00:09:43,616
So we need to debug this.


188
00:09:43,616 --> 00:09:44,246
Where do we start?


189
00:09:44,246 --> 00:09:46,196
I'll give you some clues.


190
00:09:46,936 --> 00:09:49,806
DemoBots is a little arcade
game written in SpriteKit,


191
00:09:49,806 --> 00:09:53,326
but this screen has been laid
out using UIKit and auto layout.


192
00:09:53,726 --> 00:09:56,226
So a good place to start
is to look under the hood


193
00:09:56,226 --> 00:09:59,896
at the structure of the view
hierarchy and all the layouts.


194
00:09:59,986 --> 00:10:00,826
So let's do that now.


195
00:10:01,916 --> 00:10:05,226
If I return to Xcode,
down on the bottom,


196
00:10:05,476 --> 00:10:08,056
we can use the Debug
View Hierarchy button,


197
00:10:08,626 --> 00:10:10,446
which I'll click now.


198
00:10:10,526 --> 00:10:12,116
And that pauses the application


199
00:10:12,236 --> 00:10:13,916
and snapshots the
entire view hierarchy.


200
00:10:15,006 --> 00:10:18,556
In the editor, we now get back
an accurate representation


201
00:10:18,556 --> 00:10:19,716
of what we were seeing
on screen.


202
00:10:20,776 --> 00:10:23,016
And then to look under
the hood at the structure,


203
00:10:23,076 --> 00:10:24,776
all we need to do is
drag in the canvas


204
00:10:24,776 --> 00:10:27,046
and we get the whole
view hierarchy exploited


205
00:10:27,046 --> 00:10:28,796
out for us in the 3D view.


206
00:10:29,516 --> 00:10:33,546
[ Applause ]


207
00:10:34,046 --> 00:10:35,886
Here, we can see all
of the views that make


208
00:10:35,886 --> 00:10:38,776
up this particular screen
-- the window at the back,


209
00:10:38,776 --> 00:10:41,566
container views, visual
effects view, and then the views


210
00:10:41,566 --> 00:10:43,536
that make up the How
To Play instructions.


211
00:10:44,016 --> 00:10:44,966
Let's zoom in on those.


212
00:10:45,736 --> 00:10:47,396
We see the DemoBots
logo at the back,


213
00:10:47,396 --> 00:10:49,256
and then a bunch of
labels and images.


214
00:10:49,786 --> 00:10:53,226
And we quickly get some insight
by panning around the reason


215
00:10:53,266 --> 00:10:55,036
for the mess we see on screen.


216
00:10:55,436 --> 00:10:56,466
All of these views
have been laid


217
00:10:56,466 --> 00:10:58,026
out one on top of the other.


218
00:10:58,336 --> 00:10:59,296
So we've got a layout issue.


219
00:10:59,796 --> 00:11:03,106
Now our traditional workflow
would be to inspect each


220
00:11:03,106 --> 00:11:05,006
of these views and their
constraints and try


221
00:11:05,006 --> 00:11:06,836
and determine the reason
for the layout issue.


222
00:11:06,836 --> 00:11:09,226
But in Xcode 8, we
have some additional


223
00:11:09,226 --> 00:11:10,166
information available.


224
00:11:10,976 --> 00:11:14,046
Notice up here in the Activity
Viewer Xcode is reporting


225
00:11:14,046 --> 00:11:15,656
that we have some
runtime issues.


226
00:11:16,666 --> 00:11:20,396
We could click on that
one, and that would take us


227
00:11:20,426 --> 00:11:21,396
to the issue navigator.


228
00:11:22,076 --> 00:11:25,126
But you may also notice
that over here on the left


229
00:11:25,126 --> 00:11:27,606
in the Debug Navigator,


230
00:11:27,606 --> 00:11:29,466
Xcode has badged some
of the views for us.


231
00:11:29,736 --> 00:11:31,966
And that's telling us that
these views have layout issues.


232
00:11:31,966 --> 00:11:32,996
So let's go straight to here.


233
00:11:34,296 --> 00:11:35,736
If I select the first view,


234
00:11:36,316 --> 00:11:38,356
that highlights the view
in the canvas for us.


235
00:11:38,356 --> 00:11:40,776
And let's open the Size
Inspector for that view


236
00:11:40,776 --> 00:11:41,586
over here on the right.


237
00:11:43,066 --> 00:11:43,756
Here, we can see


238
00:11:43,756 --> 00:11:46,136
under constraints the
reason for the layout issue.


239
00:11:46,546 --> 00:11:49,396
This view has an
ambiguous vertical position.


240
00:11:50,136 --> 00:11:52,526
Now that means that auto layout
doesn't have enough information


241
00:11:52,716 --> 00:11:54,746
to be able to unambiguously
position this view


242
00:11:54,906 --> 00:11:56,136
in the vertical dimension.


243
00:11:57,036 --> 00:11:58,566
Typically, constraints
are missing.


244
00:11:59,456 --> 00:12:01,496
Let's have a look
at the next view.


245
00:12:02,306 --> 00:12:04,656
That has the same issue --
vertical position is ambiguous.


246
00:12:05,356 --> 00:12:06,966
And so does the next one.


247
00:12:06,966 --> 00:12:08,226
If I randomly click
on a few more,


248
00:12:08,226 --> 00:12:09,626
it looks like they all
have the same problem.


249
00:12:10,396 --> 00:12:12,556
What I find curious is
the very first sub-view


250
00:12:12,826 --> 00:12:15,066
in this list is not
badged with an issue.


251
00:12:15,246 --> 00:12:17,206
So that could be a clue when
we get to the layout code.


252
00:12:17,966 --> 00:12:18,746
Let's go to that now.


253
00:12:19,306 --> 00:12:22,316
If I select the Parent
View, which has a class name


254
00:12:22,316 --> 00:12:25,006
of InstructionsLayoutView,
this is the view responsible


255
00:12:25,006 --> 00:12:26,636
for laying out this
How To Play screen.


256
00:12:27,696 --> 00:12:29,676
So let's jump to the
source code for that.


257
00:12:29,936 --> 00:12:32,816
An easy way to do that
is to select the view.


258
00:12:32,816 --> 00:12:34,936
And over here on the
right, we will find


259
00:12:35,026 --> 00:12:38,246
in the Object Inspector a button
where we can jump directly


260
00:12:38,246 --> 00:12:39,996
to the source code
for that view.


261
00:12:40,686 --> 00:12:41,396
So we'll do that now.


262
00:12:41,546 --> 00:12:43,546
We'll close the Inspector
to give us some room.


263
00:12:44,096 --> 00:12:45,246
And let's take a
look at the source


264
00:12:45,246 --> 00:12:46,456
for InstructionsLayoutView.


265
00:12:48,256 --> 00:12:50,976
It starts by iterating
over each of the parts


266
00:12:50,976 --> 00:12:53,156
of the instructions, which
are just model objects


267
00:12:53,276 --> 00:12:57,746
which describe section headers,
section paragraphs, and images.


268
00:12:58,286 --> 00:13:00,996
And the code lays these
out top-to-bottom.


269
00:13:01,576 --> 00:13:03,896
So for each part, we fix
the view and we add it


270
00:13:03,896 --> 00:13:04,716
to the view hierarchy.


271
00:13:05,256 --> 00:13:07,066
Then we have some code
for the horizontal layout.


272
00:13:07,096 --> 00:13:09,446
But we didn't notice any
issues with horizontal layout,


273
00:13:09,446 --> 00:13:11,716
so let's skip over that
to the vertical layout.


274
00:13:12,606 --> 00:13:13,566
Here, we have two paths.


275
00:13:13,566 --> 00:13:17,276
The first is for the very
first sub-view to constrain it


276
00:13:17,276 --> 00:13:18,276
to the top of the container.


277
00:13:18,926 --> 00:13:22,866
Well, we already noted that the
first sub-view wasn't reported


278
00:13:22,866 --> 00:13:23,816
as having any issues.


279
00:13:24,156 --> 00:13:26,566
So, that constraint we
assume is set up correctly.


280
00:13:26,566 --> 00:13:28,456
So let's jump to the other
side of the conditional.


281
00:13:28,956 --> 00:13:32,616
Here, we're evaluating an
optional previousPartView.


282
00:13:32,656 --> 00:13:35,906
And if we have it, we assign it
to the local variable above you.


283
00:13:36,476 --> 00:13:39,966
And then we can constrain each
view to the view above it.


284
00:13:40,106 --> 00:13:41,736
It looks like this is the
constraint that's missing.


285
00:13:42,486 --> 00:13:44,556
So let's have a look at
why this conditional is not


286
00:13:44,966 --> 00:13:46,986
becoming true.


287
00:13:47,556 --> 00:13:50,596
If we select previousPartView
-- we'll start with that one --


288
00:13:50,596 --> 00:13:53,356
I'll use Command-A to
select it for search


289
00:13:53,646 --> 00:13:55,286
and Command-F to
get the Find Bar.


290
00:13:56,156 --> 00:13:57,706
Let's look for instances
of this variable.


291
00:13:58,366 --> 00:13:59,996
We see it's defined at the top.


292
00:14:00,206 --> 00:14:02,606
It's set to "nil" before
answering the fore loop.


293
00:14:02,956 --> 00:14:04,186
We evaluate it down here,


294
00:14:04,756 --> 00:14:06,826
and then we evaluate it
again outside of the loop


295
00:14:06,876 --> 00:14:08,596
to handle the bottom constraint.


296
00:14:08,636 --> 00:14:10,836
But it looks like we're
never assigning to it.


297
00:14:11,026 --> 00:14:11,836
So let's quickly fix that.


298
00:14:11,836 --> 00:14:15,356
So at the end of the loop,
we can set previousPartView


299
00:14:16,136 --> 00:14:16,986
to the current partView.


300
00:14:17,066 --> 00:14:18,976
And then on each iteration,


301
00:14:19,426 --> 00:14:21,206
we'll have the previous
view available,


302
00:14:21,206 --> 00:14:23,676
which will be assigned
to above you.


303
00:14:23,676 --> 00:14:27,036
And we'll set up the constraint
from a view to the one above it.


304
00:14:27,336 --> 00:14:29,016
Let's stop and rerun
it and check our work.


305
00:14:29,016 --> 00:14:31,286
And I'll bring QuickTime
to the front.


306
00:14:32,206 --> 00:14:34,416
Just note how much
information Xcode was able


307
00:14:34,416 --> 00:14:36,476
to give us before
we even got to code.


308
00:14:37,066 --> 00:14:39,436
We use view debugger to look
under the hood at the structure


309
00:14:39,436 --> 00:14:40,876
and get some insight
into the problem.


310
00:14:41,266 --> 00:14:43,526
But more than that,
Xcode proactively told us


311
00:14:43,526 --> 00:14:46,466
about some layout issues
in our application,


312
00:14:46,916 --> 00:14:47,946
which views had issues,


313
00:14:47,946 --> 00:14:50,116
and specifically what
those issues were.


314
00:14:50,586 --> 00:14:53,186
So that gave us a lot of insight
before we even got to the code,


315
00:14:53,186 --> 00:14:55,406
so we could quickly
zero-in on the part


316
00:14:55,406 --> 00:14:56,386
of the code that we needed to.


317
00:14:57,796 --> 00:14:59,916
Now that our application is
running, I can tap How To Play.


318
00:15:00,006 --> 00:15:02,076
And there, it looks much better.


319
00:15:02,386 --> 00:15:03,806
We have a nice-looking
instructions screen.


320
00:15:05,516 --> 00:15:10,796
[ Applause ]


321
00:15:11,296 --> 00:15:15,256
So Xcode is now able to
report on issues detected


322
00:15:15,256 --> 00:15:19,366
at runtime using the same UI as
we did for build time issues.


323
00:15:20,636 --> 00:15:23,376
Xcode's view debugger has
great enhancements this year,


324
00:15:23,876 --> 00:15:27,636
including faster snapshotting
and more accurate rendering


325
00:15:27,676 --> 00:15:30,296
of complex layouts
and blurred views.


326
00:15:31,696 --> 00:15:32,946
We've got some great enhancement


327
00:15:32,946 --> 00:15:34,396
for auto layout debugging
as well.


328
00:15:34,676 --> 00:15:36,536
In particular, Xcode is now able


329
00:15:36,536 --> 00:15:39,046
to automatically detect
ambiguous layout issues


330
00:15:39,276 --> 00:15:39,956
at runtime.


331
00:15:40,716 --> 00:15:43,146
Xcode's view debugger
supports debugging UIs


332
00:15:43,146 --> 00:15:45,486
on Mac OS, iOS, and tvOS.


333
00:15:46,186 --> 00:15:47,816
Give it a try with your
projects, and we'd love


334
00:15:47,816 --> 00:15:49,286
to hear feedback
on how it helps you


335
00:15:49,286 --> 00:15:50,836
with your debugging workflow.


336
00:15:51,866 --> 00:15:55,476
And with that, I'd like to
hand over to Tyler who's going


337
00:15:55,476 --> 00:15:58,676
to tell us about debugging state
machines and frame rate issues.


338
00:15:59,006 --> 00:15:59,256dle
Thanks.


339
00:16:00,516 --> 00:16:04,546
[ Applause ]


340
00:16:05,046 --> 00:16:05,696
>> Thanks, Chris.


341
00:16:06,566 --> 00:16:08,356
Today, I'll be showing you a
new way you can enhance your


342
00:16:08,356 --> 00:16:10,636
debugging experience with
the State Machine Quick Look,


343
00:16:10,886 --> 00:16:13,476
as well as some additions made
inside the FPS performance gauge


344
00:16:13,566 --> 00:16:14,326
for Xcode 8.


345
00:16:15,976 --> 00:16:16,716
Today, we have a number


346
00:16:16,716 --> 00:16:19,436
of useful Quick Looks already
available inside of Xcode 7,


347
00:16:19,436 --> 00:16:22,246
and these provide you the
ability to view a wide variety


348
00:16:22,246 --> 00:16:24,116
of objects live during
your debugging.


349
00:16:24,116 --> 00:16:26,746
And you can even provide
your own custom Quick Look


350
00:16:27,146 --> 00:16:28,946
to view objects within your app.


351
00:16:29,736 --> 00:16:30,856
And now in Xcode 8,


352
00:16:31,136 --> 00:16:32,876
we're extending our
built-in Quick Looks


353
00:16:32,876 --> 00:16:34,196
to include state machines.


354
00:16:34,646 --> 00:16:37,536
So let's first dive into what
exactly a state machine is


355
00:16:37,536 --> 00:16:40,246
and how you could use
it within your app.


356
00:16:41,246 --> 00:16:43,886
So, many of you may already be
familiar with GKStateMachine,


357
00:16:43,886 --> 00:16:46,106
which was part of our release
of GameplayKit last year.


358
00:16:46,246 --> 00:16:49,066
And it's available on
Mac OS, iOS, and tvOS.


359
00:16:50,376 --> 00:16:53,276
State machines allow you to more
easily define complex behavior


360
00:16:53,276 --> 00:16:55,966
by structuring it
as a directed graph.


361
00:16:55,966 --> 00:16:57,146
And within a state machine,


362
00:16:57,146 --> 00:16:59,566
you provide discrete
behavior for each state.


363
00:17:00,276 --> 00:17:02,866
This could be something
as simple as an animation


364
00:17:02,866 --> 00:17:05,406
that will play, or something
more complex like an AI.


365
00:17:06,536 --> 00:17:09,046
And then for each state,
you define the conditions


366
00:17:09,046 --> 00:17:10,886
by which the state
machine will transition


367
00:17:10,886 --> 00:17:12,276
from one state to another.


368
00:17:13,915 --> 00:17:16,336
Once assembled, state
machines can produce remarkably


369
00:17:16,336 --> 00:17:17,556
sophisticated behavior.


370
00:17:17,806 --> 00:17:21,205
However, they can quickly become
difficult to visualize in code


371
00:17:21,455 --> 00:17:22,996
as they expand in complexity.


372
00:17:23,455 --> 00:17:25,546
And simple state machines
can quickly evolve


373
00:17:25,546 --> 00:17:26,986
into far more elaborate ones.


374
00:17:27,546 --> 00:17:30,036
In Xcode 7.3, our support


375
00:17:30,036 --> 00:17:32,706
for debugging state machines was
limited to the current state,


376
00:17:32,706 --> 00:17:34,096
as well as its transitions.


377
00:17:34,506 --> 00:17:36,086
However, now in Xcode 8,


378
00:17:36,256 --> 00:17:38,546
we're able to visualize
the entire state machine


379
00:17:38,546 --> 00:17:40,476
so that you can see
exactly what's going on.


380
00:17:41,506 --> 00:17:43,906
This is incredibly useful
whether you're operating


381
00:17:43,906 --> 00:17:46,896
with very simple state machines
or whether you're working


382
00:17:46,896 --> 00:17:49,436
with much more complex
state machines.


383
00:17:50,056 --> 00:17:53,176
With Quick Look, you're able to
quickly debug potential issues


384
00:17:53,446 --> 00:17:55,116
and evaluate exactly
what's happening


385
00:17:55,206 --> 00:17:56,356
within your state machines.


386
00:17:56,926 --> 00:18:01,446
So, now, let's shift our
focus over to performance.


387
00:18:02,336 --> 00:18:04,806
Any time you're creating any
sort of game or visual app,


388
00:18:04,936 --> 00:18:06,546
maintaining good
performance is key.


389
00:18:07,056 --> 00:18:09,836
And in Xcode 8, we've expanded
the FPS performance gauge


390
00:18:09,836 --> 00:18:12,356
to help you with this.


391
00:18:12,586 --> 00:18:14,156
Many of you may already
be familiar with parts


392
00:18:14,156 --> 00:18:16,596
of the FPS performance
gauge from Xcode 7.


393
00:18:16,906 --> 00:18:19,216
And at the top of the report,
you're provided a number


394
00:18:19,216 --> 00:18:20,566
of real-time statistics.


395
00:18:21,586 --> 00:18:23,726
This includes your frame rate,
which is the current number


396
00:18:23,726 --> 00:18:25,146
of frames being rendered
per second,


397
00:18:26,076 --> 00:18:28,496
as well as your GPU
utilization to see which parts


398
00:18:28,496 --> 00:18:31,626
of your GPU are being used
the most, and your frame time


399
00:18:31,626 --> 00:18:33,486
for both the CPU and the GPU.


400
00:18:34,226 --> 00:18:35,026
This helps indicate


401
00:18:35,026 --> 00:18:37,586
to you whether you may be
CPU-bound or GPU-bound.


402
00:18:40,016 --> 00:18:41,976
Now, in addition to
real-time statistics,


403
00:18:42,056 --> 00:18:44,676
Xcode 8 now provides
you a timeline history


404
00:18:44,936 --> 00:18:47,326
of your SpriteKit and
SceneKit's frame time


405
00:18:47,416 --> 00:18:49,076
for both the CPU and the GPU.


406
00:18:49,076 --> 00:18:51,586
This is available
on iOS and watchOS.


407
00:18:52,216 --> 00:18:53,276
And what's great about this is


408
00:18:53,276 --> 00:18:56,496
that we breakdown your CPU frame
time and its individual parts


409
00:18:56,496 --> 00:18:59,086
so you're able to see
exactly how much time is spent


410
00:18:59,086 --> 00:19:01,276
rendering, or running
your update loop,


411
00:19:01,276 --> 00:19:02,926
or evaluating actions
and physics,


412
00:19:03,076 --> 00:19:04,576
and even how much
time is spent idle.


413
00:19:05,126 --> 00:19:08,576
And when your app is
paused, you're able to scroll


414
00:19:08,576 --> 00:19:10,316
through the history of
your app's performance


415
00:19:10,316 --> 00:19:11,766
so that you can see
how it evolves


416
00:19:11,766 --> 00:19:13,006
as you progress through
your app.


417
00:19:13,006 --> 00:19:15,976
And if there's a particular
sample you're interested in,


418
00:19:16,256 --> 00:19:18,916
you can dive deeper to
examine finer details on it


419
00:19:19,486 --> 00:19:21,256
and get some exact timings.


420
00:19:21,446 --> 00:19:25,976
So let's take a look at how we
can use these within our app.


421
00:19:43,186 --> 00:19:45,906
So now that we've addressed the
layout issues that we've got.


422
00:19:46,026 --> 00:19:47,626
In our How To Play
menu, let's go ahead


423
00:19:47,626 --> 00:19:48,946
and dive into the game itself.


424
00:19:51,136 --> 00:19:53,246
The objective of our
game is to convert all


425
00:19:53,246 --> 00:19:56,916
of the corrupted robots within
our computer into good robots.


426
00:19:57,136 --> 00:19:59,616
And to do this, I have
a beam that can zap them


427
00:19:59,616 --> 00:20:02,096
and reconfigure them
into good robots.


428
00:20:02,266 --> 00:20:04,906
Now we see here I've already
got a bad robot trying to come


429
00:20:04,906 --> 00:20:06,976
after me, so I'll use
my beam to zap him.


430
00:20:11,236 --> 00:20:12,756
So you see he's been converted


431
00:20:12,756 --> 00:20:14,686
to a good robot --
indicated with green.


432
00:20:15,496 --> 00:20:18,346
But I see that we still have
a part of our beam present


433
00:20:18,346 --> 00:20:20,726
above our character, and
this shouldn't be the case.


434
00:20:21,466 --> 00:20:23,986
Now since we're using a state
machine to manage the behavior


435
00:20:23,986 --> 00:20:26,766
of our beam, this
is a good candidate


436
00:20:26,766 --> 00:20:28,666
to use the State Machine
Quick Look to figure


437
00:20:28,666 --> 00:20:29,606
out what's going on here.


438
00:20:30,476 --> 00:20:34,176
So I'll go ahead and pause
our app while I navigate


439
00:20:34,176 --> 00:20:35,226
to our BeamComponent.


440
00:20:36,276 --> 00:20:38,186
Now our BeamComponent
is where we create


441
00:20:38,186 --> 00:20:39,616
and update our state machine


442
00:20:39,616 --> 00:20:41,586
that manages the
behavior of our beam.


443
00:20:42,036 --> 00:20:44,156
And I'll add a breakpoint
here on our update loop


444
00:20:44,406 --> 00:20:45,746
and resume our game
so that we hit


445
00:20:45,746 --> 00:20:46,906
that break point immediately.


446
00:20:47,446 --> 00:20:50,596
So now that we're paused,
I can go into debug area


447
00:20:50,596 --> 00:20:52,626
and find our instance
of the state machine,


448
00:20:53,026 --> 00:20:53,986
and we can Quick Look it.


449
00:20:54,196 --> 00:20:57,396
And from here, we can see
the entire state machine.


450
00:20:58,126 --> 00:21:00,416
In blue, we see the
current state that we're in,


451
00:21:00,466 --> 00:21:01,956
which is the BeamFiringState.


452
00:21:02,016 --> 00:21:04,436
And in gray, we see all
of the additional states


453
00:21:04,436 --> 00:21:05,916
that comprise our state machine.


454
00:21:06,836 --> 00:21:09,486
Now we also see the transitions
between each of the states.


455
00:21:09,646 --> 00:21:11,346
And one thing that I've
immediately noticed is


456
00:21:11,346 --> 00:21:12,876
that we have a number
of transitions


457
00:21:12,876 --> 00:21:16,206
into our BeamFiringState but we
have no transitions out of it.


458
00:21:16,206 --> 00:21:18,736
So this means, as soon as we
get into our firing state,


459
00:21:18,736 --> 00:21:19,886
we have no way of leaving it.


460
00:21:20,186 --> 00:21:22,856
So let's go ahead and take a
look at our BeamFiringState


461
00:21:22,856 --> 00:21:23,876
to see what's going on here.


462
00:21:24,406 --> 00:21:27,766
So I'll remove our breakpoint
and close our debug area


463
00:21:27,866 --> 00:21:29,506
and switch to our
BeamFiringState.


464
00:21:30,246 --> 00:21:33,256
Now we'll take a look
at the update loop.


465
00:21:33,256 --> 00:21:36,246
And I see here we have some
logic to transition both


466
00:21:36,246 --> 00:21:38,666
into the CoolingState as
well as the IdleState.


467
00:21:39,586 --> 00:21:40,806
But down here in our method


468
00:21:40,806 --> 00:21:42,896
where we're checking whether the
state we're trying to transition


469
00:21:42,896 --> 00:21:45,806
to is valid, we're
always returning false,


470
00:21:45,946 --> 00:21:48,056
which shouldn't be the case
because we want to transition


471
00:21:48,056 --> 00:21:49,256
to either cooling or idle.


472
00:21:50,256 --> 00:21:52,656
So I'll go ahead and fix that by
checking whether the state we're


473
00:21:52,656 --> 00:21:55,466
trying to transition to is
either of the two valid ones.


474
00:21:55,886 --> 00:21:57,296
And we'll go ahead
and rerun our game


475
00:21:57,336 --> 00:21:58,876
and check whether this
has addressed the issue


476
00:21:58,876 --> 00:21:59,556
that we were seeing.


477
00:22:00,816 --> 00:22:02,866
Now when we transition
to the FiringState


478
00:22:02,866 --> 00:22:05,856
and meet the conditions to exit
it, we should properly be able


479
00:22:05,856 --> 00:22:07,886
to transition back
into our IdleState.


480
00:22:09,236 --> 00:22:12,566
So I'll jump back into the
game and go ahead and fire


481
00:22:12,566 --> 00:22:15,776
at the corrupted robot to
convert him into a good one.


482
00:22:16,186 --> 00:22:19,996
And we'll see the beam is no
longer present above our player,


483
00:22:20,116 --> 00:22:21,706
so it looks like we've
addressed the issue.


484
00:22:22,526 --> 00:22:24,936
So now we've also noticed
a performance issue


485
00:22:24,936 --> 00:22:26,086
within our game.


486
00:22:26,086 --> 00:22:28,686
We have a number of ground
robots here on the bottom.


487
00:22:28,686 --> 00:22:30,836
And I notice that when
we get attacked by them,


488
00:22:31,096 --> 00:22:32,906
our performance drops
dramatically.


489
00:22:33,966 --> 00:22:35,896
So I'll switch to our
FPS performance gauge


490
00:22:35,896 --> 00:22:38,426
so that we can see our
performance live while


491
00:22:38,426 --> 00:22:39,116
we're running.


492
00:22:39,746 --> 00:22:41,406
And you can see on the
right here we indicate


493
00:22:41,406 --> 00:22:43,016
to you your target frame time.


494
00:22:43,346 --> 00:22:47,006
And in our case, it's 16.6
milliseconds, which corresponds


495
00:22:47,006 --> 00:22:49,376
to maintaining a frame rate
of 60 frames per second.


496
00:22:50,306 --> 00:22:52,226
We can also see that
a good amount


497
00:22:52,226 --> 00:22:53,796
of our time is spent rendering,


498
00:22:53,796 --> 00:22:55,506
as well as running
our client update,


499
00:22:55,856 --> 00:22:58,426
and we've got a good amount of
wiggle room of CPU idle time.


500
00:22:58,986 --> 00:23:02,236
So I'll go into our game
and move to the right here


501
00:23:02,236 --> 00:23:04,996
where we have an enemy robot,
and I'll let him hit me


502
00:23:04,996 --> 00:23:07,036
so that we can try to reproduce
this performance issue.


503
00:23:07,286 --> 00:23:09,996
So now I'll switch back
to our performance gauge


504
00:23:09,996 --> 00:23:11,806
to see what's going on
within our update loop.


505
00:23:12,386 --> 00:23:13,706
And I'm noticing
that quite a bit


506
00:23:13,706 --> 00:23:15,536
of time is spent
evaluating actions.


507
00:23:15,536 --> 00:23:18,196
In fact, now our frame rate is
dropping quite dramatically.


508
00:23:18,976 --> 00:23:20,516
So I'll go ahead
and pause our app


509
00:23:20,516 --> 00:23:22,616
so that we can take a closer
look at what's going on.


510
00:23:23,306 --> 00:23:26,446
Now that we're paused, I
can scroll back in time


511
00:23:26,446 --> 00:23:27,956
within our frame breakdown


512
00:23:27,956 --> 00:23:30,316
to see our frame time
previously within our app.


513
00:23:30,776 --> 00:23:32,356
In fact, here we can see
the time that we were


514
00:23:32,356 --> 00:23:35,246
in the main menu where we spent
a little bit of time rendering


515
00:23:35,246 --> 00:23:36,566
but most of it was spent idle,


516
00:23:36,596 --> 00:23:39,056
as well as the breakdown we
were seeing within our game.


517
00:23:39,666 --> 00:23:42,406
And now when we are seeing
performance issues, I can click


518
00:23:42,406 --> 00:23:44,246
and hold to examine details


519
00:23:44,246 --> 00:23:46,676
for the performance
issue we were seeing.


520
00:23:47,306 --> 00:23:51,286
Here, I see we're getting
36.2 millisecond frame time,


521
00:23:51,286 --> 00:23:54,676
and 71% of that is spent
evaluating actions.


522
00:23:54,676 --> 00:23:57,196
So what that tells me
is there may be one


523
00:23:57,196 --> 00:23:58,906
of two issues present
within our game.


524
00:23:59,526 --> 00:24:00,746
We could have a single action


525
00:24:00,746 --> 00:24:03,426
within our scene that's taking
an exceedingly large amount


526
00:24:03,426 --> 00:24:05,926
of time to evaluate, or we
could have a large number


527
00:24:05,926 --> 00:24:08,026
of actions that's
bottlenecking our update loop.


528
00:24:08,226 --> 00:24:12,306
So now I know where within our
update loop we're having issues.


529
00:24:15,816 --> 00:24:18,276
So we've seen how we can use
the State Machine Quick Look


530
00:24:18,336 --> 00:24:20,696
to debug an issue we were
seeing within our game,


531
00:24:21,046 --> 00:24:23,206
as well as how the FPS
performance gauge can show us


532
00:24:23,206 --> 00:24:25,936
where exactly within our update
loop we're having issues.


533
00:24:26,856 --> 00:24:28,756
I'd like to now invite
up Daniel Delwood


534
00:24:28,756 --> 00:24:31,686
who will show you a new memory
graph debugger that we can use


535
00:24:31,686 --> 00:24:34,336
to determine where our issue
with actions originates


536
00:24:34,336 --> 00:24:35,866
from so we can fix it.


537
00:24:36,516 --> 00:24:42,966
[ Applause ]


538
00:24:43,466 --> 00:24:43,986
>> Thank you, Tyler.


539
00:24:45,066 --> 00:24:46,216
So I'm very excited to tell you


540
00:24:46,216 --> 00:24:48,536
about the new memory
graph debugger in Xcode 8.


541
00:24:48,846 --> 00:24:51,466
And like the view debugger,


542
00:24:51,696 --> 00:24:54,036
it's a tool for understanding
your applications better.


543
00:24:54,186 --> 00:24:57,216
So just as the view debugger
understands your view hierarchy,


544
00:24:57,216 --> 00:25:00,496
the memory graph debugger helps
you understand your memory


545
00:25:00,496 --> 00:25:02,006
and how it's referencing
each other.


546
00:25:02,576 --> 00:25:05,976
The core question though that
it's trying to answer is -


547
00:25:06,396 --> 00:25:09,126
why does a certain object
still exist on your heap?


548
00:25:10,096 --> 00:25:12,296
Now objects reference
each other.


549
00:25:12,296 --> 00:25:16,726
And, you know, this is more and
more a question of references


550
00:25:16,726 --> 00:25:17,956
and annotation these days


551
00:25:18,306 --> 00:25:19,896
in an automatic
reference-guiding world.


552
00:25:20,686 --> 00:25:24,936
So where can we go from
having this problem of objects


553
00:25:24,936 --> 00:25:27,356
that we don't want, objects
that are leaked, or abandoned?


554
00:25:28,266 --> 00:25:29,346
Well, there's some
command-line tools


555
00:25:29,346 --> 00:25:31,466
that can help, such as Heap.


556
00:25:32,146 --> 00:25:34,916
And what Heap does is it
snapshots your process,


557
00:25:35,256 --> 00:25:37,876
looks through it for a
summary of the different types


558
00:25:37,946 --> 00:25:41,256
and the counts of objects
that are in your process.


559
00:25:41,256 --> 00:25:43,816
And you can even use the
"addresses" flag to look


560
00:25:43,816 --> 00:25:45,706
for a specific type of object


561
00:25:45,706 --> 00:25:47,806
and get a list of
those instances.


562
00:25:48,366 --> 00:25:50,736
Once you have an instance
you're interested in,


563
00:25:51,316 --> 00:25:53,366
leaks is where you go
for the connectivity kind


564
00:25:53,366 --> 00:25:55,746
of information of, well,
is it unreferenced?


565
00:25:55,746 --> 00:25:56,346
Is it leaked?


566
00:25:56,846 --> 00:25:59,956
Or is there some path
from a global location


567
00:25:59,996 --> 00:26:03,906
in your application that goes
all the way down to your object?


568
00:26:05,136 --> 00:26:07,156
Now, at any point in
this investigation,


569
00:26:07,156 --> 00:26:08,946
you might need some
further detail,


570
00:26:08,946 --> 00:26:10,496
such as the allocation
stack trace.


571
00:26:10,856 --> 00:26:12,176
And, that, you can get
with malloc-history.


572
00:26:12,986 --> 00:26:15,586
And this is all not a
very visual experience,


573
00:26:15,586 --> 00:26:18,006
and that's why we pulled all of
these three tools into the IDE


574
00:26:18,006 --> 00:26:20,066
for the memory graph debugger.


575
00:26:20,066 --> 00:26:24,146
And so just a quick overview of,
you know, how this is laid out.


576
00:26:24,646 --> 00:26:26,986
On the left, the Navigator is
where you get that heap-type


577
00:26:26,986 --> 00:26:29,306
of information to
start your analysis.


578
00:26:30,036 --> 00:26:31,476
The center editor area is


579
00:26:31,476 --> 00:26:33,786
where the connectivity
information gets presented.


580
00:26:34,406 --> 00:26:37,526
And on the right -- that's
what we're showing you now --


581
00:26:37,606 --> 00:26:40,446
the allocation stack
trace via the Inspector.


582
00:26:40,976 --> 00:26:43,396
So with that, I'd just like to
jump right back into the demo


583
00:26:44,156 --> 00:26:46,646
where Tyler left off and
see if we can take a look


584
00:26:46,646 --> 00:26:48,466
at those action problems
that he was seeing.


585
00:26:48,916 --> 00:26:49,306
All right.


586
00:26:49,506 --> 00:26:55,456
So here we are with the FPS
performance gauge, looking at,


587
00:26:55,696 --> 00:26:57,236
you know, actions
that are probably


588
00:26:57,236 --> 00:26:59,576
at fault here in
our application.


589
00:27:00,036 --> 00:27:01,446
So I'm just going to jump right


590
00:27:01,446 --> 00:27:04,646
in by choosing the Memory
Graph Debugger button


591
00:27:05,136 --> 00:27:07,506
in the Debug Menu Bar.


592
00:27:08,136 --> 00:27:09,806
And on the left here,


593
00:27:10,006 --> 00:27:14,386
the Navigator shows me
my application with all


594
00:27:14,386 --> 00:27:17,086
of the different types
that are allocated in it.


595
00:27:17,316 --> 00:27:20,206
And so they're broken
down by a hierarchy


596
00:27:20,206 --> 00:27:21,896
of module and then type.


597
00:27:21,896 --> 00:27:24,256
And then under each of
these, there's an instance.


598
00:27:25,136 --> 00:27:28,266
And so, in this case, I'm kind


599
00:27:28,266 --> 00:27:30,056
of interested in
searching my heap.


600
00:27:30,256 --> 00:27:31,386
And it's very easy to do.


601
00:27:31,386 --> 00:27:34,616
I can just type into the filter,
and I'll look for actions.


602
00:27:35,906 --> 00:27:36,976
So here we are.


603
00:27:37,036 --> 00:27:38,946
We've got types in SpriteKit.


604
00:27:38,946 --> 00:27:42,846
And we see that, yeah, we
have a lot of actions -- 559.


605
00:27:43,336 --> 00:27:46,296
So it's probably that we
have too many actions and not


606
00:27:46,296 --> 00:27:49,086
that we have some
long-running single actions.


607
00:27:50,776 --> 00:27:52,666
So let me select one
of these objects.


608
00:27:53,116 --> 00:27:57,566
And the editor changes to show
me the answer to the question


609
00:27:57,566 --> 00:27:59,696
of why this object
is still around.


610
00:28:00,116 --> 00:28:02,296
In this case, it's showing
me a root analysis graph


611
00:28:02,296 --> 00:28:07,146
which allows me to trace the
object I've selected back


612
00:28:07,186 --> 00:28:09,416
to the left, back to the
roots of my application.


613
00:28:09,946 --> 00:28:11,316
So I can see that
it's referenced


614
00:28:11,316 --> 00:28:14,136
by an SKC sequence by repeat.


615
00:28:14,196 --> 00:28:15,776
There's an array
holding onto this.


616
00:28:15,876 --> 00:28:19,346
And I can even disclose
further to see


617
00:28:19,346 --> 00:28:22,046
that here we've got an
SKNode with some actions.


618
00:28:22,356 --> 00:28:25,086
So, OK, it's part of
this SKNode actions list.


619
00:28:25,516 --> 00:28:29,346
I can click on this and
try Quick Looking it.


620
00:28:29,346 --> 00:28:33,886
If I want to take some
more looks at this action,


621
00:28:34,316 --> 00:28:37,056
I can select it and
pull in the Inspector.


622
00:28:38,186 --> 00:28:41,036
Now the Inspector shows
me some memory details,


623
00:28:41,036 --> 00:28:44,746
such as the class name,
the address, the hierarchy


624
00:28:44,746 --> 00:28:47,786
if it is a sub-class
of some other objects.


625
00:28:48,306 --> 00:28:50,736
What I'm interested in is
where this action was created


626
00:28:50,736 --> 00:28:51,976
so I can jump to there.


627
00:28:52,446 --> 00:28:57,876
I can go ahead and collapse this
stack trace and jump to my code.


628
00:28:58,016 --> 00:29:02,036
And here, we see I've got this
function -- refreshHurtAction.


629
00:29:03,066 --> 00:29:06,166
All right, so it's
running a HurtAction.


630
00:29:06,346 --> 00:29:11,696
I can use the Quick Help to
see that this action is added


631
00:29:11,696 --> 00:29:13,986
to the list of actions
on the node.


632
00:29:14,816 --> 00:29:18,616
But I actually wanted to only
have a single-player action


633
00:29:18,616 --> 00:29:20,916
and make sure that this was
replacing my previous actions.


634
00:29:21,376 --> 00:29:22,676
So it's a pretty simple fix.


635
00:29:22,676 --> 00:29:25,406
I'm just going to use
the withKey variant here


636
00:29:25,506 --> 00:29:27,886
and replace the player action.


637
00:29:28,526 --> 00:29:33,206
And the Quick Help
will show me that, yes,


638
00:29:33,286 --> 00:29:35,036
this is actually the
one I was wanting.


639
00:29:35,166 --> 00:29:37,296
If an action using the same
key is already running,


640
00:29:37,296 --> 00:29:38,766
it is removed before
the action is added.


641
00:29:39,066 --> 00:29:44,926
Great. So that's a pretty simple
way to jump to an investigation


642
00:29:44,926 --> 00:29:46,286
about a specific type.


643
00:29:46,346 --> 00:29:48,006
But one of the other
things I noticed


644
00:29:48,006 --> 00:29:51,106
when I hit the Memory
Graph Debugging button is


645
00:29:51,106 --> 00:29:54,416
that the Runtime Issues
Navigator alerted me


646
00:29:54,416 --> 00:29:55,116
to some issues.


647
00:29:55,376 --> 00:29:56,606
So I can click on that.


648
00:29:56,606 --> 00:30:00,336
And now I'm taken to the
new Runtime Issues Navigator


649
00:30:00,926 --> 00:30:04,226
which has a bunch of leaks that
were reported in my application.


650
00:30:05,256 --> 00:30:09,226
So I'll start out with a type
that is defined in my module --


651
00:30:09,336 --> 00:30:11,266
say, this LoadSceneOperation.


652
00:30:12,626 --> 00:30:15,096
If I select it, now the
graph isn't showing me


653
00:30:15,096 --> 00:30:16,166
that same style.


654
00:30:16,396 --> 00:30:18,666
It's showing me a
reference cycle,


655
00:30:19,296 --> 00:30:22,006
which is because this
is a leaked object.


656
00:30:22,006 --> 00:30:25,166
It's not reachable from those
locations in my application.


657
00:30:25,426 --> 00:30:28,116
And I need to find
out what objects


658
00:30:28,186 --> 00:30:30,806
in the leaked set are
referencing each other.


659
00:30:31,846 --> 00:30:35,546
So looking at this
quickly, I have an operation


660
00:30:35,546 --> 00:30:36,876
with some internal state.


661
00:30:37,156 --> 00:30:39,186
It's referencing a
completion block.


662
00:30:39,676 --> 00:30:44,026
And then this has some
captures as part of that block


663
00:30:44,086 --> 00:30:46,196
that strongly referenced
my LoadSceneOperation.


664
00:30:46,746 --> 00:30:47,086
Interesting.


665
00:30:48,366 --> 00:30:51,546
So if I click on the block,
I can see the back trace


666
00:30:51,546 --> 00:30:54,686
and go immediately there.


667
00:30:54,916 --> 00:30:56,706
And here we are --


668
00:30:56,706 --> 00:30:58,596
my LoadSceneOperation
completion block.


669
00:30:58,596 --> 00:31:01,516
I'm even using a capture
list for "unowned self".


670
00:31:02,096 --> 00:31:04,756
But the graph showed me that
"self" wasn't the problem.


671
00:31:04,756 --> 00:31:08,806
It was the LoadSceneOperation
capturing itself right there


672
00:31:09,036 --> 00:31:09,836
within the block.


673
00:31:11,536 --> 00:31:13,486
So it's a pretty
easy fix to make.


674
00:31:13,736 --> 00:31:17,466
I just need to capture
it unowned


675
00:31:18,296 --> 00:31:21,826
and I can get going again.


676
00:31:23,296 --> 00:31:26,626
But, unfortunately, that's
not quite the solution here.


677
00:31:27,056 --> 00:31:28,756
Because, since it's
a completion block,


678
00:31:28,756 --> 00:31:31,166
my LoadSceneOperation
is just about done.


679
00:31:31,616 --> 00:31:33,836
And so once it executes
this block here,


680
00:31:34,266 --> 00:31:36,816
the LoadSceneOperation is
going to end its lifecycle


681
00:31:36,956 --> 00:31:38,556
and it won't be around
for much longer.


682
00:31:39,036 --> 00:31:41,366
This means that when I dispatch
async back to the main queue,


683
00:31:42,616 --> 00:31:45,106
this LoadSceneOperation
may no longer be valid


684
00:31:45,106 --> 00:31:46,066
and I'm going to get a crash.


685
00:31:46,876 --> 00:31:50,466
So it just goes to show that
these captures can be tricky


686
00:31:50,466 --> 00:31:54,266
at times and require a
little bit of investigation.


687
00:31:54,636 --> 00:31:57,166
And hopefully the memory
graph debugger will help you


688
00:31:57,736 --> 00:31:58,836
in your investigations as well.


689
00:31:59,516 --> 00:32:05,996e
[ Applause ]


690
00:31:59,516 --> 00:32:05,996
[ Applause ]


691
00:32:06,496 --> 00:32:08,436
So, let's talk a little bit more


692
00:32:08,436 --> 00:32:10,936
about leaked and
abandoned memory.


693
00:32:11,146 --> 00:32:15,606
The memory graph debugger is a
debugger mode, and so it pauses


694
00:32:15,606 --> 00:32:17,466
to inspect your target
application.


695
00:32:17,826 --> 00:32:19,526
This is so your application
doesn't keep going


696
00:32:19,526 --> 00:32:22,026
and changing its state, and
you can get a consistent view


697
00:32:22,026 --> 00:32:22,586
of the world.


698
00:32:22,986 --> 00:32:24,696
It also lets you do
things like Quick Look


699
00:32:24,696 --> 00:32:27,686
or PO different objects as you
go through your investigation,


700
00:32:27,776 --> 00:32:30,226
and it's available on
all of our platforms.


701
00:32:31,146 --> 00:32:32,516
Now, as I showed in the demo,


702
00:32:32,516 --> 00:32:33,596
there's two different
graph styles.


703
00:32:34,136 --> 00:32:37,266
And the first one is that
root paths graph style


704
00:32:37,646 --> 00:32:39,276
which shows you for
referenced memory --


705
00:32:39,566 --> 00:32:40,496
maybe you've abandoned it --


706
00:32:41,116 --> 00:32:45,416
how are different roots in
your application like globals


707
00:32:45,456 --> 00:32:47,806
and currently-running threads
referencing that memory.


708
00:32:48,606 --> 00:32:50,286
Now with the progressive
disclosure model,


709
00:32:50,286 --> 00:32:52,506
it lets you work back
from your objecst


710
00:32:52,636 --> 00:32:55,846
to different intermediate
objects and find the reference


711
00:32:55,926 --> 00:32:57,356
that should no longer be there.


712
00:32:58,466 --> 00:33:00,806
For unreferenced
memory or leaked memory,


713
00:33:01,196 --> 00:33:02,586
that's when you see
the cycles view.


714
00:33:02,896 --> 00:33:07,716
And the goal there is to help
show you what is strongly


715
00:33:07,716 --> 00:33:09,146
referencing itself.


716
00:33:09,146 --> 00:33:11,986
And it'll let you figure out,
again, a reference problem.


717
00:33:13,826 --> 00:33:17,156
So, for stack logging
integration that you saw


718
00:33:17,156 --> 00:33:22,486
in the Inspector, it's not
quite free to record all


719
00:33:22,486 --> 00:33:24,356
of the mallocs and frees
in your application.


720
00:33:24,606 --> 00:33:26,916
And so this is a diagnostic
that you'll need to opt into.


721
00:33:27,706 --> 00:33:32,036
Just going to the Scheme Editor
and selecting MallocStackLogging


722
00:33:32,036 --> 00:33:34,906
in the Diagnostics Tab
is enough to enable it.


723
00:33:34,906 --> 00:33:38,006
And it will record, again, all
of the mallocs and frees to disk


724
00:33:38,286 --> 00:33:39,596
so you can look them up later.


725
00:33:40,626 --> 00:33:43,576
But for memory graph debugging,
you don't really need all


726
00:33:43,576 --> 00:33:44,766
of the malloc and frees.


727
00:33:44,766 --> 00:33:46,306
And previous lifetimes


728
00:33:46,306 --> 00:33:49,336
of a malloc block just
aren't usually that useful.


729
00:33:49,886 --> 00:33:56,206
So, new in our current OSs is
a Live Allocations Only Mode.


730
00:33:56,246 --> 00:34:00,986
And so this has a lower
overhead, and it also allows you


731
00:34:01,056 --> 00:34:03,616
to get this rich information
while you're memory


732
00:34:03,616 --> 00:34:04,226
graph debugging.


733
00:34:04,736 --> 00:34:09,116
So this will set the "lite"
flag to MallocStackLogging


734
00:34:09,525 --> 00:34:10,985
in target environment.


735
00:34:13,436 --> 00:34:17,005
So one other thing
that you may enjoy


736
00:34:17,005 --> 00:34:18,906
about memory graph debugging is


737
00:34:18,956 --> 00:34:21,386
that we've introduced a
.memgraph file format.


738
00:34:21,876 --> 00:34:24,005
Now, sometimes you'll
be debugging an issue


739
00:34:24,005 --> 00:34:26,956
and you won't have the time
to really dive into it.


740
00:34:27,326 --> 00:34:30,056
And so you may want to save
this off or have other engineers


741
00:34:30,056 --> 00:34:31,545
on your team take
a look as well.


742
00:34:31,826 --> 00:34:35,116
So, from Xcode, you can
actually go to the File menu


743
00:34:35,286 --> 00:34:37,376
and select Export Memory Graph.


744
00:34:37,806 --> 00:34:39,406
And what it'll do
is save out all


745
00:34:39,406 --> 00:34:41,786
of the connectivity information
and heap information,


746
00:34:42,005 --> 00:34:43,496
as well as some VM statistics


747
00:34:43,496 --> 00:34:45,686
about your application
to a file.


748
00:34:45,956 --> 00:34:47,976
Then at some later time,
you can just double-click,


749
00:34:48,116 --> 00:34:52,366
load that file in the Xcode, and
take a look at the memory graph.


750
00:34:53,056 --> 00:34:55,216
Now this does mean that there's
no process in the debugger.


751
00:34:55,216 --> 00:34:59,326
So you can't get back traces,
or Quick Look or PO the objects.


752
00:34:59,326 --> 00:35:00,996
But it's still a very
powerful technique


753
00:35:00,996 --> 00:35:03,506
for an app analyzing
after the fact.


754
00:35:04,736 --> 00:35:06,466
Now if you want to build this


755
00:35:06,466 --> 00:35:08,576
into your continuous
integration,


756
00:35:09,546 --> 00:35:11,656
we've actually got some
options from the command line.


757
00:35:12,366 --> 00:35:16,216
So you can just run
leaks-outputGraph, pick a path,


758
00:35:16,516 --> 00:35:18,826
and save out a .memgraph
file for later.


759
00:35:20,106 --> 00:35:23,896
So leaks, vmmap, and heap have
all been enhanced to read this.


760
00:35:24,516 --> 00:35:31,006
[ Applause ]


761
00:35:31,506 --> 00:35:33,346
All right, now the fun part.


762
00:35:33,346 --> 00:35:36,006
Let's talk about some usage tips
here because this is all built


763
00:35:36,006 --> 00:35:37,786
on the leaks infrastructure.


764
00:35:38,446 --> 00:35:40,526
Now what this means is
the graph is conservative.


765
00:35:41,286 --> 00:35:45,356
We're trying very, very
hard not to report things


766
00:35:45,356 --> 00:35:46,366
as leaked when they're not.


767
00:35:46,366 --> 00:35:50,266
And so in that attempt
to avoid false positives,


768
00:35:51,026 --> 00:35:52,566
there may be some
extraneous references


769
00:35:52,606 --> 00:35:53,476
that you see in the graph.


770
00:35:54,486 --> 00:35:59,136
Now these references will show
up gray for being unknown.


771
00:35:59,206 --> 00:36:01,156
They may be valid
references, they may not.


772
00:36:01,476 --> 00:36:04,456
We may not just have metadata
available to the tool.


773
00:36:04,846 --> 00:36:08,986
And so take them
with a grain of salt


774
00:36:08,986 --> 00:36:10,276
as you're reading these graphs.


775
00:36:10,786 --> 00:36:13,486
Now one thing you can do
to improve the accuracy is


776
00:36:13,486 --> 00:36:14,456
to enable Malloc Scribble,


777
00:36:14,586 --> 00:36:16,926
which is another
diagnostic in this scheme.


778
00:36:17,406 --> 00:36:20,456
And this will mean that
when allocation are free,


779
00:36:20,816 --> 00:36:23,716
it will write over the
memory so that you don't have


780
00:36:23,976 --> 00:36:27,766
that uninitialized
memory in that new block.


781
00:36:29,156 --> 00:36:32,146
So for references that are known
to be strong, these will show


782
00:36:32,146 --> 00:36:33,526
up as bold in the graph.


783
00:36:33,626 --> 00:36:37,736
And Swift 3 actually has
a lot more reflection


784
00:36:37,736 --> 00:36:39,206
metadata available.


785
00:36:39,686 --> 00:36:43,896
And so I encourage
you to use this


786
00:36:43,996 --> 00:36:47,436
because it definitely is a
lot more accurate in terms


787
00:36:47,436 --> 00:36:49,566
of understanding
captures and references.


788
00:36:50,616 --> 00:36:51,986
And finally, I should put


789
00:36:51,986 --> 00:36:53,636
out that the memory
graph debugger requires


790
00:36:53,636 --> 00:36:55,736
that you temporarily
turn off sanitizers


791
00:36:55,886 --> 00:36:58,426
like Address Sanitizer
or Thread Sanitizer.


792
00:36:59,716 --> 00:37:01,516
So this is a lot of information.


793
00:37:02,316 --> 00:37:04,386
Where is a great place to get
started with your application?


794
00:37:05,186 --> 00:37:07,146
Well, validate your
expectations.


795
00:37:07,326 --> 00:37:10,676
Are there more objects of a
certain type than you expect?


796
00:37:11,266 --> 00:37:13,896
Are objects being
deallocated when you expect?


797
00:37:14,506 --> 00:37:18,016
Are there any leaks
in your types as well?


798
00:37:18,766 --> 00:37:20,546
Once you find an object
that you're interested


799
00:37:20,546 --> 00:37:23,176
in investigating, then
the goal is to find a path


800
00:37:23,506 --> 00:37:25,646
that shouldn't be there
holding onto your object.


801
00:37:26,166 --> 00:37:29,076
And two very common patterns


802
00:37:29,076 --> 00:37:32,036
that you'll find are
strong captures from blocks


803
00:37:32,036 --> 00:37:37,396
and closures, or potentially
even references upward


804
00:37:37,436 --> 00:37:41,246
in your graph that need to be
marked as "weak" or "unowned".


805
00:37:42,496 --> 00:37:45,426
So, that's a lot of information.


806
00:37:46,056 --> 00:37:50,886
But I just want to thank
you very much for listening


807
00:37:50,886 --> 00:37:52,266
to our information about new


808
00:37:52,266 --> 00:37:54,746
and improved visual
tools in Xcode 8.


809
00:37:54,926 --> 00:37:56,256
We're really excited
about things


810
00:37:56,306 --> 00:38:00,146
like the better visual debugging
with the view debugger,


811
00:38:00,416 --> 00:38:03,746
with FPS gauge, and
memory graph debugging.


812
00:38:04,126 --> 00:38:06,736
So go out, try them
out in your app today,


813
00:38:06,736 --> 00:38:08,396
and solve a lot of issues.


814
00:38:09,516 --> 00:38:12,500
[ Applause ]

