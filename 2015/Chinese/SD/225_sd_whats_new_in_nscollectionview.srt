1
00:00:20,487 --> 00:00:21,321
感谢您的莅临


2
00:00:22,289 --> 00:00:26,593
欢迎进入第225章
《NS集合视图的应用更新》


3
00:00:27,060 --> 00:00:30,430
我的名字是特洛伊斯特芬
我是来自AppKit团队的一名软件工程师


4
00:00:30,731 --> 00:00:34,201
我很高兴今天可以
为你们解答这个问题


5
00:00:34,635 --> 00:00:35,802
有什么更新呢？


6
00:00:36,003 --> 00:00:37,070
让我们来看看


7
00:00:38,505 --> 00:00:41,108
NS集合视图在10.5版本
的OS X里


8
00:00:41,175 --> 00:00:42,209
已经存在一段时间了


9
00:00:42,276 --> 00:00:43,877
它提供了一个便捷的方法


10
00:00:43,944 --> 00:00:47,014
来显示格式的项目
在用户的界面上


11
00:00:47,080 --> 00:00:48,115
例如


12
00:00:48,282 --> 00:00:49,850
在屏保的偏好设置面板上


13
00:00:50,918 --> 00:00:54,254
我们有着不同格式的项目
来代表不同的屏保


14
00:00:54,321 --> 00:00:57,758
集合视图在这方面很擅长
它能够显示相似尺寸的项目


15
00:00:58,058 --> 00:01:00,127
假如您给集合视图一个原型


16
00:01:00,494 --> 00:01:04,063
带有您图样树状的子目录


17
00:01:04,298 --> 00:01:06,433
和共同负责管理它的视图控制器


18
00:01:07,067 --> 00:01:09,169
集合视图将复制项目的...


19
00:01:09,670 --> 00:01:10,704
原型


20
00:01:11,038 --> 00:01:14,208
以自我繁殖来代表模型物


21
00:01:16,210 --> 00:01:18,679
集合视图支持选择
拖动和放下该项目


22
00:01:18,745 --> 00:01:21,949
动画式重新全面布局格式
这是一项非常便利的功能


23
00:01:22,783 --> 00:01:25,519
现在进入iOS的UI集合视图


24
00:01:25,652 --> 00:01:27,521
这和NS集合视图有莫大的关系


25
00:01:27,988 --> 00:01:29,089
而且拥有多功能


26
00:01:29,156 --> 00:01:31,525
我们可以在iPad的时钟App里


27
00:01:31,592 --> 00:01:33,727
看到世界时钟的部分


28
00:01:37,331 --> 00:01:39,233
UI集合视图 顾名思义


29
00:01:39,299 --> 00:01:41,568
它用于显示项目集


30
00:01:41,635 --> 00:01:43,103
其中包括每个项目


31
00:01:43,370 --> 00:01:46,740
都会有一个完全是自己设计的
树状子目录为代表


32
00:01:46,807 --> 00:01:49,376
通常它运用UI集合视图
来加载nib文件


33
00:01:50,611 --> 00:01:53,213
UI集合视图支持混合种类的项目


34
00:01:53,280 --> 00:01:55,749
您可以拥有不同的nib文件
它们原型是不同的项目


35
00:01:55,816 --> 00:01:57,317
所以您不是只有一个选项


36
00:01:58,886 --> 00:02:00,420
UI集合视图支持


37
00:02:00,554 --> 00:02:01,788
标头及注脚的观点


38
00:02:01,855 --> 00:02:04,691
并把它们放在括号里


39
00:02:05,158 --> 00:02:08,495
如果您把它和将项目组
和成绩格式的能力一起用


40
00:02:08,562 --> 00:02:10,564
会显得更方便好用


41
00:02:10,631 --> 00:02:13,267
每个区段都可以拥有一个
标头及注脚的观点


42
00:02:15,335 --> 00:02:18,172
布局非常有柔性
而且可以由客户自己定制


43
00:02:18,238 --> 00:02:21,241
它会有一个处理大概90%的
内定流程布局


44
00:02:21,308 --> 00:02:23,844
来满足您的需要
而且可以按客户的要求来定制


45
00:02:23,911 --> 00:02:26,180
您可以把它的参数


46
00:02:26,246 --> 00:02:27,581
调到您满意为止


47
00:02:28,282 --> 00:02:30,284
UI集合视图也可以开启于


48
00:02:30,350 --> 00:02:33,086
任意自定义开发的列印格式


49
00:02:33,153 --> 00:02:35,155
UI集合视图可以运用任何


50
00:02:35,389 --> 00:02:36,790
您可以实施的演算法列印格式


51
00:02:36,857 --> 00:02:38,892
来应用在所显示的项目上


52
00:02:40,661 --> 00:02:43,063
最重要的是
UI集合视图是可以被调整的


53
00:02:43,497 --> 00:02:44,865
它的智能设计


54
00:02:44,932 --> 00:02:48,502
让它可以规划大量有潜力的项目


55
00:02:48,569 --> 00:02:52,873
而它的智能也能在视图模型对象中
让项目实例化


56
00:02:53,006 --> 00:02:55,876
以及回收并重新使用
已滑出视线的项目


57
00:02:55,943 --> 00:02:58,679
来呈现进入视线范围的模型对象


58
00:02:58,745 --> 00:02:59,646
这是很简便的


59
00:03:01,348 --> 00:03:03,083
像是在iOS的其他项目


60
00:03:03,150 --> 00:03:04,885
UI集合视图的设计让
所有的屏幕


61
00:03:04,952 --> 00:03:06,987
都由一个底层的
分层式系统来驱动


62
00:03:07,287 --> 00:03:10,991
这也使整个高帧速率的动画
流程很流畅


63
00:03:11,058 --> 00:03:14,094
在全方面地操作集合视图时


64
00:03:14,161 --> 00:03:16,463
这可以给您一个
很优良的动画般的效果


65
00:03:16,830 --> 00:03:18,732
有了这些优良的特征


66
00:03:19,132 --> 00:03:22,436
和开发者都已经熟悉的API


67
00:03:23,237 --> 00:03:26,173
还有对iOS Apps广泛的
应用和使用


68
00:03:26,240 --> 00:03:29,276
我们觉得UI集合视图
将会形成一个


69
00:03:29,343 --> 00:03:30,611
良好的基础


70
00:03:30,811 --> 00:03:33,146
于我们在El
Capitan所介绍的


71
00:03:33,213 --> 00:03:35,482
全新且大大改良的
NS集合视图中


72
00:03:36,149 --> 00:03:37,918
这个全新的NS集合视图


73
00:03:38,252 --> 00:03:40,153
承受了所有的UI集合视图


74
00:03:40,220 --> 00:03:41,321
可扩缩性的形态


75
00:03:42,122 --> 00:03:44,925
它将知道如何在需要的时候
启动项目


76
00:03:45,125 --> 00:03:48,161
以便只让少数的项目进行着


77
00:03:48,395 --> 00:03:50,831
以便让它们可以
重新使用或是再循环


78
00:03:51,098 --> 00:03:52,332
而不是重新启动它们


79
00:03:52,399 --> 00:03:55,135
这可以省下一些附加操作
您可以根据组别来规划项目


80
00:03:55,302 --> 00:03:57,271
您也可以为那些组别
标上标头及注脚观点


81
00:03:57,337 --> 00:03:58,172
由您所好


82
00:03:58,238 --> 00:03:59,439
为它们标上任何您想要的


83
00:04:00,274 --> 00:04:02,242
列印格式完全是个人化的


84
00:04:02,309 --> 00:04:05,846
所以NS集合视图不再只是
硬布线般认为它只是网格


85
00:04:06,113 --> 00:04:08,482
您可以插入任何您想要的布局


86
00:04:09,850 --> 00:04:12,519
我们可以处理不同大小的项目


87
00:04:12,586 --> 00:04:14,254
项目可以以不同的种类出现


88
00:04:14,321 --> 00:04:16,723
您也可以混合搭配流程式布局


89
00:04:16,790 --> 00:04:19,625
尤其是可以把它处理成恰当的


90
00:04:21,295 --> 00:04:23,664
就像先前一样
外貌格式也是个人化的


91
00:04:23,730 --> 00:04:25,866
您可以定义出
您的子树状视图


92
00:04:25,933 --> 00:04:27,334
为您想要的样貌


93
00:04:28,068 --> 00:04:29,803
集合视图是您的空白画板


94
00:04:29,870 --> 00:04:31,038
它让您可以规划您想要的


95
00:04:32,105 --> 00:04:34,341
当动画在进行的时候


96
00:04:34,408 --> 00:04:37,277
根据时间调制
您将拥有绝对的控制权


97
00:04:37,411 --> 00:04:38,712
我们来看看这是怎样做到的


98
00:04:39,813 --> 00:04:41,014
当然我们不会只是把


99
00:04:41,081 --> 00:04:43,584
UI集合视图的功能
转移到OS X


100
00:04:43,650 --> 00:04:46,453
我们更想要让全新的
NS集合视图更适合


101
00:04:46,520 --> 00:04:48,055
在家里的平台使用


102
00:04:48,322 --> 00:04:50,757
其中一个
我们配备在平台的科技是


103
00:04:50,824 --> 00:04:53,927
NS集合视图一直都
支持的拖拽及放下功能


104
00:04:54,494 --> 00:04:57,698
但作为把UI集合视图
布局API


105
00:04:58,031 --> 00:04:59,600
输送到平台的一部分


106
00:04:59,867 --> 00:05:01,602
我们在API上添加了几个功能


107
00:05:01,668 --> 00:05:03,804
我们在这场讲座会结束之前
会再提到这些功能


108
00:05:04,104 --> 00:05:06,006
这些功能基本上能让任何布局


109
00:05:06,139 --> 00:05:07,841
包括您自定义的布局


110
00:05:08,075 --> 00:05:08,909
去...


111
00:05:09,610 --> 00:05:12,846
執行识别候选放置目标
的命中测试


112
00:05:12,913 --> 00:05:14,414
我们稍后会再谈谈
如何做到这一点


113
00:05:14,882 --> 00:05:17,818
任何您设计的自定义布局
都支持...


114
00:05:18,151 --> 00:05:19,019
拖拽及放下的功能


115
00:05:19,286 --> 00:05:20,320
就像是甲级布局一样


116
00:05:20,954 --> 00:05:22,689
您运用Rubber Band
拖拽选择


117
00:05:22,756 --> 00:05:23,991
来拖拽各种项目


118
00:05:24,057 --> 00:05:25,993
然后大批量地选择项目群


119
00:05:26,660 --> 00:05:28,529
此选项像之前一样
全面地支持这项功能


120
00:05:28,862 --> 00:05:30,731
我们也修改了这个选项


121
00:05:30,797 --> 00:05:33,033
并高亮了系统通知设备
和传递设备


122
00:05:33,100 --> 00:05:34,101
以便处理那些


123
00:05:34,168 --> 00:05:35,002
大量...


124
00:05:35,169 --> 00:05:38,505
高亮项目功能的准确性


125
00:05:38,572 --> 00:05:39,439
因为有时候


126
00:05:39,506 --> 00:05:41,275
会有很多想象不到的事情
在平台上发生


127
00:05:41,341 --> 00:05:44,244
您将使用全选功能
或是取消全选功能


128
00:05:44,344 --> 00:05:45,379
或是大批量选择


129
00:05:45,445 --> 00:05:47,481
我们希望可以有效地把它处理好


130
00:05:47,714 --> 00:05:49,983
API上有些许的调整


131
00:05:50,751 --> 00:05:52,085
就像之前一样


132
00:05:52,186 --> 00:05:55,489
项目还是在平台上
通过视图控制器呈现


133
00:05:55,556 --> 00:05:57,791
我们认为这是很好的机会


134
00:05:57,858 --> 00:05:59,426
它让您能整齐地象限化


135
00:05:59,493 --> 00:06:00,594
分割出您的代码


136
00:06:00,861 --> 00:06:03,497
好让您的控制器代码
和视图代码分开


137
00:06:04,097 --> 00:06:05,499
以获得更好的代码整理


138
00:06:06,800 --> 00:06:08,802
我们所加入的最后一个小修饰就是


139
00:06:08,869 --> 00:06:09,770
让集合视图


140
00:06:09,937 --> 00:06:13,240
可以自动寻找适合的nibs文件
来运用在项目上


141
00:06:13,307 --> 00:06:14,808
如果您只是惯例式地命名


142
00:06:14,908 --> 00:06:17,477
而您所选择的nib文件名字
与您所命名的


143
00:06:17,544 --> 00:06:18,846
相似于您所要求的项目种类


144
00:06:18,912 --> 00:06:20,013
从集合视图的角度看来


145
00:06:20,080 --> 00:06:24,218
您根本不需要
去帮您的项目在集合视图注册了


146
00:06:24,318 --> 00:06:26,153
这些小小的代码
可以为您省下不少时间


147
00:06:27,588 --> 00:06:29,156
所以我们今天的目标就是


148
00:06:29,223 --> 00:06:30,557
我想真正地深入这个话题


149
00:06:30,624 --> 00:06:33,126
我想让你们准备好
运用这个全新的集合视图


150
00:06:33,193 --> 00:06:35,796
我们来看看当我们开始
使用新的...


151
00:06:35,929 --> 00:06:37,231
API 10.5版本时


152
00:06:37,297 --> 00:06:39,933
是怎么装置其中一些全新的


153
00:06:40,267 --> 00:06:41,101
NS集合视图


154
00:06:41,301 --> 00:06:42,436
我们会学习关于


155
00:06:42,669 --> 00:06:44,771
OS X和在iOS上有什么不同


156
00:06:44,938 --> 00:06:46,240
我想 我们将会有小小的惊喜


157
00:06:46,306 --> 00:06:47,441
给在座的各位


158
00:06:47,674 --> 00:06:49,910
无论您是不是一个有经验的
iOS开发者


159
00:06:50,143 --> 00:06:52,145
把这个应用程式带到OS X


160
00:06:52,212 --> 00:06:55,115
您也许曾经用过UI集合视图
您对API很熟悉


161
00:06:55,415 --> 00:06:57,851
您将会传递一些知识
一些代码


162
00:06:57,918 --> 00:06:58,785
我们会...


163
00:06:58,852 --> 00:07:00,320
给您实用的资料


164
00:07:01,255 --> 00:07:02,990
也可能您是前OS X开发者


165
00:07:03,056 --> 00:07:04,992
您曾经为NS集合视图工作


166
00:07:05,092 --> 00:07:08,095
您想要学习一些新的API模式
并学习怎么运用它


167
00:07:08,161 --> 00:07:09,730
在这之前
我们将会给出足够的介绍


168
00:07:09,796 --> 00:07:12,499
让您明白什么是
UI集合视图API


169
00:07:13,600 --> 00:07:16,069
可是就算您从来都
没有接触过任何一个


170
00:07:16,136 --> 00:07:18,672
我们会作充分介绍
深入实用的了解


171
00:07:18,739 --> 00:07:20,073
还有代码样本


172
00:07:20,207 --> 00:07:21,742
在今天的话题会提到


173
00:07:21,808 --> 00:07:23,377
您将能快速地学习和认知


174
00:07:23,443 --> 00:07:25,712
以便迅速了解
什么是全新的集合视图


175
00:07:26,513 --> 00:07:29,883
在开始之前我们先对今天的概念
做一个快速的讲解


176
00:07:29,950 --> 00:07:32,319
我们需要知道关于
全新的API的基础概念


177
00:07:32,386 --> 00:07:34,922
然后我们会更深入地
了解API是怎么操作的


178
00:07:34,988 --> 00:07:37,191
哪个模式比较重要
怎么启动


179
00:07:37,257 --> 00:07:38,525
之后我们会做个总结


180
00:07:38,859 --> 00:07:40,127
现在说说大纲


181
00:07:41,295 --> 00:07:44,932
在运用旧的
集合视图 OS X 10.10


182
00:07:44,998 --> 00:07:46,733
NS集合视图或更早的版本时


183
00:07:47,234 --> 00:07:49,536
您会设置您的
集合视图的内容


184
00:07:49,670 --> 00:07:51,171
以传递至阵列
或是阵列控制部件


185
00:07:51,238 --> 00:07:52,673
从而让您可以参考


186
00:07:52,873 --> 00:07:54,241
怎么设定您的项目


187
00:07:54,508 --> 00:07:56,009
和让您的项目
给予原型一个模范


188
00:07:56,109 --> 00:07:57,811
这就是NS集合视图的项目


189
00:07:57,878 --> 00:07:59,279
那是视图控制器的子类


190
00:07:59,346 --> 00:08:00,747
您基本上拥有一个
视图控制器


191
00:08:00,814 --> 00:08:02,850
和一个关联视图的子树


192
00:08:02,916 --> 00:08:05,719
这将增加到您的集合视图


193
00:08:06,386 --> 00:08:08,555
最后
您的集合视图也许会拥有一个委托


194
00:08:08,622 --> 00:08:10,190
如果您需要拖拽及放下的功能


195
00:08:10,290 --> 00:08:12,159
那就是这个委托的责任了


196
00:08:12,359 --> 00:08:14,161
因此您需要装置一个委托


197
00:08:15,562 --> 00:08:17,664
在全新的API中
将会有一些变动


198
00:08:17,731 --> 00:08:19,733
您不像往常般给予内容排列


199
00:08:20,334 --> 00:08:21,702
您现在需要做的


200
00:08:22,002 --> 00:08:24,271
是在El Capitan
安装一个数据源


201
00:08:24,471 --> 00:08:27,407
这个集合视图数据源的规程
其实很简单


202
00:08:27,474 --> 00:08:29,676
在iOS里只需要两个做法


203
00:08:29,810 --> 00:08:31,445
它将会是又快又简单的


204
00:08:31,612 --> 00:08:33,714
就像是您在集合视图里
装置您的模型一样


205
00:08:34,914 --> 00:08:36,549
您还是需要一个委托
就像之前一样


206
00:08:36,616 --> 00:08:38,818
但是现在的委托将有机会拥有


207
00:08:38,885 --> 00:08:41,321
参与选项和高亮度选择项目的功能


208
00:08:41,388 --> 00:08:42,890
我们等下会
详细地讨论这个话题


209
00:08:43,222 --> 00:08:44,825
现在您需要的是给出一个


210
00:08:45,125 --> 00:08:46,894
拥有的项目的nib文件


211
00:08:47,160 --> 00:08:49,329
而不是只有模范项目


212
00:08:49,396 --> 00:08:51,031
和一个联合视图的子树


213
00:08:51,265 --> 00:08:53,433
您没有局限于一个项目
像我所说过的


214
00:08:53,500 --> 00:08:54,968
您可以混搭任何类型的项目


215
00:08:55,035 --> 00:08:57,271
您可以拥有众多的nib文件
每种类型的项目里


216
00:08:57,604 --> 00:09:00,407
都可以选一个视图子树
可以跟这个完全不同


217
00:09:01,275 --> 00:09:03,243
最后一项最重要的是


218
00:09:03,744 --> 00:09:05,479
我们采取布局功能


219
00:09:05,712 --> 00:09:06,547
并把它分解


220
00:09:06,613 --> 00:09:08,749
好让集合视图不会再硬布线


221
00:09:08,815 --> 00:09:11,885
我们现在拥有像在iOS上的
模组化的模型


222
00:09:12,219 --> 00:09:14,288
所以您可以采取您原有的
集合视图


223
00:09:14,421 --> 00:09:16,757
分开原本链接住的布局


224
00:09:16,957 --> 00:09:18,292
再把不同的布局附上


225
00:09:18,358 --> 00:09:19,626
然而您的项目


226
00:09:19,760 --> 00:09:23,764
将以不同布局和大小摆列算法


227
00:09:23,964 --> 00:09:26,466
而这些布局是
可以被完全切换的


228
00:09:26,533 --> 00:09:28,669
您还可以在布局中


229
00:09:28,902 --> 00:09:31,972
以动画变迁的方式更换布局
十分简单


230
00:09:32,239 --> 00:09:33,440
就像我们的代码样本一样


231
00:09:34,975 --> 00:09:36,510
在自定式的布局里


232
00:09:36,577 --> 00:09:39,346
您的布局可以被委托于您的集合视图


233
00:09:39,413 --> 00:09:41,248
您可以实施
几个可以被调整的选项


234
00:09:41,381 --> 00:09:43,784
让您进行一对一的调整


235
00:09:43,851 --> 00:09:45,686
如果您需要自定义
改变您的布局的话


236
00:09:45,752 --> 00:09:47,387
您也没有必要拥有子类型


237
00:09:48,021 --> 00:09:49,723
让我们快速地
看看布局的类别


238
00:09:49,790 --> 00:09:52,259
在 iOS里 它们很相似
但并非一模一样


239
00:09:52,559 --> 00:09:54,561
在iOS里的
NS集合视图布局


240
00:09:54,628 --> 00:09:56,430
它是一个可以定义所有


241
00:09:56,496 --> 00:09:59,399
API平面布局普遍形式的
基本类别


242
00:10:00,434 --> 00:10:01,869
NS集合视图网格布局


243
00:10:01,935 --> 00:10:03,704
对OS X来说不但新颖且独特


244
00:10:03,837 --> 00:10:06,573
而且它的功能其实是
囊括了NS集合视图里


245
00:10:06,640 --> 00:10:09,776
本来的资料
就像是那种被调整的网格算法


246
00:10:09,943 --> 00:10:12,846
万一您需要用到全新的API


247
00:10:13,380 --> 00:10:15,182
它将被给予被调整的网格


248
00:10:15,249 --> 00:10:17,784
不但可以让所有的项目大小一致


249
00:10:18,018 --> 00:10:20,888
但是因为它们
是有大小限制的


250
00:10:20,954 --> 00:10:23,891
而且它们会将面积尽量填满


251
00:10:24,458 --> 00:10:25,592
有时候很有用处


252
00:10:25,659 --> 00:10:27,661
但终究还是个传统的布局


253
00:10:27,728 --> 00:10:30,430
它还没有开始支持分区
或标头及注脚视图的功能


254
00:10:30,764 --> 00:10:33,200
然而和流式布局相比
还是比较有弹性


255
00:10:33,967 --> 00:10:35,736
我们会建议您先运用流式布局


256
00:10:35,802 --> 00:10:38,372
在 iOS上
NS集合视图流式布局其实和


257
00:10:38,438 --> 00:10:40,908
UI集合视图流式布局...
比较相似


258
00:10:40,974 --> 00:10:42,976
它是一个强大的布局算法


259
00:10:44,044 --> 00:10:45,679
而这个算法更能让


260
00:10:45,846 --> 00:10:49,583
正文档案或CSS框达到流畅


261
00:10:49,650 --> 00:10:51,518
您可能有面对过这些问题


262
00:10:51,585 --> 00:10:53,921
总体来说
您可以有不同大小的项目


263
00:10:54,121 --> 00:10:56,523
而布局算法可以把它处理好


264
00:10:56,690 --> 00:10:59,059
根据您所给的校准


265
00:10:59,126 --> 00:11:01,395
它会把它们以横竖分配排列好


266
00:11:02,129 --> 00:11:03,630
当它被横竖地分配好后


267
00:11:03,697 --> 00:11:05,732
它将会被更新
然后继续下一个任务


268
00:11:06,333 --> 00:11:07,434
流式布局支持


269
00:11:07,634 --> 00:11:09,770
有附加标题的分区
和注脚视图的功能


270
00:11:10,003 --> 00:11:11,338
概括来说它是很有用的


271
00:11:11,405 --> 00:11:13,740
而且是可自定义的
如果您需要子类处理的话


272
00:11:15,042 --> 00:11:16,543
通常您会在流式布局开始


273
00:11:16,610 --> 00:11:18,378
接着通过子类处理
去得到您想要的


274
00:11:18,445 --> 00:11:19,279
然而


275
00:11:19,346 --> 00:11:22,115
您始终可以自地在
NS集合视图布局里做子类


276
00:11:22,649 --> 00:11:24,284
去得到一个完全自定义的设计


277
00:11:24,351 --> 00:11:26,587
我们今天的代码例子
将会做出演示


278
00:11:28,388 --> 00:11:32,092
布局属性对象
如果您是第一次看到它们


279
00:11:32,159 --> 00:11:34,127
不是直接就能领会的


280
00:11:34,194 --> 00:11:36,964
这是一个概念
和iOS一样的概念


281
00:11:37,197 --> 00:11:39,466
一旦您明白了它是什么
一切就都非常简单了


282
00:11:40,267 --> 00:11:41,602
想象您可以用


283
00:11:41,869 --> 00:11:42,936
视图结构


284
00:11:43,237 --> 00:11:44,805
还有其它各种各样的属性


285
00:11:44,872 --> 00:11:47,207
然后它们从视图中封装开来


286
00:11:47,274 --> 00:11:49,776
这就是布局属性的用处


287
00:11:49,843 --> 00:11:51,979
这是一个直接的...
结构例子


288
00:11:52,045 --> 00:11:53,447
这个很直白 对吗？


289
00:11:53,514 --> 00:11:56,483
您需要知道一个项目的位置和大小


290
00:11:56,750 --> 00:11:59,453
但是它还带有其它附属的性质
例如Alpha值


291
00:11:59,520 --> 00:12:00,621iddle
透明度


292
00:11:59,520 --> 00:12:00,621
透明度


293
00:12:00,821 --> 00:12:03,190
即Zindex
用于从后到前排列


294
00:12:03,991 --> 00:12:05,459
不管视图是否被隐藏


295
00:12:05,526 --> 00:12:07,461
它可以称为布局状态


296
00:12:07,528 --> 00:12:09,429
当您在使用状态
并且给它拍快照时


297
00:12:09,630 --> 00:12:10,664
这会让...


298
00:12:10,898 --> 00:12:13,667
新的API导出那些还没有


299
00:12:13,901 --> 00:12:15,702
实例化的项目


300
00:12:15,769 --> 00:12:18,438
记住
我们只是依赖程序去实例化


301
00:12:19,039 --> 00:12:21,608
最终我们创造并分享了


302
00:12:21,675 --> 00:12:23,076
这些布局属性的实例


303
00:12:23,277 --> 00:12:26,380
布局API就负责把它们传播开来


304
00:12:26,547 --> 00:12:29,016
最后他们会被应用到项目中


305
00:12:29,082 --> 00:12:30,250
或者在布局时间的视图中


306
00:12:30,384 --> 00:12:31,318
应用是为了


307
00:12:31,451 --> 00:12:33,287
获得一个动画对象


308
00:12:33,353 --> 00:12:35,055
然后过渡去一个新的境界


309
00:12:35,422 --> 00:12:36,490
这就是它们的用途了


310
00:12:38,792 --> 00:12:41,028
是非常简单地去归类项目


311
00:12:41,094 --> 00:12:43,130
您现在可以试着去归类


312
00:12:43,330 --> 00:12:45,098
每个组可以有...


313
00:12:45,465 --> 00:12:46,300
标题


314
00:12:46,567 --> 00:12:47,401
在上面


315
00:12:47,467 --> 00:12:48,335
和一个页脚在下面


316
00:12:48,435 --> 00:12:49,736
您也可以把它们放在旁边


317
00:12:49,803 --> 00:12:51,438
如果您从这个方向去做


318
00:12:52,239 --> 00:12:54,575
标题
页脚和项目一起


319
00:12:54,641 --> 00:12:56,109
组合成一个部分


320
00:12:56,176 --> 00:12:58,078
第一个部分是
部分0


321
00:12:58,378 --> 00:13:01,815
这个部分里面的项目
被标记为0, 1, 2...


322
00:13:02,516 --> 00:13:04,384
这和iOS是一样的


323
00:13:04,551 --> 00:13:06,520
下一个部分有标题和页脚


324
00:13:06,920 --> 00:13:09,122
和项目放在一起
这是部分1


325
00:13:09,189 --> 00:13:11,458
在里面的项目也是被标记为


326
00:13:11,592 --> 00:13:13,794
从0开始1, 2... 数字


327
00:13:14,528 --> 00:13:17,664
很明显
我们需要帮项目改名


328
00:13:17,731 --> 00:13:19,933
先开始修改项目
就像在iOS里一样


329
00:13:20,000 --> 00:13:21,835
我们不止是需要知道项目索引


330
00:13:22,169 --> 00:13:23,370
还要知道部门索引


331
00:13:23,737 --> 00:13:26,106
这将影响现存的API


332
00:13:26,173 --> 00:13:28,842
您会看到很多API
因此发生改变


333
00:13:29,343 --> 00:13:31,245
以Item AtIndex方法为例


334
00:13:31,311 --> 00:13:33,514
它原来仅需要单个整数索引


335
00:13:33,580 --> 00:13:34,848
但现在这么做还不够


336
00:13:35,182 --> 00:13:36,250
我们还需要部分


337
00:13:36,316 --> 00:13:37,751
我们还需要知道部分索引号


338
00:13:38,185 --> 00:13:41,321
所以现在这样的API
随我们喜好被修改


339
00:13:41,388 --> 00:13:42,723
以便适应新的参数


340
00:13:43,156 --> 00:13:44,324
NS索引路径


341
00:13:44,491 --> 00:13:45,959
只是一个现存的值形


342
00:13:46,026 --> 00:13:48,095
它让我们可以非常方便地


343
00:13:48,228 --> 00:13:49,363
封装一个部分索引号


344
00:13:49,429 --> 00:13:52,299
以及一个项目索引号
它们被一起封装在一个值对象内


345
00:13:52,499 --> 00:13:54,935
我们可以把它传递给
一个集合或其它


346
00:13:55,169 --> 00:13:57,704
很多您将遇到的API变化


347
00:13:57,771 --> 00:13:59,373
都属于这种情况


348
00:13:59,439 --> 00:14:01,108
仅仅是为了适应多个索引的变化


349
00:14:01,408 --> 00:14:03,177
您仍可使用原来的API


350
00:14:03,410 --> 00:14:05,512
如果您的集合视图
只有一个部分


351
00:14:05,579 --> 00:14:06,480
这是默认的情况


352
00:14:06,813 --> 00:14:08,549
但如果您应用多个部分


353
00:14:08,815 --> 00:14:10,484
我们建议您使用新的API


354
00:14:12,686 --> 00:14:14,488
显然我们要开始进入细节内容了


355
00:14:14,555 --> 00:14:16,089
我们将深入细节


356
00:14:16,423 --> 00:14:18,559
并深入研读我们的示例代码


357
00:14:18,625 --> 00:14:20,827
今天的示例是
Cocoa幻灯片集合


358
00:14:20,894 --> 00:14:22,496
它基本上是一个图像浏览器


359
00:14:22,663 --> 00:14:23,897
它用一个集合视图


360
00:14:24,097 --> 00:14:26,533
来展现一个图像文件的文件夹


361
00:14:26,800 --> 00:14:27,634
以便您浏览


362
00:14:29,069 --> 00:14:30,537
对于文件夹里的每个图像


363
00:14:30,604 --> 00:14:31,905
我们将展示它的缩略图


364
00:14:31,972 --> 00:14:34,208
和图像的各种信息


365
00:14:36,510 --> 00:14:39,079
在布局上我们应用流水布局


366
00:14:39,146 --> 00:14:40,714
这是系统自带的布局


367
00:14:40,781 --> 00:14:43,083
并且我们将使用个性化的布局
来展示如何应用它


368
00:14:45,185 --> 00:14:46,220
我们认为


369
00:14:46,286 --> 00:14:49,022
我们的每个图像
都有一个关联的标签


370
00:14:49,089 --> 00:14:50,224
我们将以此为由


371
00:14:50,290 --> 00:14:53,227
来展示如何实现
具有页眉和页脚的部分


372
00:14:53,293 --> 00:14:55,495
我们能够根据
每个项目的标签来分组


373
00:14:57,731 --> 00:14:59,199
我们还支持选择


374
00:14:59,366 --> 00:15:01,368
拖动和放下项目


375
00:15:01,635 --> 00:15:03,837
我们将应用今天讨论的API
来实现这些功能


376
00:15:04,605 --> 00:15:07,741
为了把内容分成多个组成部分
我们要把内容分为六个部分


377
00:15:08,141 --> 00:15:09,543
以便一步一步演示


378
00:15:09,610 --> 00:15:12,646
首先我们当然要把项目显示出来
这总是好的


379
00:15:12,713 --> 00:15:13,714
这是一个很大的障碍


380
00:15:13,780 --> 00:15:15,015
只要您能显示出东西


381
00:15:15,082 --> 00:15:17,184
您就可以实现更高级的功能
我们将快速实现


382
00:15:17,818 --> 00:15:20,187
然后我们看看如何把项目分组
放到各个部分里


383
00:15:20,921 --> 00:15:22,923
然后我们想看看如何处理它


384
00:15:22,990 --> 00:15:25,559
当模型发生变化时
图像也会相应增加或减少


385
00:15:25,626 --> 00:15:27,027
我们应如何更新
集合视图呢


386
00:15:27,094 --> 00:15:28,462
我们看看如何正确实施


387
00:15:28,862 --> 00:15:31,798
我们先看看如何处理部分
并重点看看


388
00:15:32,099 --> 00:15:33,233
如何处理拖放的程序代码


389
00:15:33,300 --> 00:15:35,035
最后非常有趣的是


390
00:15:35,102 --> 00:15:37,337
我们将看看
如何实现个性化的布局


391
00:15:37,971 --> 00:15:39,473
首先 为了显示项目


392
00:15:39,706 --> 00:15:41,074
先要回到我们的这个模型


393
00:15:41,141 --> 00:15:42,409
这又是一个新的API


394
00:15:42,910 --> 00:15:44,478
我们还需要提供一个数据源


395
00:15:44,611 --> 00:15:46,547
它将实现那两个必须实现的功能


396
00:15:47,347 --> 00:15:49,149
我们需要提供一个项目尖


397
00:15:49,449 --> 00:15:51,919
这足够简单
然后是一个集合视图布局


398
00:15:53,120 --> 00:15:54,454
这两个必需的方法


399
00:15:54,521 --> 00:15:57,357
将赋予集合视图了解此部分...


400
00:15:57,758 --> 00:16:00,594
有多少个项目的能力
默认条件下我们只有一个部分


401
00:16:00,661 --> 00:16:02,396
我们将只传递一个0
作为部分的索引值


402
00:16:02,462 --> 00:16:03,697
它将返回项目的数量


403
00:16:04,231 --> 00:16:06,300
第二个方法的任务是


404
00:16:06,366 --> 00:16:07,334
把项目


405
00:16:07,835 --> 00:16:09,036
初始化


406
00:16:09,102 --> 00:16:10,337
或者它将...


407
00:16:10,537 --> 00:16:12,472
直接利用回收的项目


408
00:16:12,739 --> 00:16:14,341
通过集合视图幕后的支持


409
00:16:14,408 --> 00:16:15,809
并把它们返回到集合视图


410
00:16:17,644 --> 00:16:19,279
在Cocoa幻灯片集合当中


411
00:16:19,413 --> 00:16:22,082
我们需要理解的
基本对象是图像文件


412
00:16:22,783 --> 00:16:25,686
一个图像文件对象本质上
是关联一个图像文件的URL


413
00:16:25,819 --> 00:16:28,522
这个图像文件存在于
我们扫描的硬盘里的文件夹中


414
00:16:28,589 --> 00:16:31,258
它包含的信息有文件名
显示于幻灯片的顶端


415
00:16:32,125 --> 00:16:32,960
文件的类型


416
00:16:33,026 --> 00:16:35,796
我们将以用户
可阅读的描述方式


417
00:16:36,096 --> 00:16:38,131
来显示原始图像的尺寸


418
00:16:39,066 --> 00:16:40,701
然后当然是缩略图


419
00:16:42,336 --> 00:16:43,537
您将在代码中


420
00:16:43,904 --> 00:16:45,005
看到它们


421
00:16:45,305 --> 00:16:48,075
一个图像集合
拥有一个图像文件数组


422
00:16:48,141 --> 00:16:51,311
一个图像集合
还拥有一个标签数组


423
00:16:51,378 --> 00:16:53,413
每个标签数组拥有一组图像


424
00:16:53,480 --> 00:16:54,581
这些图像有同一个标签


425
00:16:54,882 --> 00:16:57,117
还有一个无标签的
图像文件数组同时存在


426
00:16:58,118 --> 00:17:00,120
我们先来看看如何显示项目


427
00:17:00,187 --> 00:17:01,655
我们到这台演示机器这儿来看看


428
00:17:02,623 --> 00:17:03,790
让我们先运行它


429
00:17:05,392 --> 00:17:07,027
让我们先打开
一个Xcode项目


430
00:17:10,696 --> 00:17:12,766
正如您所知道的
东西已经基本齐全了


431
00:17:12,833 --> 00:17:14,501
但我们窗口还没有集合视图


432
00:17:14,568 --> 00:17:15,569
这是一个问题


433
00:17:15,636 --> 00:17:17,771
我们看看...
如何获得一个集合视图


434
00:17:19,806 --> 00:17:21,241
进入这个...


435
00:17:21,909 --> 00:17:22,976
资源类型


436
00:17:23,042 --> 00:17:26,012
我们有一个浏览器窗口nib
它关联着主窗口


437
00:17:27,079 --> 00:17:28,147
让我们看看这个


438
00:17:29,449 --> 00:17:30,918
我们进入这个库


439
00:17:33,687 --> 00:17:35,355
然后查找集合视图


440
00:17:37,157 --> 00:17:38,091
我们把它拖出来


441
00:17:42,529 --> 00:17:44,331
我们调整它的尺寸
使填满我们的窗口


442
00:17:45,832 --> 00:17:46,967
对它运用约束


443
00:17:47,167 --> 00:17:49,403
这将成为窗口内的主体文件视图


444
00:17:53,473 --> 00:17:54,308
好


445
00:17:55,075 --> 00:17:57,110
当我们拖出一个集合视图的时候


446
00:17:57,177 --> 00:17:58,612
我们实际得到了什么呢


447
00:17:58,679 --> 00:18:00,547
这很像是一个表视图


448
00:18:00,747 --> 00:18:02,449
或一个轮廓视图


449
00:18:02,816 --> 00:18:04,351
您实际上得到了一个
集合视图


450
00:18:04,418 --> 00:18:06,453
它内嵌在一个滚动视图里
不像在iOS里


451
00:18:06,653 --> 00:18:08,388
滚动视图是一个分离的东西


452
00:18:08,622 --> 00:18:11,024
它是一个可滚动的
文件视图的组成部分


453
00:18:11,091 --> 00:18:12,526
您不能继承滚动行为


454
00:18:12,593 --> 00:18:13,794
它通过组合来实现


455
00:18:14,895 --> 00:18:16,997
我们有一个滚动视图 我说过


456
00:18:17,297 --> 00:18:19,433
新的集合视图是用于
底层运行的


457
00:18:19,499 --> 00:18:21,502
我们将进入我们的检视器


458
00:18:22,069 --> 00:18:25,138
然后我们在滚动视图上
设置一曾的属性


459
00:18:25,205 --> 00:18:26,473
来确定图层置底


460
00:18:27,040 --> 00:18:29,576
现在我们深入看看集合视图本身


461
00:18:29,643 --> 00:18:31,378
它是滚动视图的文件视图


462
00:18:32,312 --> 00:18:34,948
在Xcode 7里有一个
新的属性检视面板


463
00:18:35,015 --> 00:18:36,617
它支持一些新的功能


464
00:18:36,683 --> 00:18:39,386
我们选择一个我们希望
使用的布局 例如流动


465
00:18:39,453 --> 00:18:40,921
同时我们甚至可以
设置它的属性


466
00:18:41,121 --> 00:18:42,189
在这个示例程序中


467
00:18:42,256 --> 00:18:44,391
我们实际上将有规划地
在不同的布局之间切换


468
00:18:44,458 --> 00:18:46,560
因此我们不需要用
我们从nib中反归档的那个


469
00:18:46,960 --> 00:18:48,262
但我们仍可以设置它


470
00:18:48,495 --> 00:18:49,496
您可以...


471
00:18:49,930 --> 00:18:52,199
做一些简单而有趣的东西
例如设置背景颜色


472
00:18:52,399 --> 00:18:54,101
一旦我找到了颜色面板


473
00:18:59,540 --> 00:19:00,440e
更有趣的事情是


474
00:18:59,540 --> 00:19:00,440
更有趣的事情是


475
00:19:00,507 --> 00:19:02,142
您将关联那个数据源
是吗


476
00:19:02,943 --> 00:19:05,913
在此项目中我们的文件拥有者
是一个对象实例


477
00:19:06,780 --> 00:19:10,617
它是API浏览器
窗口控制器的实例


478
00:19:10,684 --> 00:19:12,386
我们通过一个窗口控制器
来管理窗口


479
00:19:12,452 --> 00:19:13,787
它也将成为我们的数据源


480
00:19:13,854 --> 00:19:15,489
和集合视图的委托


481
00:19:15,822 --> 00:19:17,124
我们从集合视图


482
00:19:17,824 --> 00:19:19,960
关联到文件的拥有者


483
00:19:20,027 --> 00:19:21,695
它将成为集合视图的数据源


484
00:19:22,095 --> 00:19:24,598
它也是它的委托
这样我们就可以实现拖放


485
00:19:25,065 --> 00:19:27,734
我们把文件拥有者关联回
集合视图


486
00:19:28,001 --> 00:19:30,037
我们已定义了一个
图像集合视图的出口


487
00:19:30,103 --> 00:19:32,172
以便更容易找到
集合视图


488
00:19:33,473 --> 00:19:36,510
这就是我们基本上
要对尖端做的事情


489
00:19:37,077 --> 00:19:39,313
我们还创建了一个滑动尖端


490
00:19:40,881 --> 00:19:42,916
它拥有一个容器视图


491
00:19:42,983 --> 00:19:44,885
这个容器被一个滑块引用


492
00:19:45,219 --> 00:19:47,387
我们的滑块类是集合的一个子类


493
00:19:47,454 --> 00:19:49,122
NS集合视图项目类


494
00:19:49,189 --> 00:19:50,757
通过这个子类我们可以添加功能


495
00:19:51,091 --> 00:19:53,727
为我们自己的个性化
控制器增加功能


496
00:19:54,228 --> 00:19:55,729
根视图只是一个容器


497
00:19:55,796 --> 00:19:59,099
这个容器的尺寸
由集合视图的布局规则决定


498
00:19:59,466 --> 00:20:00,701
然后 我们有控制器


499
00:20:00,767 --> 00:20:02,336
文字字段...


500
00:20:04,371 --> 00:20:06,440
有自动布局约束来设置它们


501
00:20:06,507 --> 00:20:07,641
这与它们的容器相关


502
00:20:07,708 --> 00:20:09,610
此布局将设置项目的框架


503
00:20:09,676 --> 00:20:11,111
及此项目的根视图


504
00:20:11,245 --> 00:20:13,814
余下的将由内置的
自动布局来完成


505
00:20:14,882 --> 00:20:16,450
我还使用了绑定


506
00:20:16,517 --> 00:20:17,351
来...


507
00:20:17,851 --> 00:20:18,685
连接...


508
00:20:19,019 --> 00:20:20,187
一些数值


509
00:20:20,254 --> 00:20:22,055
它们由这些文字域显示


510
00:20:22,322 --> 00:20:23,757
他们通过滑块对象...


511
00:20:24,124 --> 00:20:25,125
来显示


512
00:20:25,192 --> 00:20:27,828
请记住一个滑块是
一个集合视图项目


513
00:20:28,028 --> 00:20:29,229
因此它也是一个
视图控制器


514
00:20:29,296 --> 00:20:30,831
视图控制器有一个
可显示的对象


515
00:20:30,898 --> 00:20:32,900
这里是我们连接项目的地方


516
00:20:33,100 --> 00:20:34,735
连接它所显示的模型对象


517
00:20:34,801 --> 00:20:36,336
对图像文件实例而言


518
00:20:36,637 --> 00:20:38,639
我们可以读到这个实例的属性


519
00:20:38,906 --> 00:20:41,074
我们只需要把我们的项目


520
00:20:41,141 --> 00:20:42,743
关联到显示的对象


521
00:20:42,943 --> 00:20:44,611
即它的图像文件随即所有的


522
00:20:44,678 --> 00:20:46,313
这些控制器将自动显示


523
00:20:46,380 --> 00:20:47,981
包括图像视图


524
00:20:48,682 --> 00:20:51,451
因为我们将为新的API


525
00:20:51,618 --> 00:20:53,954
使用一个独立的nib文件


526
00:20:54,188 --> 00:20:56,023
为了使用集合视图
我们要删除一些东西


527
00:20:56,089 --> 00:20:58,525
这些东西是Xcode
默认放进来的


528
00:20:58,825 --> 00:21:01,628
我们的图像集合视图
仍然有一个项目样品


529
00:21:02,529 --> 00:21:03,497
我们需要清除它


530
00:21:03,564 --> 00:21:04,631
让我们分离它


531
00:21:05,632 --> 00:21:07,234
否则这将干扰
我们正在做的事情


532
00:21:07,467 --> 00:21:08,802
我们要删除项目样品


533
00:21:08,869 --> 00:21:10,671
我们还要删除与之关联的视图


534
00:21:10,737 --> 00:21:11,605
我们不需要这些


535
00:21:12,005 --> 00:21:14,107
我们可以编译了
差不多好了


536
00:21:14,641 --> 00:21:16,577
如果我们看看这个警告
我们发现一个提示


537
00:21:16,643 --> 00:21:19,513
我们没有应用必需的
数据源方法


538
00:21:19,580 --> 00:21:21,648
只有两个
我们很快地完成


539
00:21:22,649 --> 00:21:24,318
我们进入浏览器窗口控制器


540
00:21:26,787 --> 00:21:28,856
看这里就是数据源方法
所在的地方


541
00:21:28,922 --> 00:21:30,958
幸亏我提前标注了


542
00:21:33,727 --> 00:21:34,895
我们把它拖进来


543
00:21:40,000 --> 00:21:41,935
对于非部分的集合视图
这非常简单


544
00:21:42,002 --> 00:21:43,303
我们实施集合视图


545
00:21:43,370 --> 00:21:44,738
定义这个部分里的项目数量


546
00:21:44,805 --> 00:21:46,907
集合视图
默认只有一个部分


547
00:21:47,074 --> 00:21:48,942
我们返回图像文件的数量


548
00:21:49,142 --> 00:21:50,344
它们在我们的图像集合内


549
00:21:50,878 --> 00:21:52,179
我们还需要做的事情是


550
00:21:52,246 --> 00:21:53,447
按需求定义这些东西


551
00:21:53,514 --> 00:21:55,749
集合视图将传递
集合视图项目


552
00:21:55,816 --> 00:21:57,551
对于代表对象和索引路径


553
00:21:58,218 --> 00:21:59,520
一个需要澄清的重要事情是


554
00:21:59,586 --> 00:22:00,821
当我们使用集合视图时


555
00:22:00,888 --> 00:22:02,422
也试图根据标示符号
来构造项目


556
00:22:02,489 --> 00:22:04,625
这令人费解
实际上我们只是想


557
00:22:04,691 --> 00:22:06,927
构造或循环使用现存的索引路径


558
00:22:07,828 --> 00:22:10,731
我们只是把得到的
索引路径传入


559
00:22:10,797 --> 00:22:11,999
但它标识了这个项目


560
00:22:12,866 --> 00:22:15,569
正如我所说的
我们想关联代表对象的项目


561
00:22:15,636 --> 00:22:17,504
以便找到相应的属性


562
00:22:17,571 --> 00:22:19,106
针对这个项目实例


563
00:22:19,506 --> 00:22:21,375
我们这里有...
一个小方法


564
00:22:21,441 --> 00:22:23,277
可以分解出索引目录
和图像文件


565
00:22:23,343 --> 00:22:24,444
使我们得以非常容易地


566
00:22:24,511 --> 00:22:25,646
深入我们的数据模型


567
00:22:25,712 --> 00:22:27,314
并找出相应的...


568
00:22:27,548 --> 00:22:28,882
那个图像文件实例


569
00:22:29,316 --> 00:22:31,351
这就是我们需要做的
只需要返回该项目


570
00:22:31,451 --> 00:22:32,352
到集合视图


571
00:22:33,086 --> 00:22:35,489
如果我们足够勇敢
我们可以试试编译并运行


572
00:22:35,556 --> 00:22:36,823
看看它是否可以运行了


573
00:22:37,257 --> 00:22:39,193
然后 我们将看到
就是这个


574
00:22:39,259 --> 00:22:40,928
默认条件下我们有一个窗口


575
00:22:40,994 --> 00:22:43,830
指向并扫描库
桌面 图片里的文件


576
00:22:44,765 --> 00:22:46,033
它查找图像文件


577
00:22:46,099 --> 00:22:47,868
并把通过集合视图项目
来呈现它们


578
00:22:47,935 --> 00:22:50,537
当我们滚动时
那些移出视图范围以外的项目


579
00:22:50,604 --> 00:22:52,506
实际上将按需要被初始化


580
00:22:52,573 --> 00:22:56,243
甚至从那些从顶端移开的
项目处回收重用


581
00:22:57,010 --> 00:22:59,546
您可以改变大小
使布局重构


582
00:23:00,480 --> 00:23:02,416
然后我们可以免费获得很多东西


583
00:23:02,482 --> 00:23:04,518
在此
我把它称为包围布局


584
00:23:04,618 --> 00:23:07,120
这是流式布局的
一个简单的子类


585
00:23:07,521 --> 00:23:09,990
我们还有一些
已经实现了的个性化布局


586
00:23:11,258 --> 00:23:12,960
我们可以设置布局...
这些已经实现


587
00:23:13,026 --> 00:23:14,928
通过导入一个不同的布局对象


588
00:23:15,195 --> 00:23:16,496
到集合视图


589
00:23:17,764 --> 00:23:19,800
我们可以通过标签来分类


590
00:23:20,567 --> 00:23:21,702
但这还没有真正做什么


591
00:23:21,768 --> 00:23:23,704
让我们回到幻灯片


592
00:23:23,770 --> 00:23:26,406
看看需要做些什么来实现它


593
00:23:30,210 --> 00:23:31,044
谢谢


594
00:23:33,814 --> 00:23:35,916
开场的最佳办法是
运行第一个示例


595
00:23:37,017 --> 00:23:39,586
现在我们希望按照标签
给图像文件分类


596
00:23:39,653 --> 00:23:41,922
而不仅仅满足于在
一个部分中显示它们


597
00:23:41,989 --> 00:23:43,790
我们希望看到
哪个图与哪个标签有关系


598
00:23:45,092 --> 00:23:46,627
我们将要做的是每个标签


599
00:23:46,827 --> 00:23:48,729
都有一组图像文件


600
00:23:49,129 --> 00:23:51,265
它们按照某种规则排序


601
00:23:51,698 --> 00:23:53,233
我们希望按照这个顺序
显示它们


602
00:23:53,600 --> 00:23:55,502
一个图像文件可以有多个标签
这意味着


603
00:23:55,569 --> 00:23:57,504
我们将在多个部分
显示一个图像文件


604
00:23:57,571 --> 00:23:58,405
这完全没有问题


605
00:23:58,972 --> 00:24:02,042
也可能有些图像文件
不会在任何部分显示


606
00:24:02,409 --> 00:24:04,444
因此我们会创建
一个无标签的图像部分


607
00:24:04,511 --> 00:24:05,979
作为最后一个额外的部分


608
00:24:06,046 --> 00:24:07,948
在此我们显示
所有没有标签的图像文件


609
00:24:08,916 --> 00:24:11,385
我们为每个部分添加了
页头和页脚视图


610
00:24:11,451 --> 00:24:13,187
因为我们想演示我们可以这么做


611
00:24:13,720 --> 00:24:14,922
为您演示如何做到这一步


612
00:24:15,155 --> 00:24:17,191
与项目类型相似


613
00:24:17,558 --> 00:24:19,560
实例化页头视图和页脚视图


614
00:24:19,626 --> 00:24:21,028
您会发现这非常容易


615
00:24:22,829 --> 00:24:27,000
一般而言 一个页头或页脚
实际是由一个集合视图


616
00:24:27,067 --> 00:24:30,537
调用一个补充视图
它不代表一个项目


617
00:24:30,604 --> 00:24:32,072
但它是一种扩增


618
00:24:32,139 --> 00:24:33,841
或一种把项目括入括号的方式


619
00:24:33,907 --> 00:24:35,375
例如 标题和页脚


620
00:24:36,610 --> 00:24:39,580
我们要把数据源
设为可选集合视图


621
00:24:39,646 --> 00:24:41,748
补充元素的视图种类


622
00:24:41,815 --> 00:24:43,317
这是一种与众不同的方式


623
00:24:43,383 --> 00:24:44,418
通过索引路径来...


624
00:24:44,718 --> 00:24:45,919
调用页头和页脚


625
00:24:47,621 --> 00:24:49,256
我们将回到演示机器那里


626
00:24:52,759 --> 00:24:54,494
我们将把它们
很快地关联起来


627
00:24:56,296 --> 00:24:59,166
我们调用现成的数据源方法


628
00:25:00,801 --> 00:25:03,003
并用更成熟的方法
来代替它们


629
00:25:03,070 --> 00:25:04,705
这些方法更适用于
处理部分


630
00:25:06,940 --> 00:25:08,041
它们就在这儿


631
00:25:08,108 --> 00:25:09,476
我们将简要地解释一遍


632
00:25:10,010 --> 00:25:11,845
现在我们需要告诉集合视图


633
00:25:11,912 --> 00:25:13,514
有多少部分在它里面


634
00:25:14,381 --> 00:25:16,483
如果标签分组选项


635
00:25:16,550 --> 00:25:18,218
被选中这个属性
将被设为开启


636
00:25:18,352 --> 00:25:21,054
我们返回标签的数量


637
00:25:21,121 --> 00:25:22,122
在图像集合里


638
00:25:22,389 --> 00:25:23,590
这里加1
因为我们想要一个


639
00:25:23,657 --> 00:25:25,926
额外的无标签图像文件集合部分


640
00:25:26,226 --> 00:25:27,995
对不起
排在最后


641
00:25:29,096 --> 00:25:29,930
非常简单


642
00:25:30,931 --> 00:25:33,667
报告一个部分里面有多少个项目


643
00:25:33,800 --> 00:25:36,203
以下两种情况有些不同
如果我们以标签分组


644
00:25:36,503 --> 00:25:37,738
基本上我们想说


645
00:25:38,038 --> 00:25:40,574
如果某个部分
与集合内的某个标签有关系


646
00:25:40,641 --> 00:25:41,842
我们将返回这个数值


647
00:25:41,909 --> 00:25:43,143
即属于这个标签...


648
00:25:43,744 --> 00:25:44,745
的图像文件的数量


649
00:25:44,811 --> 00:25:45,879
它与该部分相关


650
00:25:46,580 --> 00:25:48,982
如果我们在无标签图像文件部分


651
00:25:49,049 --> 00:25:51,919
最后我们会返回
无标签图和其它图的数量


652
00:25:51,985 --> 00:25:53,220
这非常直白


653
00:25:58,759 --> 00:25:59,626
让我们看看它们


654
00:25:59,693 --> 00:26:01,128
对于对象索引路径


655
00:26:01,195 --> 00:26:03,830
这是同样的应用与以前一样
它之所以好用


656
00:26:03,897 --> 00:26:05,365
是因为我提取了


657
00:26:05,532 --> 00:26:07,935
图像文件索引路径... 方法


658
00:26:08,101 --> 00:26:09,069
这只是我个人使用的


659
00:26:10,103 --> 00:26:11,839
实际上这并不适用


660
00:26:11,905 --> 00:26:13,574
原因是它只看项目索引


661
00:26:13,941 --> 00:26:15,876
而不是部分索引


662
00:26:15,943 --> 00:26:17,978
让我们替换一个更聪明的版本


663
00:26:19,413 --> 00:26:21,315
它知道我们有时需要
通过标签来分类


664
00:26:27,888 --> 00:26:29,556
如果我们以标签分组


665
00:26:29,623 --> 00:26:32,593
假设此部分与我们的
其中一个标签相同


666
00:26:32,893 --> 00:26:36,797
我们就能在表里找到
属于这个标签的图像文件


667
00:26:36,864 --> 00:26:39,066
根据项目索引和部分索引


668
00:26:39,600 --> 00:26:42,169
它们告诉我们
哪个标签是我们正在处理的


669
00:26:43,070 --> 00:26:45,606
让我们试着...
建造并使之运行


670
00:26:47,407 --> 00:26:49,209
我们可以根据标签来分组


671
00:26:49,676 --> 00:26:52,212
现在我们已经根据
标签来分组了


672
00:26:53,113 --> 00:26:55,048
我拥有跟以前一样的...


673
00:26:55,716 --> 00:26:56,550
布局


674
00:26:56,950 --> 00:26:58,018
如果我们放大能看到


675
00:26:58,085 --> 00:26:58,919
这是...


676
00:26:58,986 --> 00:27:01,221
我们在一个nib里定义的
页首视图


677
00:27:01,288 --> 00:27:02,589
它基本上是一个容器


678
00:27:02,656 --> 00:27:04,091
它有浅灰色的背景


679
00:27:04,157 --> 00:27:06,460
并有一个可以让您
输入任何东西的文本框


680
00:27:06,527 --> 00:27:07,494
按照您的需要...


681
00:27:07,761 --> 00:27:08,795
在这里


682
00:27:08,862 --> 00:27:11,498
这是我们的页脚视图
这是一种更深的灰色


683
00:27:11,565 --> 00:27:12,399
告诉我们


684
00:27:12,566 --> 00:27:13,867
我们已经创建了一个文本框


685
00:27:13,934 --> 00:27:15,702
以告诉我们一个组里面
有多少个文件


686
00:27:16,303 --> 00:27:18,372
这就是所有应用部分所需要的东西


687
00:27:18,438 --> 00:27:21,008
这与iOS基本相同


688
00:27:21,341 --> 00:27:26,346
我省去的一方面
啊 我省去了两个方面


689
00:27:26,413 --> 00:27:29,950
就是创建附属视图页头和页脚


690
00:27:30,250 --> 00:27:31,351
这里有一点代码


691
00:27:31,418 --> 00:27:33,153
但这是平行的


692
00:27:33,387 --> 00:27:36,690
最重要的是我们是否能调用


693
00:27:36,757 --> 00:27:38,759
makeSupplementary
ElementView...


694
00:27:38,825 --> 00:27:40,861
makeSupplementary
ViewOfKind


695
00:27:40,928 --> 00:27:42,896
流式布局的种类定义的是


696
00:27:43,130 --> 00:27:44,231
部分页头


697
00:27:44,665 --> 00:27:45,499
和部分页脚


698
00:27:45,566 --> 00:27:46,867
它将是其中之一


699
00:27:47,201 --> 00:27:48,702
我们知道它是部分页头


700
00:27:48,936 --> 00:27:50,637
我们将参考页头nib


701
00:27:50,704 --> 00:27:52,372
我们将寻找页脚nib
如果这是页脚


702
00:27:52,539 --> 00:27:54,408
我们传入这个值作为标识


703
00:27:54,842 --> 00:27:57,144
一旦我们拥有了视图
我们就有了一个视图


704
00:27:57,211 --> 00:27:58,779
而不是一个视图控制器


705
00:28:00,214 --> 00:28:03,116
我们已找到并建立文本框的值


706
00:28:03,183 --> 00:28:05,853
做我们想做的任何事情
并把它返回给集合视图


707
00:28:06,286 --> 00:28:08,722
最后我们需要做的是
实现这些委托方法


708
00:28:08,789 --> 00:28:10,357
布局可以定


709
00:28:10,657 --> 00:28:12,092
最适合的尺寸


710
00:28:12,359 --> 00:28:14,094
基本是页头显示的高度


711
00:28:14,161 --> 00:28:16,096
以及页脚显示的高度


712
00:28:16,163 --> 00:28:18,232
我们在每个案例中都有NSI


713
00:28:18,932 --> 00:28:21,602
因为我们有一个
垂直滚动的流式布局


714
00:28:21,802 --> 00:28:24,004
只有高度很重要
宽度会被自动裁切为


715
00:28:24,071 --> 00:28:26,006
滚动视图的宽度


716
00:28:27,007 --> 00:28:28,575
为了页头和页脚可以显示


717
00:28:28,842 --> 00:28:30,344
我们必须这么做


718
00:28:31,545 --> 00:28:32,379
就是这样


719
00:28:34,214 --> 00:28:36,750
现在我们可以开始学习
当我们的模型改变了如何更新


720
00:28:37,084 --> 00:28:40,053
图像文件在文件夹里进进出出


721
00:28:40,220 --> 00:28:41,588
我们需要告诉集合视图


722
00:28:41,655 --> 00:28:42,756
何时我们的模型改变了


723
00:28:42,990 --> 00:28:44,858
以便更新对用户所显示的东西


724
00:28:46,159 --> 00:28:49,129
这与OS X的轮廓视图


725
00:28:49,530 --> 00:28:52,299
被处理的方式很相似


726
00:28:52,499 --> 00:28:54,968
基本上有四种运行模式


727
00:28:55,302 --> 00:28:56,603
项目可以被插入


728
00:28:56,670 --> 00:28:57,638
删除


729
00:28:57,971 --> 00:28:59,173
和移动


730
00:28:59,239 --> 00:29:00,374
从一个地方到另一个地方


731
00:29:00,440 --> 00:29:01,808
或者项目可以被重载


732
00:29:01,875 --> 00:29:03,510
这意味着项目还在那里


733
00:29:03,577 --> 00:29:06,547
但属性被改变了
您需要重新显示它


734
00:29:06,613 --> 00:29:07,714
您需要重新收集...


735
00:29:07,948 --> 00:29:08,782
属性信息


736
00:29:09,449 --> 00:29:12,619
这些运行模式可以应用于
部分和项目


737
00:29:12,686 --> 00:29:15,255
对于熟悉iOS的人来说
这是一样的


738
00:29:15,589 --> 00:29:18,959
也可以插入 删除
移动和重载部分


739
00:29:21,061 --> 00:29:23,530
就像我所说的
与基于视图的轮廓视图很相似


740
00:29:23,597 --> 00:29:26,133
这意味着任何时候
当模型发生改变


741
00:29:26,366 --> 00:29:29,203
您的数据源或您代码的其它部分


742
00:29:29,269 --> 00:29:30,704
凡是与模型有关的


743
00:29:30,904 --> 00:29:32,306
必须去通知集合视图


744
00:29:32,573 --> 00:29:35,008
并准确表述所发生的变化


745
00:29:35,075 --> 00:29:37,678
我在这些索引路径里
插入了项目


746
00:29:37,744 --> 00:29:39,646
我把这些项目移除


747
00:29:39,713 --> 00:29:42,049
以使它可以与模型同步


748
00:29:42,616 --> 00:29:44,184
只要您做对了
这非常简单


749
00:29:45,419 --> 00:29:48,188
默认条件下
任何您通知集合视图的变化


750
00:29:48,255 --> 00:29:51,291
将马上显示 但您可以很容易
显示一个动画化的改变


751
00:29:51,592 --> 00:29:53,727
通过集合视图的动画设计


752
00:29:53,794 --> 00:29:56,763
这是视图所拥有的
一个通用代理对象


753
00:29:56,830 --> 00:29:59,533
您可以通过它来实现一个动画化的更新


754
00:29:59,600 --> 00:30:01,869
通常情况下
当您要设置一个参数


755
00:30:02,102 --> 00:30:05,105
当它通知布局动画
那个项目已经被插入


756
00:30:05,372 --> 00:30:08,242
这就我们在示范中所做的
也正因为这样我们可以看见


757
00:30:08,308 --> 00:30:12,212
项目动来动去的画面
项目被插入 其他项目被迁出


758
00:30:12,513 --> 00:30:13,580
以一种栩栩如生的方式


759
00:30:13,981 --> 00:30:16,183
在我们Cocoa幻灯片
集合的示范里


760
00:30:16,383 --> 00:30:18,852
我们将看到影像文件夹的变化


761
00:30:19,620 --> 00:30:21,722
每当出现变化 我们都会通知...


762
00:30:21,788 --> 00:30:24,691
首先 我们立即更新模型
然后在我们改变模型后


763
00:30:24,758 --> 00:30:27,394
通知集合视图
我们对模型所做的改变


764
00:30:28,762 --> 00:30:31,064
图片档案可能会来来去去


765
00:30:31,932 --> 00:30:33,033
它们可能被我们改变了


766
00:30:33,166 --> 00:30:35,369
这些都是我们要
处理的更新类型


767
00:30:36,703 --> 00:30:38,172
我们要使用一个小的特性装置


768
00:30:38,238 --> 00:30:40,307
一个基础的特性装置
叫键值对观察


769
00:30:40,374 --> 00:30:43,777
基本上就是提供一个方法
去观察其它物件的特性


770
00:30:43,844 --> 00:30:45,812
然后自动给予通知


771
00:30:45,879 --> 00:30:48,549
这样您就可以知道
自己该用什么方法来应对


772
00:30:48,615 --> 00:30:50,817
我们的示范
从头到尾都是键值对观察


773
00:30:51,385 --> 00:30:53,887
让我们马上
回到我们的示范机器


774
00:30:54,521 --> 00:30:55,989
我已经让它开始运作


775
00:30:58,425 --> 00:31:01,295
我们先运作我们的范例
看看它可以做些什么


776
00:31:01,962 --> 00:31:04,398
我现在准备开启桌面上
度假图片的文件夹


777
00:31:05,332 --> 00:31:09,403
而不是看桌面的图片文件夹


778
00:31:11,972 --> 00:31:14,842
让我们假设我在度假时
拍了些照片


779
00:31:16,076 --> 00:31:17,177
去了些很棒的地方


780
00:31:17,511 --> 00:31:20,013
在底下我有一个
寻捡器窗口


781
00:31:20,514 --> 00:31:21,982
指向我的桌面照片


782
00:31:22,049 --> 00:31:23,717
我现在要从桌面照片中复制些材料


783
00:31:23,784 --> 00:31:25,118
假装我去过这些地方


784
00:31:26,820 --> 00:31:29,189
我会拖拽一些项目


785
00:31:29,890 --> 00:31:30,724
到文件夹中


786
00:31:31,325 --> 00:31:33,393
Cocoa幻灯片集合
正在监督这些档案


787
00:31:33,460 --> 00:31:34,828
它会发现当中的变化


788
00:31:35,662 --> 00:31:37,664
并在它的模型中加入


789
00:31:37,731 --> 00:31:39,266
项目和图片档案的例子


790
00:31:39,433 --> 00:31:41,368
最后它会通知集合视图


791
00:31:41,602 --> 00:31:44,271
现在图片档案已经添加
让我们显示更多的项目


792
00:31:44,338 --> 00:31:47,407
这种情况每次都
会在动画方式中同步发生


793
00:31:47,574 --> 00:31:49,042
我们可以拉出一个项目


794
00:31:49,443 --> 00:31:50,277
取出档案


795
00:31:50,444 --> 00:31:51,845
然后当它消失的时候


796
00:31:52,012 --> 00:31:53,981
做一个更新的文件系统
扫描时要注意变化


797
00:31:54,047 --> 00:31:55,549
更新我们的模型
和相应的更新


798
00:31:55,616 --> 00:31:56,884
集合视图


799
00:31:57,951 --> 00:32:00,521
这里的键值对观察技术
已经相当不错了


800
00:32:00,587 --> 00:32:01,688
使用运行轧机


801
00:32:01,889 --> 00:32:04,391
最有趣的地方是您如何和
集合视图对话


802
00:32:04,992 --> 00:32:07,194
那么我们省略早前的
只看最近的


803
00:32:08,195 --> 00:32:10,130
您想看看这些
在窗口控制器类底层的方法


804
00:32:10,197 --> 00:32:11,732
处理插入的图片档案


805
00:32:12,232 --> 00:32:15,302
在指数的路径
这只是一些我们定义给自己用的


806
00:32:15,369 --> 00:32:18,038
还有这里是我们和图片集合视图
对话的地方


807
00:32:18,372 --> 00:32:20,340
并用这些插入项目


808
00:32:20,407 --> 00:32:23,377
在指数路径 API上
我们基本上要做的就是弄清楚


809
00:32:23,443 --> 00:32:24,845
好的
到底什么项目的指数路径


810
00:32:24,912 --> 00:32:25,879
会受到这个的影响？


811
00:32:25,946 --> 00:32:27,080
哪里我们可以插入项目？


812
00:32:27,347 --> 00:32:29,049
我们传递消息给
集合视图


813
00:32:29,116 --> 00:32:31,518
由于我们透过动画制作者通讯
我们会收到动画的变化


814
00:32:31,585 --> 00:32:33,153
其中重新布局是
需要发生的


815
00:32:33,453 --> 00:32:35,789
它会以平滑的方式出现
并非一瞬间


816
00:32:35,956 --> 00:32:38,392
如果您想 也可以让它即时发生
可以省略这里


817
00:32:38,659 --> 00:32:39,493
如果您想


818
00:32:39,560 --> 00:32:41,695
要一个动画的回应
和动画制作者的通讯


819
00:32:42,062 --> 00:32:43,597
您甚至可以控制持续的时间


820
00:32:43,664 --> 00:32:45,966
只要设定动画内容的
持续时间便可


821
00:32:47,367 --> 00:32:49,069
设定成和图片档案运转
速度差不多


822
00:32:49,136 --> 00:32:51,672
deleteItemsAt
IndexPaths


823
00:32:53,340 --> 00:32:56,677
这样就会有分类档案
有插入部分 删除的部分


824
00:32:56,743 --> 00:32:57,744
还有其他关于API的


825
00:32:57,811 --> 00:32:59,446
为了要处理
各个分类档案的来来去去


826
00:32:59.513 --> 00:33:00.547 align:middle
我们甚至有能力去


827
00:32:59,513 --> 00:33:00,547
我们甚至有能力去


828
00:33:00,781 --> 00:33:01,882
处理新添加的标签


829
00:33:01,949 --> 00:33:03,050
还有被移除的标签


830
00:33:04,718 --> 00:33:06,053
这大概就是这么一回事


831
00:33:09,456 --> 00:33:12,292
所以分类和高亮显示
在要与用户交流时是重要的


832
00:33:12,359 --> 00:33:13,827
我们现在来更加仔细地分析它们


833
00:33:15,362 --> 00:33:17,297
基本上分类和高亮显示都是


834
00:33:17,364 --> 00:33:18,866
可以在视觉上有指示标准的


835
00:33:19,132 --> 00:33:21,935
特別是高亮显示
其实是一种过渡的状态


836
00:33:22,002 --> 00:33:25,439
在途中令项目有可能成为
被选择的或不被选择的


837
00:33:25,672 --> 00:33:27,140
或用作放置目标


838
00:33:29,510 --> 00:33:31,712
在这里有一个图示
我们有一个项目


839
00:33:31,778 --> 00:33:33,547
那里短暂地显示橙色
当我不断拉过它们


840
00:33:33,614 --> 00:33:35,916
它们就是分类的候选人


841
00:33:35,983 --> 00:33:37,651
当它们确定被选择
而不是高亮显示


842
00:33:37,918 --> 00:33:39,152
我们可以从橙色边框
来判断


843
00:33:39,419 --> 00:33:41,655
但是之后它们会变
成蓝色


844
00:33:44,725 --> 00:33:47,394
就是说 OS X 是有
高亮显示的项目的


845
00:33:47,461 --> 00:33:48,896
这里和iOS是有点分别的


846
00:33:48,962 --> 00:33:50,731
这里只有布尔数学的
高亮显示功能


847
00:33:50,964 --> 00:33:53,267
在桌面上我们需要更多的灵活性


848
00:33:53,333 --> 00:33:55,235
从而能够形容不同的状态


849
00:33:55,602 --> 00:33:57,070
高亮显示


850
00:33:58,672 --> 00:34:00,340
有四种可能存在的价值


851
00:34:00,941 --> 00:34:04,211
没有系统默认值
意思就是不要高亮突出这些项目


852
00:34:04,311 --> 00:34:06,346
您会想知道这些项目
被选择了没


853
00:34:06,413 --> 00:34:07,915
然后决定如何呈现它们


854
00:34:08,581 --> 00:34:09,983
如果它没有被选择或突出


855
00:34:10,217 --> 00:34:11,251
您会正常地显示它


856
00:34:12,485 --> 00:34:14,288
如果项目是被高亮显示的


857
00:34:14,353 --> 00:34:16,089
这意味它现在并没有被选择


858
00:34:16,156 --> 00:34:18,158
但是我们在考虑
要不要选择它


859
00:34:18,225 --> 00:34:20,694
这要看使用者想要有什么用途
比如 拉过项目


860
00:34:20,994 --> 00:34:22,728
然后您想把它透过


861
00:34:22,795 --> 00:34:25,199
高亮指示来呈现
这完全是根据


862
00:34:25,331 --> 00:34:27,501
您想怎样来设计您的UI


863
00:34:27,568 --> 00:34:29,069
我们用橙色门框


864
00:34:29,136 --> 00:34:30,904
围绕边边来显示


865
00:34:30,971 --> 00:34:32,572
将被选择
可还没有被选择


866
00:34:33,841 --> 00:34:36,610
项目可以为了被取消选择
而被高亮显示出来


867
00:34:37,010 --> 00:34:39,980
这可以以shift拉拖动作来实现


868
00:34:40,080 --> 00:34:42,516
和在搜寻器图标上的概观一样


869
00:34:43,784 --> 00:34:47,487
基本上 这里的窍门是
项目被选中


870
00:34:47,788 --> 00:34:49,822
但您要压制展示
通常选择的状态


871
00:34:49,889 --> 00:34:51,458
您想要显示一些不一样的


872
00:34:51,525 --> 00:34:52,826
为了要告知使用者


873
00:34:53,126 --> 00:34:56,230
这个项目被选择了
但我们在看怎能取消选择它


874
00:34:56,295 --> 00:34:57,598
您想用平常的方法显示


875
00:34:57,664 --> 00:34:59,166
这其实完全是看您想怎样


876
00:34:59,867 --> 00:35:01,401
根据您的新iDesign


877
00:35:01,869 --> 00:35:03,737
最后 一个项目可以被突出显示


878
00:35:04,004 --> 00:35:05,806
并暗示
它将是有可能被弃置的目标


879
00:35:05,873 --> 00:35:08,475
虽然以我们今天的例子来说
是不合理的


880
00:35:08,542 --> 00:35:10,444
因为一个图像
就是一个叶节点


881
00:35:10,511 --> 00:35:11,845
我们真的没有理由


882
00:35:12,112 --> 00:35:14,114
去将图像拉动到
另外一个图像上


883
00:35:14,281 --> 00:35:16,283
但是如果我们有一些东西
更像是容器


884
00:35:16,483 --> 00:35:19,086
就会合理很多
我们会想指明那个容器


885
00:35:19,720 --> 00:35:20,854
就是我要放置东西的容器


886
00:35:20,921 --> 00:35:23,423
如果用户让鼠标
指向当前点


887
00:35:25,492 --> 00:35:27,160
这些都是在不同的亮点状态


888
00:35:27,361 --> 00:35:28,896
正如我所说
要记住的一样事情


889
00:35:28,962 --> 00:35:30,464
现在所有的都有阶层备份


890
00:35:30,531 --> 00:35:32,900
以全新的集合视图
的成就


891
00:35:33,200 --> 00:35:34,034
因此


892
00:35:34,368 --> 00:35:38,472
它给您机会去利用阶层备份功能


893
00:35:38,772 --> 00:35:40,807
一个更简单的方法
去改变项目的外貌


894
00:35:40,874 --> 00:35:42,176
无需做重绘


895
00:35:42,342 --> 00:35:43,177
所以


896
00:35:43,243 --> 00:35:45,812
CN阶层功能
例如背景颜色 边框颜色


897
00:35:45,879 --> 00:35:47,915
边框宽度 圆角半径
您以前应该计算过这些


898
00:35:48,048 --> 00:35:49,249
有了这个会很方便


899
00:35:49,449 --> 00:35:50,384
因此 我们可以设置


900
00:35:50,617 --> 00:35:53,654
一个项目的根源
来观察阶层的背景颜色


901
00:35:53,720 --> 00:35:54,555
对一些颜色


902
00:35:54,788 --> 00:35:57,424
然后给它一个圆角半径
激增成两行代码


903
00:35:57,491 --> 00:35:59,526
我们已经有了一个
快速的亮点指示


904
00:35:59.593 --> 00:36:00.594 align:middle
或选择指示


905
00:35:59,593 --> 00:36:00,594
或选择指示


906
00:36:00,894 --> 00:36:01,728
又简单又好


907
00:36:02,329 --> 00:36:03,697
您不是必须用这个方法


908
00:36:03,764 --> 00:36:05,432
这只是随意的
要记着


909
00:36:05,499 --> 00:36:06,967
我们现在
在阶层备份的世界


910
00:36:07,835 --> 00:36:09,536
什么时候要使用亮显？


911
00:36:09,736 --> 00:36:10,571
很简单


912
00:36:10,637 --> 00:36:12,773
任何时候您的
亮点状态有所改变


913
00:36:12,840 --> 00:36:14,141
在Swift您能做到这点


914
00:36:14,208 --> 00:36:16,243
一个
DidSetObserver条例


915
00:36:17,144 --> 00:36:18,579
同样您也会看到


916
00:36:18,645 --> 00:36:23,217
当选项被选中后
布尔计算变为是或者否


917
00:36:23,283 --> 00:36:27,054
您会综合考虑高亮显示状态
和选中状态


918
00:36:27,187 --> 00:36:29,556
然后决定如何在视觉上显示选项


919
00:36:29,623 --> 00:36:31,258
根据您的用户界面风格


920
00:36:33,460 --> 00:36:35,195
选中当然是我们要做的


921
00:36:35,262 --> 00:36:36,997
我们希望用户能选中选项


922
00:36:37,064 --> 00:36:39,900
这样他们才能通过拖放操作


923
00:36:39,967 --> 00:36:41,101
或者用命令操作


924
00:36:42,069 --> 00:36:43,070
在集合视图中


925
00:36:43,136 --> 00:36:45,138
选项是组成选择的东西


926
00:36:45,205 --> 00:36:46,406
它们可以被选中


927
00:36:47,274 --> 00:36:50,377
Ns集合视图支持单次
或者多次选中


928
00:36:50,444 --> 00:36:51,345
就像以前一样


929
00:36:51,612 --> 00:36:54,181
关键的问题是
它是否可以被选中


930
00:36:55,315 --> 00:36:56,383
如果您让它可被选中


931
00:36:56,450 --> 00:36:57,985
您可以允许多次选中


932
00:36:58,051 --> 00:37:00,821
或者强制只能选中一次


933
00:37:00,888 --> 00:37:03,457
您还可以拒绝空选


934
00:37:03,724 --> 00:37:05,492
这样集合视图就可以


935
00:37:05,559 --> 00:37:07,160
始终保持
至少有一个选项被选中


936
00:37:07,227 --> 00:37:08,395
这些是比较标准的


937
00:37:08,662 --> 00:37:11,265
它们也是在其它的Apple
KitCollection


938
00:37:11,331 --> 00:37:12,366
视图控制里常见的


939
00:37:12,900 --> 00:37:14,401
例如表格视图
或大纲视图


940
00:37:16,136 --> 00:37:19,406
选中是由新的
选择索引路径属性来追踪


941
00:37:19,473 --> 00:37:20,974
在视图集合里


942
00:37:21,041 --> 00:37:24,144
这是权威 表示
在集合视图中的选中


943
00:37:24,211 --> 00:37:26,180
而我们使用索引路径
而不是项目 对吧？


944
00:37:26,246 --> 00:37:27,381
因为项目来来去去


945
00:37:27,581 --> 00:37:28,949
但该指数路径固定不变


946
00:37:29,316 --> 00:37:31,652
一个项目
如果它恰好被实例化


947
00:37:32,019 --> 00:37:33,654
不知道是否是
在选择的一部分


948
00:37:33,720 --> 00:37:34,555
就像我提到过的


949
00:37:34,821 --> 00:37:36,590
项目来来去去


950
00:37:36,723 --> 00:37:38,392
集合视图是永远不变的


951
00:37:38,458 --> 00:37:41,128
所以您总是要看项目索引路径
看集合视图


952
00:37:41,461 --> 00:37:44,398
来进行操作
并且可以在索引路径选中选项


953
00:37:44,698 --> 00:37:47,401
还可以取消选中
或可以使用这些方法


954
00:37:47,467 --> 00:37:49,870
您也可以直接设定
选择索引路径


955
00:37:50,404 --> 00:37:52,739
当您在iOS索引路径
中选择项目时


956
00:37:52,806 --> 00:37:54,141
您也可以让集合视图


957
00:37:54,274 --> 00:37:57,344
以特定的对齐方式
滚动显示选项


958
00:37:57,678 --> 00:37:58,512
如果您想的话


959
00:37:59,913 --> 00:38:02,049
我们经常要处理的
是用户的选择


960
00:38:03,217 --> 00:38:05,652
在iOS里
委托代表有机会


961
00:38:05,719 --> 00:38:07,154
来批准选中
与取消选中


962
00:38:07,221 --> 00:38:08,956
我们让API有点不同


963
00:38:09,590 --> 00:38:10,824
再次因为我们希望


964
00:38:10,891 --> 00:38:13,527
能够在处理大量操作时更有效率


965
00:38:13,594 --> 00:38:16,597
现在我们有集合视图
应该可以选中项目在索引路径


966
00:38:16,897 --> 00:38:19,499
并且集合视图应该可以
在索引路径取消选中


967
00:38:19,766 --> 00:38:22,135
每一步都要使用一套
索引路径作为参数


968
00:38:22,202 --> 00:38:23,504
这些是计划的索引路径


969
00:38:23,570 --> 00:38:25,105
就是我们要选中和取消选中


970
00:38:26,073 --> 00:38:28,575
注意到这点是它们返回
一套索引路径


971
00:38:28,642 --> 00:38:30,644
而不是一个布尔


972
00:38:30,811 --> 00:38:32,613
所以如果您想说
随便做什么


973
00:38:32,679 --> 00:38:35,249
集合视图会只发回我们已给您
的一套索引路径


974
00:38:35,382 --> 00:38:37,117
但是您在这里也有机会


975
00:38:37,251 --> 00:38:39,286
返回一套不同的
索引路径


976
00:38:39,353 --> 00:38:41,788
您也可以做一条线
如果您想的话


977
00:38:42,022 --> 00:38:43,457
您也可以根据
您想要的标准


978
00:38:43,524 --> 00:38:46,727
您可以把细颗粒控制
用于您选中的


979
00:38:46,793 --> 00:38:48,462
或者某些情况下
取消选中的选项


980
00:38:48,929 --> 00:38:51,365
也有DidSelect
和DeDeselect


981
00:38:51,698 --> 00:38:52,599
选中委托方法


982
00:38:52,900 --> 00:38:56,069
这样您就在对选择
做过改变之后 找出事实


983
00:38:57,204 --> 00:39:00,007le
同样 对亮显委托有办法


984
00:38:57,204 --> 00:39:00,007
同样 对亮显委托有办法


985
00:39:00,641 --> 00:39:03,677
批准并对这些
改变作出反映


986
00:39:03,744 --> 00:39:06,480
所以在索引路径对
突出显示的状态做出改变


987
00:39:06,547 --> 00:39:08,815
您可以返回
一套索引路径


988
00:39:09,049 --> 00:39:10,350
您可以控制细颗粒程度


989
00:39:10,584 --> 00:39:12,452
用在委托的突出强调上


990
00:39:14,354 --> 00:39:16,657
我们再来快速
看一边演示机


991
00:39:21,395 --> 00:39:22,262
幸运的是 时间关系


992
00:39:22,329 --> 00:39:23,730
我已经写好了所有的
代码并运行


993
00:39:23,797 --> 00:39:25,499
我们现在只要到
nib文件里去看


994
00:39:26,600 --> 00:39:28,802
然后仔细
来看集合视图


995
00:39:36,577 --> 00:39:38,579
我们将确保它
被标记为...


996
00:39:38,912 --> 00:39:39,746
可选择的


997
00:39:39,813 --> 00:39:41,281
我们将让空选择


998
00:39:41,815 --> 00:39:43,584
而且我们会允许多重性选择


999
00:39:44,384 --> 00:39:46,687
实施的其余部分是相当直接简单的


1000
00:39:46,753 --> 00:39:48,889
基于我们现在的理解


1001
00:39:50,557 --> 00:39:52,125
我们将停止构建和运行


1002
00:39:56,530 --> 00:39:58,899
现在我们可以点击
项目和选择它们


1003
00:39:58,966 --> 00:40:01,802
我们因为想去展示
说明的用途而选择


1004
00:40:02,069 --> 00:40:04,171
它们是可被选择的候选人


1005
00:40:04,238 --> 00:40:06,707
它们在被选择前以橙色去突出显示


1006
00:40:06,773 --> 00:40:08,642
当我松开触控板时


1007
00:40:08,709 --> 00:40:10,143
它变成蓝色就代表已被选择


1008
00:40:10,210 --> 00:40:11,211
而不再被突出


1009
00:40:11,545 --> 00:40:12,913
我们可以点击背景


1010
00:40:13,013 --> 00:40:13,981
清除选择


1011
00:40:14,248 --> 00:40:15,883
我可以单击并拖动整个项目


1012
00:40:15,949 --> 00:40:18,619
再来我们展示项目作为
突出显示而成为被选择的


1013
00:40:18,685 --> 00:40:19,620
它们还没有被选择


1014
00:40:19,887 --> 00:40:21,421
但当我松开触控板時


1015
00:40:21,655 --> 00:40:22,756
它们已不再被突出


1016
00:40:22,956 --> 00:40:24,157
现在它们已被选定


1017
00:40:24,625 --> 00:40:27,995
正如我提到的在搜寻器的图案


1018
00:40:28,061 --> 00:40:29,830
如果您按住Shift键
然后拖动选择


1019
00:40:29,897 --> 00:40:31,431
那便会变成反转的选择


1020
00:40:31,498 --> 00:40:33,967
这里是一个项目中
选定的一个例子


1021
00:40:34,334 --> 00:40:36,737
然后这成为突出的取消选择


1022
00:40:37,070 --> 00:40:38,372
所以 尽管它们是被选择的


1023
00:40:38,438 --> 00:40:40,440
我们仍在亮点状态覆盖它


1024
00:40:40,507 --> 00:40:41,808
及我们如何在
视觉上呈现出来


1025
00:40:41,875 --> 00:40:42,843
以及我们只是...


1026
00:40:43,177 --> 00:40:44,745
把它们以一般形式地呈现出来


1027
00:40:44,811 --> 00:40:45,946
与它们无边框


1028
00:40:46,013 --> 00:40:48,348
然后 当我松手
该选择已被待发


1029
00:40:48,782 --> 00:40:51,418
现在 因为我可以选择
我可以拖放东西


1030
00:40:51,485 --> 00:40:52,586
重新排序


1031
00:40:52,920 --> 00:40:53,921
这个很棒


1032
00:40:54,221 --> 00:40:55,155
一旦您有选中


1033
00:40:55,222 --> 00:40:56,156
就有很多...


1034
00:40:56,690 --> 00:40:57,658
整洁的事情可以做


1035
00:40:59,059 --> 00:41:01,495
由于这是所有实施
一个非常普遍的方式


1036
00:41:01,562 --> 00:41:03,230
所以是不可知的不同的布局


1037
00:41:03,297 --> 00:41:04,898
大家可以去看看
我们的自定义布局


1038
00:41:05,232 --> 00:41:07,067
因为它们执行所需的方法


1039
00:41:07,501 --> 00:41:11,038
我们也可以在我们的
自定义布局里拖选整个项目


1040
00:41:11,104 --> 00:41:11,939
单击选择


1041
00:41:12,239 --> 00:41:13,841
并自动发生


1042
00:41:13,907 --> 00:41:15,509
因为它们符合在标准


1043
00:41:15,809 --> 00:41:18,178
NS系列视图布局API


1044
00:41:18,745 --> 00:41:20,581
这是一种很好的免费东西


1045
00:41:20,647 --> 00:41:22,382
甚至当我们在此节模式


1046
00:41:22,950 --> 00:41:24,885
流式布局让我们跨节地...


1047
00:41:25,285 --> 00:41:26,320
拖选


1048
00:41:26,486 --> 00:41:27,321
如此类推


1049
00:41:28,155 --> 00:41:28,989
这还挺整洁


1050
00:41:29,823 --> 00:41:30,724
这个可行


1051
00:41:35,028 --> 00:41:35,996
还有两样事情


1052
00:41:36,063 --> 00:41:38,265
我们将快速谈论拖拉及放置


1053
00:41:38,532 --> 00:41:40,067
这是很重要的支持点


1054
00:41:40,133 --> 00:41:41,535
由于老而被弃用的API


1055
00:41:41,602 --> 00:41:42,736
它并没有从根本上改变


1056
00:41:42,803 --> 00:41:44,638
但也有一些新的东西要了解


1057
00:41:46,507 --> 00:41:48,876
现在我们可以拖动选择的项目


1058
00:41:48,942 --> 00:41:51,745
然后如果您有一个集群项的选择
或只是一个单一的项


1059
00:41:51,812 --> 00:41:53,647
您可以拖动它并移动它


1060
00:41:54,515 --> 00:41:56,183
集合视图
因为您在拖动


1061
00:41:56,817 --> 00:41:59,453
计算候选目标
在哪里放下


1062
00:41:59,520 --> 00:42:01,822
在此种情况下
我们不允许放置在物品上


1063
00:42:01,889 --> 00:42:03,624
因为它们不代表容器


1064
00:42:03,690 --> 00:42:05,759
但我们允许项目之间的放置


1065
00:42:05,826 --> 00:42:07,427
这是我们要关注的新的东西


1066
00:42:07,494 --> 00:42:09,329
在OS X
而不是在iOS上


1067
00:42:11,765 --> 00:42:13,600
所以拖放和放置
和以前一样


1068
00:42:13,667 --> 00:42:15,903
由NS集合视图委托处理


1069
00:42:15,969 --> 00:42:18,238
它负责为您
拖放和放置反应


1070
00:42:18,805 --> 00:42:22,709
该模型是很明显地类似
NS大纲视图的API


1071
00:42:22,776 --> 00:42:24,878
它并没有基本原因
让它变得很不一样


1072
00:42:25,145 --> 00:42:27,981
如果您看过拖放及放置
大纲视图的例子


1073
00:42:28,048 --> 00:42:30,851
您会看到很多的实现有相同的概念


1074
00:42:31,118 --> 00:42:34,087
它基本与NSCollection
View的概念是一样的


1075
00:42:34,821 --> 00:42:37,224
如果您希望您的集合视图
成为拖动源


1076
00:42:37,291 --> 00:42:39,193
这意味着项目可以
被拖出来


1077
00:42:40,260 --> 00:42:42,829
您的基本职责是
项目放在粘贴板上时


1078
00:42:42,896 --> 00:42:45,933
能请求集合视图


1079
00:42:46,233 --> 00:42:47,534
如果您想做一个
拖放的终点


1080
00:42:47,601 --> 00:42:49,036
如果您想接受拖放
您需要能够


1081
00:42:49,937 --> 00:42:53,507
估量所计划的拖放
集合视图会呼叫您


1082
00:42:53,574 --> 00:42:56,243
说：我想... 我打算在这里


1083
00:42:56,310 --> 00:42:59,213
放置这些东西
从粘贴板到目标位置


1084
00:42:59,279 --> 00:43:02,649
这是一个索引路径
暗示一个空白


1085
00:43:02,716 --> 00:43:05,485
这个空白在选项之间
在已命名的选项


1086
00:43:05,552 --> 00:43:08,622
前或者一个位置
这个位置在已有的选项之上


1087
00:43:08,722 --> 00:43:10,224
如果您允许它
作为一个容器


1088
00:43:10,290 --> 00:43:11,225
有一种操作


1089
00:43:11,291 --> 00:43:13,260
它们是标准的
拖放操作


1090
00:43:13,327 --> 00:43:15,295
例如拷贝 移动等


1091
00:43:15,629 --> 00:43:19,533
您可以看这个计划
您可以选择重写


1092
00:43:19,600 --> 00:43:21,134
这些参数
比如我自己计划的


1093
00:43:21,201 --> 00:43:23,537
您其实打算用这个位置来放置


1094
00:43:23,604 --> 00:43:25,105
或者拒绝放置


1095
00:43:25,572 --> 00:43:27,774
您需要能够
安排接受放置


1096
00:43:27,841 --> 00:43:30,611
这很相似
但是用户已经执行了放置


1097
00:43:31,111 --> 00:43:32,479
而您需要完成


1098
00:43:32,546 --> 00:43:34,948
并且来相应地
更改您的模型


1099
00:43:35,015 --> 00:43:36,517
并且来相应地
更新集合视图


1100
00:43:37,017 --> 00:43:38,352
这个运作方式


1101
00:43:39,019 --> 00:43:41,188
归结于这些API
您需要


1102
00:43:41,255 --> 00:43:43,323
像其他NS视图一样


1103
00:43:43,557 --> 00:43:44,625
您想注册


1104
00:43:44,691 --> 00:43:46,927
您渴望能被接受的
拖放类型


1105
00:43:47,027 --> 00:43:48,795
因为集合视图
一般不能分辨


1106
00:43:48,862 --> 00:43:50,130
您处理类型的对象


1107
00:43:50,597 --> 00:43:51,632
就您的模组而言


1108
00:43:51,999 --> 00:43:54,902
集合视图拥有拖放
原始动作掩饰


1109
00:43:54,968 --> 00:43:56,904
对于本地和非本地拖放


1110
00:43:56,970 --> 00:43:59,039
这仅仅是基本的
让您预先设定的


1111
00:43:59,239 --> 00:44:02,809
我支援复制和移动
但不包括化名或类似的东西


1112
00:44:03,343 --> 00:44:04,611
您想预先设置


1113
00:44:04,912 --> 00:44:06,847
我们会在范例里
示范


1114
00:44:07,848 --> 00:44:10,350
然后所需要的授权
方法对应于


1115
00:44:10,417 --> 00:44:12,920
我在上一个幻灯片
提到的责任


1116
00:44:14,321 --> 00:44:16,423
同样 您需要能够
在纸板上编写物件


1117
00:44:16,557 --> 00:44:18,959
在现代的API上
您能提供一个纸板编辑器


1118
00:44:19,026 --> 00:44:20,661
给在索引路径的物件


1119
00:44:21,028 --> 00:44:22,663
这允许您更得体地


1120
00:44:22,729 --> 00:44:24,531
处理多项目拖放


1121
00:44:25,199 --> 00:44:27,534
某些数据类型是
纸板作者


1122
00:44:27,634 --> 00:44:29,203
在这个例子中


1123
00:44:29,436 --> 00:44:31,872
NS路径如果是绝对路径


1124
00:44:31,939 --> 00:44:34,441
您只需要退回
路径作为纸板作者


1125
00:44:34,942 --> 00:44:36,643
它会自已
在纸板上编辑


1126
00:44:36,844 --> 00:44:38,278
您或者可以在索引路径


1127
00:44:38,412 --> 00:44:39,980
实行编写项目


1128
00:44:40,080 --> 00:44:40,914
向纸板二选一


1129
00:44:41,148 --> 00:44:42,182
您也能完成目标


1130
00:44:42,749 --> 00:44:44,184
现在 再次选择拖放目的地


1131
00:44:44,251 --> 00:44:46,386
这里有一个验证授权放置方法


1132
00:44:46,720 --> 00:44:47,621
和接受...


1133
00:44:47,955 --> 00:44:50,123
授权放置方法
来进一步简化它们


1134
00:44:50,190 --> 00:44:52,693
您会在代码示例
看到那些被实践的


1135
00:44:54,461 --> 00:44:56,897
我们没有时间详细地
去介绍那些代码示例


1136
00:44:56,964 --> 00:44:58,465
因为拖放在这
是相当地涉及了


1137
00:44:58,532 --> 00:44:59,466
它的设计是.̆..


1138
00:44:59,933 --> 00:45:01,568dle
使您可以拖动项目


1139
00:44:59,933 --> 00:45:01,568
使您可以拖动项目


1140
00:45:01,802 --> 00:45:04,271
从一个应用程式到另一个
有很多需要再做的


1141
00:45:04,338 --> 00:45:07,941
但有很多需要明白的基本技巧
一旦您明白了这些概念


1142
00:45:08,342 --> 00:45:09,710
剩下的只是运作方式


1143
00:45:09,776 --> 00:45:12,179
您就可以明白
今天的例子的全部


1144
00:45:12,813 --> 00:45:14,047
被多次讨论的编码内容


1145
00:45:15,182 --> 00:45:16,650
需要记住的一个重要的事情是


1146
00:45:17,484 --> 00:45:19,553
我们要弄清楚


1147
00:45:19,620 --> 00:45:21,388
并且处理好 


1148
00:45:21,455 --> 00:45:23,924
要在哪里进行拖放
使用您的集合视图


1149
00:45:24,191 --> 00:45:25,492
当您开始得到


1150
00:45:25,893 --> 00:45:28,562
拖放目的地的委托信息时


1151
00:45:28,929 --> 00:45:30,697
值得说的是 嘿


1152
00:45:30,964 --> 00:45:33,300
我知道这是
我自己发起的拖放


1153
00:45:33,367 --> 00:45:35,869
我知道哪个选项
哪个索引路径会被拖放


1154
00:45:36,036 --> 00:45:38,739
这样我就可以更容易地处理
相对于一般的情况


1155
00:45:38,805 --> 00:45:40,774
这个拖放可能来自
这个系统任何地方的情况


1156
00:45:40,841 --> 00:45:43,544
我必须从粘贴板取出东西
诸如此类


1157
00:45:45,045 --> 00:45:47,714
使用集合视图
这让您可以告诉集合视图


1158
00:45:47,781 --> 00:45:50,117
您只是在从
索引路径挪动东西


1159
00:45:50,184 --> 00:45:53,020
到这些新的索引路径中
并且给您一个很好的动画


1160
00:45:53,320 --> 00:45:54,621
作为附加的好处


1161
00:45:54,821 --> 00:45:57,457
这样更好 更精致


1162
00:45:57,791 --> 00:45:59,993
相比与挪动那些选项
然后 哦


1163
00:46:00,060 --> 00:46:02,396
我还得到别处重新插入
一样的东西


1164
00:46:02,663 --> 00:46:03,564
然后重建这些东西


1165
00:46:04,064 --> 00:46:06,266
在集合视图中
一个好用之处


1166
00:46:06,333 --> 00:46:08,135
就是拖放期
开始于项目


1167
00:46:08,368 --> 00:46:11,371
在指引路径委托方法时


1168
00:46:11,471 --> 00:46:13,373
这是个可选的方法
但是个好的地方


1169
00:46:13,440 --> 00:46:17,110
来获取那些索引路径
隐藏它们到私立的属性


1170
00:46:17,211 --> 00:46:19,279
在您的... 数据源中


1171
00:46:19,346 --> 00:46:21,448
这样您将来可以
找到它们并且说 哈


1172
00:46:21,515 --> 00:46:23,350
我可以更简单地处理这个
并且您会发现


1173
00:46:23,417 --> 00:46:24,952
示例程序在那里也这么做


1174
00:46:26,386 --> 00:46:27,821
我想花点时间


1175
00:46:28,155 --> 00:46:31,892
向你们展示自定制界面
这个改变更加有趣


1176
00:46:32,025 --> 00:46:33,460
我们来看一下


1177
00:46:34,361 --> 00:46:36,296
这是我们最后的任务


1178
00:46:36,730 --> 00:46:39,633
我们会考虑您需要做什么
去调整现有的布局


1179
00:46:39,700 --> 00:46:42,269
比方说
流式几乎满足了您所有的需求


1180
00:46:42,336 --> 00:46:44,505
但您想稍微调整一下
让一切看起来都很完美


1181
00:46:44,872 --> 00:46:47,508
我之前就听过这种做法


1182
00:46:48,141 --> 00:46:48,976
或者


1183
00:46:49,142 --> 00:46:52,012
您想采用
一个全新的自定义布局类型


1184
00:46:52,079 --> 00:46:53,313
就像我们现在


1185
00:46:53,380 --> 00:46:55,115
通过不同的


1186
00:46:55,682 --> 00:46:56,917
幻灯片布局一样


1187
00:46:57,150 --> 00:46:58,986
我们来看看要完成这个任务
需要什么条件


1188
00:46:59,486 --> 00:47:01,922
调整现有的布局
相对比较轻松


1189
00:47:02,055 --> 00:47:03,056
我们先看看这个变化


1190
00:47:03,323 --> 00:47:05,759
比方说您想
列入流程布局级别


1191
00:47:05,826 --> 00:47:07,160
将项目的位置


1192
00:47:07,528 --> 00:47:08,362
稍微调整一下


1193
00:47:08,428 --> 00:47:09,530
把东西从这里拉到那里


1194
00:47:09,963 --> 00:47:11,798
您通过一个指令就可以做到
但我们假设


1195
00:47:11,865 --> 00:47:14,101
您希望做一些
您在现有的API基础上


1196
00:47:14,201 --> 00:47:15,335
做不到的事


1197
00:47:16,737 --> 00:47:18,338
这就是主要的方法


1198
00:47:18,605 --> 00:47:20,607
需要大家去了解


1199
00:47:20,908 --> 00:47:23,110
目前为止
它跟iOS是一样的


1200
00:47:23,443 --> 00:47:26,680
矩形元素布局属性
是非常普遍的API


1201
00:47:26,747 --> 00:47:27,814
集合视图的到来


1202
00:47:28,248 --> 00:47:31,385
为您提供一个矩形
那是个矩形


1203
00:47:31,618 --> 00:47:33,420
在集合视图的
内部坐标系统中


1204
00:47:33,487 --> 00:47:34,488
从基本上来说


1205
00:47:34,855 --> 00:47:35,989
这个矩形里面是什么


1206
00:47:36,490 --> 00:47:38,458
您必须返回


1207
00:47:38,592 --> 00:47:39,860
布局属性对象的排列


1208
00:47:39,927 --> 00:47:41,495
记住那是我们的


1209
00:47:41,828 --> 00:47:43,297
项目描述的包装


1210
00:47:43,363 --> 00:47:47,034
不依赖于真正的
实例化项目


1211
00:47:47,401 --> 00:47:50,103
您可以返回
项目的信息


1212
00:47:50,170 --> 00:47:52,039
如果您有... 页眉
和页脚视图


1213
00:47:52,105 --> 00:47:54,141
或者其他附属视图
适用于该领域


1214
00:47:54,508 --> 00:47:56,076
您必须了解
那是什么


1215
00:47:56,143 --> 00:47:57,411
并返回那些描述


1216
00:47:57,544 --> 00:47:58,545
这显然


1217
00:47:58,812 --> 00:48:01,481
高度独立于您的布局算法


1218
00:48:01,582 --> 00:48:02,783
它可以是任何东西 对吧？


1219
00:48:02,850 --> 00:48:04,751
所以您穿梭于
您自己的内部数据结构中


1220
00:48:04,818 --> 00:48:07,788
您想要发现如何真正
高效地做到这个布局


1221
00:48:08,121 --> 00:48:09,823
那就是这种方法的
责任所在


1222
00:48:09,890 --> 00:48:11,825
返回矩形中所有数据的描述


1223
00:48:12,292 --> 00:48:14,194
当集合视图
第一次列出您定义的所有项目时


1224
00:48:14,261 --> 00:48:15,529
那就是核心部分


1225
00:48:15,596 --> 00:48:16,597
那就是它的来由


1226
00:48:17,764 --> 00:48:19,933
会出现这个说明
项目的布局属性


1227
00:48:20,000 --> 00:48:21,768
在索引路径中
似乎有些多余


1228
00:48:21,835 --> 00:48:24,571
但集合视图需要
询问某一项目时


1229
00:48:25,239 --> 00:48:27,207
比方说向我描述该项目


1230
00:48:27,541 --> 00:48:29,109
那就是
需要您做的地方


1231
00:48:30,077 --> 00:48:32,412
如果那个索引路径中没有项目
您就没有返回


1232
00:48:32,813 --> 00:48:34,615
通常都会有
如果它询问的话


1233
00:48:34,915 --> 00:48:38,719
这个功能会启动
在您把东西从一个地方


1234
00:48:38,819 --> 00:48:40,120
移到另一个地方时


1235
00:48:40,454 --> 00:48:42,556
所以您也想要实现那个目标


1236
00:48:42,623 --> 00:48:44,992
结果需要跟第一种方法
保持一致


1237
00:48:47,594 --> 00:48:50,297
然后会出现上下文的无效布局
这是一种


1238
00:48:50,364 --> 00:48:54,368
普通的无效方法
是由集合视图在上下文中触发的


1239
00:48:54,568 --> 00:48:56,570
如果
您查看它的属性


1240
00:48:56,637 --> 00:48:58,405
检查它
它跟iOS的情况一样


1241
00:48:58,639 --> 00:49:00,140ddle
它描述改变了的项目


1242
00:48:58,639 --> 00:49:00,140
它描述改变了的项目


1243
00:49:00,207 --> 00:49:01,742
插入或删除的项目


1244
00:49:01,808 --> 00:49:05,112
可能集合视图在调整大小
任何一种情况都可能发生


1245
00:49:05,679 --> 00:49:08,715
检查上下文属性
让您有机会


1246
00:49:08,949 --> 00:49:11,051
尝试变得聪明和高效


1247
00:49:11,118 --> 00:49:12,252
这是一种先进的优化


1248
00:49:12,452 --> 00:49:13,754
正如您希望的


1249
00:49:13,921 --> 00:49:16,190
您把布局
按照自己的想法


1250
00:49:16,256 --> 00:49:17,090
设置好以后使用


1251
00:49:17,291 --> 00:49:20,861
这是您的机会
清除在布局记录的


1252
00:49:21,662 --> 00:49:24,464
内部状态中的无效数据


1253
00:49:24,531 --> 00:49:25,566
以及有调整时


1254
00:49:27,134 --> 00:49:28,602
您自己对它的描述


1255
00:49:29,870 --> 00:49:32,005
所以我们刚刚看到了
流式布局


1256
00:49:32,072 --> 00:49:33,674
接下来我们一起实施


1257
00:49:33,740 --> 00:49:35,976
前面两种方法


1258
00:49:36,043 --> 00:49:37,644
布局属性返回方法


1259
00:49:38,111 --> 00:49:39,413
使用先进的方法


1260
00:49:39,847 --> 00:49:42,482
看看NS集合视图
流式布局的提议


1261
00:49:42,716 --> 00:49:46,153
我们可以检查
布局属性成品的状态


1262
00:49:46,220 --> 00:49:47,221
或者它们的排列


1263
00:49:47,454 --> 00:49:49,056
然后进行任何一种
我们希望的改变


1264
00:49:49,122 --> 00:49:51,124
返回一组新的
布局属性排列


1265
00:49:51,191 --> 00:49:52,526
或者单一的
布局属性排列


1266
00:49:53,126 --> 00:49:54,628
那就是关于
这个东西的介绍


1267
00:49:54,695 --> 00:49:57,898
只要您做出的改变
不改变布局需要的空间


1268
00:49:59,399 --> 00:50:01,134
要是您想进行
全新的自定义布局


1269
00:50:01,201 --> 00:50:02,436
就像我们所做的那样？


1270
00:50:02,970 --> 00:50:05,138
您可以直接将
NS集合视图布局归为子集


1271
00:50:05,205 --> 00:50:07,007
将所有东西
重新开始


1272
00:50:07,074 --> 00:50:09,810
比方说 如果您的类型和
流式相似


1273
00:50:10,444 --> 00:50:11,912
您采用同样的方法
就像我们刚


1274
00:50:12,145 --> 00:50:13,647
在上一张幻灯片中提到的那样


1275
00:50:14,481 --> 00:50:16,149
此外 您要能够


1276
00:50:16,984 --> 00:50:18,819
回答一下基本的问题
比如


1277
00:50:19,052 --> 00:50:22,956
您需要的大小 宽度和高度
去排列项目


1278
00:50:23,023 --> 00:50:24,758
是不是集合视图
能够提供的？


1279
00:50:25,325 --> 00:50:27,561
基本上您只需要告诉
集合视图


1280
00:50:27,661 --> 00:50:30,097
我的文件视图大小


1281
00:50:30,163 --> 00:50:31,798
这决定了您的滚动区域


1282
00:50:33,734 --> 00:50:37,070
要是边界改变的无效布局
返回一个布尔值


1283
00:50:37,237 --> 00:50:38,505
在调整大小的过程中


1284
00:50:38,572 --> 00:50:39,873
集合视图将会
触发这个功能


1285
00:50:40,340 --> 00:50:43,810
通常您会观察
我的布局算法是什么？


1286
00:50:43,911 --> 00:50:46,246
我的布局是否受到
重新调整大小的影响？


1287
00:50:46,513 --> 00:50:49,049
如果您是流式布局
比方说 垂直界面


1288
00:50:49,116 --> 00:50:50,651
将所有东西排成行


1289
00:50:51,151 --> 00:50:52,452
或许您并不是非常在意


1290
00:50:52,519 --> 00:50:55,022
如果集合视图的高度
发生改变 对吧？


1291
00:50:55,088 --> 00:50:56,557
那只是为您提供了
空间而已


1292
00:50:56,623 --> 00:50:58,926
但是如果宽度发生改变
您必须重新排列


1293
00:50:59,259 --> 00:51:01,295
比方说您可能
在那种情况下返回是对的


1294
00:51:01,562 --> 00:51:02,963
这就是那种方法的作用


1295
00:51:04,731 --> 00:51:07,234
如果您修改流式布局


1296
00:51:07,301 --> 00:51:09,169
来获得您需要修改的空间


1297
00:51:09,303 --> 00:51:11,538
您真正需要进行那两项修改


1298
00:51:11,605 --> 00:51:13,307
即使是细微的自定义排列


1299
00:51:14,675 --> 00:51:16,844
然而这些方法
在OS X上是全新的


1300
00:51:16,910 --> 00:51:19,513
我刚刚提到
我们有能力去进行测试


1301
00:51:19,580 --> 00:51:20,414
拥有一个...


1302
00:51:20,881 --> 00:51:21,715
抽象的布局


1303
00:51:21,782 --> 00:51:22,616
去进行...


1304
00:51:22,783 --> 00:51:24,017
目标放置的测试


1305
00:51:24,251 --> 00:51:25,853
这是个很强大的新特性


1306
00:51:26,253 --> 00:51:28,355
您可以在
任何一种自定义布局中进行设置


1307
00:51:28,755 --> 00:51:31,491
点击目标放置的布局属性
是第一种方法


1308
00:51:32,092 --> 00:51:34,928
如果目标是一个项目
那就非常直接


1309
00:51:34,995 --> 00:51:37,865
您将会返回一个属性
布局属性实例


1310
00:51:38,465 --> 00:51:40,501
其代表的
元素类型是项目


1311
00:51:41,201 --> 00:51:43,337
您在对一个项目
进行放置


1312
00:51:43,971 --> 00:51:45,973
您插入所发现的


1313
00:51:46,039 --> 00:51:48,609
需要放置的项目的索引路径


1314
00:51:49,743 --> 00:51:50,577
然后您想


1315
00:51:50,644 --> 00:51:52,713
返回该项目的边界框


1316
00:51:52,779 --> 00:51:54,615
作为布局属性的框架


1317
00:51:54,982 --> 00:51:56,016
那非常简单


1318
00:51:56,617 --> 00:51:59,152
现在更有趣的情况是
我们无需去处理


1319
00:51:59,219 --> 00:52:01,154
iOS中
项目之间的间隙


1320
00:52:02,656 --> 00:52:05,425
如果您决定这个点
应该进行测试


1321
00:52:05,492 --> 00:52:07,861
但它却在项目之间
可您以通过


1322
00:52:07,928 --> 00:52:11,532
项目的序列号码去辨别
间隙的位置 好的


1323
00:52:11,598 --> 00:52:15,235
这个介于
索引6和索引7


1324
00:52:15,302 --> 00:52:17,037
您想返回项目间隙


1325
00:52:18,005 --> 00:52:21,141
那样用户可以在布局中
在项目之间放置目标


1326
00:52:21,475 --> 00:52:24,311
您返回的元素
类型是项目间隙


1327
00:52:25,045 --> 00:52:26,346
属性的索引路径是


1328
00:52:26,813 --> 00:52:30,317
间隙后的项目所在的索引路径


1329
00:52:30,517 --> 00:52:33,153
如果您还是在6和7之间
您返回的索引路径是


1330
00:52:33,220 --> 00:52:35,189
该部分项目7的位置


1331
00:52:36,423 --> 00:52:39,826
其次 您返回的
属性框架


1332
00:52:40,127 --> 00:52:40,961
间隙的边界框


1333
00:52:41,361 --> 00:52:44,064
集合视图
将使用该边界框


1334
00:52:44,131 --> 00:52:46,733
去定义如何
在那个矩形中规划


1335
00:52:46,800 --> 00:52:48,001
标准的指标


1336
00:52:51,471 --> 00:52:53,407
接下来的一种方法
叫做索引路径前


1337
00:52:53,473 --> 00:52:55,576
项目间隙的布局属性


1338
00:52:55,642 --> 00:52:57,544
集合视图有时也需要
这种方法


1339
00:52:57,611 --> 00:52:59,580
它也会询问特定的位置


1340
00:53:00,013 --> 00:53:01,548
要求您描述该间隙


1341
00:53:02,115 --> 00:53:03,717
所以这里我们返回一种


1342
00:53:03,784 --> 00:53:05,485
元素类型的属性
项目间隙


1343
00:53:05,853 --> 00:53:08,589
它代表的元素类型是
项目间隙指标


1344
00:53:08,956 --> 00:53:12,259
所以我们利用这个
建立一个补充视图


1345
00:53:12,326 --> 00:53:15,162
那就是项目
间隙指标的应用


1346
00:53:15,896 --> 00:53:17,931
您只需插入您所给予的
索引路径


1347
00:53:18,599 --> 00:53:20,767
返回的是
属性框架


1348
00:53:20,868 --> 00:53:22,102
作为该间隙的矩形


1349
00:53:22,202 --> 00:53:23,804
综合这两种方法


1350
00:53:24,171 --> 00:53:25,439
集合视图支持...


1351
00:53:26,907 --> 00:53:29,076
项目之间目标放置的指示


1352
00:53:29,142 --> 00:53:32,379
即使是任意的
自定义布局


1353
00:53:32,446 --> 00:53:34,581
您自己的设计
也可以做到相当整齐


1354
00:53:35,582 --> 00:53:37,384
我们简单看一下
我们的自定义布局


1355
00:53:37,451 --> 00:53:38,552
以及它们如何实施


1356
00:53:39,086 --> 00:53:40,187
请看我们最后一个短片


1357
00:53:47,861 --> 00:53:49,596
请看这里左侧边栏


1358
00:53:49,963 --> 00:53:51,298
我们将代码进行分类


1359
00:53:51,365 --> 00:53:53,333
我们有一个代码组
您可能想看一下


1360
00:53:53,734 --> 00:53:55,769
今天我们看一个例子


1361
00:53:56,203 --> 00:53:57,171dle
圆形布局


1362
00:54:01,575 --> 00:54:03,277
它很简单


1363
00:54:03,410 --> 00:54:06,346
我们在索引路径采用
项目布局属性


1364
00:54:06,413 --> 00:54:08,248
在这里我们会询问
某一特定的项目


1365
00:54:08,815 --> 00:54:12,619
这些是我们理论上能做的事
我们将项目索引


1366
00:54:13,453 --> 00:54:14,922
从索引路径提取出来


1367
00:54:15,189 --> 00:54:18,091
那将定义我们距离
圆圈有多远


1368
00:54:18,425 --> 00:54:20,327
我们利用那个想法去计算


1369
00:54:22,262 --> 00:54:23,730
0至2π弧度的角


1370
00:54:23,931 --> 00:54:26,767
那样我们计算出一个幻灯片
理应的走向框架


1371
00:54:27,701 --> 00:54:29,536
那么最重要的一部分是这里


1372
00:54:30,304 --> 00:54:31,805
API是一个敏感的部分


1373
00:54:31,872 --> 00:54:34,308
您如何举例说明
布局属性对象


1374
00:54:34,374 --> 00:54:36,610
获得一个
与索引路径相关的


1375
00:54:36,677 --> 00:54:38,011
正确索引


1376
00:54:38,345 --> 00:54:39,913
您想小心
用这种方式进行


1377
00:54:40,681 --> 00:54:42,216
我们会谈及...


1378
00:54:43,217 --> 00:54:44,985
布局的层次


1379
00:54:45,352 --> 00:54:48,055
获得相应的
布局属性层次


1380
00:54:48,121 --> 00:54:49,923
基本上拥有这个API


1381
00:54:50,123 --> 00:54:52,459
可以让布局属性


1382
00:54:52,526 --> 00:54:54,728
NS集合视图
布局属性层次


1383
00:54:54,962 --> 00:54:56,530
得以归类和延伸


1384
00:54:56,797 --> 00:54:59,499
或许您有一些真正的
在iOS的自定义布局


1385
00:54:59,800 --> 00:55:01,768
需要与
其它属性一起使用


1386
00:55:01,835 --> 00:55:04,371
或者记住其它信息
关于已经陈列的项目内容


1387
00:55:04,571 --> 00:55:06,740
您可以通过归类
增加那些属性


1388
00:55:07,441 --> 00:55:09,309
您推翻布局属性层次


1389
00:55:09,376 --> 00:55:11,345
返回您自己的分类


1390
00:55:12,145 --> 00:55:14,915
通过这个方法去确定
举例说明这个分类


1391
00:55:14,982 --> 00:55:15,816
如果有需要的话


1392
00:55:16,016 --> 00:55:16,850
适合的那一个


1393
00:55:17,451 --> 00:55:19,386
我们启动这个出厂模式


1394
00:55:20,020 --> 00:55:21,255
有索引路径的项目的


1395
00:55:21,321 --> 00:55:23,757
布局模式
我们往那个路径传输获得的东西


1396
00:55:23,824 --> 00:55:26,159
一旦我们获得一个布局
属性对象


1397
00:55:27,194 --> 00:55:29,563
我们按照自己的想法设置
我们设置框架


1398
00:55:29,630 --> 00:55:33,033
前后颠倒的Z索引
层中的序号


1399
00:55:33,634 --> 00:55:36,537
然后我们返回那个特性对象
至集合视图


1400
00:55:37,171 --> 00:55:38,705
我们拥有一个超级层


1401
00:55:39,039 --> 00:55:41,608
所有的自定义布局
我们都采用


1402
00:55:42,109 --> 00:55:43,944
矩形方法


1403
00:55:44,511 --> 00:55:46,547
矩形元素
布局属性


1404
00:55:46,613 --> 00:55:48,715
我们可以做到那一点
因为在这种情况下


1405
00:55:48,782 --> 00:55:50,050
特别的是这些所有的布局


1406
00:55:50,284 --> 00:55:53,020
在这种情况下不单单是可以
滚动的布局还能扩大至


1407
00:55:53,086 --> 00:55:54,121
它们需要的大小


1408
00:55:54,354 --> 00:55:55,923
去展示它们的项目


1409
00:55:56,123 --> 00:55:57,691
这些都选择在可视化区域


1410
00:55:57,958 --> 00:56:00,961
展示集合视图的
所有项目


1411
00:56:01,361 --> 00:56:03,630
所以采用这种方法


1412
00:56:03,697 --> 00:56:04,831
基本上是一样的


1413
00:56:05,232 --> 00:56:07,568
我们看到一个矩形
我们会看到


1414
00:56:07,634 --> 00:56:09,503
我们所有的项目


1415
00:56:09,970 --> 00:56:13,774
我们返回这些描述
至集合视图


1416
00:56:14,074 --> 00:56:16,810
所以我们实际上
利用了索引路径项目的


1417
00:56:16,877 --> 00:56:18,545
布局属性方法


1418
00:56:18,745 --> 00:56:20,547
我们在分类中
采用这个方法


1419
00:56:21,481 --> 00:56:23,817
集合视图内容
大小是一样的


1420
00:56:23,884 --> 00:56:25,519
这些幻灯片的布局
我们看到


1421
00:56:25,586 --> 00:56:27,287
省略视图的大小


1422
00:56:27,554 --> 00:56:28,822
我们拥有的内容


1423
00:56:28,889 --> 00:56:29,990
是否让用户可见呢？


1424
00:56:30,057 --> 00:56:31,692
我们计划陈列出
所有的东西


1425
00:56:31,925 --> 00:56:32,993
因为我们在做那一点


1426
00:56:33,594 --> 00:56:36,797
我们努力在边界改变时
让布局失效


1427
00:56:36,864 --> 00:56:39,766
无论如何改变
我们想重新布局


1428
00:56:39,900 --> 00:56:43,971
这样才能合理地
使用可用的空间


1429
00:56:45,138 --> 00:56:48,075
在iOS准备布局
这只是个轻而易举的事


1430
00:56:48,141 --> 00:56:50,944
当布局参数发生改变时
您就处于


1431
00:56:51,011 --> 00:56:52,546
新布局周期的开端


1432
00:56:52,813 --> 00:56:55,282
您可以做任何提前计算
您可以做任何事情


1433
00:56:55,516 --> 00:56:57,684
触发功能
在周期的开端


1434
00:56:58,652 --> 00:57:01,154
我们可以看一下
这里活动的布局


1435
00:57:07,861 --> 00:57:11,832
在调整大小中遇到的
圆形布局


1436
00:57:11,899 --> 00:57:13,934
布局每次都会
失效


1437
00:57:14,001 --> 00:57:14,835
因为我们想


1438
00:57:15,202 --> 00:57:16,603
获得最大的圆形


1439
00:57:16,870 --> 00:57:19,072
在可用空间内预留边界


1440
00:57:21,175 --> 00:57:24,678
通过采用那些
相对要求少的方法


1441
00:57:25,045 --> 00:57:26,713
我们获得一个
完全自定义的布局


1442
00:57:26,780 --> 00:57:27,881
另外 跟以往一样


1443
00:57:28,115 --> 00:57:30,150
它支持交叉筛选


1444
00:57:30,484 --> 00:57:32,119
在这里点击筛选


1445
00:57:32,586 --> 00:57:34,321
它很通用


1446
00:57:35,656 --> 00:57:38,492
所以无需太多
就可以定义布局


1447
00:57:39,593 --> 00:57:41,495
在NS集合视图内的使用布局


1448
00:57:41,795 --> 00:57:43,964
事实上布局层次
以及您找到的API


1449
00:57:44,198 --> 00:57:45,465
除了特殊情况


1450
00:57:45,532 --> 00:57:48,602
我们增加了这些功能
去支持放置目标测试


1451
00:57:48,969 --> 00:57:51,038
API基本上跟iOS一样


1452
00:57:51,104 --> 00:57:53,106
所以如果您有
在iOS使用的布局


1453
00:57:53,207 --> 00:57:55,642
您会发现
迁移到OS X其实很简单


1454
00:57:57,311 --> 00:57:59,213
今天我们讲了
许多话题


1455
00:57:59,279 --> 00:58:01,615
我们现在推出测试版


1456
00:58:01,682 --> 00:58:03,984
您可以获得完整的源代码


1457
00:58:04,051 --> 00:58:05,552
我鼓励您去研究它


1458
00:58:05,719 --> 00:58:07,554
它应该能帮助您开始


1459
00:58:07,788 --> 00:58:11,091
在El Capitan使用
全新的NS集合视图


1460
00:58:12,926 --> 00:58:15,429
最后 我们拥有
极大提升了的


1461
00:58:15,495 --> 00:58:17,931
NS集合视图
我希望您会喜欢El Capitan


1462
00:58:17,998 --> 00:58:21,335
它现已在市场推出
能够处理大量的项目


1463
00:58:21,735 --> 00:58:23,770
能灵活进行随意布局


1464
00:58:24,404 --> 00:58:27,274
所有您希望看的最艰难的项目


1465
00:58:27,341 --> 00:58:28,909
我们鼓励您这样做


1466
00:58:28,976 --> 00:58:31,812
让我们知道细节
让我们知道您碰到的难处


1467
00:58:32,679 --> 00:58:34,081
如果您需要任何的帮助或指导


1468
00:58:34,147 --> 00:58:37,551
我们有一个专门的集合视图实验室
专注于未来发明


1469
00:58:37,784 --> 00:58:41,121
叫做Foundation实验室B
Frameworks实验室B不好意思


1470
00:58:41,488 --> 00:58:42,656
在这栋建筑的底层


1471
00:58:43,557 --> 00:58:46,660
明早9:00我到时会和
团队中的其他工程师一起


1472
00:58:46,727 --> 00:58:48,028
他们都很了解集合视图


1473
00:58:49,263 --> 00:58:53,100
不要只看文件
还要看应用套装发布笔记


1474
00:58:53,166 --> 00:58:56,537
我会以个人名义将关于
集合视图的使用笔记放到那里


1475
00:58:57,538 --> 00:58:59,173
里面关于如何建立的信息


1476
00:59:00,007 --> 00:59:03,377
而且您能看到
关于在10.11的AppKit中的


1477
00:59:03,443 --> 00:59:05,846
所有其它伟大发明的信息


1478
00:59:06,880 --> 00:59:09,149
如果您错过了
Cocoa有什么新内容


1479
00:59:09,216 --> 00:59:12,386
这是找寻其他
新添的特性的好地方


1480
00:59:12,452 --> 00:59:14,721
信息量很大
一个演讲无法涵盖所有内容


1481
00:59:14,888 --> 00:59:18,358
我鼓励您去看一看会议视频


1482
00:59:18,692 --> 00:59:22,062
最后我们有两大自动布局会议
在今天早些时候


1483
00:59:22,129 --> 00:59:24,064
如果您正在使用自动布局限制


1484
00:59:24,298 --> 00:59:26,800
来在项目中定位您的控制


1485
00:59:27,034 --> 00:59:30,304
对自动布局的仔细了解
是很有帮助的


1486
00:59:31,004 --> 00:59:33,640
谢谢你们的出席
我很期待看到你们会创造出什么


1487
00:59:33,707 --> 00:59:36,844
享受WWDC的冲击吧！
我们明天实验室见

