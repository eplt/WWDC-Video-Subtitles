1
00:00:00,506 --> 00:00:10,146
[ Silence ]


2
00:00:10,646 --> 00:00:11,946
>> Hi. I'm Tim Isted.


3
00:00:12,166 --> 00:00:13,256
Welcome back after lunch.


4
00:00:13,706 --> 00:00:15,256
Let's talk Core Data
performance,


5
00:00:16,616 --> 00:00:18,836
so you've taken the
time to learn Core Data


6
00:00:18,906 --> 00:00:20,406
and you've built
your app around it.


7
00:00:21,546 --> 00:00:23,616
Maybe you found


8
00:00:23,756 --> 00:00:26,456
that occasionally you get
slightly just re-scroll view,


9
00:00:27,446 --> 00:00:27,916
table view.


10
00:00:28,466 --> 00:00:30,566
Maybe the information takes a
while to come into your app.


11
00:00:31,256 --> 00:00:33,446
Maybe users are reporting
a few occasional issues.


12
00:00:34,246 --> 00:00:36,956
We're going to look at we can
identify those issues today


13
00:00:36,956 --> 00:00:41,256
and how we can fix them, so when
we're talking about optimization


14
00:00:41,256 --> 00:00:44,786
and particularly with Core Data,
we're trying to make a balance


15
00:00:44,976 --> 00:00:47,806
between memory usage on the one
hand and speed on the other,


16
00:00:48,386 --> 00:00:51,176
so the more memory we use,
the more information we have


17
00:00:51,176 --> 00:00:53,266
in memory, but we're
using more memory.


18
00:00:54,416 --> 00:00:56,576
The less information we have in
memory, the slower things get


19
00:00:56,576 --> 00:00:58,396
because we have to pull it in
and push it back out again.


20
00:00:59,026 --> 00:01:02,866
In iOS, obviously, you're
even more limited with memory


21
00:01:02,866 --> 00:01:03,796
than you are on the desktop,


22
00:01:04,146 --> 00:01:06,236
so you can't sacrifice
memory for speed.


23
00:01:06,236 --> 00:01:08,776
You have to find a way to
optimize where possible


24
00:01:08,776 --> 00:01:11,946
without using too much
memory, so some of the things


25
00:01:11,946 --> 00:01:15,106
that cause people problems are
loading too much information.


26
00:01:15,196 --> 00:01:16,836
Maybe you're pulling in
more than you really need.


27
00:01:17,476 --> 00:01:19,146
Maybe you're firing
too many faults.


28
00:01:19,886 --> 00:01:20,826
You're trying to
use up something


29
00:01:20,826 --> 00:01:22,726
that you haven't previously
indicated you wanted


30
00:01:22,726 --> 00:01:24,756
and Core Data has to go out
and fetch it and bring it in.


31
00:01:25,736 --> 00:01:27,216
Maybe your queries
are too expensive.


32
00:01:28,386 --> 00:01:32,266
Maybe your text searches are
using the wrong type of query


33
00:01:32,266 --> 00:01:34,136
or using something more
expensive than you really need,


34
00:01:34,606 --> 00:01:35,976
and finally, a more
advanced thing,


35
00:01:35,976 --> 00:01:37,846
maybe you're incurring
too many locks


36
00:01:37,906 --> 00:01:39,646
when you're accessing
through context.


37
00:01:39,646 --> 00:01:43,266
So today we're going to be
talking a lot about Instruments


38
00:01:43,266 --> 00:01:45,356
and not only how we use
Instruments to find problems,


39
00:01:45,356 --> 00:01:47,376
but how we interpret the
information that we see


40
00:01:47,376 --> 00:01:49,406
and figure out what it means
and what we need to do about it.


41
00:01:49,406 --> 00:01:51,856
We're going to be talking
about debug logging


42
00:01:51,856 --> 00:01:54,086
so that you can see exactly
what's happening underneath the


43
00:01:54,086 --> 00:01:56,286
hood and what Core Data is
doing behind the scenes,


44
00:01:56,736 --> 00:01:58,886
and we'll be talking about some
of the optimizations we can make


45
00:01:58,886 --> 00:02:01,426
to our model, to fetch
requests and predicates.


46
00:02:01,726 --> 00:02:04,856
We're looking at concurrency
and optimizing text searches.


47
00:02:05,256 --> 00:02:08,106
So let's jump right in and talk
about measuring performance


48
00:02:09,196 --> 00:02:12,936
and primarily our tool for this
is Instruments, but obviously


49
00:02:12,936 --> 00:02:15,316
with Xcode 5 you've now got
debug gauges that are there


50
00:02:15,316 --> 00:02:16,376
without even running
Instruments,


51
00:02:16,376 --> 00:02:19,106
so you can get read outs
on memory usage, CP usage,


52
00:02:19,106 --> 00:02:22,056
et cetera, but your
first port of call


53
00:02:22,056 --> 00:02:24,356
for a more advanced information
is the Core Data Instrument,


54
00:02:24,586 --> 00:02:25,766
but that's not all.


55
00:02:25,846 --> 00:02:28,316
Also consider running a
time profiler allocation.


56
00:02:28,316 --> 00:02:29,576
See how much memory
you're using.


57
00:02:29,576 --> 00:02:30,716
Look at file activity.


58
00:02:30,716 --> 00:02:31,416
Look at disk IO.


59
00:02:31,416 --> 00:02:34,056
How many times are you hitting
the disk to pull information in?


60
00:02:34,676 --> 00:02:35,826
Though when you're
using instruments,


61
00:02:36,526 --> 00:02:37,696
you need to know two things.


62
00:02:37,946 --> 00:02:39,456
First of all, what
are you looking for?


63
00:02:39,746 --> 00:02:41,366
What are the patterns
you're trying to find out?


64
00:02:41,366 --> 00:02:41,966
What's wrong?


65
00:02:42,036 --> 00:02:44,196
How do you interpret
that information?


66
00:02:44,196 --> 00:02:46,006
How do you use it
to make a change?


67
00:02:47,416 --> 00:02:49,236
And you also need to know
how long to something --


68
00:02:49,326 --> 00:02:50,406
should something take.


69
00:02:50,596 --> 00:02:51,806
At app launch it should be fast.


70
00:02:51,806 --> 00:02:54,056
Whatever you're doing to load
initial information should


71
00:02:54,056 --> 00:02:54,716
happen quickly.


72
00:02:54,796 --> 00:02:56,896
A table view should
pop up straight away.


73
00:02:56,896 --> 00:02:58,696
If you're doing something
in the background,


74
00:02:58,696 --> 00:03:01,346
obviously that can take longer,
but how long is too long?


75
00:03:01,346 --> 00:03:02,956
How short is the right amount?


76
00:03:04,346 --> 00:03:06,796
Let's jump straight to a
quick demo, so here's an app


77
00:03:07,186 --> 00:03:09,436
and it has a problem that I'm
sure you -- many of you've seen,


78
00:03:09,436 --> 00:03:10,066
that when I run it


79
00:03:10,376 --> 00:03:13,556
in the simulator takes
really a rather long time


80
00:03:13,556 --> 00:03:15,956
for anything to happen.


81
00:03:15,956 --> 00:03:19,836
Eventually my UI appears, and
if I look in the debug gauge,


82
00:03:20,376 --> 00:03:22,806
my memory usage is
way up at 640 Meg.


83
00:03:22,906 --> 00:03:24,046
That's a lot.


84
00:03:24,046 --> 00:03:25,786
On a device, that's
probably going to get killed,


85
00:03:26,196 --> 00:03:28,176
and if it took that long
in the simulator to launch,


86
00:03:28,176 --> 00:03:29,876
it's going to take much,
much longer on a device


87
00:03:29,876 --> 00:03:31,306
and probably won't
even launch at all,


88
00:03:32,506 --> 00:03:34,546
so we can say it's taking
a long time to launch,


89
00:03:34,546 --> 00:03:35,666
but that's rather subjective.


90
00:03:36,046 --> 00:03:37,366
How do we get an
objective measure?


91
00:03:38,006 --> 00:03:39,646
Lets choose Profile,
and we're going


92
00:03:39,646 --> 00:03:42,756
to choose the Core Data template
and let's see what comes in.


93
00:03:42,756 --> 00:03:45,976
Let's look at the Core
Data Fetches Instrument,


94
00:03:45,976 --> 00:03:47,556
and I'm going to look at the UI.


95
00:03:47,726 --> 00:03:50,606
Just before that UI eventually
appears I get some blocks


96
00:03:50,606 --> 00:03:51,586
up here in the read out,


97
00:03:51,586 --> 00:03:54,476
and this time line
shows a wide block.


98
00:03:54,566 --> 00:03:57,416
Those blue and those pink
blocks are big, and this is bad,


99
00:03:57,686 --> 00:03:59,176
particularly at app launch.


100
00:04:00,526 --> 00:04:02,086
And to see exactly what's bad,


101
00:04:02,826 --> 00:04:04,216
let's look in the
bottom right hand corner,


102
00:04:04,476 --> 00:04:08,146
so we've got a duration here
of just over three seconds,


103
00:04:08,426 --> 00:04:11,006
so the initial fetch request is
taking three seconds to come in,


104
00:04:11,046 --> 00:04:13,416
and we're fetching 505 objects


105
00:04:13,756 --> 00:04:15,606
so there are two things
we might look at here.


106
00:04:15,606 --> 00:04:17,596
One is the fetch is
taking way too long.


107
00:04:17,596 --> 00:04:20,505
Three seconds is like a
millennium in computer cycles,


108
00:04:20,966 --> 00:04:23,116
and we're fetching 505 objects.


109
00:04:23,416 --> 00:04:25,966
Do we really need to do that?


110
00:04:26,166 --> 00:04:30,056
Let's look at optimizing fetch
requests, and the first thing.


111
00:04:30,626 --> 00:04:31,936
Don't fetch more than you need.


112
00:04:32,826 --> 00:04:34,706
This is a really, really
quick fix that you can make.


113
00:04:34,926 --> 00:04:35,786
You've got a table view.


114
00:04:36,146 --> 00:04:38,416
It's showing maybe ten,
twelve, thirteen views --


115
00:04:38,416 --> 00:04:40,426
rows, depending on, you
know, your configuration


116
00:04:40,426 --> 00:04:43,996
of the table view on the device,
so don't fetch all 505 objects


117
00:04:43,996 --> 00:04:45,396
from the store just
for the first ten.


118
00:04:45,396 --> 00:04:47,576
And there are various
ways we can do this,


119
00:04:47,576 --> 00:04:49,796
but the very easiest is
to add one line of code.


120
00:04:50,276 --> 00:04:52,656
Use a fetch batch size,
and this limits the number


121
00:04:52,656 --> 00:04:53,526
of results that come in.


122
00:04:53,526 --> 00:04:55,606
We can use a fetch
batch size of twenty.


123
00:04:55,606 --> 00:04:57,256
That accounts for what's in
the table view at the time


124
00:04:57,256 --> 00:04:58,196
and a little bit of scrolling,


125
00:04:59,076 --> 00:05:01,146
so do that we just
set a fetch batch size


126
00:05:01,226 --> 00:05:02,406
on the request itself.


127
00:05:02,866 --> 00:05:06,766
And what this means is that
the results that we get back


128
00:05:06,886 --> 00:05:09,976
from the batched fetch is
a special kind of array.


129
00:05:09,976 --> 00:05:11,716
It behaves just like
any other array.


130
00:05:11,716 --> 00:05:13,546
You can query the count,
and you get the right number


131
00:05:13,546 --> 00:05:16,026
of objects back as to what would
be there without the batch,


132
00:05:16,496 --> 00:05:19,536
but only the first fetched
batch size worth of objects are


133
00:05:19,536 --> 00:05:21,256
in the array, in this
case the first twenty,


134
00:05:21,906 --> 00:05:25,126
so as you iterate through,
everything works as normal,


135
00:05:25,126 --> 00:05:28,486
but when you reach the 20th
object and then you try to put


136
00:05:28,486 --> 00:05:30,926
in the 21st, that's a
promise from Core Data


137
00:05:30,926 --> 00:05:32,706
that the results will be
there when you need them.


138
00:05:32,976 --> 00:05:34,016
So Core Data will go out,


139
00:05:34,016 --> 00:05:35,696
and it will execute another
fetch request to bring


140
00:05:35,696 --> 00:05:37,176
in those objects
as you want them,


141
00:05:37,176 --> 00:05:38,966
and this all happens
automatically,


142
00:05:38,966 --> 00:05:40,336
so you don't need
to worry about it.


143
00:05:40,516 --> 00:05:41,286
Just set this.


144
00:05:41,286 --> 00:05:42,946
Iterate through the results
as you would normally,


145
00:05:43,106 --> 00:05:44,996
and the information flows
in as it did before,


146
00:05:45,416 --> 00:05:47,706
but you're minimizing the amount
of objects you have in memory


147
00:05:47,706 --> 00:05:49,486
because you're limiting the
initial fetch to twenty.


148
00:05:49,976 --> 00:05:51,456
Let's take a look in the
app and see what happens,


149
00:05:51,646 --> 00:05:54,006
so here I've got a fetch
batch size of zero.


150
00:05:54,006 --> 00:05:54,726
That's the default.


151
00:05:54,856 --> 00:05:56,066
It means an unlimited batch.


152
00:05:56,126 --> 00:05:56,926
Everything will come in.


153
00:05:57,166 --> 00:06:00,866
Let's change it to 20, and
then we're re-profile the app,


154
00:06:02,026 --> 00:06:04,796
so product, profile,
Core Data Instruments.


155
00:06:05,176 --> 00:06:08,156
Sorry, I'm going to run it first
apparently, and here we have --


156
00:06:08,246 --> 00:06:10,306
the memory has gone right
down, so we're using a tenth


157
00:06:10,306 --> 00:06:11,166
of what we had before.


158
00:06:11,166 --> 00:06:13,976
Instead of the 600 Meg
before, we've now got 62,


159
00:06:14,036 --> 00:06:15,126
so that's a big improvement.


160
00:06:15,126 --> 00:06:16,596
It's not ideal.


161
00:06:16,596 --> 00:06:17,616
That's still quite
a lot of memory,


162
00:06:17,886 --> 00:06:19,576
but it's better than
it was before.


163
00:06:20,576 --> 00:06:23,876
Let's profile it and see
what's happened, so stop it


164
00:06:23,876 --> 00:06:27,176
and re-profile, and take
a look at the read out.


165
00:06:27,496 --> 00:06:30,386
So this time the app
launches very quickly.


166
00:06:30,386 --> 00:06:34,366
If we look in the simulator --
if we look in the time line,


167
00:06:34,486 --> 00:06:35,776
we've got a very thin line.


168
00:06:35,776 --> 00:06:37,046
The thin line is good.


169
00:06:37,506 --> 00:06:39,566
Thin line means a
very fast fetch.


170
00:06:40,446 --> 00:06:41,226
That's what you want to see.


171
00:06:41,226 --> 00:06:42,346
You don't want to
see wide lines.


172
00:06:42,346 --> 00:06:43,416
You want to see very thin ones.


173
00:06:43,466 --> 00:06:47,706
If we look in the simulator,
and we scroll the table view,


174
00:06:48,006 --> 00:06:49,176
then you'll see more
entries appear


175
00:06:49,176 --> 00:06:51,416
in the fetches instrument, and
this is Core Data going out


176
00:06:51,416 --> 00:06:53,206
and bringing in more
objects as it's needed.


177
00:06:53,486 --> 00:06:55,776
This would, you know, to
fulfill different rows


178
00:06:55,776 --> 00:06:59,316
in the table view, so you've got
the thin line at the beginning


179
00:06:59,316 --> 00:07:01,536
for the initial fetch and then
you've got subsequent lines


180
00:07:01,536 --> 00:07:04,136
appearing, ten lines again
to bring in more objects.


181
00:07:04,196 --> 00:07:06,886
If we look in the bottom right
hand -- this slide, this time,


182
00:07:07,826 --> 00:07:10,346
we see something interesting,
so we've got one fetch count


183
00:07:10,346 --> 00:07:13,766
of 505, and that's Core Data
going out and doing a count


184
00:07:13,766 --> 00:07:16,326
for fetch request to see how
many objects should eventually


185
00:07:16,326 --> 00:07:19,386
be in this array, 505,
and the duration is short.


186
00:07:19,446 --> 00:07:21,496
That's three milliseconds,
less than three milliseconds.


187
00:07:21,526 --> 00:07:22,016
That's okay.


188
00:07:22,016 --> 00:07:23,166
That's a reasonable amount.


189
00:07:23,166 --> 00:07:26,776
The first fetch batch that
comes in is for 20 objects,


190
00:07:26,896 --> 00:07:31,916
and that's 176 milliseconds,
177, so a huge improvement


191
00:07:31,916 --> 00:07:34,336
over the three seconds we had
before just by changing one line


192
00:07:34,336 --> 00:07:37,556
of code and setting a fetch
batch size, but is it enough?


193
00:07:37,926 --> 00:07:40,246
One hundred and seventy six
milliseconds is still quite a


194
00:07:40,246 --> 00:07:42,396
long time, especially in
the simulator on a device


195
00:07:42,396 --> 00:07:44,666
that will be more, and at
app launch you want the UI


196
00:07:44,666 --> 00:07:46,616
to appear immediately,
so what else can we do?


197
00:07:47,186 --> 00:07:51,696
Let's talk about optimizing the
data model, so if you've been


198
00:07:51,696 --> 00:07:54,266
to the WWDC presentations
on Core Data


199
00:07:54,266 --> 00:07:56,156
and performance before, you'll
know that we've talked a lot


200
00:07:56,156 --> 00:07:58,486
about designing your
model for your apps usage


201
00:07:59,006 --> 00:08:01,176
and in particular saying
don't over-normalize.


202
00:08:01,526 --> 00:08:04,506
And normalization in a
traditional sense means


203
00:08:04,506 --> 00:08:05,886
that you're trying to
minimize the amount


204
00:08:05,886 --> 00:08:08,256
of information that's
duplicated across a database,


205
00:08:09,016 --> 00:08:10,206
so if you've got something


206
00:08:10,206 --> 00:08:11,776
in one place you don't
really want it anywhere else


207
00:08:11,776 --> 00:08:13,046
because if you need to
change it you've got


208
00:08:13,046 --> 00:08:13,866
to update it everywhere.


209
00:08:14,846 --> 00:08:16,926
With Core Data, you
might be able


210
00:08:16,926 --> 00:08:19,456
to get a performance benefit
by actually caching information


211
00:08:19,456 --> 00:08:21,786
or storing it in multiple
places where you really need it,


212
00:08:21,786 --> 00:08:23,966
so you don't have to keep
firing relationships to go off


213
00:08:23,966 --> 00:08:25,076
and get related information.


214
00:08:25,666 --> 00:08:27,816
Duplication is not
necessarily a bad thing.


215
00:08:30,446 --> 00:08:33,566
We've also said that when
you're using large blobs,


216
00:08:33,566 --> 00:08:34,966
in this case our
photos that we're seeing


217
00:08:34,966 --> 00:08:37,866
in the contact list, you should
use external storage attribute.


218
00:08:38,176 --> 00:08:40,405
It's a simple checkbox
in the data model.


219
00:08:40,486 --> 00:08:44,015
You just enable it, and we will
store blobs as you set them


220
00:08:44,015 --> 00:08:46,756
on a property -- out to
disk, but not necessarily.


221
00:08:46,986 --> 00:08:50,006
Sometimes SQLite is actually
better for small file sizes.


222
00:08:50,006 --> 00:08:52,526
It's much more responsive
giving back data blobs


223
00:08:52,526 --> 00:08:55,946
than using a separate file,
so if the file is below


224
00:08:55,946 --> 00:08:58,476
that threshold we will store
it out there in SQLite.


225
00:08:58,626 --> 00:09:00,596
If it's above the threshold,
we'll write it to a file


226
00:09:00,596 --> 00:09:01,486
and store a reference.


227
00:09:01,746 --> 00:09:03,056
That all happens automatically.


228
00:09:03,056 --> 00:09:04,226
You don't need to
worry about it.


229
00:09:04,506 --> 00:09:05,846
You simply set a data property,


230
00:09:05,846 --> 00:09:07,096
and then you get it
back when you want it.


231
00:09:07,526 --> 00:09:11,326
Now this is my current entity.


232
00:09:11,486 --> 00:09:13,126
I have a first name, a
last name and a photo,


233
00:09:13,126 --> 00:09:14,916
and that's what's
displayed in my UI.


234
00:09:16,976 --> 00:09:19,176
Do we really need
that photo in there?


235
00:09:19,606 --> 00:09:21,746
It might be that we could
change our UI to get rid


236
00:09:21,746 --> 00:09:23,876
of the little thumbnail and just
show first name and last name,


237
00:09:23,876 --> 00:09:25,276
but we still want the photo.


238
00:09:25,276 --> 00:09:26,546
Maybe we're going to
push a view controller


239
00:09:26,546 --> 00:09:29,756
on screen that's going to give
us maybe the picture of the user


240
00:09:29,756 --> 00:09:32,266
and then all their
information overlaid on top,


241
00:09:32,566 --> 00:09:34,516
so in previous talks
we've recommended


242
00:09:34,516 --> 00:09:36,776
that you split your data
out into a separate entity.


243
00:09:36,776 --> 00:09:38,886
Anything that's a big
blob of data should go


244
00:09:38,886 --> 00:09:41,156
into a separate entity, in
this case, a photo entity


245
00:09:41,156 --> 00:09:42,436
with a photo data attribute,


246
00:09:42,436 --> 00:09:43,916
and there's a one-to-one
relationship


247
00:09:43,916 --> 00:09:47,156
between them, but there's more.


248
00:09:48,176 --> 00:09:50,016
Let's see what happens
when we try this.


249
00:09:50,836 --> 00:09:53,066
I've put the data
into my photo entity,


250
00:09:53,186 --> 00:09:55,086
and I've got my external
storage checkbox used.


251
00:09:55,256 --> 00:09:56,206
Let's profile this again.


252
00:09:59,236 --> 00:10:02,006
This time the app
launches quickly again,


253
00:10:02,006 --> 00:10:02,976
but there's some
marks appearing.


254
00:10:03,046 --> 00:10:06,066
Have a look in this instrument
as I scroll the table view,


255
00:10:06,376 --> 00:10:09,586
got little black marks appearing
the Core Data Cache Misses


256
00:10:09,586 --> 00:10:12,926
Instrument, and this is because
we have actually still used


257
00:10:12,926 --> 00:10:15,286
that photo to display a
little tiny thumbnail.


258
00:10:15,836 --> 00:10:18,346
We've got the contacts
being loaded,


259
00:10:18,346 --> 00:10:19,906
and that's what we're
fetching right now,


260
00:10:19,906 --> 00:10:22,536
but each time we access that
photo relationship to display


261
00:10:22,536 --> 00:10:25,486
in the table view, Core Data's
having to go out and fetch


262
00:10:25,486 --> 00:10:26,956
that related photo
blob and bring it


263
00:10:26,956 --> 00:10:28,206
in so we can create
the thumbnail.


264
00:10:29,696 --> 00:10:36,526
What we should really consider
doing is maybe we can pre-fetch


265
00:10:36,526 --> 00:10:37,486
the objects that we need.


266
00:10:37,826 --> 00:10:39,676
If you're seeing that kind
of activity in an instrument,


267
00:10:39,676 --> 00:10:41,976
it generally means that you
haven't set enough information


268
00:10:41,976 --> 00:10:43,746
on what you -- what you're
trying to bring in and use.


269
00:10:44,366 --> 00:10:45,526
You've requested your contacts,


270
00:10:45,526 --> 00:10:47,126
but you haven't told it
you also want the photo,


271
00:10:47,336 --> 00:10:50,046
so you do that by calling
set relationship key paths


272
00:10:50,046 --> 00:10:51,726
for pre-fetching and
providing an array


273
00:10:51,726 --> 00:10:53,756
of key paths, in
this case photo.


274
00:10:54,046 --> 00:10:55,116
That's the name of
the relationship,


275
00:10:57,326 --> 00:11:00,016
but that might not be the
right thing to do in this case


276
00:11:00,466 --> 00:11:01,806
because our photo is 10 Meg.


277
00:11:02,266 --> 00:11:04,236
We're actually displaying
a little tiny thumbnail.


278
00:11:04,236 --> 00:11:06,906
We don't really need an
entire image just to show


279
00:11:06,906 --> 00:11:09,716
that thumbnail, nor do we really
want to scale it at runtime,


280
00:11:10,326 --> 00:11:12,606
so what we should really do is
cache the thumbnail separately


281
00:11:12,606 --> 00:11:13,766
in the contact identity.


282
00:11:14,486 --> 00:11:16,296
If we're loading the first name
and last name and the thumbnail


283
00:11:16,296 --> 00:11:17,796
in one go, and we're
displaying it in the UI,


284
00:11:17,796 --> 00:11:19,376
let's have it all
in the same entity.


285
00:11:20,026 --> 00:11:21,756
Less data takes less
time to fetch.


286
00:11:21,756 --> 00:11:23,276
We're not skipping
a relationship.


287
00:11:23,276 --> 00:11:24,456
We're not having
to scale in memory,


288
00:11:25,486 --> 00:11:27,656
so let's move to
this arrangement.


289
00:11:27,716 --> 00:11:29,476
I've got my first name,
last name and a thumbnail


290
00:11:29,476 --> 00:11:32,526
in the contact entity and
photo data in the photo entity.


291
00:11:33,996 --> 00:11:35,306
What happens when
I profile this?


292
00:11:38,216 --> 00:11:39,806
Again, product profile.


293
00:11:40,076 --> 00:11:42,666
Look at the Core Data
template, and let's look


294
00:11:42,666 --> 00:11:46,136
in the Fetches Instrument.


295
00:11:46,926 --> 00:11:49,856
As I scroll my table view
this time I see no activity


296
00:11:49,856 --> 00:11:51,556
in cache misses, but the
information is still brought


297
00:11:51,556 --> 00:11:53,856
in by the batches, seems
to be very responsive.


298
00:11:53,856 --> 00:11:54,626
The scrolling's great.


299
00:11:54,626 --> 00:11:57,106
Let's have a look
in the bottom right.


300
00:11:57,496 --> 00:12:00,656
This time my fetch durations
have dropped dramatically,


301
00:12:00,956 --> 00:12:03,006
so the longest thing right
now is actually the count,


302
00:12:03,006 --> 00:12:04,006
505 objects.


303
00:12:04,006 --> 00:12:05,496
It's taking about
three milliseconds.


304
00:12:05,736 --> 00:12:09,326
All the 20 individual object
fetches, about two milliseconds,


305
00:12:09,976 --> 00:12:11,546
even less than that
as it goes on.


306
00:12:11,736 --> 00:12:12,866
That's much more realistic.


307
00:12:12,866 --> 00:12:14,076
That's what it should
be at app launch.


308
00:12:14,076 --> 00:12:15,416
We want the UI to
appear immediately.


309
00:12:15,416 --> 00:12:16,926
We want the information
pulled in quickly.


310
00:12:16,926 --> 00:12:18,386
We don't want to keep
the user waiting.


311
00:12:18,966 --> 00:12:20,476
Good user experience is
what we're aiming for,


312
00:12:21,266 --> 00:12:25,036
so that's basic problems
with simple applications.


313
00:12:25,206 --> 00:12:26,586
Let's talk a little bit now


314
00:12:26,586 --> 00:12:28,496
about performing
background tasks,


315
00:12:28,816 --> 00:12:32,826
so this might involve importing
information from somewhere.


316
00:12:32,826 --> 00:12:35,696
It might involve doing some
complicated calculations


317
00:12:35,696 --> 00:12:37,376
on a lot of data that
you've already saved.


318
00:12:37,916 --> 00:12:41,266
First of all, let's look at
dealing with a simple app.


319
00:12:41,266 --> 00:12:42,346
This is an earthquakes app.


320
00:12:42,346 --> 00:12:45,066
It shows the location of recent
earthquakes, which it gets


321
00:12:45,096 --> 00:12:46,006
from a [inaudible] web service.


322
00:12:46,006 --> 00:12:48,396
It pulls in some JSON
data, translates it


323
00:12:48,996 --> 00:12:52,736
and updates the local store.


324
00:12:52,926 --> 00:12:54,716
What I have right
now has a problem,


325
00:12:54,826 --> 00:12:57,636
so profile it once more.


326
00:12:57,636 --> 00:13:00,426
Let's look at the Fetches
Instrument, and I'm going


327
00:13:00,426 --> 00:13:03,656
to hit my little
refresh button in my UI,


328
00:13:03,766 --> 00:13:05,056
which will trigger an update.


329
00:13:05,556 --> 00:13:10,186
So what you're seeing
is a large amount


330
00:13:10,186 --> 00:13:11,356
of activity in that instrument.


331
00:13:12,226 --> 00:13:14,666
It's kind of like red
meadow grass, lots and lots


332
00:13:14,666 --> 00:13:15,986
of thin lines, one
after the other.


333
00:13:16,816 --> 00:13:17,906
This is also a bad thing.


334
00:13:17,906 --> 00:13:19,936
I'm not going to make you
sit through all of this,


335
00:13:19,936 --> 00:13:23,726
so let's skip on a little bit
and hey, it's still going on.


336
00:13:24,566 --> 00:13:27,846
This is now nearly a 50
second import operation.


337
00:13:29,126 --> 00:13:31,626
That seems a little excessive
even for a background operation.


338
00:13:31,876 --> 00:13:34,566
If you look in the bottom
right, we've got a whole bunch


339
00:13:34,566 --> 00:13:36,306
of fetches that just
have a count of one.


340
00:13:37,626 --> 00:13:41,296
That's -- that seems a bit odd,
and what's even more if we look


341
00:13:41,356 --> 00:13:43,556
in the Saves Instrument, you see


342
00:13:43,556 --> 00:13:45,216
that we've got a single
save happening at the end


343
00:13:45,216 --> 00:13:47,346
and it's taking 175
milliseconds.


344
00:13:47,696 --> 00:13:50,106
Again, quite a long time even
on the -- on my simulator,


345
00:13:50,106 --> 00:13:52,126
going to be much longer
than that on the device.


346
00:13:52,126 --> 00:13:54,606
When we talk about locking
later, this is going to be key.


347
00:13:54,606 --> 00:13:56,666
We want to keep the
time it takes to save


348
00:13:56,766 --> 00:14:00,656
to a minimum wherever
possible, and the reason


349
00:14:00,656 --> 00:14:02,966
that that's bad is that we're
performing a fetch request


350
00:14:02,966 --> 00:14:04,496
for every object that
we're trying to update.


351
00:14:04,736 --> 00:14:06,416
Every item in our JSON
dictionary we're going out


352
00:14:06,416 --> 00:14:08,336
and we're executing fetch
requests to see if it exists.


353
00:14:08,336 --> 00:14:09,156
If it does we update it.


354
00:14:09,156 --> 00:14:10,426
If we don't, we insert it.


355
00:14:10,426 --> 00:14:12,856
Let's talk about a
better algorithm,


356
00:14:13,576 --> 00:14:16,346
so the first you do is you
sort your input objects


357
00:14:16,346 --> 00:14:17,326
by some kind of ID.


358
00:14:17,326 --> 00:14:20,436
That's how you tie some relation
data to the thing in the store,


359
00:14:20,436 --> 00:14:24,796
and you execute one sorted
fetch against your store to pull


360
00:14:24,796 --> 00:14:26,896
in all the objects that have
a matching ID from the ones


361
00:14:26,896 --> 00:14:29,156
that you're trying to
import, and then you iterate


362
00:14:29,156 --> 00:14:30,116
through them concurrently.


363
00:14:30,876 --> 00:14:32,886
If the next object in each
enumerator is the same,


364
00:14:32,886 --> 00:14:33,396
you update.


365
00:14:33,466 --> 00:14:34,606
If it's different, you insert,


366
00:14:35,146 --> 00:14:36,766
so a picture's worth
a thousand words.


367
00:14:36,766 --> 00:14:38,106
Let's take a look
at this in practice.


368
00:14:38,896 --> 00:14:40,096
Say we've got three
objects, and we're trying


369
00:14:40,096 --> 00:14:44,006
to update our local store, and
we've got a couple of objects


370
00:14:44,006 --> 00:14:46,636
that actually exist in
this particular data.


371
00:14:46,956 --> 00:14:48,046
First thing we do, we sort them,


372
00:14:48,046 --> 00:14:49,356
so the fetch request
must be sorted.


373
00:14:49,396 --> 00:14:51,206
We can sort our JSON
dictionary as well by ID,


374
00:14:51,336 --> 00:14:55,016
and we enumerate concurrently,
so the first object in each


375
00:14:55,016 --> 00:14:57,266
of these collections has ID 101.


376
00:14:57,676 --> 00:14:58,206
It's a match.


377
00:14:58,406 --> 00:15:00,286
That's an update, and we go


378
00:15:00,286 --> 00:15:01,696
to the next object
in each enumerator.


379
00:15:01,696 --> 00:15:03,626
In this case, they don't match.


380
00:15:04,566 --> 00:15:05,616
That's saying it's an insert,


381
00:15:05,786 --> 00:15:08,146
so we can insert the
object into the store.


382
00:15:09,076 --> 00:15:12,056
And this point we increment
only the information to update


383
00:15:12,056 --> 00:15:13,816
because we haven't yet
dealt with the one --


384
00:15:13,886 --> 00:15:15,776
number 104 in our
existing objects.


385
00:15:16,486 --> 00:15:17,986
This time they match.


386
00:15:17,986 --> 00:15:19,596
It's an update, so
we can update.


387
00:15:20,336 --> 00:15:22,456
That's a much more efficient
algorithm for inserting


388
00:15:22,456 --> 00:15:25,466
or update because you're only
ever executing one fetch request


389
00:15:25,466 --> 00:15:26,036
to the store.


390
00:15:26,036 --> 00:15:27,496
You're only pulling
in one lot of data.


391
00:15:27,546 --> 00:15:29,446
You're not going
out individual times


392
00:15:29,786 --> 00:15:31,166
to get each object separately,


393
00:15:31,416 --> 00:15:33,566
and you won't see these
little crazy lines going


394
00:15:33,566 --> 00:15:35,856
across in the time -- in
the profile in Instruments.


395
00:15:36,206 --> 00:15:38,676
Let's see what difference
this makes.


396
00:15:38,676 --> 00:15:41,056
I've got two enumerators
here, JSON quake enumerator


397
00:15:41,056 --> 00:15:42,336
and matching quake enumerator.


398
00:15:43,056 --> 00:15:44,816
When I run -- I profile it.


399
00:15:45,866 --> 00:15:46,976
See how much faster this is.


400
00:15:47,516 --> 00:15:52,976
[ Pause ]


401
00:15:53,476 --> 00:15:54,696
Boom. That's pretty good.


402
00:15:55,176 --> 00:15:58,716
I've got one line in my
Fetch Request Instrument now.


403
00:15:59,046 --> 00:15:59,966
It's not thin.


404
00:15:59,966 --> 00:16:01,676
It's a little bit wide,
a few pixels wide,


405
00:16:01,676 --> 00:16:03,026
but it's a certainly
better than before.


406
00:16:03,026 --> 00:16:04,616
Instead of like a
minute's worth of import,


407
00:16:04,616 --> 00:16:05,836
we've got maybe a second.


408
00:16:05,956 --> 00:16:10,286
I kept saying that thin
was better than wide.


409
00:16:11,246 --> 00:16:12,106
Why is it wide?


410
00:16:12,106 --> 00:16:17,086
Well our fetch count is actually
23,000 objects, so I had a batch


411
00:16:17,086 --> 00:16:18,856
of JSON dictionaries to
update, and I've gone out


412
00:16:18,856 --> 00:16:20,076
and I've fetched
all my existing ones


413
00:16:20,076 --> 00:16:22,726
and I got 23,000 objects
coming back into memory.


414
00:16:23,296 --> 00:16:26,876
That's probably not a good
thing, and it took just


415
00:16:26,876 --> 00:16:28,746
under 300 milliseconds, so again


416
00:16:28,746 --> 00:16:30,506
that will be slow
on an actual device.


417
00:16:31,556 --> 00:16:32,336
This isn't good.


418
00:16:33,046 --> 00:16:34,646
You want to minimize the number
of objects you're dealing


419
00:16:34,646 --> 00:16:36,616
with at any time and keep
those fetch durations low,


420
00:16:36,616 --> 00:16:38,626
again for locking purposes
as we'll talk later.


421
00:16:40,906 --> 00:16:42,636
What we really want to
do is work in batches,


422
00:16:42,636 --> 00:16:44,786
and this applies both to the
implementing update or insert


423
00:16:44,846 --> 00:16:48,016
but also any kind of background
activity that you're doing


424
00:16:48,016 --> 00:16:49,796
where you're pulling in
lots of objects at the time.


425
00:16:49,796 --> 00:16:52,366
You should be working in batches
rather than the whole lot


426
00:16:52,366 --> 00:16:54,536
at once, and it's
worth experimenting


427
00:16:54,536 --> 00:16:56,006
to find the optimal batch size.


428
00:16:56,826 --> 00:16:57,846
Maybe it's 500.


429
00:16:57,846 --> 00:16:58,646
Maybe it's 1000.


430
00:16:58,896 --> 00:17:00,126e
Maybe it's 550.


431
00:16:58,896 --> 00:17:00,126
Maybe it's 550.


432
00:17:00,676 --> 00:17:02,426
Just that little bit
of difference means


433
00:17:02,426 --> 00:17:03,546
that you get things much faster,


434
00:17:03,546 --> 00:17:06,915
but without using too much
memory, so experiment and test


435
00:17:06,915 --> 00:17:08,165
on every device that
you support.


436
00:17:08,276 --> 00:17:08,925
Just because it works


437
00:17:08,925 --> 00:17:11,616
on an iPhone 5 very well doesn't
necessarily mean it'll be


438
00:17:11,616 --> 00:17:13,516
so good on a 4 or even a 3GS.


439
00:17:15,715 --> 00:17:19,215
So, let's talk about minimizing
memory usage we'll be batching.


440
00:17:20,195 --> 00:17:22,836
You've got a number of ways to
deal with getting rid of some


441
00:17:22,836 --> 00:17:24,425
of the information that
you've just pulled in,


442
00:17:24,425 --> 00:17:27,656
and the first way is to turn
a single managed object back


443
00:17:27,656 --> 00:17:29,816
into a fault, so this
can be really helpful


444
00:17:29,816 --> 00:17:32,376
if you've got a single managed
object and it has a bunch


445
00:17:32,376 --> 00:17:35,366
of related objects hanging
off it, and you fetch them all


446
00:17:35,366 --> 00:17:36,996
in to do something and you've
been operating on them,


447
00:17:36,996 --> 00:17:37,936
and then you've finished
with it.


448
00:17:37,936 --> 00:17:40,776
So on to arc, you've probably
got a strong reference


449
00:17:40,776 --> 00:17:43,106
to your managed object and then
this will have references all


450
00:17:43,106 --> 00:17:44,876
the way across to all the
related objects, so they'll stay


451
00:17:44,876 --> 00:17:46,156
in memory and use memory


452
00:17:46,156 --> 00:17:47,556
that you don't really
need at this point.


453
00:17:48,166 --> 00:17:50,766
So by calling refresh object
merge changes on this object,


454
00:17:50,766 --> 00:17:51,836
you'll turn it into a fault.


455
00:17:52,146 --> 00:17:53,556
All its other data
will disappear,


456
00:17:53,556 --> 00:17:55,336
and it will be re-fetched
if you need it,


457
00:17:56,526 --> 00:17:57,416
but that's a single object.


458
00:17:57,416 --> 00:17:59,116
What about, you know,
doing a batch?


459
00:17:59,466 --> 00:18:01,726
The most efficient way
is to reset the context


460
00:18:01,806 --> 00:18:04,136
by calling reset,
and this will clear


461
00:18:04,136 --> 00:18:05,606
out all the existing
managed objects


462
00:18:05,846 --> 00:18:07,906
so they'll be re-fetched the
next time you need to use them.


463
00:18:08,986 --> 00:18:10,146
It does come with a caveat.


464
00:18:10,146 --> 00:18:12,596
If you have any existing
references to any of the objects


465
00:18:12,596 --> 00:18:15,716
in that context, they will be
invalid after you've reset.


466
00:18:16,306 --> 00:18:17,826
If you try and access
one, you'll get an error


467
00:18:17,826 --> 00:18:19,306
in the console that
says something like,


468
00:18:19,556 --> 00:18:20,526
"Could not fulfill a fault."


469
00:18:21,126 --> 00:18:25,426
So let's look at the batch
size and see what's happened


470
00:18:25,426 --> 00:18:26,566
when I've re-profiled the app.


471
00:18:26,896 --> 00:18:28,346
Got a batch size of 500 here.


472
00:18:28,346 --> 00:18:29,586
That seemed to work quite well


473
00:18:30,016 --> 00:18:33,606
when I profile with
the instrument.


474
00:18:34,036 --> 00:18:36,856
Check the fetch requests, and
then click refresh in the app.


475
00:18:36,976 --> 00:18:39,156
I get a little flurry
of activity,


476
00:18:39,156 --> 00:18:40,996
but this time it's
only a few entries


477
00:18:40,996 --> 00:18:41,896
in the time line, which is good.


478
00:18:41,896 --> 00:18:47,066
They're few and thin, and the
times are far much reduced,


479
00:18:47,596 --> 00:18:52,066
so if I look down in the bottom
right you can see we've only got


480
00:18:52,066 --> 00:18:55,246
500 objects coming in at a time
and we're dealing with a matter


481
00:18:55,246 --> 00:18:59,336
of maybe 13, 14 milliseconds, so
each of these fetches is going


482
00:18:59,336 --> 00:19:03,036
to be very, very short and
we're not using too much memory


483
00:19:03,036 --> 00:19:05,136
because we're using a
batch, so this is the ideal,


484
00:19:05,746 --> 00:19:07,356
most optimized background import


485
00:19:07,356 --> 00:19:09,246
that we could possibly
use for this process.


486
00:19:09,696 --> 00:19:11,246
So that's importing data.


487
00:19:12,906 --> 00:19:14,796
What about operations
that we need to do?


488
00:19:15,756 --> 00:19:18,136
Well, it's always worth saying
only fetch what you need.


489
00:19:18,186 --> 00:19:19,836
We talked earlier about
the fetch batch size,


490
00:19:19,836 --> 00:19:21,396
so that's a way to limit
the number of results


491
00:19:21,396 --> 00:19:23,466
that you get initially rather
than fetching everything,


492
00:19:23,466 --> 00:19:25,406
but there are other
things you can consider.


493
00:19:25,946 --> 00:19:28,216
If all you're doing is
performing a calculation


494
00:19:28,216 --> 00:19:31,066
on your data, you don't need
read write access to that data.


495
00:19:32,046 --> 00:19:34,186
Potentially you don't even
need an entire managed object


496
00:19:34,186 --> 00:19:35,916
with all your business
logic hanging off it.


497
00:19:36,516 --> 00:19:37,596
What you might be able to do is


498
00:19:37,596 --> 00:19:38,976
to use a dictionary
request type --


499
00:19:39,576 --> 00:19:41,846
result type, so when
you execute this,


500
00:19:41,846 --> 00:19:43,296
instead of getting
managed objects back,


501
00:19:43,826 --> 00:19:45,856
you get plain NS
Dictionary instances,


502
00:19:46,176 --> 00:19:48,006
and you can even limit
the number of properties


503
00:19:48,006 --> 00:19:49,146
that you actually get so rather


504
00:19:49,146 --> 00:19:50,676
than getting your
entire managed object,


505
00:19:50,786 --> 00:19:52,246
you can just specify one value.


506
00:19:52,586 --> 00:19:54,766
In this case, I want
to get the magnitudes


507
00:19:54,766 --> 00:19:57,016
of all the earthquakes
in my app.


508
00:19:57,976 --> 00:19:59,966
Perhaps I'm trying to use
this make a calculation.


509
00:20:00,046 --> 00:20:03,556
Maybe I want to get a minimum
or a maximum or an average,


510
00:20:04,016 --> 00:20:05,416
so I'm loading all
the information in


511
00:20:05,416 --> 00:20:06,686
and then performing
some calculation


512
00:20:06,686 --> 00:20:07,406
in the background on that.


513
00:20:07,406 --> 00:20:11,456
And that certainly will work,
but it's not the best way


514
00:20:11,456 --> 00:20:13,966
to do this because it requires
us to bring in everything


515
00:20:14,286 --> 00:20:16,086
and build objects around
the data that we have.


516
00:20:17,416 --> 00:20:20,016
What's far better is to
use aggregate operations,


517
00:20:20,466 --> 00:20:24,076
and what we can do is we could
actually have Core Data query


518
00:20:24,186 --> 00:20:26,486
the SQL store --
SQLite store and say,


519
00:20:27,016 --> 00:20:28,396
"Perform these operations
on the data,


520
00:20:28,396 --> 00:20:30,686
and give me a single
result back,"


521
00:20:30,936 --> 00:20:32,706
so in this case I've got
an expression description


522
00:20:33,206 --> 00:20:33,916
called minimum.


523
00:20:33,916 --> 00:20:36,006
That would be the key in the
dictionary that I get back,


524
00:20:36,496 --> 00:20:38,586
and I'm calling expression
for function Min.


525
00:20:39,236 --> 00:20:42,436
As it might seem, you're going
to get minimum values back,


526
00:20:43,476 --> 00:20:46,106
a single minimum value back
for the minimum magnitude


527
00:20:46,106 --> 00:20:47,386
in the app, so rather
than having


528
00:20:47,506 --> 00:20:48,716
to fetch all the information in,


529
00:20:48,716 --> 00:20:49,936
I've got a single
result come in.


530
00:20:50,686 --> 00:20:51,706
Now you can take this further


531
00:20:51,706 --> 00:20:53,286
because not only are
you specifying that,


532
00:20:53,286 --> 00:20:55,126
but you can also specify a
predicate, so if you want


533
00:20:55,126 --> 00:20:57,356
to say, for example, "Give
me the minimum values


534
00:20:57,356 --> 00:20:59,676
across the last seven days,"
you could still set a predicate


535
00:20:59,676 --> 00:21:02,886
on the fetch request and
set the properties to fetch.


536
00:21:03,376 --> 00:21:06,176
I just want this expression
description to come back,


537
00:21:06,686 --> 00:21:08,796
and you will get a dictionary
back with a single result,


538
00:21:08,976 --> 00:21:10,296
minimum and the minimum value.


539
00:21:12,676 --> 00:21:16,916
This is another complicated
potentially scenario.


540
00:21:16,916 --> 00:21:20,106
I want to summarize my
data, so I want to look


541
00:21:20,106 --> 00:21:22,956
at all the different
magnitudes and get the number


542
00:21:22,956 --> 00:21:26,196
of earthquakes that happen
with that magnitude, and yes,


543
00:21:26,196 --> 00:21:28,116
there really is a
magnitude of minus one.


544
00:21:28,256 --> 00:21:29,266
It's a logarithmic scale,


545
00:21:29,356 --> 00:21:31,506
smaller the earthquake
actually goes to minus one.


546
00:21:33,236 --> 00:21:34,026
How do I do this?


547
00:21:34,026 --> 00:21:36,546
Well I might go and I might
go and get the unique values


548
00:21:36,546 --> 00:21:38,186
from the store for magnitude


549
00:21:38,186 --> 00:21:40,976
and then count how many
earthquakes actually have


550
00:21:40,976 --> 00:21:41,646
that magnitude.


551
00:21:43,016 --> 00:21:44,186
That's not the most
efficient way though.


552
00:21:44,186 --> 00:21:46,556
We can actually do this
with a single fetch request.


553
00:21:46,876 --> 00:21:49,906
We can execute expression for
function count, so that's going


554
00:21:49,906 --> 00:21:52,426
to give us a count of something,
in case the magnitudes,


555
00:21:52,526 --> 00:21:54,866
and we're going to supply
the properties to fetch,


556
00:21:54,866 --> 00:21:56,476
both magnitude and
account, and we're going


557
00:21:56,476 --> 00:22:00,186
to group the results using
group by, specify magnitude.


558
00:22:00,186 --> 00:22:02,356
And this will actually
give us back a dictionary


559
00:22:02,456 --> 00:22:05,026
with all these results in a
single dictionary with magnitude


560
00:22:05,166 --> 00:22:07,126
and count, and that's it
so we can just display


561
00:22:07,126 --> 00:22:07,996
that straight in a table view.


562
00:22:07,996 --> 00:22:09,096
We've not had to load anything


563
00:22:09,096 --> 00:22:10,376
into memory other
than this dictionary.


564
00:22:10,466 --> 00:22:14,956
We're not performing any complex
calculations, so that's going


565
00:22:14,956 --> 00:22:16,426
to be quite complicated
when we implement this,


566
00:22:16,426 --> 00:22:18,616
and it's also interesting to
see what's really going on.


567
00:22:19,306 --> 00:22:21,646
So you've made these
optimizations.


568
00:22:21,646 --> 00:22:23,156
You've tried these
aggregate queries,


569
00:22:23,156 --> 00:22:25,066
but what you really want to
know is actually what Core


570
00:22:25,066 --> 00:22:25,666
Data's doing.


571
00:22:26,436 --> 00:22:28,706
In the labs quite frequently
we hear that, you know,


572
00:22:28,706 --> 00:22:30,406
you find Core Data a
bit of a black box.


573
00:22:30,406 --> 00:22:31,776
You're not sure what's
really happening,


574
00:22:32,426 --> 00:22:34,646
so you can actually
use SQL logging


575
00:22:34,646 --> 00:22:38,116
to tell you exactly what Core
Data's doing, passing argument


576
00:22:38,116 --> 00:22:40,436
on launch or even in
your user defaults called


577
00:22:40,496 --> 00:22:43,876
Com.Apple.CoreData.SQLDebug,
and you supply an Apple of one,


578
00:22:43,876 --> 00:22:45,896
two -- I'm sorry, a value
of one, two or three.


579
00:22:45,896 --> 00:22:48,136
Don't forget the dash
on the beginning.


580
00:22:48,366 --> 00:22:50,896
This will give you
the raw SQL queries


581
00:22:50,896 --> 00:22:52,676
that Core Data's
generating, and the more --


582
00:22:52,676 --> 00:22:53,756
the higher the value
you provide,


583
00:22:53,756 --> 00:22:55,306
the more information
you get back.


584
00:22:55,776 --> 00:22:57,946
You also get exact timings
for how long a fetch took


585
00:22:57,946 --> 00:23:00,106
or how long an insert took
and writing the values back


586
00:23:00,106 --> 00:23:03,316
and forth, but it does give
you a lot of information


587
00:23:03,376 --> 00:23:05,056
and don't use it unwisely.


588
00:23:05,836 --> 00:23:07,686
Just because you can see
how we've used a schema,


589
00:23:07,686 --> 00:23:09,866
don't trust that that's always
going to be the same way.


590
00:23:09,866 --> 00:23:13,256
You should never, ever try and
access data directly in SQLite.


591
00:23:13,326 --> 00:23:15,056
Always, always go
through Core Data.


592
00:23:15,136 --> 00:23:17,716
We have changed it in the past.


593
00:23:17,886 --> 00:23:18,556
Don't risk it.


594
00:23:19,826 --> 00:23:21,386
So, let's take a look at this.


595
00:23:21,676 --> 00:23:23,176
I built my app.


596
00:23:23,586 --> 00:23:26,456
I've changed the UA slightly so
that I now don't have my map.


597
00:23:26,456 --> 00:23:27,726
I actually get some
summary data.


598
00:23:28,496 --> 00:23:31,446
When I run the app, I get my
minimum average and maximum,


599
00:23:31,756 --> 00:23:34,106
and I also get my nice list
with the different magnitudes


600
00:23:34,106 --> 00:23:35,276
and the number of
quakes that happened.


601
00:23:37,726 --> 00:23:39,826
My fetch request is maybe
a bit more complicated now


602
00:23:39,826 --> 00:23:41,146
in using expression
descriptions,


603
00:23:41,196 --> 00:23:43,506
so let's use logging to find
out exactly what's going.


604
00:23:43,646 --> 00:23:44,006
I'm sorry.


605
00:23:44,136 --> 00:23:49,216
I'm going to go back a bit.


606
00:23:49,276 --> 00:23:52,986
Right, so if I stop the app, I'm
going to go to Product, Scheme,


607
00:23:52,986 --> 00:23:58,056
Edit Scheme, and I'm going
to add a launch argument.


608
00:23:58,616 --> 00:24:01,296
Again,
-Com.Apple.CoreData.SQLDebug.


609
00:24:01,426 --> 00:24:02,996
Let's specify a value of one.


610
00:24:02,996 --> 00:24:07,156
When we re-launch the app, we're
going to get some information


611
00:24:07,156 --> 00:24:10,196
in the console, and here we
can actually see the raw SQL.


612
00:24:10,196 --> 00:24:10,956
Select Min.


613
00:24:11,026 --> 00:24:14,746
That's the SQL minimum value
of magnitude from quake


614
00:24:15,096 --> 00:24:16,076
where time is equal to this.


615
00:24:16,076 --> 00:24:18,446
I've actually got a predicate
on there giving me a rough idea


616
00:24:18,446 --> 00:24:19,496
of the last seven days.


617
00:24:21,366 --> 00:24:25,456
Let's take a look when I go and
look at the grouped information.


618
00:24:25,576 --> 00:24:26,896
Well, we get more
information now.


619
00:24:26,896 --> 00:24:28,736
We get the very complicated
SQL statement.


620
00:24:29,246 --> 00:24:30,536
Select magnitude.


621
00:24:31,026 --> 00:24:35,536
Count it from quake grouped by
magnitude, ordered by magnitude,


622
00:24:35,536 --> 00:24:37,296
and this gives us the
dictionary back that we want,


623
00:24:37,296 --> 00:24:40,346
so at this point you might
be tempted to use NSLog


624
00:24:40,346 --> 00:24:41,996
or something to see exactly
what you're getting back


625
00:24:41,996 --> 00:24:44,226
so that you can work out how to
use it, but you don't have to.


626
00:24:44,976 --> 00:24:48,226
Let's try increasing the value
for the log level to three,


627
00:24:49,136 --> 00:24:50,656
so again, Product,
Scheme, Edit Scheme.


628
00:24:51,206 --> 00:24:56,206
Change one to three, and this
time when we re-run the app,


629
00:24:56,566 --> 00:24:57,886
we get a lot more information,


630
00:25:00,576 --> 00:25:02,126
so we've got our
average showing there.


631
00:25:02,126 --> 00:25:05,616
When I hit list, I get actually
the entire dictionary results.


632
00:25:05,616 --> 00:25:07,406
I get all -- to see
all the bound variables


633
00:25:07,406 --> 00:25:10,056
that Core Data has used to
give us the information back


634
00:25:10,566 --> 00:25:13,256
from the queries it's executed,
so this can be really helpful


635
00:25:13,256 --> 00:25:14,586
to debug what's going on.


636
00:25:14,726 --> 00:25:16,256
If you make performance
optimizations,


637
00:25:16,256 --> 00:25:17,936
you can see whether what
you've done has actually made a


638
00:25:17,936 --> 00:25:19,806
benefit, whether it
looks great in the SQL


639
00:25:20,326 --> 00:25:21,286
and it gives you a little peek


640
00:25:21,286 --> 00:25:24,266
into what we're doing behind the
scenes, so that's debug logging.


641
00:25:24,816 --> 00:25:29,676
We talked a little bit
about background tasks.


642
00:25:29,716 --> 00:25:31,766
Let's talk about concurrency
models that we can use


643
00:25:31,766 --> 00:25:36,116
when we're working
with background tasks.


644
00:25:36,116 --> 00:25:37,936
In previous years we've
talked in great detail


645
00:25:37,936 --> 00:25:40,046
about the different
confinement types,


646
00:25:40,046 --> 00:25:42,966
so you should be using private
queue types for background work,


647
00:25:43,026 --> 00:25:45,776
main queue types for your UI
work, and then you interact


648
00:25:45,776 --> 00:25:47,086
with those with the
perform block API.


649
00:25:47,346 --> 00:25:49,056
Don't use the old style
thread confinement,


650
00:25:49,896 --> 00:25:52,926
and you might perhaps have a
set up that looks like this


651
00:25:52,926 --> 00:25:55,296
with a main queue context and
a private queue context talking


652
00:25:55,296 --> 00:25:56,766
to the same persistent
store coordinator.


653
00:25:57,576 --> 00:25:59,176
Maybe you've got something
a little more complicated.


654
00:25:59,176 --> 00:26:00,796
Maybe this time you're
using a nested context.


655
00:26:00,796 --> 00:26:02,806
Maybe a main queue talks
to the private queue,


656
00:26:02,996 --> 00:26:04,716
which talks to the
persistent store coordinator.


657
00:26:05,116 --> 00:26:07,156
This will give you asynchronous
saves because a save --


658
00:26:07,156 --> 00:26:08,876
and it only goes up one
level, so when you save


659
00:26:08,876 --> 00:26:11,646
in the main queue context,
it saves the information just


660
00:26:11,646 --> 00:26:12,816
to the private queue context.


661
00:26:13,026 --> 00:26:15,886
When you call save on that, it
will then save to the store.


662
00:26:17,096 --> 00:26:18,906
Maybe you've got something a
little more complicated still,


663
00:26:19,956 --> 00:26:22,606
or maybe even more than
this, and this is all fine.


664
00:26:22,606 --> 00:26:26,256
If it's working for you, that's
great, but if you're running


665
00:26:26,256 --> 00:26:28,986
into a non-deterministic issue.


666
00:26:28,986 --> 00:26:30,466
Maybe occasionally
you're seeing something


667
00:26:30,466 --> 00:26:33,086
that you can't reproduce, maybe
a little jitter in a table view.


668
00:26:33,406 --> 00:26:34,796
Maybe something's taking
a little bit longer


669
00:26:34,796 --> 00:26:36,896
to save sometimes, but
not the other times.


670
00:26:37,236 --> 00:26:39,086
It may be that you're
running into a locking issue,


671
00:26:40,796 --> 00:26:44,196
so when you're working in this
context, and you call save,


672
00:26:45,576 --> 00:26:47,586
in order to make sure nothing
goes wrong during the save we


673
00:26:47,586 --> 00:26:48,876
lock the level above
because that's


674
00:26:48,876 --> 00:26:50,236
where the save information
goes to.


675
00:26:51,496 --> 00:26:52,966
That doesn't mean
that, you know,


676
00:26:52,966 --> 00:26:54,256
you're completely
locked out from anything.


677
00:26:54,256 --> 00:26:57,416
It just means that if you need
to execute a fetch or a save


678
00:26:57,766 --> 00:27:01,286
in the main queue context up on
the top right, that will have


679
00:27:01,316 --> 00:27:04,346
to wait until the lock is
removed, but you can continue


680
00:27:04,346 --> 00:27:05,696
to use objects just
like you did before.


681
00:27:05,696 --> 00:27:09,486
If you have to queue to save on
this context in the background,


682
00:27:09,736 --> 00:27:12,826
so maybe you've got that 173
milliseconds saved in the end


683
00:27:12,826 --> 00:27:13,996
of a big batch operation.


684
00:27:15,006 --> 00:27:17,076
Then we lock the
persistent store quantity.


685
00:27:17,076 --> 00:27:19,746
The save goes up one level,
so again, you can continue


686
00:27:19,746 --> 00:27:21,106
to operate with the
objects you already have


687
00:27:21,106 --> 00:27:23,386
in the other context, but if
you need to execute a fetch


688
00:27:23,386 --> 00:27:26,436
or a save, it won't complete
until the lock is removed.


689
00:27:26,696 --> 00:27:27,986
Otherwise the data
might be corrupted.


690
00:27:30,536 --> 00:27:33,826
When we're fetching, potentially
we're having to pull information


691
00:27:33,826 --> 00:27:36,846
out of the store, so the
locks go all the way down.


692
00:27:37,966 --> 00:27:39,966
Again, you can continue
to use your other context


693
00:27:39,966 --> 00:27:41,926
as you were before, but
if a fetch or a save needs


694
00:27:41,926 --> 00:27:44,696
to happen it will be blocked
until the lock is released,


695
00:27:46,076 --> 00:27:48,906
so if you're not seeing
problems with this,


696
00:27:48,956 --> 00:27:50,876
this is absolutely the model
that you should be using,


697
00:27:51,346 --> 00:27:54,796
if you are seeing issues that
you can't do anything about.


698
00:27:54,796 --> 00:27:56,396
You've done all the other
optimization tricks.


699
00:27:56,946 --> 00:28:01,116
You might want to consider using
a different concurrency style,


700
00:28:01,116 --> 00:28:03,616
and this time you have two
persistent store coordinators,


701
00:28:03,616 --> 00:28:05,926
two almost completely
separate Core Data stacks,


702
00:28:06,326 --> 00:28:08,196
so you've got one stack
for your background work,


703
00:28:08,316 --> 00:28:10,966
one stack for your main
queue work and they both talk


704
00:28:10,966 --> 00:28:14,376
to the same persistent store
file, and the benefit of this is


705
00:28:14,376 --> 00:28:15,656
that when we need
to perform a lock


706
00:28:15,656 --> 00:28:18,206
for something the only
really relevant bit to one


707
00:28:18,206 --> 00:28:21,926
of the other context is the
store file, so when you work


708
00:28:22,076 --> 00:28:25,046
in the background, for example,
the lock is on the store file.


709
00:28:25,646 --> 00:28:27,696
And file locks will come
and go much more quickly,


710
00:28:28,406 --> 00:28:30,886
so if you're performing
background work,


711
00:28:30,886 --> 00:28:32,266
like a massive import,
operation,


712
00:28:33,336 --> 00:28:36,256
then this will be a good way
to avoid locks particularly


713
00:28:36,256 --> 00:28:40,706
with a change that we've just
made, but if you're saying,


714
00:28:40,706 --> 00:28:42,556
"How do I use this in the
way that I am right now?


715
00:28:42,766 --> 00:28:43,286
What happens?


716
00:28:43,286 --> 00:28:44,656
How do I merge changes across?"


717
00:28:45,016 --> 00:28:46,926
Well, just like you do now.


718
00:28:47,086 --> 00:28:48,786
When you get a contexted
save notification,


719
00:28:49,366 --> 00:28:52,126
you can call merge changes from
contexted save notification


720
00:28:52,506 --> 00:28:55,946
and pass the context across and
poof, it will be imported just


721
00:28:55,946 --> 00:28:57,436
as you wish, but you should ask,


722
00:28:57,436 --> 00:28:58,876
"Is this really what
you want to do?"


723
00:29:00,256 --> 00:29:02,356
If you're using a fetch
results controller, for example,


724
00:29:02,356 --> 00:29:04,876
in iOS and you've got -- you've
just imported maybe 1000 objects


725
00:29:04,876 --> 00:29:07,896
into the background and your
Fetch Results Controller is tied


726
00:29:07,896 --> 00:29:08,566
to a table view.


727
00:29:08,566 --> 00:29:10,106
You've got all the
delegate methods set up.


728
00:29:10,376 --> 00:29:13,616
Then we have to make 1000
changes in that table view


729
00:29:13,616 --> 00:29:15,726
on a row by row basis, so
rows are being inserted,


730
00:29:15,726 --> 00:29:17,156
moved, pushed up and down.


731
00:29:17,156 --> 00:29:19,866
That's probably not
what you really want.


732
00:29:19,866 --> 00:29:20,756
That's going to take a while.


733
00:29:21,386 --> 00:29:23,266
Instead what you probably want
to do is listen out for them,


734
00:29:23,296 --> 00:29:26,586
contexted save notification
and then re-fetch the data,


735
00:29:26,586 --> 00:29:27,966
reload it in the table view.


736
00:29:27,966 --> 00:29:29,336
That will be much
faster to call.


737
00:29:29,336 --> 00:29:31,006
Perform fetch on the
fetch results controller


738
00:29:31,006 --> 00:29:32,056
and reload the table view


739
00:29:32,276 --> 00:29:34,296
than making 1000
changes individually.


740
00:29:37,236 --> 00:29:39,516
If you were there this morning
-- well, you see the video.


741
00:29:39,876 --> 00:29:42,416
We talked so that we've not
made price [inaudible] mode the


742
00:29:42,416 --> 00:29:47,286
default journaling mode with
Core Data with SQLite in iOS 7


743
00:29:47,346 --> 00:29:49,276
and OS X 10.9 Mavericks.


744
00:29:49,276 --> 00:29:52,176
And what this means is that we
actually now support multiple


745
00:29:52,176 --> 00:29:54,896
concurrent reads and one
concurrent write on the file


746
00:29:54,896 --> 00:29:59,826
at any one time, so if
you've got multiple stacks


747
00:29:59,876 --> 00:30:01,726
and you're doing a
background import over here


748
00:30:01,726 --> 00:30:04,246
and it's saving data into
the store, there are no locks


749
00:30:04,246 --> 00:30:05,106
on the store at this point


750
00:30:05,106 --> 00:30:05,976
because there's only
one write happening.


751
00:30:06,746 --> 00:30:09,316
Multiple reads can be happening,
potentially from multiple stacks


752
00:30:09,856 --> 00:30:11,756
and getting that
data out, no locks.


753
00:30:12,096 --> 00:30:16,906
This is also available in iOS
4 and 10.7 Lion and above,


754
00:30:17,406 --> 00:30:19,016
just by setting this
options dictionary


755
00:30:19,016 --> 00:30:20,556
when you add the persistent
store, and you call


756
00:30:20,556 --> 00:30:22,166
that at persistent store
with options method


757
00:30:22,506 --> 00:30:24,946
and that's SQLite
PRAGMAs option,


758
00:30:24,946 --> 00:30:26,276
journal mode equals wall.


759
00:30:29,476 --> 00:30:31,616
Okay, let's move onto
something a little different,


760
00:30:32,296 --> 00:30:35,706
text queries, so
there's some very,


761
00:30:35,706 --> 00:30:37,836
very simple things you can
do immediately to speed


762
00:30:37,836 --> 00:30:39,416
up when you're working
with predicates


763
00:30:39,686 --> 00:30:43,026
that involve some kind of text
query, so a predicate is the way


764
00:30:43,026 --> 00:30:44,576
that you limit the
results that you get back.


765
00:30:44,646 --> 00:30:47,316
In this case, I'm querying
against my contact entity.


766
00:30:47,406 --> 00:30:49,726
Perhaps the contacts app that
you saw at the beginning,


767
00:30:51,176 --> 00:30:53,986
and I'm asking for all the
objects that have a first name


768
00:30:54,046 --> 00:30:56,406
with John, and they're
aged over 40.


769
00:30:57,176 --> 00:31:00,876
In this case I'm asking for
a text query to happen first,


770
00:31:00,876 --> 00:31:04,496
so I'm saying I want to query
all the objects with the name


771
00:31:04,496 --> 00:31:06,806
of John, so I'm going through
ever single item in that table,


772
00:31:07,306 --> 00:31:08,436
pulling out the ones
that are called John,


773
00:31:08,436 --> 00:31:11,326
and then I'm executing the
age query on them to pull


774
00:31:11,326 --> 00:31:12,486
out the ones that are over 40.


775
00:31:12,486 --> 00:31:15,356
Text comparison is
quite expensive


776
00:31:16,106 --> 00:31:18,686
and much more expensive
than the numeric comparison.


777
00:31:18,906 --> 00:31:20,126
Computers are great
with numbers.


778
00:31:20,596 --> 00:31:22,326
A greater than is actually
a very cheap operation,


779
00:31:22,326 --> 00:31:25,786
so what's much better to
do is to swap these round


780
00:31:25,786 --> 00:31:27,346
and put the numeric
comparison first.


781
00:31:27,716 --> 00:31:29,816
This means that we're pulling
out, looking through our data,


782
00:31:30,166 --> 00:31:32,586
checking all the ones
that are over 40 and then,


783
00:31:32,676 --> 00:31:34,766
we then use that reduced
set to check for the ones


784
00:31:34,766 --> 00:31:36,386
that are called John, so always,


785
00:31:36,386 --> 00:31:38,296
always put your numeric
comparison,


786
00:31:38,296 --> 00:31:40,786
your most limiting
numeric comparison first


787
00:31:40,786 --> 00:31:42,816
and that will speed up
your predicate immediately.


788
00:31:45,196 --> 00:31:47,766
You should also look at which
type of query you're using,


789
00:31:48,496 --> 00:31:53,096
so in increasing cost at the top
we've got begins with and ends


790
00:31:53,096 --> 00:31:54,866
with and that's by
far the cheapest query


791
00:31:54,866 --> 00:31:55,596
that you can execute.


792
00:31:56,016 --> 00:31:58,096
What we're doing at that point
is we're checking the first


793
00:31:58,096 --> 00:31:58,916
characters match.


794
00:31:58,916 --> 00:32:00,286
As soon as we come across
one that doesn't match,


795
00:32:00,286 --> 00:32:01,236
we can move on to the next one.


796
00:32:01,566 --> 00:32:03,576
Ends with is the same thing,
but coming from the other end.


797
00:32:04,606 --> 00:32:06,506
Equality, well obviously we're
checking all the characters


798
00:32:06,506 --> 00:32:07,066
at this point.


799
00:32:07,756 --> 00:32:10,686
Contains is more expensive
because we have to work along


800
00:32:10,686 --> 00:32:12,826
and see whether it contains, and
then we'll keep going through


801
00:32:13,286 --> 00:32:15,166
and Match is the most expensive.


802
00:32:15,536 --> 00:32:17,356
We fire up a regular
Expression Engine for this.


803
00:32:17,356 --> 00:32:18,946
This is going to take
up a lot more time than,


804
00:32:18,946 --> 00:32:20,216
for example, a begins
with query.


805
00:32:20,216 --> 00:32:23,586
If you're at case and
diacritic insensitivity,


806
00:32:23,636 --> 00:32:24,876
that's the square bracket CD,


807
00:32:25,096 --> 00:32:26,826
that increases the
cost even more,


808
00:32:26,826 --> 00:32:30,636
so it's always worth
trying to work


809
00:32:30,636 --> 00:32:32,336
out whether this is really
what you want to be doing.


810
00:32:33,006 --> 00:32:34,636
If you writing a
dictionary app, for example,


811
00:32:34,966 --> 00:32:36,536
and you allow the user
to search in that,


812
00:32:36,536 --> 00:32:38,266
which is what they probably
want to do in a dictionary,


813
00:32:38,866 --> 00:32:41,206
what they're probably
looking for is a word


814
00:32:41,206 --> 00:32:42,976
that matches the first few
characters that they've typed.


815
00:32:42,976 --> 00:32:44,556
You probably don't need
to do a matches query.


816
00:32:44,556 --> 00:32:46,176
What you really want
is a begins with query.


817
00:32:46,176 --> 00:32:49,706
That will be much faster, give
the results much more quickly,


818
00:32:50,336 --> 00:32:51,916
so that's simple
predicate optimization,


819
00:32:52,076 --> 00:32:52,996
but what else can we do?


820
00:32:53,476 --> 00:32:54,996
Well I talked to you about case


821
00:32:54,996 --> 00:32:57,376
and diacritic insensitivity
being more expensive.


822
00:32:58,596 --> 00:33:00,646
How can we deal with that?


823
00:33:01,976 --> 00:33:04,456
And again, let's come
back to this idea


824
00:33:04,456 --> 00:33:05,966
of not duplicating information,


825
00:33:06,076 --> 00:33:08,236
and somehow actually duplicating
information is a good thing.


826
00:33:08,236 --> 00:33:12,436
We can use a canonicalized
search, so in addition


827
00:33:12,906 --> 00:33:14,836
to a text property that
maybe supports case


828
00:33:14,836 --> 00:33:16,246
and diacritic insensitivity,


829
00:33:17,396 --> 00:33:18,746
so maybe you've got
different cases.


830
00:33:18,746 --> 00:33:19,666
You've got lots of
different marks.


831
00:33:19,666 --> 00:33:21,546
Maybe, hopefully, you've
localized your apps


832
00:33:21,546 --> 00:33:24,096
for multiple languages and
the user's typing all sorts


833
00:33:24,096 --> 00:33:25,766
of stuff, but when they search
they want to just be able


834
00:33:25,766 --> 00:33:26,976
to type a few characters easily.


835
00:33:28,466 --> 00:33:31,196
We can save a second
text property at the time


836
00:33:31,196 --> 00:33:34,416
that you update the
localized text that has all


837
00:33:34,416 --> 00:33:36,226
that stripped out,
so you normalize it.


838
00:33:36,226 --> 00:33:37,866
You remove all the case
and the diacritic marks


839
00:33:37,866 --> 00:33:38,836
and you store it in, you know,


840
00:33:38,836 --> 00:33:41,326
a canonicalized property
in the same entity.


841
00:33:42,226 --> 00:33:44,986
You can then use a normalized
query, a square bracket N


842
00:33:44,986 --> 00:33:48,446
and parse in a normalized
version of the query term


843
00:33:48,446 --> 00:33:49,326
that the user's typed.


844
00:33:49,326 --> 00:33:51,556
So for example, if
they typed t-h-e,


845
00:33:51,636 --> 00:33:54,136
it should match maybe
capital T, h, and then e acute


846
00:33:54,136 --> 00:33:56,726
or something, and that will
happen much more quickly


847
00:33:56,816 --> 00:33:59,076
than having to fire up whatever
we need to do to do the case


848
00:33:59,076 --> 00:34:00,616
and diacritic insensitive
search,


849
00:34:01,126 --> 00:34:02,876
so that's another way
to speed things up.


850
00:34:03,556 --> 00:34:07,686
If that's not enough, then you
might consider using tokens,


851
00:34:08,176 --> 00:34:11,766
so rather than maintaining
a separate attribute,


852
00:34:12,266 --> 00:34:14,335
we actually maintain an
entirely separate entity


853
00:34:14,686 --> 00:34:18,056
and in this case, this is a
journal app, so I allow the user


854
00:34:18,056 --> 00:34:19,636
to have a journal
entry with a date


855
00:34:19,636 --> 00:34:21,466
and then they can type
whatever they want in there,


856
00:34:22,045 --> 00:34:25,556
but to make it as fast as
possible to search I'm going


857
00:34:25,556 --> 00:34:28,656
to create a second entity that
has a many-to-many relationship


858
00:34:28,656 --> 00:34:31,746
between these two, that contains
all the tokens whenever they set


859
00:34:31,746 --> 00:34:34,056
a string for the text
in my journal entry


860
00:34:34,126 --> 00:34:38,505
and that will be a normalized
token of each word in the entry,


861
00:34:38,505 --> 00:34:41,406
and we can get those tokens
out by calling something


862
00:34:41,406 --> 00:34:43,476
like components separated
by characters in a set.


863
00:34:43,476 --> 00:34:46,676
And maybe you want to separate
by whitespace, by symbol,


864
00:34:46,676 --> 00:34:48,735
punctuation, maybe a
combination of all of those.


865
00:34:49,266 --> 00:34:51,096
Maybe in an -- a, you know,
engineering app you should think


866
00:34:51,096 --> 00:34:52,755
about whether symbols
are important to you,


867
00:34:53,036 --> 00:34:55,306
but essentially you're
separating out tokens.


868
00:34:55,446 --> 00:34:57,956
And this means that you've
got tokens stored separately


869
00:34:57,956 --> 00:35:00,076
from the text and
you can now query


870
00:35:00,076 --> 00:35:01,836
against those using
a begins with query


871
00:35:01,946 --> 00:35:03,416
because if the user's
typing something,


872
00:35:03,416 --> 00:35:05,776
it's probably the beginning of
a word that they're looking for,


873
00:35:05,776 --> 00:35:08,366
and you can go straight
out to the token entity.


874
00:35:08,646 --> 00:35:11,046
Find the matching ones, and
then immediately get the related


875
00:35:11,046 --> 00:35:12,276
journal entries that
are tied to that,


876
00:35:12,276 --> 00:35:14,016
so that's even faster again.


877
00:35:14,016 --> 00:35:16,956
If it still doesn't
quite give you enough,


878
00:35:17,376 --> 00:35:20,646
then consider using a separate
stack, and I'm not just talking


879
00:35:20,646 --> 00:35:22,186
about a different
managed object context


880
00:35:22,186 --> 00:35:23,246
and persistent store
coordinator.


881
00:35:23,246 --> 00:35:25,156
I'm talking about a separate
store file all together,


882
00:35:25,156 --> 00:35:27,426
so you've got a completely
separate system.


883
00:35:27,696 --> 00:35:29,326
You've got your search
tokens stored on one side


884
00:35:29,326 --> 00:35:30,356
and you can query against that


885
00:35:30,356 --> 00:35:32,176
without having any
effect whatsoever


886
00:35:32,176 --> 00:35:36,006
with the primary context on
the other, and if you do that,


887
00:35:36,006 --> 00:35:38,516
and obviously you cannot have a
relationship between one object


888
00:35:38,516 --> 00:35:40,326
in one store and an
object in the other store,


889
00:35:40,896 --> 00:35:47,936
so use the URI representation
and you can call that


890
00:35:47,936 --> 00:35:50,106
and store the result that
you get from managed objects


891
00:35:50,106 --> 00:35:53,626
and store that in a secondary
persistent store stack.


892
00:35:54,516 --> 00:35:56,506
When you need to pull the
results out, you can then get


893
00:35:56,506 --> 00:35:58,456
that and then query
for objects that match.


894
00:35:59,026 --> 00:36:03,786
If that still doesn't give
enough, then you might need


895
00:36:03,786 --> 00:36:06,986
to consider having a hash
table in memory, and for this,


896
00:36:07,576 --> 00:36:09,866
you would create a
table for every --


897
00:36:09,866 --> 00:36:12,216
for the first three letters
of every token that you have.


898
00:36:13,376 --> 00:36:15,606
That's not that many items,
and you can keep that in memory


899
00:36:15,996 --> 00:36:17,756
and then as the user
starts typing something --


900
00:36:17,756 --> 00:36:19,746
well the first three letters are
going to limit it quite heavily,


901
00:36:19,746 --> 00:36:21,876
so then you can go out and
get the related tokens,


902
00:36:21,876 --> 00:36:23,086
the related journal entries


903
00:36:23,406 --> 00:36:25,456
and that will speed
things up considerably.


904
00:36:29,086 --> 00:36:32,036
So this is a debugging
and performance talk.


905
00:36:32,096 --> 00:36:33,806
Let's have a quick
chat about iCloud.


906
00:36:35,336 --> 00:36:36,956
Most of the content
here was discussed


907
00:36:36,956 --> 00:36:39,036
in great detail this morning,
so if you missed a session,


908
00:36:39,036 --> 00:36:39,966
catch up with a video.


909
00:36:40,736 --> 00:36:44,116
We've added a lot of information
to help you debug problems


910
00:36:44,116 --> 00:36:45,986
that you might find in your app.


911
00:36:46,316 --> 00:36:48,946
In particular we've added the
debug gauges, so we saw earlier


912
00:36:48,946 --> 00:36:49,946
that you were using
these to find


913
00:36:49,946 --> 00:36:52,156
out how much memory an
app is using very quickly.


914
00:36:52,686 --> 00:36:55,206
The iCloud gauge will give
you the usage that you've got,


915
00:36:55,206 --> 00:36:56,746
how much space is
left so you can check


916
00:36:56,746 --> 00:36:58,026
that everything is
connected properly.


917
00:36:58,026 --> 00:37:00,306
You'll get a little graph
of transfer activity,


918
00:37:00,396 --> 00:37:02,416
so as information goes up to
the Cloud, you get a green bar.


919
00:37:02,416 --> 00:37:04,256
As information comes
down, you get a blue bar,


920
00:37:04,426 --> 00:37:06,806
so that will help you check
that information is being pushed


921
00:37:06,806 --> 00:37:08,156
to the Cloud and
pulled in correctly.


922
00:37:08,206 --> 00:37:11,696
It will also give you a summary
of your documents directory


923
00:37:11,696 --> 00:37:13,376
with all the information that's
in there, so you can see,


924
00:37:13,376 --> 00:37:15,086
you know, when files are
changing, when they're --


925
00:37:15,086 --> 00:37:16,276
and when they're being created.


926
00:37:17,596 --> 00:37:20,496
We've also added a logging
option, so in addition


927
00:37:20,496 --> 00:37:22,276
to being able to see what Core
Data's doing underneath the


928
00:37:22,276 --> 00:37:24,696
hood, you can also see what
the ubiquity system is doing.


929
00:37:25,666 --> 00:37:28,426
Very similar as before,
Com.Apple.CoreData.


930
00:37:28,426 --> 00:37:31,306
Ubiquity.LogLevel and
again it takes a value


931
00:37:31,306 --> 00:37:32,126
of one, two or three.


932
00:37:32,516 --> 00:37:34,066
Specify this in the
same way as before,


933
00:37:34,066 --> 00:37:36,366
and your launch arguments
or in your user defaults,


934
00:37:36,726 --> 00:37:37,926
and you'll get a whole
bunch of logging.


935
00:37:38,736 --> 00:37:41,126
If you do run into
issues, enable the logging.


936
00:37:41,246 --> 00:37:43,686
File a bug, and that
helps us look


937
00:37:43,686 --> 00:37:47,416
into whether it's a
problem, so that's Core Data.


938
00:37:49,906 --> 00:37:51,066
Let's recap what
we've talked about.


939
00:37:51,506 --> 00:37:53,696
Above all, don't work too hard.


940
00:37:54,976 --> 00:37:55,916
Measure everything first.


941
00:37:55,916 --> 00:37:57,536
Use Instruments to tell
you what's going on.


942
00:37:57,536 --> 00:37:59,766
Get an objective measure of
problems that you're seeing.


943
00:37:59,766 --> 00:38:02,096
If something's taken a long
time, see how long it's taking.


944
00:38:02,176 --> 00:38:05,476
Wherever possible don't
bring more information


945
00:38:05,476 --> 00:38:06,676
into memory than
you really need.


946
00:38:07,186 --> 00:38:08,966
Use SQLite to do
your work for you.


947
00:38:08,966 --> 00:38:10,786
If you can perform some
kind of aggregate operation,


948
00:38:10,786 --> 00:38:12,366
maybe a minimum value
in the database,


949
00:38:12,636 --> 00:38:13,616
have it do that for you.


950
00:38:13,616 --> 00:38:15,766
Don't bring all the objects in,
and then calculate something.


951
00:38:16,646 --> 00:38:17,376
Measure again.


952
00:38:17,756 --> 00:38:19,366
See every change that you make.


953
00:38:19,366 --> 00:38:20,806
Make sure that you're
making those bars thinner


954
00:38:21,266 --> 00:38:22,506
and things are taking less time.


955
00:38:23,496 --> 00:38:24,726
Balance memory against speed.


956
00:38:25,326 --> 00:38:28,636
Don't use too much memory,
but don't slow things


957
00:38:28,636 --> 00:38:30,806
down by completely minimizing
the memory all together


958
00:38:30,806 --> 00:38:31,976
and then you're doing
a fetch request


959
00:38:32,176 --> 00:38:33,616
of one object multiple times.


960
00:38:34,126 --> 00:38:35,166
Optimize your predicates.


961
00:38:35,166 --> 00:38:36,946
Make sure you're doing the
right thing with text queries.


962
00:38:37,326 --> 00:38:38,366
Optimize your fetches.


963
00:38:38,366 --> 00:38:39,376
Use batch size.


964
00:38:39,896 --> 00:38:41,746
Optimize your saves so that
you're not saving too much.


965
00:38:41,746 --> 00:38:42,616
Use batches.


966
00:38:43,086 --> 00:38:43,886
Measure again.


967
00:38:44,596 --> 00:38:48,926
Profit. And for information, see
the usual suspects, Dave DeLong.


968
00:38:48,926 --> 00:38:50,096
He's our foremost evangelist.


969
00:38:50,096 --> 00:38:51,176
We have some documentation,


970
00:38:51,286 --> 00:38:52,616
and the dev forums
are there to help you.


971
00:38:53,446 --> 00:38:54,686
Thank you very much.


972
00:38:55,516 --> 00:39:00,516
[ Applause ]


973
00:39:01,016 --> 00:39:03,306
[ Silence ]

