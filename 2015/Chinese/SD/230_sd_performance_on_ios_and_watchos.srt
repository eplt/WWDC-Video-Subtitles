1
00:00:22,956 --> 00:00:24,658
iOS和watchOS的性能


2
00:00:31,632 --> 00:00:32,466
早上好


3
00:00:33,967 --> 00:00:37,004
我是 本
我是一名iOS性能工程师


4
00:00:37,538 --> 00:00:41,208
今天我们要谈一谈
iOS和watchOS的性能


5
00:00:42,876 --> 00:00:44,311
那么我们首先 要告诉你


6
00:00:44,645 --> 00:00:46,413
你为什么要思考
与性能相关的问题


7
00:00:46,647 --> 00:00:49,216
如果你之前从未思考过
你的app的性能如何


8
00:00:49,283 --> 00:00:50,417
那么为什么现在要开始


9
00:00:51,919 --> 00:00:54,388
希望我能说服你
留在你的座位上继续往下听


10
00:00:55,255 --> 00:00:58,125
然后我们可以继续聊一聊
你应该如何思考性能问题


11
00:00:58,525 --> 00:01:01,862
这个话题貌似非常宽泛
有时甚至令人生畏


12
00:01:02,362 --> 00:01:04,665
但是我们要把它细分成
几个类别


13
00:01:05,065 --> 00:01:07,167
并给你提供一些具体的策略


14
00:01:07,234 --> 00:01:10,037
来提高你的app
在这些方面的性能


15
00:01:11,038 --> 00:01:13,440
最终 很有可能
你会兴奋地发现自己


16
00:01:13,507 --> 00:01:15,676
可以给watchOS编写本地代码


17
00:01:15,909 --> 00:01:17,644
我们则要深入研究
在这个平台上


18
00:01:17,711 --> 00:01:20,948
你还可以为给用户最佳体验
做出什么贡献


19
00:01:22,015 --> 00:01:24,618
那么你为什么要
考虑性能问题呢


20
00:01:25,252 --> 00:01:29,156
最简单的回答是
性能是一个特性


21
00:01:29,957 --> 00:01:34,828
要想让你的app用户有良好的体验
性能是核心是中心要素


22
00:01:35,195 --> 00:01:38,131
它不是额外的津贴或奖金
或如果你有时间可以


23
00:01:38,198 --> 00:01:39,733
在任务结束时你可以得到的东西


24
00:01:40,467 --> 00:01:44,805
事实上 你在编写app时
应该时刻关注它的性能


25
00:01:45,339 --> 00:01:46,473
这样要求 有几个原因


26
00:01:48,041 --> 00:01:49,843
如果你的app反应迅速


27
00:01:49,910 --> 00:01:52,746
如果它总是立即
反应用户的输入


28
00:01:53,547 --> 00:01:55,983
就会构建起用户的信任


29
00:01:56,850 --> 00:02:01,355
那样就让用户知道
如果他们需要通过你的app


30
00:02:01,522 --> 00:02:03,223
访问信息或进行交互操作


31
00:02:03,624 --> 00:02:05,058
他们无需久等


32
00:02:05,526 --> 00:02:08,061
这会让他们很高兴
成为回头客


33
00:02:10,030 --> 00:02:11,932
如果你要在使用iOS 9
的iPad里


34
00:02:11,999 --> 00:02:14,101
采用多任务应用程序
Multitasking


35
00:02:14,201 --> 00:02:17,304
它不仅不能
满屏幕运行


36
00:02:18,138 --> 00:02:19,473
实际上它也不能
充分利用


37
00:02:19,540 --> 00:02:21,241
系统的资源


38
00:02:22,109 --> 00:02:25,646
所以app的性能问题
再也不只是给你的app用户


39
00:02:25,712 --> 00:02:27,314
带来糟糕的使用体验


40
00:02:27,648 --> 00:02:29,316
它还可会损害
另一个app的


41
00:02:29,416 --> 00:02:30,651
用户体验


42
00:02:31,585 --> 00:02:34,354
你肯定想成为
Multitasking里的好邻居


43
00:02:36,924 --> 00:02:39,860
所有App的体系结构都着眼于
高效利用系统资源


44
00:02:40,160 --> 00:02:42,863
比如CPU和内存
你利用它们时


45
00:02:42,930 --> 00:02:45,732
不只是感觉很好
其实也是在节省电池


46
00:02:45,799 --> 00:02:47,234
让用户可以
坚持一天


47
00:02:47,568 --> 00:02:48,735
对此他们真的很感激


48
00:02:50,170 --> 00:02:53,841
最后 iOS 9支持
范围庞大的硬件


49
00:02:54,341 --> 00:02:56,944
而要持续地
为所有的客户


50
00:02:57,010 --> 00:03:00,314
提供优秀的app和特色功能
性能是一个先决条件


51
00:03:03,984 --> 00:03:05,886
那么 我就有希望说服
各位 你们不必走出去了


52
00:03:07,554 --> 00:03:09,156
你们应该如何思考
有关性能的问题呢


53
00:03:09,489 --> 00:03:11,225
开发app的第一步


54
00:03:11,558 --> 00:03:14,161
是选择技术


55
00:03:15,062 --> 00:03:17,865
这一步至关重要 因为
你需要选择


56
00:03:17,998 --> 00:03:18,999
哪种技术会


57
00:03:19,066 --> 00:03:21,034
让你的用户有
最好的体验


58
00:03:22,569 --> 00:03:25,372
一旦你开始
构建应用程序


59
00:03:26,106 --> 00:03:27,708
你就可以开始
采取测量手段


60
00:03:27,774 --> 00:03:30,611
并真正理解
在你的app里用户


61
00:03:30,844 --> 00:03:32,412
在重要的交互中的
体验情况


62
00:03:34,081 --> 00:03:37,284
你的测量手段会告诉
你今天你的app的下载情况


63
00:03:37,918 --> 00:03:40,454
一旦你得到了那些数据
你就可以设定一些目标


64
00:03:40,687 --> 00:03:42,389
比如在把它提交给
应用商店之前 你想让


65
00:03:42,456 --> 00:03:43,957
你的app处于何种状态


66
00:03:45,058 --> 00:03:47,694
最后 一旦你
得到那些数据 你就已经准备好


67
00:03:47,761 --> 00:03:50,430
开始修改代码
来提高app的性能


68
00:03:50,497 --> 00:03:53,066
你可以遵循
一个很好的工作流程


69
00:03:53,300 --> 00:03:54,468
来全力实现你的目标


70
00:03:55,702 --> 00:03:57,971
那么让我们从
选择技术开始


71
00:03:59,006 --> 00:04:02,009
选择正确的工具
来完成这项工作是


72
00:04:02,075 --> 00:04:03,177
构建app的一项重要


73
00:04:03,443 --> 00:04:06,446
的早期工作 是保证app
性能卓越的一个前瞻性的步骤


74
00:04:07,214 --> 00:04:09,917
而选择技术
的第一步是


75
00:04:09,983 --> 00:04:11,118
了解的这些技术


76
00:04:11,652 --> 00:04:13,287
所以在这个演讲中


77
00:04:13,787 --> 00:04:17,057
我将引用今年
和前几年的几场其他演讲


78
00:04:17,824 --> 00:04:19,059
这几场
演讲都涉及了


79
00:04:19,293 --> 00:04:20,761
我们认为
有助于提高


80
00:04:20,861 --> 00:04:22,429
app性能的技术


81
00:04:24,198 --> 00:04:27,134
一旦你知道有多少
技术可以为你所用


82
00:04:28,202 --> 00:04:30,037
那么你就可以
根据你的app的


83
00:04:30,103 --> 00:04:32,239
设计构想和
工作内容


84
00:04:33,440 --> 00:04:35,042
来挑选最合适的技术


85
00:04:36,043 --> 00:04:38,712
举一个很好的例子
如果你的app需要


86
00:04:38,779 --> 00:04:40,080
存储三个字符串


87
00:04:40,948 --> 00:04:43,417
你可能可以把这些字符串
写进一个plist文件或


88
00:04:43,483 --> 00:04:44,852
放在用户默认中


89
00:04:45,485 --> 00:04:48,822
但是 如果您的app
需要使用3000个字符串


90
00:04:49,556 --> 00:04:50,757
你可能就要
考虑核心数据了


91
00:04:52,459 --> 00:04:53,627
说到核心数据


92
00:04:54,494 --> 00:04:55,762
当你
选择技术时


93
00:04:56,296 --> 00:04:57,264
我强烈建议你


94
00:04:57,331 --> 00:04:59,433
考虑Apple
APIs和框架


95
00:05:00,334 --> 00:05:02,569
我们在Apple
APIs和框架上花了大量时间


96
00:05:02,636 --> 00:05:04,104
力图
让它们满足你和你的用户的


97
00:05:04,404 --> 00:05:06,306
需求 我们也在其基础上
创建我们自己的产品


98
00:05:07,641 --> 00:05:11,278
采用Apple APIs和框架
的一个好处是


99
00:05:11,345 --> 00:05:13,747
用户在安装了
你的app之后


100
00:05:14,681 --> 00:05:16,383
他们可能会安装
一个iOS更新


101
00:05:16,884 --> 00:05:19,887
这些更新经常包含
对核心APIs和技术的


102
00:05:19,953 --> 00:05:21,522
性能改进


103
00:05:21,989 --> 00:05:23,757
所以下次
他们在安装了


104
00:05:23,824 --> 00:05:27,027
一个iOS更新之后 打开你的app
就会发现app神奇地变快了


105
00:05:28,195 --> 00:05:29,963
那么你选择了
某些技术


106
00:05:30,564 --> 00:05:31,698
并且开始
构建应用程序了


107
00:05:32,799 --> 00:05:33,967
现在我们要谈论测量问题


108
00:05:34,668 --> 00:05:36,403
有几个类别
的性能


109
00:05:36,470 --> 00:05:37,638
我们可以
考虑测量


110
00:05:38,939 --> 00:05:40,240
让我们从动画开始


111
00:05:40,841 --> 00:05:43,677
动画让你的app
活泼 流畅


112
00:05:43,744 --> 00:05:46,713
还能够让用户知道他们
在哪里 发生了什么


113
00:05:47,581 --> 00:05:49,349
测量动画性能的
最简单的方法


114
00:05:49,416 --> 00:05:52,186
是Core Animation工具


115
00:05:55,689 --> 00:05:59,326
反应速度测量的是
你对用户的输入做出反应的迅速程度


116
00:05:59,860 --> 00:06:01,628ddle
实际上 测量反应速度


117
00:05:59,860 --> 00:06:01,628
实际上 测量反应速度


118
00:06:01,695 --> 00:06:05,165
最简单的方法
看起来技术含量有点低


119
00:06:05,599 --> 00:06:06,533
但是它真的很强大


120
00:06:07,000 --> 00:06:09,269
并且只是插装
你的实际代码


121
00:06:09,937 --> 00:06:11,171
我将给它
举一个例子


122
00:06:12,673 --> 00:06:15,742
更复杂的场景
可能涉及多个线程


123
00:06:15,809 --> 00:06:17,411
或大量的系统交互


124
00:06:17,744 --> 00:06:19,780
对于这样的场景有一个
伟大的工具叫做系统跟踪


125
00:06:21,181 --> 00:06:22,583
最后要说的是内存


126
00:06:23,417 --> 00:06:26,320
内存是移动设备上
最宝贵的资源


127
00:06:26,987 --> 00:06:28,121
确保你的app的内存


128
00:06:28,188 --> 00:06:30,757
正好能够满足需要
不多不少


129
00:06:30,824 --> 00:06:32,292
这一点很重要


130
00:06:33,460 --> 00:06:35,796
和前面相似的是
有一个简单但强大的方法


131
00:06:35,863 --> 00:06:37,664
来了解app
内存的使用情况


132
00:06:37,731 --> 00:06:40,200
我马上就要谈到了
那就是Xcode调试器


133
00:06:41,368 --> 00:06:42,636
如果你要
了解更多情况


134
00:06:43,103 --> 00:06:44,872
还有一个很好的工具
叫做存储器分配


135
00:06:45,639 --> 00:06:48,075
如果你认为
有漏洞 也有一个工具


136
00:06:48,141 --> 00:06:49,376
来帮助你追踪
这些漏洞


137
00:06:51,345 --> 00:06:52,179
那么


138
00:06:53,413 --> 00:06:55,549
让我们举一个
代码插装的例子


139
00:06:55,616 --> 00:06:58,785
我这里有一个IBAction
连接到一个按钮


140
00:06:58,852 --> 00:07:00,287dle
所以当用户按下按钮时


141
00:06:58,852 --> 00:07:00,287
所以当用户按下按钮时


142
00:07:00,687 --> 00:07:02,756
我就要加载一个图像
并把它放在我的视图


143
00:07:03,524 --> 00:07:04,992
而且我想知道
这需要多长时间


144
00:07:05,926 --> 00:07:07,160
所以我要用一个AP


145
00:07:07,895 --> 00:07:09,796
叫做"CF绝对时间当前值"


146
00:07:10,731 --> 00:07:12,833
现在 我并不关心
当前时间的


147
00:07:12,900 --> 00:07:14,635
绝对值
但我在意的是


148
00:07:14,701 --> 00:07:16,403
它们之间
的差别


149
00:07:18,038 --> 00:07:21,141
这个API 尽管它是
SWIFT 是类型推断


150
00:07:21,208 --> 00:07:24,011
非常好 但是我将
告诉你它会返回一个双精度浮点


151
00:07:24,444 --> 00:07:27,848
具体地说 这个双精度浮点数
以秒为单位代表当前时间


152
00:07:28,682 --> 00:07:30,918
一秒钟实际上
是一段很长的时间


153
00:07:31,185 --> 00:07:33,120
如果你的app用了
一秒钟 你的用户


154
00:07:33,187 --> 00:07:34,388
真的会感觉到


155
00:07:35,289 --> 00:07:37,191
其实我们发现毫秒


156
00:07:37,391 --> 00:07:39,326
是一个更可行的
度量单位


157
00:07:40,027 --> 00:07:42,262
所以我们要从结束时间
减去开始时间


158
00:07:42,329 --> 00:07:44,164
并把结果
乘以一千


159
00:07:44,464 --> 00:07:46,333
以得到以毫秒为单位的
测量结


160
00:07:49,236 --> 00:07:52,439
概要描述
app的发行组态


161
00:07:52,506 --> 00:07:55,943
很重要 这样你将得到
你的用户所得到的


162
00:07:56,543 --> 00:07:57,644
所有的编译器优化


163
00:07:57,711 --> 00:08:00,247
你也将了解你的app
在它的领域内的


164
00:08:00,881 --> 00:08:03,417
实际表现；然
同样重要的是不要


165
00:08:03,483 --> 00:08:06,320
把你的性能插装提交
给应用商店


166
00:08:06,987 --> 00:08:09,356
所以我的建议是
你在Xcode中


167
00:08:09,423 --> 00:08:11,291
复制一份你的研发流程


168
00:08:11,491 --> 00:08:13,961
同时定义一个额外的定义


169
00:08:14,228 --> 00:08:17,497
这样您就可以
用性能插装


170
00:08:17,831 --> 00:08:20,701
轻松 快捷地
构建一个app的发布版本


171
00:08:21,902 --> 00:08:25,305
那么什么类型的反应
我们有兴趣测量呢


172
00:08:25,772 --> 00:08:28,075
当然是按键和
按钮


173
00:08:29,409 --> 00:08:32,645
大多数情况下 你可以
在IBActions中做这些


174
00:08:33,347 --> 00:08:37,150
你也可以用UIView
触摸处理代码做这些事


175
00:08:37,951 --> 00:08:39,986
或者你可能以
手势识别器为目标


176
00:08:41,755 --> 00:08:44,191
App性能的
另一个有趣的方面


177
00:08:44,258 --> 00:08:46,927
就是用户在
使用这个应用程序


178
00:08:46,994 --> 00:08:49,062
并切换到不同的
视图时感受如何


179
00:08:49,530 --> 00:08:51,465
无论他们是使用
标签栏还是模态视图


180
00:08:53,133 --> 00:08:55,202
在这种情况下
我们觉得思考


181
00:08:55,269 --> 00:08:57,204
"视图将显示"和"视图出现"
之间的时间


182
00:08:57,271 --> 00:08:59,773
是件有趣的事
因为那让你可以比较


183
00:09:00,107 --> 00:09:03,110
你的哪一个观点要花更长的时间
来准备 以出现在屏幕上


184
00:09:06,013 --> 00:09:07,548
那么你已经取得了
一些测量结果


185
00:09:07,648 --> 00:09:09,383
了解了
你的app的表现


186
00:09:10,384 --> 00:09:12,986
在你将app提交到应用商店之前
你希望它取得怎样的成绩


187
00:09:13,053 --> 00:09:14,388
要如何
设定这个目标呢


188
00:09:15,589 --> 00:09:18,892
在以60帧每秒的速度
运行时 动画


189
00:09:19,193 --> 00:09:20,961
感觉很棒 逼真
流畅又有生气


190
00:09:22,162 --> 00:09:23,997
今年我不打算
过多谈论动画


191
00:09:24,431 --> 00:09:26,667
因为去年有一个很好的关于动画的
演讲 你可以查看


192
00:09:27,067 --> 00:09:29,369
名字是"iOS Apps中的
高级图形和动画"


193
00:09:30,337 --> 00:09:32,973
那场演讲谈到了
核心动画工具


194
00:09:33,040 --> 00:09:34,842
以及如何
使用它


195
00:09:34,908 --> 00:09:36,743
来衡量并利用
所有硬件


196
00:09:36,810 --> 00:09:38,212
改善动画性能


197
00:09:39,513 --> 00:09:42,482
今天我们要把大量的
时间花在反应速度上


198
00:09:43,350 --> 00:09:45,319
反应速度 再说一次


199
00:09:45,552 --> 00:09:47,521
反应的是你如何对用户输入进行反应


200
00:09:47,988 --> 00:09:49,223
我们发现


201
00:09:49,556 --> 00:09:51,859
如果它需要超过一百毫秒


202
00:09:51,925 --> 00:09:53,227
用户就能够感觉到


203
00:09:53,560 --> 00:09:57,831
所以 你对任何响应性的目标
应是一百毫秒


204
00:09:58,732 --> 00:10:00,601le
顺便提一下 你想考虑


205
00:09:58,732 --> 00:10:00,601
顺便提一下 你想考虑


206
00:10:01,034 --> 00:10:05,038
在你要支持的最老的硬件上
实现这些性能目标


207
00:10:06,373 --> 00:10:08,175
如果你针对iOS 9


208
00:10:08,375 --> 00:10:10,744
那么可能是最早的iPad mini


209
00:10:11,078 --> 00:10:13,547
iPhone 4s 甚至 iPad 2


210
00:10:14,548 --> 00:10:15,749
如果你已经有了这其中之一


211
00:10:15,816 --> 00:10:18,118
或者更确切地说
你仍然还在用这着其中之一


212
00:10:18,185 --> 00:10:21,655
那么继续用它
接下来对它进行检测


213
00:10:22,523 --> 00:10:23,423
如果不是这样


214
00:10:23,490 --> 00:10:27,127
那么在Apple Online Store上
有很棒的翻新部件


215
00:10:31,698 --> 00:10:33,200
所以你已经设定了目标


216
00:10:33,400 --> 00:10:34,468
你已经做了检测


217
00:10:34,968 --> 00:10:37,871
现在你想继续通过
在你的app上更改代码


218
00:10:38,172 --> 00:10:39,439
来提高性能


219
00:10:40,574 --> 00:10:41,441
我们如何开始呢？


220
00:10:42,576 --> 00:10:44,311
首先 不用猜


221
00:10:45,078 --> 00:10:47,347
你一定想用工具做简要分析


222
00:10:47,581 --> 00:10:50,951
解决造成你的app性能问题的根源


223
00:10:51,752 --> 00:10:55,222
你的直觉总是对的
这想法很诱人


224
00:10:55,489 --> 00:10:57,457
但是这可能如同抛硬币一样不准确


225
00:10:58,859 --> 00:11:02,029
据此 不要过早优化


226
00:11:02,563 --> 00:11:05,699
除非你有证据表明
尽可能简单的做法


227
00:11:05,766 --> 00:11:09,937
不足以达到卓越的性能
否则不用把你的代码复杂化


228
00:11:10,437 --> 00:11:16,009
经常是人们引入一些机构
试图避开性能问题


229
00:11:16,476 --> 00:11:18,345
结果却是造成他们自身的性能问题


230
00:11:20,881 --> 00:11:22,382
一次只做一处更改


231
00:11:22,749 --> 00:11:26,854
你肯定想开始培养你的直觉


232
00:11:27,054 --> 00:11:29,923
以便知道
如何能够改进你的app的性能


233
00:11:30,457 --> 00:11:36,296
但是很难知道你做的哪件事
确实改进了你的app性能


234
00:11:36,864 --> 00:11:38,599
所以一次只改一处


235
00:11:39,366 --> 00:11:42,703
我这里实际想说的是没有奇迹


236
00:11:42,970 --> 00:11:44,671
这只是普通的调试而已


237
00:11:45,038 --> 00:11:49,176
所以同样要本着严谨而科学的态度
去排除


238
00:11:49,243 --> 00:11:51,311
app中存在的死机或功能问题


239
00:11:54,815 --> 00:11:57,084
这是我希望你打印出来的图片


240
00:11:57,150 --> 00:12:00,020
挂在你墙上的的图片
设成你Mac的壁纸


241
00:12:01,121 --> 00:12:03,557
这就是我们如何通过更改代码


242
00:12:03,757 --> 00:12:05,058
来改进app性能的


243
00:12:05,826 --> 00:12:08,428
首先你要做的是在脑海中重现这个问题


244
00:12:09,630 --> 00:12:14,434
之后用工具进行分析 了解


245
00:12:14,501 --> 00:12:15,903
你的代码是哪里


246
00:12:15,969 --> 00:12:16,870
造成了性能问题


247
00:12:17,604 --> 00:12:19,273
在一个足够大的代码库在


248
00:12:19,806 --> 00:12:22,276
你的直觉可能的确不对


249
00:12:22,376 --> 00:12:23,877
所以还是收集证据为好


250
00:12:24,912 --> 00:12:28,182
之后 一旦你找到


251
00:12:28,482 --> 00:12:31,585
造成你app中性能不理想的代码


252
00:12:32,286 --> 00:12:34,154
你就能确切算出你需要为此


253
00:12:34,221 --> 00:12:35,055
花费多长时间


254
00:12:35,489 --> 00:12:38,692
最后
你只要有针对性对对代码做一次更改


255
00:12:38,926 --> 00:12:40,527
以尝试达到你的目的


256
00:12:42,796 --> 00:12:46,233
常常是一处更改


257
00:12:46,300 --> 00:12:48,702
无法让你一次达到目的 事实上


258
00:12:49,069 --> 00:12:51,038
多次更改


259
00:12:51,371 --> 00:12:53,006
才能最终达到你的目的


260
00:12:53,707 --> 00:12:55,909
这就是为什么说这是一个周期
因为你可能会发现


261
00:12:56,143 --> 00:12:59,146
你更改代码并再次重现后 有所改善


262
00:12:59,213 --> 00:13:00,447
但没有达到你最终的目的


263
00:13:01,248 --> 00:13:04,384
所以你要继续这个周期
直到你满意


264
00:13:09,623 --> 00:13:13,460
幻灯片上是分析和检测情况
似乎都类似


265
00:13:13,527 --> 00:13:15,362
但是实际上


266
00:13:15,429 --> 00:13:16,797
这是改进你的app性能的


267
00:13:17,030 --> 00:13:18,465
两个分立的步骤


268
00:13:19,032 --> 00:13:22,636
再次分析时
采用工具如Xcode调试器


269
00:13:22,836 --> 00:13:25,539
以及Instruments:
Time Profiler


270
00:13:25,639 --> 00:13:28,275
就与你性能方面具体问题相关的代码


271
00:13:28,342 --> 00:13:29,443
得到一个全面的概览


272
00:13:30,344 --> 00:13:34,014
检测针对你代码某具体区域


273
00:13:34,314 --> 00:13:36,850
以准确了解用户的


274
00:13:36,917 --> 00:13:37,751
等待时间


275
00:13:38,118 --> 00:13:38,952
我给出的


276
00:13:39,019 --> 00:13:41,922
"CF absolute time
get current"的例子


277
00:13:42,256 --> 00:13:44,124
再次证明确实很好用


278
00:13:45,092 --> 00:13:47,394
对于更复杂的情形 有System
Trace


279
00:13:50,597 --> 00:13:52,099
所以让我们来谈谈响应响应性


280
00:13:57,404 --> 00:14:00,207
响应即是对用户输入的反应


281
00:14:00,841 --> 00:14:03,210
谈到响应性 我们不得不提到


282
00:14:03,277 --> 00:14:04,912
你app的主线程


283
00:14:05,412 --> 00:14:06,680
因为你app的主线程


284
00:14:06,747 --> 00:14:08,515
是你消耗所有用户输入的所在


285
00:14:09,016 --> 00:14:10,851
--来自触摸屏的一切


286
00:14:10,918 --> 00:14:14,154
一次敲击或一次滚动--即有来自设备
其他传感器的一切


287
00:14:14,221 --> 00:14:16,023
比如定位更改


288
00:14:16,723 --> 00:14:20,294
及多重任务缩略图及其他系统状态
事件等均在这里


289
00:14:21,695 --> 00:14:24,331
如果你的主线程主要针对


290
00:14:24,464 --> 00:14:25,766
用户输入响应任务


291
00:14:26,233 --> 00:14:28,402
你的app将始终感觉很棒


292
00:14:29,770 --> 00:14:31,672
如果你对你的主线程操作有些不够细心
或者


293
00:14:31,738 --> 00:14:33,607
也许你在你的主线程上


294
00:14:33,674 --> 00:14:34,508
什么都做


295
00:14:35,008 --> 00:14:37,744
那么你的app可能出现
停滞或冻结现象


296
00:14:40,547 --> 00:14:43,217
所以
我们应该避免对我们的主线程做什么？


297
00:14:44,384 --> 00:14:47,821
特别注意CPU密集型业务


298
00:14:48,488 --> 00:14:51,191
这可能是解析你从网络上下载的很长一
段字符串


299
00:14:51,258 --> 00:14:54,127
可能是对某图像进行过滤


300
00:14:54,695 --> 00:14:57,064
以及与外部资源有关的任务


301
00:14:57,531 --> 00:14:58,565
我回头还会讲这个问题


302
00:14:59,366 --> 00:15:02,035
我今天不打算花太多时间讲CPU密集
型业务


303
00:15:02,102 --> 00:15:04,104
因为本周开始的时候有一个非常好的演
讲


304
00:15:04,304 --> 00:15:05,572
演讲者做了


305
00:15:06,173 --> 00:15:07,841
叫做"Profiling in Depth"的仪器


306
00:15:08,041 --> 00:15:10,444
他们事实上讲到用仪器


307
00:15:10,511 --> 00:15:14,248
对其中CPU密集型业务做性能改进


308
00:15:14,715 --> 00:15:15,549
很棒


309
00:15:16,750 --> 00:15:19,753
所以我们回到与外部资源有关的任务


310
00:15:20,120 --> 00:15:22,556
其另一名称叫阻塞调用


311
00:15:23,357 --> 00:15:26,693
之所以叫这个名字是因为你的线程进展
被阻止所以你被阻断


312
00:15:27,661 --> 00:15:28,695
那么 什么是阻塞调用？


313
00:15:29,429 --> 00:15:31,899
你们中可能有人熟悉
系统调用（syscall）


314
00:15:33,233 --> 00:15:34,535
任何进行了系统调用的代码


315
00:15:34,601 --> 00:15:37,004
路径均被认为是阻塞调用


316
00:15:38,505 --> 00:15:39,573
正如我所说


317
00:15:39,740 --> 00:15:41,909
这一般涉及到


318
00:15:41,975 --> 00:15:43,510
目前不在内存中的资源


319
00:15:44,244 --> 00:15:46,747
一般是
从磁盘载入内容


320
00:15:46,980 --> 00:15:48,615
或网络上取用材料


321
00:15:49,950 --> 00:15:52,252
有时候 你的主线程也会被阻塞


322
00:15:52,886 --> 00:15:55,155
原因是在等待可用资源


323
00:15:55,756 --> 00:15:57,591
但是它是在等待他人完成资源使用


324
00:15:57,658 --> 00:16:00,827
因为该资源一次只允许
一个客户使用


325
00:16:04,198 --> 00:16:06,333
那么 你如何认出你线程的阻塞调用？


326
00:16:06,867 --> 00:16:08,402
有时它们刚好出现在你目前


327
00:16:09,336 --> 00:16:11,772
"同步"一词即表示阻塞


328
00:16:12,506 --> 00:16:14,741
所以这是一个线索
当你读代码时


329
00:16:14,808 --> 00:16:16,276
你要注意到它


330
00:16:17,411 --> 00:16:18,245
所以很好


331
00:16:18,312 --> 00:16:20,047
我们在我的代码中发现了这个阻
塞调用


332
00:16:20,113 --> 00:16:22,416
‘NSURLConnection
发送同步请求’


333
00:16:23,183 --> 00:16:24,117
那么 现在我做什么？


334
00:16:25,018 --> 00:16:27,921
有时会有一个同步的API --


335
00:16:28,088 --> 00:16:30,224
尤其是对于声称


336
00:16:30,290 --> 00:16:31,758
其名字同步的API--


337
00:16:32,426 --> 00:16:33,861
你可以轻松转换到这种API


338
00:16:34,528 --> 00:16:37,364
这种情况下 我们很幸运 而事实上


339
00:16:37,431 --> 00:16:39,933
这个名字中出现的是有用的"异步"字
样


340
00:16:40,400 --> 00:16:42,369
那么我们就确切知道了
自己要进入的是哪里


341
00:16:43,537 --> 00:16:46,173
很遗憾 这不似搜索和替换那么简单


342
00:16:46,707 --> 00:16:49,576
你正在改变你的代码的执行顺序


343
00:16:49,810 --> 00:16:51,512
你可能有与此次操作结果


344
00:16:51,578 --> 00:16:53,013
有关的其他代码


345
00:16:53,547 --> 00:16:56,383
所以很遗憾 需要一些调整


346
00:16:58,485 --> 00:16:59,753
但是让我说


347
00:17:00,587 --> 00:17:03,023
你没有能够轻松切换到的相当的asy
nc


348
00:17:03,090 --> 00:17:05,459
或者你想将全部代码


349
00:17:05,526 --> 00:17:07,728
一次操作即移出主线程


350
00:17:08,529 --> 00:17:11,330
这种情况下用Grand
CentralDispatch即可


351
00:17:12,398 --> 00:17:14,867
Grand Central Dispatch
是Apple的一项技术


352
00:17:15,002 --> 00:17:17,436
可管理你app中的全局线程池


353
00:17:17,738 --> 00:17:19,239
已经好了
即使你没有注意到


354
00:17:20,941 --> 00:17:25,479
如果你熟悉其他平台上的线程编程
Grand Central Dispatch


355
00:17:25,811 --> 00:17:28,949
在某种程度上
可完全避免混淆 消除你


356
00:17:29,016 --> 00:17:31,451
对于启动线程及其状态等的担忧


357
00:17:32,152 --> 00:17:34,188
让你明确出向运行的任务


358
00:17:34,254 --> 00:17:35,355
如封闭或阻塞


359
00:17:37,524 --> 00:17:40,527
这些封闭任务一旦你提交给
Grand Central Dispatch


360
00:17:40,594 --> 00:17:42,696
即在你的流程中任一线程上运行


361
00:17:48,936 --> 00:17:51,305
所有线程都很棒 因为你不必


362
00:17:51,371 --> 00:17:52,506
启动它们 也不必考虑


363
00:17:52,573 --> 00:17:55,142
它们的数量 但是它们会有警告


364
00:17:55,542 --> 00:17:58,912
由于你不控制你的代码在哪个线程上影
响


365
00:17:59,613 --> 00:18:01,715
你在封闭或阻塞任务中明确的任何操作


366
00:18:01,782 --> 00:18:04,685
必须在任一线程上均安全


367
00:18:07,154 --> 00:18:08,388
有些什么例子吗？


368
00:18:09,823 --> 00:18:12,226
一些对象事实上只是被限制


369
00:18:12,292 --> 00:18:13,360
进入主线程


370
00:18:13,861 --> 00:18:16,196
例如UIKit视图和控制器


371
00:18:17,030 --> 00:18:21,168
必须在主
线程上创建修改或销毁


372
00:18:22,503 --> 00:18:25,372
一些对象如Foundation和C
ore Graphics


373
00:18:25,839 --> 00:18:27,541
可采用任何线程


374
00:18:28,475 --> 00:18:31,245
但是 其中许多另有规定


375
00:18:31,578 --> 00:18:33,080
这些规定是调用者提出


376
00:18:33,146 --> 00:18:37,417
目的是确保当时只有一个线程被采用


377
00:18:38,118 --> 00:18:39,920
它们内部无自我保护


378
00:18:40,420 --> 00:18:42,656
所以 如果你要用于多线程


379
00:18:43,023 --> 00:18:45,659
你常常必须自行采取保护


380
00:18:46,026 --> 00:18:49,096
为此 最好的方法是GCD串行队列


381
00:18:50,531 --> 00:18:52,566
要想知道你的对象预计会被如何处理


382
00:18:52,633 --> 00:18:54,601
最好的方法是读标题


383
00:18:54,902 --> 00:18:56,870
每个对象 通常在靠近初始化程序处


384
00:18:57,104 --> 00:18:59,606
应有一个描述 确切说明该对象


385
00:18:59,673 --> 00:19:01,341
在你的app中如何通过线程被存取


386
00:19:01,975 --> 00:19:03,410
如此 让我们回到我的例子


387
00:19:04,378 --> 00:19:05,512
我在这个代码中做什么？


388
00:19:05,579 --> 00:19:07,114
我从一个文件中加载一些数据


389
00:19:08,415 --> 00:19:09,783
我对一个图像进行处理和过滤


390
00:19:10,817 --> 00:19:13,620
最后
我把它放在我视图层次的图像视图中


391
00:19:14,655 --> 00:19:17,424
那么现在
当用户敲击我app中的一个按钮时


392
00:19:18,425 --> 00:19:19,860
我的主线程就有点像这样


393
00:19:20,360 --> 00:19:23,463
它会按顺序做3件事


394
00:19:24,464 --> 00:19:27,501
简单 直接 很好理解 很棒


395
00:19:28,836 --> 00:19:29,770
遗憾地是


396
00:19:30,137 --> 00:19:32,306
如果在我做这件事的时候


397
00:19:32,372 --> 00:19:34,942
用户偶尔做尝试
向右滚动或旋转


398
00:19:35,876 --> 00:19:41,081
我们将无法操作输入项
只能拖后


399
00:19:42,316 --> 00:19:44,351
关于阻塞请求


400
00:19:44,418 --> 00:19:47,020
你永远不知道它们要花的时间
这就像天气的变化一样


401
00:19:47,521 --> 00:19:51,325
用户需要等待不知道有多久


402
00:19:51,792 --> 00:19:52,793
这会使他们很沮丧


403
00:19:54,027 --> 00:19:55,329
那么如何解决这一问题呢？


404
00:19:55,863 --> 00:19:58,365
我们可以使用
Grand Central Dispatch


405
00:19:58,432 --> 00:20:00,634
我们可以使用
Grand Central Dispatch API的


406
00:20:00,701 --> 00:20:02,503
"dispatch async"异步执行


407
00:20:02,669 --> 00:20:05,205
现在 "dispatch async"
采取了两个命令参数


408
00:20:05,839 --> 00:20:07,307
第一个需要输入的是


409
00:20:07,875 --> 00:20:10,244
你想使用哪一个队列


410
00:20:10,844 --> 00:20:13,280
如我所提到的那样
你的app内已经有几个队列


411
00:20:13,747 --> 00:20:15,282
由GCD为你创建


412
00:20:15,816 --> 00:20:19,686
我将使用 "dispatch get global queue"
API得到其中之一


413
00:20:20,387 --> 00:20:23,223
因为有几个可供选择
我需要告知GCD


414
00:20:23,290 --> 00:20:24,124
我想要哪一个


415
00:20:24,858 --> 00:20:27,494
这儿我要用
"Quality of Service"等级


416
00:20:28,095 --> 00:20:30,430
"Quality of Service"
是关于怎样告知系统


417
00:20:30,497 --> 00:20:34,668
你请求它完成的工作
相对于app上的其它工作


418
00:20:34,935 --> 00:20:36,470
以及系统内的其它工作有多重要


419
00:20:37,237 --> 00:20:38,238
在这种情况下


420
00:20:38,305 --> 00:20:40,741
因为这是用户行为
的直接结果


421
00:20:41,208 --> 00:20:43,343
并且用户
也许正在等待这一结果


422
00:20:43,677 --> 00:20:45,679
我将使用"user-initiated"


423
00:20:45,746 --> 00:20:46,580
QOS等级


424
00:20:48,615 --> 00:20:50,684
"dispatch async"


425
00:20:51,318 --> 00:20:53,787
最后的参数是闭包
包含你想让它运行的代码


426
00:20:55,656 --> 00:20:57,191
好了
完成了


427
00:20:57,424 --> 00:20:58,292
已经离开了主线程


428
00:20:58,492 --> 00:20:59,326iddle
好了吗？


429
00:21:00,527 --> 00:21:01,361
还没完全好


430
00:21:01,895 --> 00:21:03,697
如我提到的 UIKit
views


431
00:21:03,764 --> 00:21:06,466
和controllers
只是在主线程上使用才安全


432
00:21:07,134 --> 00:21:08,535
所以我不能把它们置于该闭包内


433
00:21:10,070 --> 00:21:12,406
因此这并不是代码最慢的部分


434
00:21:12,472 --> 00:21:13,507
对吗？


435
00:21:13,574 --> 00:21:15,242
前两行是阻塞请求


436
00:21:16,143 --> 00:21:18,378
为什么我不把它移到主线程上？


437
00:21:20,047 --> 00:21:22,115
不幸地是 那样也是不行的


438
00:21:22,449 --> 00:21:24,051
因为我实际已经改变了代码


439
00:21:24,117 --> 00:21:25,452
执行的命令


440
00:21:26,453 --> 00:21:28,755
该关闭并不一定在


441
00:21:29,056 --> 00:21:31,391
"dispatch async"
返回的的时候运行


442
00:21:31,558 --> 00:21:33,760
当然希望它将很快运行


443
00:21:34,494 --> 00:21:35,662
最有可能的是


444
00:21:36,263 --> 00:21:37,931
一旦GCD将工作送至


445
00:21:37,998 --> 00:21:40,100
dispatch queue
它会立即进入到


446
00:21:40,167 --> 00:21:42,302
下一行 在此点上


447
00:21:42,936 --> 00:21:44,505
我的图像仍然可能没有


448
00:21:45,072 --> 00:21:46,440
用户将永远看不到他们的图像


449
00:21:47,074 --> 00:21:48,275
这会使他们抓狂的


450
00:21:49,943 --> 00:21:51,144
那么如何处理这种情况呢？


451
00:21:51,678 --> 00:21:53,981
我们实际上可以向"dispatch async"


452
00:21:54,982 --> 00:21:56,250
发出另外一个请求
这次


453
00:21:56,316 --> 00:21:58,585
我们将使用一个特别的队列叫做
主队列


454
00:21:59,086 --> 00:22:02,322
主队列则保证会由主线程服务


455
00:22:02,756 --> 00:22:04,458
你可以使用API
dispatch的


456
00:22:04,525 --> 00:22:06,493
"get main queue"获得主队列


457
00:22:07,227 --> 00:22:08,128
这意味着


458
00:22:08,962 --> 00:22:11,832
如果你有对象需要进入


459
00:22:11,899 --> 00:22:14,668
主线程 你可以把它们放进闭包中
并发给dispatch


460
00:22:14,735 --> 00:22:16,270
你只需要确保它们这个队列中运行


461
00:22:16,870 --> 00:22:18,038
现在
我们已经做到了


462
00:22:18,105 --> 00:22:20,307
我的imageView完好


463
00:22:21,675 --> 00:22:22,776
这样


464
00:22:23,110 --> 00:22:24,778
我们将该工作退出主线程


465
00:22:25,379 --> 00:22:27,147
但是当我们需要使用主线程上的


466
00:22:27,214 --> 00:22:29,416
对象时 一旦数据准备好


467
00:22:29,483 --> 00:22:31,351
我们就可以这样做


468
00:22:32,419 --> 00:22:35,122
顺便说一下 我们最初要解决的问题


469
00:22:35,856 --> 00:22:37,558
如果用户尝试 滚动或旋转


470
00:22:38,392 --> 00:22:40,561
将会立刻得以处理


471
00:22:41,428 --> 00:22:42,629
谢谢！


472
00:22:47,367 --> 00:22:49,670
那么你可能在代码中发现


473
00:22:49,736 --> 00:22:50,904
哪一种类型的阻塞请求？


474
00:22:50,971 --> 00:22:52,873
它们在暗处 可能藏在各种地方


475
00:22:54,508 --> 00:22:55,909
如我所提到的那样 联网、


476
00:22:56,176 --> 00:22:57,978
NSURL
Connection和朋友


477
00:22:58,212 --> 00:23:00,414
很容易无意间


478
00:23:00,781 --> 00:23:02,449
向网络发出同步请求


479
00:23:03,517 --> 00:23:05,752
通常 你可以切换到异步API


480
00:23:06,854 --> 00:23:09,423
或者如果你想要对app何时进入网络


481
00:23:09,656 --> 00:23:11,625
有更多的控制


482
00:23:12,426 --> 00:23:15,095
在某些情况下 让它在不运行时
进行下载


483
00:23:15,596 --> 00:23:18,799
我建议你查看NSURL
Session后台演讲


484
00:23:20,467 --> 00:23:23,871
Foundation initializers
当你在代码中遇到这些问题时


485
00:23:23,971 --> 00:23:25,072
它们并非看起来那么可怕


486
00:23:25,205 --> 00:23:26,073
它只是一行


487
00:23:26,139 --> 00:23:27,007
有什么可怕的？


488
00:23:27,608 --> 00:23:29,009
但是 其中一些


489
00:23:29,243 --> 00:23:31,645
像名为"contents of file"或者


490
00:23:32,279 --> 00:23:33,780
"contents of URL"


491
00:23:34,114 --> 00:23:36,617
可能不得不使用硬盘或其它资源


492
00:23:36,683 --> 00:23:37,684
来满足要求


493
00:23:39,086 --> 00:23:40,821
最后 Core Data


494
00:23:41,522 --> 00:23:44,691
它们看起来像一些对象 对吗？


495
00:23:45,425 --> 00:23:48,195
Core Data代表
你不断地进行很多I/O


496
00:23:49,363 --> 00:23:51,365
幸运地是 很容易将一些


497
00:23:51,431 --> 00:23:53,133
记录的操作移到


498
00:23:53,333 --> 00:23:54,801
不同的并发模式


499
00:23:55,335 --> 00:23:58,005
实际上 今年在Core
Data内有一个新的API


500
00:23:58,238 --> 00:24:01,408
简化各种一般的批量操作


501
00:24:02,075 --> 00:24:04,077
你可以另选时间从演讲中了解


502
00:24:04,444 --> 00:24:06,146
"Core Data的
新变化是什么"


503
00:24:06,380 --> 00:24:08,482
所以如果你发现了一个阻塞请求


504
00:24:08,982 --> 00:24:10,350
切换到异步API


505
00:24:10,951 --> 00:24:11,818
或者使用GCD


506
00:24:12,619 --> 00:24:15,088
如果你想更多了解GCD 包括


507
00:24:15,155 --> 00:24:18,258
今年可以简化一般操作的新API


508
00:24:18,725 --> 00:24:21,528
以及前面提到的quality
of service等级


509
00:24:22,262 --> 00:24:24,331
这儿一小时前就有一个不错的会话


510
00:24:24,398 --> 00:24:27,234
称作 "GCD Building
Responsive and Efficient Apps"


511
00:24:27,401 --> 00:24:28,535
我建议你看看它


512
00:24:32,272 --> 00:24:34,308
让我们继续看一看存储


513
00:24:35,442 --> 00:24:38,312
我说过存储是移动设备上


514
00:24:38,579 --> 00:24:39,446
最宝贵的资源


515
00:24:41,715 --> 00:24:45,018
如果你计划在app中采用多任务处理


516
00:24:45,953 --> 00:24:47,721
你不能再自由使用屏幕


517
00:24:48,255 --> 00:24:51,225
当然你也
不能自由使用


518
00:24:51,291 --> 00:24:52,526
其它系统资源


519
00:24:54,895 --> 00:24:56,430
如果你把一些代码从app带入


520
00:24:56,496 --> 00:24:58,565
watchOS 那么 重要的是


521
00:24:58,632 --> 00:25:00,334
内存占用应当紧凑


522
00:25:02,336 --> 00:25:05,239
另外 iOS 9支持很大范围的硬件


523
00:25:05,873 --> 00:25:08,742
如果你想把大型apps
和功能带入一些


524
00:25:08,809 --> 00:25:10,811
OS支持的低端设备


525
00:25:11,512 --> 00:25:13,680
存储在这些系统中非常重要


526
00:25:14,481 --> 00:25:17,084
最后 如果你是扩展的开发者


527
00:25:17,651 --> 00:25:19,987
想一想你的扩展也许现在被要求运行


528
00:25:20,053 --> 00:25:23,223
而这时
屏幕上还有两个其它的apps


529
00:25:24,191 --> 00:25:26,760
因此 存储会是十分需要的 你需要


530
00:25:26,827 --> 00:25:28,896
尽可能少地使用


531
00:25:30,964 --> 00:25:33,300
现在
让我们看看存储在iOS上如何工作


532
00:25:35,302 --> 00:25:36,136
基本原则


533
00:25:36,470 --> 00:25:39,439
任何iOS 装置里
都没有足够的物理内存


534
00:25:39,740 --> 00:25:42,743
把所有暂停的App
同时保存在RAM里


535
00:25:44,645 --> 00:25:47,314
当我们有内存压力时
我们实际上必须


536
00:25:47,381 --> 00:25:50,484
清理一些事情出去
把空间留给前景无限的app


537
00:25:51,485 --> 00:25:55,189
在OS X 或PC 操作系统上
我们可能要首先


538
00:25:55,255 --> 00:25:57,758
要把这些app的状态
写到磁盘上 但是


539
00:25:57,824 --> 00:26:00,093
这在移动装置上
根本行不通


540
00:26:00,594 --> 00:26:02,796
所以 一旦你要清理空间
你就必须消失


541
00:26:04,765 --> 00:26:06,900
还有更多细节
可以慢慢详述


542
00:26:07,434 --> 00:26:10,637
实际上前几年
有一个所谓的伟大谈话


543
00:26:10,737 --> 00:26:12,172
叫做"iOS App 性能内存"


544
00:26:13,040 --> 00:26:15,042
滑动模板和颜色
稍微有点不同


545
00:26:15,108 --> 00:26:17,778
但是信息真的是
货真价实


546
00:26:17,845 --> 00:26:20,013
所以如果你感兴趣的话
请去看看那个产品


547
00:26:20,080 --> 00:26:21,215
学习学习
这是如何运作的


548
00:26:22,482 --> 00:26:24,785
但是如果你以前
从未想过app里有内存


549
00:26:25,185 --> 00:26:26,220
总是归结为


550
00:26:26,954 --> 00:26:28,689
回收内存需要花时间


551
00:26:29,189 --> 00:26:31,425
如果你已经用完
系统中所有


552
00:26:31,491 --> 00:26:33,460
可用的内存
然后需要更多


553
00:26:33,861 --> 00:26:36,230
你可能要等待
而系统清理一些东西


554
00:26:36,296 --> 00:26:37,164
以你的名义清理


555
00:26:37,931 --> 00:26:40,200
如果你突然请求
大量内存


556
00:26:40,968 --> 00:26:42,970
系统就需要
清理若干不同内容


557
00:26:43,036 --> 00:26:43,937
来满足你的请求


558
00:26:44,371 --> 00:26:46,607
这影响到
App的反应效率


559
00:26:48,976 --> 00:26:50,878
相反 当你
在背景里时


560
00:26:51,545 --> 00:26:53,180
如果你的足迹
非常简缩


561
00:26:53,680 --> 00:26:55,482
实际上
你不太可能成为


562
00:26:55,549 --> 00:26:56,917
被清理之列


563
00:26:57,417 --> 00:26:59,319
所以当用户
返回到你的app时


564
00:26:59,720 --> 00:27:02,022dle
你能够恢复原貌
而不是重启


565
00:26:59,720 --> 00:27:02,022
你能够恢复原貌
而不是重启


566
00:27:02,589 --> 00:27:03,624
这感觉就快多了


567
00:27:05,492 --> 00:27:07,528
所以 如果你以前
从未想过内存的话


568
00:27:08,328 --> 00:27:09,930
这真是很重要的
第一步


569
00:27:10,063 --> 00:27:11,932
要合理化你的
App内存足迹


570
00:27:12,599 --> 00:27:14,668
也就是说
要想一想各种类型


571
00:27:14,735 --> 00:27:16,170
所用资源的类型


572
00:27:17,070 --> 00:27:20,807
这些可能是字符串；
可能是JSON 或 XML的小泡泡


573
00:27:20,874 --> 00:27:22,075
你从网络上下载的这些


574
00:27:22,943 --> 00:27:23,977
还有图片 也是


575
00:27:24,044 --> 00:27:26,380
来自网络 或者
用户用照相机照的


576
00:27:27,080 --> 00:27:29,917
还有 Core Data管理
的东西 用了很多


577
00:27:29,983 --> 00:27:32,452
潜在的资源
似乎是奇迹发生


578
00:27:34,388 --> 00:27:36,757
一旦你思考
这些资源 你就会开始


579
00:27:36,823 --> 00:27:40,127
按照用户互动
把他们分组


580
00:27:40,194 --> 00:27:43,397
归类 这有助于
你建立一个思想模式


581
00:27:43,463 --> 00:27:45,132
对于自己App
所用的资源


582
00:27:46,366 --> 00:27:47,267
一旦你已经那样做了


583
00:27:47,534 --> 00:27:50,070
我们可以用Xcode 调试器
快速检查你的作业


584
00:27:51,538 --> 00:27:53,106
要了解更多细节


585
00:27:53,173 --> 00:27:54,341
我们可以去配置栏


586
00:27:54,408 --> 00:27:55,242
和遗漏工具


587
00:27:55,876 --> 00:27:57,511
我不想说这么多
今天


588
00:27:57,578 --> 00:27:58,412
但请找找


589
00:27:58,478 --> 00:28:00,414
去年的类似谈话
名叫"用工具


590
00:28:00,480 --> 00:28:02,149
提高你的App"
从那里开始看吧


591
00:28:03,750 --> 00:28:05,485
所以我们返回到
Xcode调试器


592
00:28:06,453 --> 00:28:09,056
我已经下载了
Photos框架案例app


593
00:28:09,223 --> 00:28:10,524
这是从苹果开发者
网站下载的


594
00:28:11,258 --> 00:28:13,427
我已经安装到手机中
打开了Xcode 项目


595
00:28:13,660 --> 00:28:14,595
草创并运行


596
00:28:15,295 --> 00:28:18,999
现在我刚刚开始看看左上方
在我调试器的Xcode窗口的左上方


597
00:28:19,399 --> 00:28:20,334
放大进去


598
00:28:21,435 --> 00:28:23,403
这里 正好我看到


599
00:28:23,470 --> 00:28:26,406
不用眼睛贴着手机屏幕
也能看到第一个数据 太有趣了


600
00:28:27,307 --> 00:28:29,543
现在我知道
在我的app发起之后


601
00:28:29,610 --> 00:28:31,044
在用户可以做任何事情之前


602
00:28:31,378 --> 00:28:33,380
我正在使用大约10MB的内存


603
00:28:35,916 --> 00:28:37,918
我想要搜集的下一个数据点


604
00:28:38,452 --> 00:28:39,686
就是我想要离开


605
00:28:39,753 --> 00:28:42,556
所有在我的App中
最常见的用户交互都执行了


606
00:28:42,823 --> 00:28:45,526
因为这是一个照片App
所以我会打开一张照片


607
00:28:46,460 --> 00:28:48,795
现在我明白了
每打开一张照片


608
00:28:49,062 --> 00:28:51,665
我的App另外需要
大约2.5兆的内存


609
00:28:53,066 --> 00:28:55,836
在这一点上 另一个有趣的实验是


610
00:28:56,303 --> 00:28:58,539
一遍又一遍地重复执行同样的动作


611
00:28:58,605 --> 00:29:03,343
所以 我可能会多次打开
一张相同的照片或两张不同的照片


612
00:29:04,144 --> 00:29:06,079
如果我的内存占用持续增长


613
00:29:06,480 --> 00:29:08,482
我可能需要解决一下内存方面的问题


614
00:29:10,517 --> 00:29:11,885
最后有趣的是


615
00:29:12,586 --> 00:29:15,756
我需要使用我设备上的
Home按钮来暂停App


616
00:29:16,223 --> 00:29:18,792
而且我想看看当它进入后台时
会发生什么


617
00:29:19,459 --> 00:29:22,529
它看起来好像比它刚刚启动之后


618
00:29:22,596 --> 00:29:24,264
要稍微小了一点点


619
00:29:25,299 --> 00:29:26,834
这真是对打击很好的一种平衡


620
00:29:27,734 --> 00:29:30,537
你不想再重复你在恢复期间所做的工作


621
00:29:31,338 --> 00:29:33,640
但你也想保持后台的紧凑


622
00:29:33,841 --> 00:29:36,143
以确保你的用户实际体验到那个恢复


623
00:29:41,281 --> 00:29:42,182
需要注意的是


624
00:29:42,649 --> 00:29:43,917
照片框架示例App


625
00:29:43,984 --> 00:29:46,453
实际上并不需要做什么
特别的事情或施展魔法


626
00:29:46,653 --> 00:29:47,688
以实现这一行为


627
00:29:48,121 --> 00:29:50,190
它实际上只是一个非常简单的


628
00:29:50,257 --> 00:29:52,826
对苹果技术最小的一种应用


629
00:29:53,427 --> 00:29:56,964
而且苹果技术实际上
通常会将这个行为


630
00:29:57,030 --> 00:29:59,800
进行内置
而它们只是管理一下基本资源


631
00:30:00,033 --> 00:30:02,970
以自动响应于应用程序生命周期事件


632
00:30:03,270 --> 00:30:04,438
所以你并不需要担心这个


633
00:30:05,606 --> 00:30:06,473
但是


634
00:30:06,540 --> 00:30:08,442
如果你有大的对象或者你自己的其他资
源


635
00:30:08,509 --> 00:30:11,345
那么你将有一些动态上的损失


636
00:30:11,411 --> 00:30:14,081
并会返回来响应应用程序生命周期事件


637
00:30:14,548 --> 00:30:15,749
做到这一点最简单的方法是


638
00:30:15,816 --> 00:30:17,117
使用NSCache


639
00:30:18,185 --> 00:30:20,654
不过在某些情况下
你虽然可能会遇到


640
00:30:20,721 --> 00:30:24,358
需要将不能灵巧地被表示为可回收的对
象用于NSCache


641
00:30:25,025 --> 00:30:27,327
这时候你不得不
实际上执行自定义代码


642
00:30:27,394 --> 00:30:30,397
以响应你App中的生命周期通知


643
00:30:31,698 --> 00:30:33,133
有一些通知你可能会感兴趣


644
00:30:33,800 --> 00:30:35,569
比如"确实进入了后台"的通知


645
00:30:36,336 --> 00:30:38,338
你的App在挂起会得到这个通知


646
00:30:38,539 --> 00:30:40,707
而这正是NSCache
使用这个通知


647
00:30:40,874 --> 00:30:42,976
在你进入后台时使
App实际上执行了释放


648
00:30:43,710 --> 00:30:46,780
另一个有趣的通知是内存警告通知


649
00:30:47,314 --> 00:30:50,350
系统实际上是在发出这个通知之后
才开始逐出


650
00:30:50,417 --> 00:30:52,786
挂起的App
从而给它们一个释放的机会


651
00:30:53,720 --> 00:30:55,355
或许它们能够避免被逐出


652
00:30:55,589 --> 00:30:56,823
只要它们占用的内存下降了


653
00:30:57,958 --> 00:30:59,993
所以我在这里对那个问题举了一个简单
的例 子


654
00:31:01,028 --> 00:31:03,630
我将使用默认的
NSNotificationCenter


655
00:31:03,830 --> 00:31:05,832
在这种情况下 我要添加一个观察员


656
00:31:06,033 --> 00:31:07,935
以观察"确实收到了
内存警告"的通知


657
00:31:09,670 --> 00:31:12,840
而所有我要做的就是调用一些
"自定义缓存清除"的代码


658
00:31:14,041 --> 00:31:16,743
也许这会搭板C结构一起使用


659
00:31:16,810 --> 00:31:18,111
并释放一些其他的内存


660
00:31:19,913 --> 00:31:22,282
需要注意的是 如果你真地注册了


661
00:31:22,349 --> 00:31:26,053
NSNotificationCenter观察员
特别是在初始化时


662
00:31:26,620 --> 00:31:28,789
请一定要在反初始化中删除你自己


663
00:31:29,623 --> 00:31:31,091
你知道 内存实在是太重要了


664
00:31:31,325 --> 00:31:32,626
因为我还准备讲另外一个课程


665
00:31:32,693 --> 00:31:33,827
我希望你们去听一听


666
00:31:35,262 --> 00:31:36,163
这个课的名字叫做


667
00:31:36,230 --> 00:31:37,998
"在安装有iOS 9
系统的iPad上


668
00:31:38,065 --> 00:31:39,499
优化你的App多任务处理"


669
00:31:40,133 --> 00:31:42,636
但实际上
即使你的App无法在iPad上运行


670
00:31:42,703 --> 00:31:44,872
或者你有没有计划支持多任务处理


671
00:31:45,105 --> 00:31:46,406
也请你去听一听这个课程


672
00:31:47,140 --> 00:31:49,977
这个课程对应用程序
所使用的资源类型


673
00:31:50,043 --> 00:31:51,078
介绍了大量的详细信息


674
00:31:51,545 --> 00:31:53,480
包括它们通常以何种模式进入访问


675
00:31:53,947 --> 00:31:56,717
以及更多有关如何使你的App响应


676
00:31:56,783 --> 00:31:57,851
系统内存状态的信息


677
00:31:58,452 --> 00:31:59,286
这真是太棒了


678
00:32:01,855 --> 00:32:04,324
最后同样重要的是
我希望你们都会非常兴奋地看到


679
00:32:04,391 --> 00:32:06,360
我们把原代码带到
watchOS 2中


680
00:32:07,995 --> 00:32:10,731
当你正在思考如何建立你的watch
OS 2 App时


681
00:32:11,498 --> 00:32:13,400
你必须开始于一个伟大的设计


682
00:32:14,034 --> 00:32:16,837
这个设计真正地关注于你App的基本
功能


683
00:32:16,904 --> 00:32:19,306
使它们轻松、愉快


684
00:32:19,373 --> 00:32:20,507
并且方便于用户访问


685
00:32:21,475 --> 00:32:22,776
如果你在这方面需要获得帮助


686
00:32:22,843 --> 00:32:24,778
这里有一个非常不错的课程
你可以去听一听


687
00:32:24,845 --> 00:32:26,547
这个课程叫做"苹果手表App设计"


688
00:32:27,781 --> 00:32:30,350
一旦你为你的苹果手表App找到了一
个伟大的设计


689
00:32:31,351 --> 00:32:33,654
那么你就可以开始考虑


690
00:32:33,720 --> 00:32:36,256
你的iOS App在哪些方面
可能值得再次使用


691
00:32:37,224 --> 00:32:39,426
这可包括实际代码


692
00:32:40,360 --> 00:32:42,429
或熟悉的API访问
模式


693
00:32:42,763 --> 00:32:44,898
以及平台之间共享的框架


694
00:32:46,934 --> 00:32:48,702
有时候 你在iOS上做的一些事情


695
00:32:48,769 --> 00:32:51,338
实际上可能在watchOS上没有任
何意义


696
00:32:51,705 --> 00:32:53,106
比如出于性能上的考虑就会这样


697
00:32:53,240 --> 00:32:54,908
你最终会执行新的机制


698
00:32:55,609 --> 00:32:57,644
以便在其它平台上获得相同的结果


699
00:33:05,419 --> 00:33:08,422
watchOS用户希望交互行为快速
而简单


700
00:33:09,022 --> 00:33:12,059
而且他们总是希望能在App
看到最新的相关数据、


701
00:33:12,392 --> 00:33:14,561
通知以及快捷视图


702
00:33:15,729 --> 00:33:18,065
作为一名App开发者
这对你意味着什么呢？


703
00:33:19,132 --> 00:33:21,001
用户最有可能做的事情是


704
00:33:21,068 --> 00:33:24,071
在watchOS上刚一启动App


705
00:33:24,137 --> 00:33:26,940
随后就能看到他们想看到的内容


706
00:33:28,642 --> 00:33:29,810
那么我们能够做的工作


707
00:33:29,877 --> 00:33:32,045
是不是让watchOS有
非常久的启动时间


708
00:33:32,112 --> 00:33:33,247
以及非常缓慢的响应呢？


709
00:33:34,882 --> 00:33:37,017
我们必须关注于最大限度地减少两个工
作量


710
00:33:37,084 --> 00:33:39,987
一是你生成的网络流量
以及你必须在设备上


711
00:33:40,053 --> 00:33:42,589
完成的以便它能顺利
执行任务的工作量


712
00:33:43,891 --> 00:33:46,293
如果你正在访问的服务器
你可以对它进行控制


713
00:33:46,360 --> 00:33:47,628
并且能够添加新的API


714
00:33:49,096 --> 00:33:50,731
那么请确保你给苹果手表发送了


715
00:33:50,797 --> 00:33:52,966
适当大小和格式的响应


716
00:33:54,101 --> 00:33:57,571
有的可能很简单
比如从JSON或XML数据块中


717
00:33:57,671 --> 00:33:59,339
删除未使用的密钥


718
00:34:00,140 --> 00:34:01,508
调整图像大小等等


719
00:34:01,775 --> 00:34:03,844
这样
苹果手表就会精确地显示它们


720
00:34:03,911 --> 00:34:05,712
就如同它们是通过连线传输过来的一样


721
00:34:05,779 --> 00:34:09,550
而且不必做任何额外的工作
如果你的API适用于


722
00:34:09,616 --> 00:34:11,552
大屏幕设备


723
00:34:11,618 --> 00:34:13,120
可以同时显示10条


724
00:34:13,187 --> 00:34:14,621
或20条记录


725
00:34:15,355 --> 00:34:16,422
它可能会发回


726
00:34:16,489 --> 00:34:17,958
一次调用中发生的所有这些信息


727
00:34:18,492 --> 00:34:19,726
但实际上 对于苹果手表来说


728
00:34:19,960 --> 00:34:21,695
你应该只发送需要在
单个屏幕上显示的


729
00:34:21,762 --> 00:34:24,464
有关记录的正确数字


730
00:34:25,732 --> 00:34:28,235
为了随时显示更新的相关信息


731
00:34:28,802 --> 00:34:30,838
很重要的一点是使用
你的iPhone App


732
00:34:30,904 --> 00:34:32,572
来保持App内容的更新


733
00:34:33,206 --> 00:34:35,509
App内容是平台之间的


734
00:34:35,576 --> 00:34:37,444
一种双向共享状态


735
00:34:37,878 --> 00:34:40,147
因此
当用户在任一用户端上采取行动


736
00:34:40,214 --> 00:34:42,683
这将导致他们希望在另一用户端上


737
00:34:42,748 --> 00:34:45,052
看到可以更新的不同的东西


738
00:34:45,686 --> 00:34:46,920
API对此的反应是


739
00:34:47,420 --> 00:34:50,324
"手表连接性更新应用程序内容"


740
00:34:51,324 --> 00:34:52,592
做这个工作的最好时刻


741
00:34:53,025 --> 00:34:56,697
是你的iPhone App
被后台程序刷新唤醒的时候


742
00:34:57,598 --> 00:35:00,801
当它完成下载新信息
并更新了它自己的快照时


743
00:35:01,268 --> 00:35:03,804
它也可以
将这些信息推送到苹果手表上


744
00:35:03,871 --> 00:35:06,340
这样它将在下一次
用户启动时做好准备


745
00:35:09,543 --> 00:35:10,377
最后


746
00:35:11,278 --> 00:35:14,515
如果你所依赖的服务器
由于某种原因你不能作出更改


747
00:35:15,215 --> 00:35:17,451
比方说
你正在与第三方API竞争


748
00:35:18,285 --> 00:35:22,189
你可以利用你的iPhone网络和C
PU来连接


749
00:35:22,389 --> 00:35:24,458
从而实际上执行一个中介


750
00:35:24,591 --> 00:35:27,094
使格式和大小响应于手机


751
00:35:27,895 --> 00:35:31,832
你希望API的反应是
"手表连接发送信息"


752
00:35:33,433 --> 00:35:35,402
所以你会发送
一条消息到iPhone上


753
00:35:36,170 --> 00:35:39,439
提出你的要求
然后iPhone将会下载它


754
00:35:40,240 --> 00:35:43,277
并完成我提到的所有操作
如删除未使用的密钥、


755
00:35:43,343 --> 00:35:45,546
减少记录数、
调整图像大小等等


756
00:35:46,246 --> 00:35:49,550
然后它会向手表发送
一个紧凑的可操作的答复


757
00:35:49,816 --> 00:35:51,418
好了 WC课程又到结束的时间了


758
00:35:51,852 --> 00:35:52,686
让我作一下总结


759
00:35:54,188 --> 00:35:55,455
性能是一个特征


760
00:35:55,989 --> 00:35:57,457
这是一个重要的方面


761
00:35:57,624 --> 00:36:00,093
你的App必须给予
你的用户丰富的经验


762
00:36:00,761 --> 00:36:02,663
从建立你的App的第一天开始


763
00:36:02,729 --> 00:36:04,031
你就应该把这一点记在心里


764
00:36:05,666 --> 00:36:07,701
当你使用高效的App时
你会感觉非常棒


765
00:36:08,101 --> 00:36:11,705
因为它们建立了用户的信任
它们节省电池消耗


766
00:36:13,707 --> 00:36:16,810
请了解我提到的所有的苹果技术


767
00:36:17,244 --> 00:36:19,880
当你正在思考如何建立你的App时
请选择最好的技术


768
00:36:20,881 --> 00:36:22,983
请保持你的主线程随时
为用户输入作好准备


769
00:36:24,351 --> 00:36:26,587
你需要了解你的App
何时以及为什么使用内存


770
00:36:27,387 --> 00:36:29,323
你需要获得watchOS


771
00:36:29,690 --> 00:36:32,159
下载以及处理
极小集信息的大量经验


772
00:36:34,228 --> 00:36:35,696
这里有一些非常不错的书面资料


773
00:36:35,762 --> 00:36:38,532
如果你开始对这个东西产生兴趣
你可以学习一下这些资料


774
00:36:39,333 --> 00:36:41,468
好了 这些就是我今天上课的主要内容


775
00:36:42,436 --> 00:36:45,639
最开始 讲到的一些技术
是我们今年新推出的技术


776
00:36:45,873 --> 00:36:47,574
还有一些技术是前几年推出的


777
00:36:48,509 --> 00:36:49,877
谢谢大家 祝你们周五愉快！

