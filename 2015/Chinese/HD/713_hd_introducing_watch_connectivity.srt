1
00:00:20,354 --> 00:00:23,857
Watch Connectivity介绍


2
00:00:31,665 --> 00:00:32,698
早上好


3
00:00:32,966 --> 00:00:35,269
欢迎来到
Watch Connectivity介绍


4
00:00:35,435 --> 00:00:36,336
我叫克里斯


5
00:00:36,403 --> 00:00:38,038
今天 我的同事亚历克斯将和我一起 


6
00:00:38,105 --> 00:00:40,040
他随后会上台


7
00:00:40,107 --> 00:00:42,276
我们很兴奋为你们展示 


8
00:00:42,342 --> 00:00:47,047
我们一直在watchOS 2
和iOS 9上做的东西


9
00:00:47,481 --> 00:00:49,483
今天 我们要说的是 


10
00:00:49,550 --> 00:00:51,718
帮助你们为Watch app做出


11
00:00:51,852 --> 00:00:53,887
更好更有反响的用户体验


12
00:00:55,289 --> 00:00:57,558
为了简单说明我们的出发点


13
00:00:57,624 --> 00:01:00,561
watchOS 1
上的世界看起来像什么


14
00:01:00,627 --> 00:01:04,331
之前iOS app
和WatchKit扩展都是依赖


15
00:01:04,498 --> 00:01:08,302
iPhone的 且当时主要处理的是
WatchKit app通信 


16
00:01:08,602 --> 00:01:11,672
而且这二者都可以共享数据存储


17
00:01:12,973 --> 00:01:15,409
在watchOS 2 
我们已经把WatchKit扩展


18
00:01:15,475 --> 00:01:19,313
扩展到Watch之上 
app在Watch可以运行更流畅了


19
00:01:19,513 --> 00:01:20,848
这有不少的好处 


20
00:01:20,914 --> 00:01:23,350
但是也意味着它们都
各自使用自己的数据存储


21
00:01:24,718 --> 00:01:28,155
显然 下个问题是 我们如何把数据 


22
00:01:28,322 --> 00:01:29,723
搬到Apple Watch上 


23
00:01:29,923 --> 00:01:31,225
这是我们今天要讨论的内容


24
00:01:33,327 --> 00:01:37,464
我们将为你展示解决
这个问题的两个主要方法


25
00:01:37,531 --> 00:01:39,499
如何将数据移到Watch上 


26
00:01:39,566 --> 00:01:42,169
这是新框架
WatchConnectivity


27
00:01:42,236 --> 00:01:46,473
我们将它引入了
watchOS 2 和iOS 9


28
00:01:47,708 --> 00:01:53,313
然后这是可在Foundation上
获NSURLSession API


29
00:01:53,580 --> 00:01:55,682
也适用于WatchKit扩展 


30
00:01:56,383 --> 00:01:59,419
也已经集成到watchOS 2 


31
00:02:00,821 --> 00:02:03,924
我想今天要讨论的话题适用于


32
00:02:03,991 --> 00:02:09,729
大多数Watch app 
对于多数人来说也是适用的


33
00:02:10,464 --> 00:02:12,799
今天展示中即将用到的大量示例


34
00:02:12,866 --> 00:02:14,968
将会证明这一点


35
00:02:15,536 --> 00:02:18,405
你可以看到 这个范围很广 
我们希望每个人


36
00:02:18,472 --> 00:02:21,208
都可以至少辨认出一种


37
00:02:22,276 --> 00:02:24,912
我们先讨论
WatchConnectivity


38
00:02:24,978 --> 00:02:29,449
这是我们引入watchOS 2 
和iOS 9的新架构


39
00:02:29,516 --> 00:02:31,618
它在两个平台中都适用 


40
00:02:31,685 --> 00:02:33,921
几乎所有的API在两边都适用


41
00:02:33,987 --> 00:02:39,026
我们将会看到不少
iPhone专用的 API


42
00:02:39,092 --> 00:02:42,329
当你开始采用
WatchConnectivity


43
00:02:42,396 --> 00:02:44,498
你想做的第一件事是


44
00:02:44,565 --> 00:02:46,066
仔细设置


45
00:02:46,633 --> 00:02:49,269
我们建议尽早进行设置


46
00:02:49,336 --> 00:02:52,005
在使用app的整个过程中 
在两方面都要


47
00:02:52,072 --> 00:02:57,511
在Watch运行的WatchKit
扩展和在iOS 9 app内部


48
00:02:57,945 --> 00:03:01,081
你要确保使用代码路径进行设置


49
00:03:01,148 --> 00:03:02,616
这样一来 尽管是在后台启动


50
00:03:02,683 --> 00:03:03,851
也还是可以被执行


51
00:03:03,917 --> 00:03:07,321
所以不要把它放在里面如视图
控制器View Did Load内


52
00:03:07,387 --> 00:03:09,790
因为当你在后台启动时 
这些是不会被调用的 


53
00:03:10,757 --> 00:03:12,659
所以在iOS app中


54
00:03:12,726 --> 00:03:15,162
你做的第一件事是查看


55
00:03:15,229 --> 00:03:16,930
是否支持WCSession  


56
00:03:17,164 --> 00:03:19,533
你或许有一个通用的iOS app


57
00:03:19,600 --> 00:03:22,269
意思是代码可以在iPad上执行 


58
00:03:22,336 --> 00:03:24,838
iPad无法使用
WatchConnectivity


59
00:03:25,305 --> 00:03:29,009
你在Watch上执行任何工作之前 
请事先检查一下 


60
00:03:29,076 --> 00:03:34,815
因为我们不想你浪费CPU做无用功


61
00:03:34,882 --> 00:03:36,350
下一件事情是创建一个对象实例 


62
00:03:36,416 --> 00:03:39,086
你可以通过调用Default
 Session进行创建


63
00:03:39,920 --> 00:03:43,590
然后在会话对象上设置指派 


64
00:03:43,957 --> 00:03:45,859
最后调用Activate


65
00:03:45,926 --> 00:03:48,896
滴啊用后就可以继续
设置WCSession对象 


66
00:03:48,962 --> 00:03:52,499
初始化所有属性 
而且一旦调用返回 


67
00:03:52,566 --> 00:03:54,535
所有属性将被更新


68
00:03:54,601 --> 00:03:56,970
更新为正确的初始化数值


69
00:03:58,705 --> 00:04:01,275
同样此刻 任何指派回调


70
00:04:01,341 --> 00:04:03,610
任何向上尾接
的内容会可以开始进入


71
00:04:03,944 --> 00:04:04,845
这是为什么你需要


72
00:04:04,912 --> 00:04:06,947
尽快执行上述步骤的原因


73
00:04:07,014 --> 00:04:09,983
或许有内容正等着上传到你的app上


74
00:04:10,551 --> 00:04:12,886
所以 请确保提前处理这些步骤


75
00:04:13,687 --> 00:04:15,088
一旦这些步骤完成


76
00:04:15,155 --> 00:04:17,891
下一件你将想做的事情是 
查看会话状态


77
00:04:17,958 --> 00:04:22,396
然后通知你的app  


78
00:04:22,462 --> 00:04:25,032
iOS app和the Watch
之间目前的关系如何


79
00:04:26,099 --> 00:04:30,070
所以这些
属性只适用于iPhone app


80
00:04:30,137 --> 00:04:33,674
它正在通知iOS与Watch的关系


81
00:04:34,208 --> 00:04:36,510
所以没有必要
在你的Watch app上使用


82
00:04:36,577 --> 00:04:38,011
因为基本上不适用


83
00:04:39,112 --> 00:04:41,281
在这个示例中 
 我们将使用一款新闻app


84
00:04:41,548 --> 00:04:43,383
一款推送最近


85
00:04:43,450 --> 00:04:44,685
有趣文章的应用


86
00:04:46,053 --> 00:04:49,857
首先要做的是
执行我们刚才讨论的设置过程


87
00:04:49,923 --> 00:04:51,558
这应当在使用应用的时候尽快完成


88
00:04:51,625 --> 00:04:55,629
下一步进行设备检查 
检查该设备是否与Watch配对？


89
00:04:55,896 --> 00:04:58,732
如果未配对 
那么相当于这是在iPad上运行


90
00:04:58,799 --> 00:05:00,234
没什么需要做的了


91
00:05:00,300 --> 00:05:01,335
你无法进行通讯


92
00:05:01,802 --> 00:05:04,671
所以这个时候 你可能
要停止所有在Watch上进行的工作


93
00:05:05,472 --> 00:05:08,408
用户会出去并买个新的Watch 


94
00:05:08,475 --> 00:05:09,977
然后执行配对步骤


95
00:05:10,110 --> 00:05:12,546
启动Apple Watch app


96
00:05:13,680 --> 00:05:14,815
操作配对 


97
00:05:14,882 --> 00:05:16,550
设置这些设备


98
00:05:17,985 --> 00:05:20,087
现在当你的app启动后 


99
00:05:20,153 --> 00:05:21,955
你会得到一个指派回调


100
00:05:22,422 --> 00:05:24,258
说明Watch状态会话改变了


101
00:05:25,058 --> 00:05:27,294
当你检查配对属性的数值时 


102
00:05:27,361 --> 00:05:28,962
你会看到返回为真 


103
00:05:29,029 --> 00:05:30,430
因为设备已经配对了


104
00:05:31,298 --> 00:05:32,633
所以 这时候你可以继续


105
00:05:32,699 --> 00:05:34,968
检查下个属性 也就是


106
00:05:35,035 --> 00:05:36,470
Watch app是否安装了？


107
00:05:37,204 --> 00:05:38,739
如果还未安装 那么就没法通讯 


108
00:05:38,805 --> 00:05:40,374
工作到此为止


109
00:05:40,674 --> 00:05:44,444
但是 通过默认设置
Watch app是默认安装的 


110
00:05:44,511 --> 00:05:46,580
但是用户可能会由于某些原因 
选择不进行安装


111
00:05:46,647 --> 00:05:50,150
在这种情况下 
用户将接续执行并进行重新安装


112
00:05:50,217 --> 00:05:52,219
返回Apple Watch app


113
00:05:53,287 --> 00:05:56,957
打开设备 
如果你的Apple正在运行 


114
00:05:57,057 --> 00:05:58,725
你将再一次获得指派回调 


115
00:05:58,792 --> 00:06:00,794
你就可以检查该属性数值了 


116
00:06:00,861 --> 00:06:03,497
可见Watch App 
Installed返回为真


117
00:06:04,665 --> 00:06:06,800
现在 你可以进行通讯了


118
00:06:06,867 --> 00:06:07,935
这时候说明你可以


119
00:06:08,001 --> 00:06:10,270
使用Watch app
开始进行通讯了


120
00:06:10,337 --> 00:06:13,006
你需要输入通讯的内容


121
00:06:14,641 --> 00:06:17,878
无论何时一旦Watch App 
Installed值为True 


122
00:06:18,946 --> 00:06:22,249
另个属性Watch 
Directory URL也可用 


123
00:06:22,416 --> 00:06:25,686
你会发现一旦Watch App 
Installed值为True


124
00:06:25,752 --> 00:06:28,889
Watch Directory 
URL将会有一个非0值


125
00:06:28,956 --> 00:06:32,926
这将指向在
container创建的一个目录


126
00:06:33,760 --> 00:06:35,662
我们稍微深入地讨论一下这个


127
00:06:36,396 --> 00:06:39,132
目录和它的内容 它的使用周期与


128
00:06:39,199 --> 00:06:41,535
Watch App
Installed属性息息相关


129
00:06:41,602 --> 00:06:45,105
WatchAppInstalled
值从True变成False 


130
00:06:45,172 --> 00:06:48,375
这个目录和它的所有内容都会消失


131
00:06:48,742 --> 00:06:50,444
无论何时 当值为True时 


132
00:06:50,511 --> 00:06:53,213
目录会再次出现 但是是空目录


133
00:06:54,848 --> 00:06:56,783
我们建议你 仅在数据与


134
00:06:56,850 --> 00:06:58,886
你的Watch app
特别实例有关时才使用


135
00:06:59,152 --> 00:07:00,554
实例是要说明什么呢 


136
00:07:00,754 --> 00:07:03,023
一些事物 比如最后队列项目标记


137
00:07:03,557 --> 00:07:04,791
就可以存储在这


138
00:07:04,858 --> 00:07:07,227
若用户未安装并重新安装app 


139
00:07:07,294 --> 00:07:09,763
那么Watch app
是从一个空的容器开始的


140
00:07:09,863 --> 00:07:12,733
因此
这个目录以开始是没有内容的 


141
00:07:12,799 --> 00:07:16,737
你需要同步到app通讯的位置


142
00:07:16,803 --> 00:07:20,274
其他你可以保存的事物有偏好设置


143
00:07:20,340 --> 00:07:25,345
当用户首次运行iOS app时 


144
00:07:25,412 --> 00:07:27,881
你可能想让他设置一下


145
00:07:27,948 --> 00:07:29,917
想要的Watch app体验


146
00:07:29,983 --> 00:07:32,519
或许他不想显示全部内容 


147
00:07:32,586 --> 00:07:35,122
但想要显示特别主题的前十条新闻 


148
00:07:35,189 --> 00:07:37,724
比如国际新闻或体育新闻


149
00:07:37,791 --> 00:07:39,293
这个位置就很适合来存储这些设置


150
00:07:40,460 --> 00:07:43,964
同样 如果你正处理全尺寸的资料 


151
00:07:44,031 --> 00:07:46,166
想生成适合Watch尺寸的资料 


152
00:07:46,333 --> 00:07:49,670
你要压缩图片 音频 视频 


153
00:07:50,470 --> 00:07:53,407
在提示传输时可使用
WatchConnectivity


154
00:07:53,473 --> 00:07:55,909
API 将这些资料储存到这里 
随后我们会说到这点


155
00:07:57,311 --> 00:07:58,979
所以 这就是Watch 目录


156
00:07:59,279 --> 00:08:01,114
我们建议你将内容存储在这 


157
00:08:01,181 --> 00:08:03,650
因为随后我们会将内容清理掉 
如果Watch消失了 


158
00:08:03,717 --> 00:08:07,354
如果他未配对他的手表 
我们将自动清除这些内容


159
00:08:07,421 --> 00:08:10,657
这样就省去了管理的麻烦


160
00:08:11,225 --> 00:08:15,262
最后会话状态属性是
Complication Enabled


161
00:08:15,929 --> 00:08:18,832
用户并不能
启动Complication 


162
00:08:18,899 --> 00:08:22,536
但可编辑Watch表面然后启动 


163
00:08:22,803 --> 00:08:24,805
之后你会收到同样的的回调 


164
00:08:24,872 --> 00:08:26,240
会话或状态变换信号


165
00:08:26,840 --> 00:08:29,343
当你查看属性时 现在值将是True


166
00:08:31,879 --> 00:08:35,515
你已经设置 会话
WatchConnectivity


167
00:08:35,982 --> 00:08:38,150
已知道watch的状态是什么的 


168
00:08:38,217 --> 00:08:42,054
iOS app
和Watch app 


169
00:08:42,121 --> 00:08:43,423
之间是什么关系


170
00:08:43,490 --> 00:08:47,327
下一件事情是
开始将信息传输到Watch上 


171
00:08:47,394 --> 00:08:49,496
或从Watch
传输到iOS app上


172
00:08:50,030 --> 00:08:53,033
为了这么做 我将邀请亚历山大 


173
00:08:53,100 --> 00:08:54,768
他将为我们讲解通讯API


174
00:09:05,012 --> 00:09:09,082
谢谢 好的
所以就像克里斯说 你设置好了会话


175
00:09:09,583 --> 00:09:12,719
也已经检查过 设备已经配对了


176
00:09:12,786 --> 00:09:15,055
Apple Watch app
也已经安装了


177
00:09:15,422 --> 00:09:17,891
现在 我们从如何才能


178
00:09:18,058 --> 00:09:19,293
在两台设备之间进行通讯


179
00:09:20,894 --> 00:09:23,764
关于通讯 我们有不少分类


180
00:09:24,231 --> 00:09:26,700
第一类是后台传输


181
00:09:27,467 --> 00:09:29,536
后台传输意思是说 


182
00:09:29,603 --> 00:09:33,173
在收到方看来
内容并不是立即需要的


183
00:09:34,541 --> 00:09:36,810
因为内容不是立即需要的 


184
00:09:37,077 --> 00:09:40,013
这意味着在传输这些内容时 


185
00:09:40,080 --> 00:09:42,182
系统可以处理其他的事情


186
00:09:43,917 --> 00:09:46,453
除了后台传输外 我们还将讲到


187
00:09:46,520 --> 00:09:48,055
交互式信息传输


188
00:09:49,256 --> 00:09:52,326
交互式信息传输是指


189
00:09:52,392 --> 00:09:55,429
两个实时沟通的app之间的通讯


190
00:09:55,529 --> 00:09:58,832
所以 这时候两个app都在使用中
它们来回发送信息 


191
00:09:59,566 --> 00:10:01,902
要求响应 之类的事情 


192
00:10:02,703 --> 00:10:04,104
这里有你可能需要使用


193
00:10:04,171 --> 00:10:05,539
交互式信息传输的一些情况


194
00:10:05,606 --> 00:10:09,510
假设你有一个游戏 用户正在
同时使用两个app进行游戏时候 


195
00:10:09,977 --> 00:10:11,812
或者
你正在Apple Watch上 


196
00:10:12,079 --> 00:10:16,049
你需要启动iOS上的一些东西


197
00:10:16,316 --> 00:10:19,253
比如你想要触发iOS设备 


198
00:10:19,319 --> 00:10:21,321
以便了解用户位置


199
00:10:23,190 --> 00:10:26,159
我们先来说说第一个 后台传输


200
00:10:27,294 --> 00:10:31,164
关于后台传输 首先要讲的是


201
00:10:31,231 --> 00:10:34,268
app内容的类型 以及用户如何


202
00:10:34,334 --> 00:10:36,136
与这两台设备进行互动


203
00:10:36,803 --> 00:10:39,106
还是用新闻app的示例 


204
00:10:39,173 --> 00:10:40,807
这个新闻app有很多内容


205
00:10:41,308 --> 00:10:44,545
它从服务器读取了不少内容 


206
00:10:44,912 --> 00:10:47,181
而且它断定这些内容


207
00:10:47,581 --> 00:10:48,782
对于Watch是有用的 


208
00:10:49,583 --> 00:10:53,020
现在
用户并未在目前情况下使用Watch


209
00:10:53,353 --> 00:10:56,690
所以在Watch方面来说 
这些内容并不是立即需要的


210
00:10:57,257 --> 00:11:00,694
当然啦iOS app 
这个新闻app 


211
00:11:00,761 --> 00:11:03,463
想要挑一些新闻 在系统里列队备好


212
00:11:04,598 --> 00:11:07,134
以便系统可以挑选对的内容


213
00:11:07,201 --> 00:11:08,802
进行传输


214
00:11:09,403 --> 00:11:11,972
在用户真的进行接收时


215
00:11:12,072 --> 00:11:14,641
在这个
示例中是Apple Watch 


216
00:11:14,708 --> 00:11:16,510
系统将考虑电源和性能的情况


217
00:11:17,411 --> 00:11:20,647
当条件都正确的时候内容将传输


218
00:11:21,148 --> 00:11:25,152
它将在接收方这个示例中的
Apple Watch中等待


219
00:11:25,419 --> 00:11:28,222
直到用户启动接收app  


220
00:11:28,722 --> 00:11:30,057
当接收app启动 


221
00:11:30,123 --> 00:11:31,692
内容将被传输过去 


222
00:11:32,192 --> 00:11:33,961
app也可以更新它的状态


223
00:11:36,296 --> 00:11:39,166
这是后台传输所提供的


224
00:11:39,433 --> 00:11:41,401
它允许内容列队等候


225
00:11:43,504 --> 00:11:45,939
系统将为你传输内容


226
00:11:46,473 --> 00:11:50,277
这允许了发送方 发送方app退出


227
00:11:50,777 --> 00:11:52,212
系统将处理接下来的一切


228
00:11:52,846 --> 00:11:55,983
它允许系统挑选合适时间传输内容 


229
00:11:57,317 --> 00:11:59,653
允许系统将信息存储到


230
00:11:59,720 --> 00:12:03,190
接收方 并等待接收app启动


231
00:12:04,525 --> 00:12:07,227
对于app上有的大部分内容 


232
00:12:07,528 --> 00:12:10,764
我们建议你使用后台传输


233
00:12:12,199 --> 00:12:15,335
原因是 对于接收方来说 


234
00:12:15,402 --> 00:12:17,070
大部分内容并不是立即所需的


235
00:12:17,137 --> 00:12:20,741
当然啦 一旦接收app打开 
就需要这些内容了


236
00:12:22,643 --> 00:12:24,411
所以 我们来讲讲具体细节


237
00:12:25,512 --> 00:12:28,148
我们有三种不同的后台传输类型


238
00:12:29,283 --> 00:12:31,919
第一种是应用上下文


239
00:12:32,619 --> 00:12:35,289
应用上下文代表的是app提供给


240
00:12:35,389 --> 00:12:37,491
另一方的最有趣的


241
00:12:37,558 --> 00:12:38,692
信息单一集合


242
00:12:39,860 --> 00:12:43,096
比如说在iOS方面 有个app 


243
00:12:43,463 --> 00:12:46,633
它跟踪用户位置 根据用户位置 


244
00:12:47,100 --> 00:12:50,437
app挑选该位置附近的一个饭店 


245
00:12:50,504 --> 00:12:52,072
并想推荐给用户


246
00:12:52,840 --> 00:12:54,942
除了在iOS方面分享饭店外 


247
00:12:55,008 --> 00:12:56,977
也想在
Apple Watch app上


248
00:12:57,044 --> 00:12:58,378
显示这个饭店


249
00:12:59,112 --> 00:13:00,647
所以你可以将建议打包到


250
00:13:00,714 --> 00:13:02,616
应用上下文中 


251
00:13:03,183 --> 00:13:04,751
它将传输信息 


252
00:13:04,818 --> 00:13:07,487
然后下次
用户在Apple Watch启用


253
00:13:07,688 --> 00:13:10,224
这个app时 内容就会出现 


254
00:13:10,290 --> 00:13:11,892
推荐也会出现


255
00:13:13,026 --> 00:13:15,796
可能想使用应用上下文的其他示例 


256
00:13:16,763 --> 00:13:19,499
假设在iOS方面 
你有一个社交app 


257
00:13:19,566 --> 00:13:22,836
它读取了一堆的帖子 并确定了


258
00:13:22,903 --> 00:13:27,641
10个最有趣的帖子 


259
00:13:27,708 --> 00:13:30,477
在Apple Watch设备上展示


260
00:13:30,711 --> 00:13:32,913
用户可看Apple Watch 


261
00:13:32,980 --> 00:13:34,681
并立即可以看到有趣的信息了


262
00:13:35,482 --> 00:13:37,618
你也可以将这排名前10的帖子


263
00:13:37,684 --> 00:13:40,721
打包到应用上下文中
他们将传输过去 


264
00:13:41,922 --> 00:13:44,625
现在 应用上下文是


265
00:13:44,691 --> 00:13:46,894
后台传输最简单的方法 


266
00:13:46,960 --> 00:13:48,996
但如果你需要一些稍微复杂的东西 


267
00:13:49,363 --> 00:13:51,899
或你需要进行排队等候 
而不是信息的一个单一集合


268
00:13:51,965 --> 00:13:54,635
我们为你提供两种方法


269
00:13:55,569 --> 00:13:58,138
第一种是用户信息传输


270
00:13:58,972 --> 00:14:01,842
这允许你传输你想打包的 


271
00:14:01,909 --> 00:14:04,244
用户信息字典的内存内容


272
00:14:04,344 --> 00:14:07,080
举个例子 
假设你在Apple Watch上


273
00:14:07,514 --> 00:14:08,849
有一个游戏


274
00:14:08,916 --> 00:14:10,450
用户不断升级继续游戏 


275
00:14:11,318 --> 00:14:14,087
当用户升级后继续游戏时 


276
00:14:14,154 --> 00:14:18,091
你想将进度后台同步到iOS app


277
00:14:18,292 --> 00:14:20,494
iOS app
将展示一些细微图形 


278
00:14:20,861 --> 00:14:22,629
说明用户在每个等级是如何操作的


279
00:14:23,931 --> 00:14:26,333
除了用户信息传输 


280
00:14:26,400 --> 00:14:28,535
我们还提供文件传输


281
00:14:29,069 --> 00:14:29,903
非常类似


282
00:14:29,970 --> 00:14:32,606
它允许你让内容进行排队等候 


283
00:14:32,673 --> 00:14:34,708
在这个案例中 内容是一个文件


284
00:14:35,676 --> 00:14:38,178
在这个展示中 接下来我们要讲到的


285
00:14:38,245 --> 00:14:40,447
关于文件传输的示例是 
假设你有一个iOS app 


286
00:14:40,514 --> 00:14:43,050
它可让你对图片进行编辑 


287
00:14:43,584 --> 00:14:45,652
在编辑完图片后 


288
00:14:45,719 --> 00:14:47,154
用户可挑选他们喜欢的


289
00:14:47,221 --> 00:14:48,789
这些喜欢的图片就是


290
00:14:48,856 --> 00:14:50,357
想在Apple Watch显示的


291
00:14:50,457 --> 00:14:52,526
你可以在喜欢的图片之间


292
00:14:52,593 --> 00:14:54,361
使用文件传输进行传输


293
00:14:54,428 --> 00:14:56,263
图片
可通过Apple Watch查看


294
00:14:56,330 --> 00:14:59,099
用户可以向他们的朋友进行展示之类的


295
00:15:00,300 --> 00:15:02,636
让我们一个一个来说


296
00:15:04,238 --> 00:15:06,240
我们从应用上下文开始


297
00:15:07,007 --> 00:15:07,875
为了示范说明


298
00:15:07,941 --> 00:15:11,178
我们使用社交网络app


299
00:15:11,245 --> 00:15:15,048
刚才我提到 这个在iOS上的app


300
00:15:15,115 --> 00:15:16,583
从社交网络网站读取所有的帖子


301
00:15:16,650 --> 00:15:19,520
然后选出最有趣的 


302
00:15:19,586 --> 00:15:21,355
发送到Watch app


303
00:15:22,089 --> 00:15:26,560
关于应用上下文 
首先要说的是这两个属性


304
00:15:28,028 --> 00:15:30,497
第一个属性Application 
Context


305
00:15:30,697 --> 00:15:34,201
它是这样一种属性 先在发送方 


306
00:15:34,268 --> 00:15:36,803
然后在接收方存储最新内容 


307
00:15:36,870 --> 00:15:38,839
Received 
Application


308
00:15:38,906 --> 00:15:41,675
Context将在接收方存储


309
00:15:41,742 --> 00:15:43,210
最新收到的内容


310
00:15:44,444 --> 00:15:49,449
假设这个iOS app
已经读取了一堆的帖子 


311
00:15:49,750 --> 00:15:53,253
它也已经为
Watch打包好最有趣的那些


312
00:15:53,654 --> 00:15:56,423
将调用Update
Application Context


313
00:15:57,024 --> 00:16:00,427
这个方法读取一个词典 


314
00:16:00,494 --> 00:16:02,663
代表你想要发送的最新最有趣的状态


315
00:16:04,031 --> 00:16:06,867
我们获得这个内容 Update


316
00:16:06,934 --> 00:16:09,203
Application 
Context被调用后 


317
00:16:09,336 --> 00:16:11,972
将它叠加到Application 
Context属性


318
00:16:12,706 --> 00:16:13,974
这样内容就在那里了 


319
00:16:14,041 --> 00:16:17,411
系统将决定传输内容的最佳时间 


320
00:16:17,744 --> 00:16:20,314
或许是当用户
启动他们的Watch的时候


321
00:16:21,648 --> 00:16:23,317
现在 与此同时  


322
00:16:24,351 --> 00:16:29,089
这个iOS app可以读取更多内容


323
00:16:29,456 --> 00:16:31,792
并决定它想发送到Watch 


324
00:16:31,859 --> 00:16:33,794
最新的有趣信息


325
00:16:34,194 --> 00:16:36,196
在这个示例中 
它将再一次调用Update


326
00:16:36,263 --> 00:16:38,098
Application 
Context


327
00:16:38,832 --> 00:16:40,267
然后 我们将把那些内容


328
00:16:40,334 --> 00:16:42,736
叠加到Application 
Context属性


329
00:16:42,970 --> 00:16:45,072
它将把旧的相关状态清出 


330
00:16:45,138 --> 00:16:47,574
并放入新的相关状态 
因为我们真正在意的是


331
00:16:47,641 --> 00:16:51,578
那些最有趣 最新的数据集合


332
00:16:53,180 --> 00:16:55,249
这个新内容就在那里了 再一次


333
00:16:55,315 --> 00:16:56,650
等待系统挑选一个合适的时间 


334
00:16:56,717 --> 00:16:58,418
将内容传输过去


335
00:16:59,319 --> 00:17:01,021
一旦系统挑出合适的时间 


336
00:17:01,154 --> 00:17:02,422
内容就会被传输过去


337
00:17:02,489 --> 00:17:04,657
它将
传输到到Apple Watch方


338
00:17:05,759 --> 00:17:07,493
它将等待用户启动app 


339
00:17:07,961 --> 00:17:09,663
即Apple Watch app


340
00:17:10,664 --> 00:17:13,133
当app启动后
我们将把内容转传输到


341
00:17:13,200 --> 00:17:14,968
你的WatchKit扩展 


342
00:17:15,035 --> 00:17:18,238
这里是在Apple Watch
上所有代码执行的地方


343
00:17:20,073 --> 00:17:22,576
所以以上是应用上下文的流程


344
00:17:23,210 --> 00:17:25,746
我们来看一些代码


345
00:17:26,413 --> 00:17:29,383
你想做的第一件事是打包


346
00:17:29,716 --> 00:17:32,886
你的上下文词典 代表你想要发送的


347
00:17:33,120 --> 00:17:34,521
最新状态的词典


348
00:17:34,855 --> 00:17:37,291
调用Update 
Application


349
00:17:37,357 --> 00:17:38,358
Context 你将使用词典


350
00:17:39,493 --> 00:17:42,696
关于代码示例
需要提的最后一件事情是Update


351
00:17:42,763 --> 00:17:45,599
Application 
Context调用被打包到


352
00:17:45,666 --> 00:17:50,037
Do Catch块中
这个调用通过调试是事先引导的


353
00:17:50,404 --> 00:17:52,506
这是Swift的新错误处理方式 
Update


354
00:17:52,573 --> 00:17:55,309
Application
Context会返回一个错误


355
00:17:55,576 --> 00:17:59,079
若错误被返回
Catch块将被激发 


356
00:17:59,546 --> 00:18:01,849
我们强烈建议你


357
00:18:01,915 --> 00:18:02,850
恰当的处理错误


358
00:18:04,885 --> 00:18:08,355
所以这是应用上下文的发送方


359
00:18:08,856 --> 00:18:10,591
我们来看看接收方


360
00:18:11,792 --> 00:18:13,026
在接收方看来 


361
00:18:13,093 --> 00:18:15,028
接收方将得到指派回调


362
00:18:15,095 --> 00:18:17,364
Did Receive 
Application Context


363
00:18:17,865 --> 00:18:19,266
它将向发送者


364
00:18:19,366 --> 00:18:20,634
发送打包的字典


365
00:18:21,268 --> 00:18:26,640
然后此时 接收者可以获得内容 


366
00:18:26,707 --> 00:18:27,941
并更新它的app状态


367
00:18:28,775 --> 00:18:30,577
关于API中这个指派回调


368
00:18:30,644 --> 00:18:34,081
和所有指派回调
我们需要知道的一件事是 


369
00:18:34,147 --> 00:18:36,250
它们按照非主要串行队列被返回


370
00:18:37,317 --> 00:18:38,852
假若由于你因为要更新某些UI 


371
00:18:38,919 --> 00:18:41,755
而需要在主要队列中做些事情 


372
00:18:41,822 --> 00:18:44,558
需要在此内容或其他事情的基础上 


373
00:18:44,625 --> 00:18:47,361
发送到主要队列 从而更新你的UI


374
00:18:49,997 --> 00:18:51,598
以上是应用上下文


375
00:18:52,299 --> 00:18:54,301
它是app为另一方所提供的的 


376
00:18:54,368 --> 00:18:56,303
最有趣的相关内容


377
00:18:56,670 --> 00:18:58,305
它的行为优先权确实更高 


378
00:18:58,372 --> 00:19:04,178
这是因为你重视接收方在意的内容


379
00:19:04,244 --> 00:19:06,980
并处理最新内容而任何非最新的内容


380
00:19:07,047 --> 00:19:10,417
都是无关紧要的


381
00:19:12,019 --> 00:19:13,921
应用上下文有一个词典


382
00:19:14,688 --> 00:19:16,924
这个词典有属性清单类型


383
00:19:17,691 --> 00:19:20,561
属性清单类型是基本对象类型 
比如数字 


384
00:19:20,627 --> 00:19:24,431
字符串 基本集合型 字典 阵列


385
00:19:25,132 --> 00:19:28,135
如果你想要更新属性清单类型 


386
00:19:28,302 --> 00:19:31,371
Apple有很棒的在线文件


387
00:19:33,574 --> 00:19:35,876
所以 对于应用上下文 


388
00:19:35,943 --> 00:19:37,377
我们有一些特别推荐的使用示例


389
00:19:38,278 --> 00:19:41,715
对于Apple Watch app
来说应用上下文真的很不错 


390
00:19:41,849 --> 00:19:44,384
因为不少
Apple Watch app展示


391
00:19:44,451 --> 00:19:46,553
iOS所有信息的一个子集


392
00:19:47,221 --> 00:19:49,923
如果app是这样工作的 我们建议你


393
00:19:49,990 --> 00:19:53,293
将那信息的子集放到应用上下文中 


394
00:19:53,660 --> 00:19:56,496
让它可发送到Apple Watch


395
00:19:57,197 --> 00:19:58,732
除了这些app 


396
00:19:59,032 --> 00:20:01,902
应用上下文在Glance上也很好用


397
00:20:03,103 --> 00:20:05,672
Glance获得app提供的


398
00:20:05,739 --> 00:20:07,641
单个最有趣的数据段


399
00:20:08,108 --> 00:20:09,843
我们建议你将该数据段


400
00:20:09,910 --> 00:20:12,913
放到iOS方的应用上下文中 


401
00:20:12,980 --> 00:20:14,648
这样它就可以被传输到Watch方


402
00:20:14,815 --> 00:20:17,184
当用户扫过
手表表面显示Glance时 


403
00:20:17,818 --> 00:20:20,320
就可以看到数据了


404
00:20:22,356 --> 00:20:25,659
结束应用上下文部分 现在将继续谈谈


405
00:20:25,726 --> 00:20:27,361
用户信息传输


406
00:20:28,729 --> 00:20:31,698
我们将用到的一个示例是 


407
00:20:32,232 --> 00:20:33,734
Apple Watch上有个游戏


408
00:20:33,800 --> 00:20:36,170
用户不断升级从而进行游戏 


409
00:20:36,436 --> 00:20:39,106
当用户升级后 你将把进度


410
00:20:39,173 --> 00:20:41,608
后台同步到iOS方 


411
00:20:41,742 --> 00:20:44,344
iOS app展示一些细微图形 


412
00:20:45,112 --> 00:20:47,314
是关于用户在该等级
的信息用户信息传输要讲到的


413
00:20:48,015 --> 00:20:53,053
第一件事是未解决的用户信息传输队列


414
00:20:53,420 --> 00:20:55,956
这控制了所有


415
00:20:56,023 --> 00:20:57,291
等待传输的内容


416
00:20:58,492 --> 00:20:59,593
当用户升两级后 


417
00:20:59,660 --> 00:21:01,795
这时候的当前状态


418
00:21:02,596 --> 00:21:04,198
进度位于


419
00:21:04,731 --> 00:21:07,601
未解决的用户传输队列中


420
00:21:08,735 --> 00:21:10,771
目前 用户的等级是3级


421
00:21:11,572 --> 00:21:13,774
一旦他们再次升级
你将打包那些内容 


422
00:21:13,841 --> 00:21:18,145
调用Transfer
User Info 


423
00:21:18,212 --> 00:21:20,480
然后传递一个描述进度的词典


424
00:21:21,648 --> 00:21:24,117
获取到该词典后
系统将对其进行打包 


425
00:21:24,384 --> 00:21:27,721
并将它放到未解决用户输入
传输队列中


426
00:21:29,056 --> 00:21:33,093
现在这个内容将在这里等待
然后系统会根据电源情况


427
00:21:33,493 --> 00:21:35,229
或在用户
开始使用iPhone的时候 


428
00:21:35,395 --> 00:21:37,731
决定传输内容的最佳时机


429
00:21:39,166 --> 00:21:42,202
内容将被传输和先前的API一样


430
00:21:42,269 --> 00:21:46,406
我们需要等待直到iOS上app启动


431
00:21:46,940 --> 00:21:49,176
当它启动后 我们将传输内容 


432
00:21:49,910 --> 00:21:52,212
现在iOS app可以更新这些图形


433
00:21:52,279 --> 00:21:55,082
以显示用户在
Apple Watch游戏中的进度


434
00:21:56,717 --> 00:21:58,886
所以这是用户信息传输流程


435
00:21:59,319 --> 00:22:01,054
我们来看一些代码


436
00:22:03,590 --> 00:22:07,861
首先要做打包所有用户信息词典 


437
00:22:08,395 --> 00:22:10,330
这代表的是你想要发送的


438
00:22:10,397 --> 00:22:11,565
目前状态的内容全部


439
00:22:11,932 --> 00:22:14,301
然后你调用带有那个词典的


440
00:22:14,401 --> 00:22:15,369
传输用户信息


441
00:22:16,436 --> 00:22:19,806
传输用户信息
返回一个用户信息传输对象


442
00:22:20,174 --> 00:22:22,409
对象包含你正在发送的字典 


443
00:22:22,476 --> 00:22:26,880
倘若传输仍然在未解决队列 


444
00:22:26,947 --> 00:22:28,849
你可以选择取消这个传输


445
00:22:29,917 --> 00:22:32,452
除了返回这个传输对象 


446
00:22:32,986 --> 00:22:34,755
我们也提供了一个方法用来获取所有


447
00:22:34,821 --> 00:22:37,157
仍在队列中的未解决用户信息传输


448
00:22:37,958 --> 00:22:40,761
这方法返回一个数组 
你可以迭代这个数组 


449
00:22:40,827 --> 00:22:42,596
查看所有内容 


450
00:22:43,263 --> 00:22:45,165
若你需要也可取消


451
00:22:46,400 --> 00:22:48,535
所以这是用户信息传输的发送方


452
00:22:49,570 --> 00:22:51,271
我们来看下接收方


453
00:22:51,605 --> 00:22:54,408
在接收方看来你将调用 


454
00:22:54,575 --> 00:22:56,743
Did Receive User
Info Transfer


455
00:22:57,411 --> 00:23:00,247
和应用上下文和
其他所有指派回调一样 


456
00:23:00,314 --> 00:23:02,382
这是在一个非主要串联队列中被返回的


457
00:23:03,784 --> 00:23:06,019
一旦你获得回调 就可以获得


458
00:23:06,119 --> 00:23:08,589
内容和词典内容 
然后可以更新app状态


459
00:23:10,591 --> 00:23:12,392
那是用户信息传输


460
00:23:12,626 --> 00:23:14,261
它有用户输入词典


461
00:23:14,561 --> 00:23:17,164
这些词典和应用上下文词典一样 


462
00:23:17,231 --> 00:23:18,699
里面有属性清单类型


463
00:23:19,399 --> 00:23:22,603
这对于内存内容 比如游戏进度而言
 这种方法很好


464
00:23:23,704 --> 00:23:25,038
我们允许你访问


465
00:23:25,239 --> 00:23:29,710
队列中未解决的用户信息传输


466
00:23:30,844 --> 00:23:33,180
接下来 我们谈谈文件传输


467
00:23:34,481 --> 00:23:36,550
文件传输中要用到的示例是


468
00:23:36,617 --> 00:23:37,784
这个图像编辑app


469
00:23:38,585 --> 00:23:41,054
用户可在iOS编辑图片 


470
00:23:41,788 --> 00:23:43,423
然后挑选他们喜欢的图片 


471
00:23:43,490 --> 00:23:45,425
这些喜欢的图片就是我们想要


472
00:23:45,492 --> 00:23:47,661
传输到Apple Watch上的


473
00:23:48,996 --> 00:23:49,863
所以首先要说的是


474
00:23:49,930 --> 00:23:52,533
未解决的文件传输队列


475
00:23:53,133 --> 00:23:54,468
这里是所有文件传输


476
00:23:54,535 --> 00:23:56,170
等待发送的地方


477
00:23:57,204 --> 00:23:59,540
然后在接收方 文件在等待被转交到


478
00:23:59,606 --> 00:24:02,476
接收方app时 将被放入


479
00:24:02,543 --> 00:24:04,478
Documents/Inbox
文件夹


480
00:24:06,313 --> 00:24:08,515
这时候的状态是
用户有两张喜欢的图片 


481
00:24:08,582 --> 00:24:11,652
两个图像正在队列里等待 


482
00:24:12,719 --> 00:24:14,054
进程进行到第三个


483
00:24:15,122 --> 00:24:17,357
一旦完成进程并且将它挑选为


484
00:24:17,424 --> 00:24:20,727
喜欢的图片后 
你将调用Transfer File


485
00:24:21,461 --> 00:24:24,131
你将传输一个文件URL 它指向


486
00:24:24,198 --> 00:24:27,267
你想要传输的文件 
我们提供一个方法 


487
00:24:27,334 --> 00:24:31,405
以词典的方式传输附加的元数据


488
00:24:32,306 --> 00:24:35,676
你可能想要增加
一些元数据的一个情况是 


489
00:24:35,742 --> 00:24:39,713
通过在
每个元数据词典中放一个标识符 


490
00:24:40,180 --> 00:24:43,417
将一些文件集合在一起


491
00:24:43,750 --> 00:24:46,587
接收方可以识别那个标识符 


492
00:24:46,687 --> 00:24:48,055
把正在接受的文件聚集在一起


493
00:24:49,556 --> 00:24:51,692
所以这是用户喜欢的图片


494
00:24:51,859 --> 00:24:53,493
我们称之为文件传输


495
00:24:53,560 --> 00:24:56,029
现在我们将获得打包好的内容 


496
00:24:56,430 --> 00:24:58,599
我们将把它放入未解决的文件传输队列


497
00:24:59,299 --> 00:25:01,468
它将在这里等待 直到系统确定


498
00:25:01,535 --> 00:25:02,836
传输内容的最佳时间


499
00:25:03,670 --> 00:25:06,640
当系统确定传输内容的最佳时间后 


500
00:25:06,974 --> 00:25:08,675
它将开始传输内容 


501
00:25:09,042 --> 00:25:14,114
等待接收方启动并接收内容


502
00:25:15,115 --> 00:25:16,617
需要注意文件的一件事是 


503
00:25:16,683 --> 00:25:18,619
文件可能会稍微大一些


504
00:25:19,286 --> 00:25:20,888
文件越大 


505
00:25:20,954 --> 00:25:22,589
传输的时间就越长


506
00:25:22,990 --> 00:25:25,225
当传输的时候 你可能需要注意


507
00:25:25,292 --> 00:25:27,227
电源和性能的情况


508
00:25:27,661 --> 00:25:29,796
请注意
如果准备传输的是大文件 


509
00:25:29,863 --> 00:25:32,266
相比使用其他API 这种方法


510
00:25:32,633 --> 00:25:34,535
可能花费更长的时间


511
00:25:36,069 --> 00:25:37,971
现在接收者将启动设备 


512
00:25:38,071 --> 00:25:39,873
然后我们将传输这些图像


513
00:25:40,407 --> 00:25:43,310
现在Apple Watch
 app可以显示这些图像了


514
00:25:45,479 --> 00:25:48,615
所以这是文件传输流程


515
00:25:48,682 --> 00:25:49,917
我们来看一下代码


516
00:25:51,552 --> 00:25:53,787
首先你想做的是为你想要传输的文件


517
00:25:53,854 --> 00:25:55,489
获取一个URL


518
00:25:56,190 --> 00:25:58,992
然后打包你的元数据 最后


519
00:25:59,159 --> 00:26:01,762
调用Transfer File 
传输URL 


520
00:26:01,828 --> 00:26:03,297
以及元数据词典


521
00:26:04,298 --> 00:26:06,200
之后返回一个文件传输对象 


522
00:26:06,333 --> 00:26:09,503
文件传输对象包含URL 


523
00:26:09,570 --> 00:26:12,973
元数据词典 同样你也可以


524
00:26:13,040 --> 00:26:16,176
取消任何未解决的文件传输


525
00:26:18,245 --> 00:26:21,114
和用户信息传输一样 我们允许你


526
00:26:21,181 --> 00:26:25,185
撤销所有未解决文件传输的数组


527
00:26:25,485 --> 00:26:27,988
你可以迭代这个数组 检查内容 


528
00:26:28,121 --> 00:26:29,323
如若需要 也可以取消


529
00:26:30,724 --> 00:26:32,793
所以这就是文件传输的发送方


530
00:26:33,260 --> 00:26:36,530
现在我们来看看接收方


531
00:26:36,730 --> 00:26:37,931
在接收方看来 接收方会收到


532
00:26:38,065 --> 00:26:41,168
这个指派回调
Did Receive File


533
00:26:42,069 --> 00:26:44,371
关于这个指派回调 需要注意的是


534
00:26:44,438 --> 00:26:46,406
它与前面两个略有不同


535
00:26:47,474 --> 00:26:50,110
首先获得WCSession文件对象


536
00:26:50,944 --> 00:26:54,581
这个对象只包含文件URL和元数据


537
00:26:56,149 --> 00:26:59,219
关于这个回调的第二件事是


538
00:26:59,820 --> 00:27:02,289
文件现在位于
app container的


539
00:27:02,356 --> 00:27:04,258
Documents/Inbox
文件夹下


540
00:27:04,892 --> 00:27:08,962
说到控制这个文件 你需要将文件移出


541
00:27:09,029 --> 00:27:11,131
Documents/Inbox
并放到另一个


542
00:27:11,198 --> 00:27:12,566
永久位置


543
00:27:14,735 --> 00:27:18,972
移出文件的主要原因是


544
00:27:19,039 --> 00:27:20,974
在指派返回后


545
00:27:21,041 --> 00:27:23,877
Documents/Inbox
将被清空


546
00:27:24,211 --> 00:27:28,515
意思是文件将和其他内容一起被删除


547
00:27:29,283 --> 00:27:31,852
所以重要的是在文件传输之前


548
00:27:31,919 --> 00:27:35,522
将文件放到其他的位置 


549
00:27:36,590 --> 00:27:38,625
需要记住一件事 如果你正在指派到


550
00:27:38,692 --> 00:27:40,794
另一个队列 因为这是在从


551
00:27:40,861 --> 00:27:44,031
非重要串行队列返回的 


552
00:27:44,131 --> 00:27:48,368
如果该指派不同步的话 


553
00:27:48,969 --> 00:27:50,804
你需要在指派之前移动文件


554
00:27:53,373 --> 00:27:54,875
所以这是文件传输


555
00:27:55,442 --> 00:27:58,445
它和用户信息传输非常相似
但是它允许你


556
00:27:58,512 --> 00:28:01,782
传输文件或文件列队


557
00:28:02,583 --> 00:28:03,717
我们允许你


558
00:28:03,817 --> 00:28:06,353
访问队列中未解决的文件


559
00:28:07,521 --> 00:28:12,860
我们也允许你传输附加元数据


560
00:28:13,627 --> 00:28:15,796
我们建议你使用较小的元数据体积 


561
00:28:16,263 --> 00:28:17,564
另外 这个元数据词典


562
00:28:17,631 --> 00:28:19,533
和其他我们说过的词典一样 


563
00:28:19,600 --> 00:28:20,767
有属性清单类型


564
00:28:22,603 --> 00:28:25,005
所以以上是三种后台传输模式


565
00:28:25,205 --> 00:28:27,474
若接收放不是立即需要这些内容 


566
00:28:27,541 --> 00:28:28,942
请用这些模式


567
00:28:30,410 --> 00:28:35,983
但如果你需要实时来回传输信息 


568
00:28:36,350 --> 00:28:41,255
你可以使用交互信息传输


569
00:28:42,823 --> 00:28:44,758
交互信息传输指的是实时通讯 


570
00:28:44,825 --> 00:28:47,728
两个app当前都处于开启状态


571
00:28:48,061 --> 00:28:49,630
而且正在来回发送信息


572
00:28:51,098 --> 00:28:54,134
就像我先前提到的 
这里有你可能需要这么做的一些示例


573
00:28:54,801 --> 00:28:58,305
假设我们有一个游戏
游戏中两个UI都处于启动状态 


574
00:28:58,438 --> 00:29:01,508
而你想要用户与两个UI同时进行交互


575
00:29:02,042 --> 00:29:04,244
或者你正在
使用Apple Watch 你需要


576
00:29:04,311 --> 00:29:06,780
触发iOS app 


577
00:29:06,847 --> 00:29:08,615
比如查询用户的位置


578
00:29:10,284 --> 00:29:12,619
如果要使用交互信息传输 


579
00:29:12,986 --> 00:29:15,956
需要满足特定条件


580
00:29:16,190 --> 00:29:17,791
所以我们来说说这些条件


581
00:29:18,625 --> 00:29:20,194
这些条件与我们引进的概念有关 


582
00:29:20,527 --> 00:29:22,362
这个概念叫做可达性


583
00:29:23,430 --> 00:29:24,965
可达性意思是


584
00:29:25,132 --> 00:29:29,069
其他app也可以访问内容


585
00:29:29,870 --> 00:29:33,507
这要求其他app是可以访问和启动的


586
00:29:33,707 --> 00:29:36,610
从而可以使用交互信息传输


587
00:29:37,077 --> 00:29:39,346
你查看另一方是否可达的方法是 


588
00:29:40,514 --> 00:29:44,518
在默认会话中我们有可达性这个属性 
这样你可以进行查看 


589
00:29:45,786 --> 00:29:49,189
现在 
可达性的条件与之前的有些不同 


590
00:29:49,256 --> 00:29:51,825
取决于你所处的平台 不论你的代码


591
00:29:51,892 --> 00:29:53,093
是否在iOS app上执行


592
00:29:53,160 --> 00:29:55,028
或是在WatchKit扩展上执行


593
00:29:55,729 --> 00:29:57,264
我们一个一个来看


594
00:29:58,031 --> 00:29:59,733
我们从iPhone开始


595
00:30:00,667 --> 00:30:04,271
满足可达性为True的第一个条件是


596
00:30:05,405 --> 00:30:07,274
设备需被连接


597
00:30:07,641 --> 00:30:11,044
我们可以通过Bluetooth
或Wi-Fi连接 


598
00:30:11,912 --> 00:30:13,714
但是如果用户将Watch放在家里 


599
00:30:14,381 --> 00:30:17,084
拿了iPhone去上班
这种情况下设备就无法被连接 


600
00:30:17,417 --> 00:30:19,620
交互信息传输就无法进行


601
00:30:20,621 --> 00:30:23,123
iOS上可达性为True 


602
00:30:23,190 --> 00:30:25,359
需要满足的第二个条件是


603
00:30:25,492 --> 00:30:27,995
Watch app
必须处于前台操作状态


604
00:30:28,395 --> 00:30:31,532
意思是为了在
iOS上进行交换信息传输 


605
00:30:31,732 --> 00:30:34,735
用户必须与Watch app交互


606
00:30:35,536 --> 00:30:37,137
一旦满足以上两个条件 


607
00:30:38,672 --> 00:30:41,475
你的iOS app上
可达性属性也将为True


608
00:30:44,011 --> 00:30:45,412
所以这是iPhone方面


609
00:30:47,181 --> 00:30:49,016
来说说Apple Watch方面


610
00:30:49,683 --> 00:30:51,752
在你的WatchKit扩展设备上


611
00:30:51,952 --> 00:30:53,720
可达性为True的第一个条件是


612
00:30:53,787 --> 00:30:56,256
必须连接设备


613
00:30:57,391 --> 00:30:59,927
意思是说倘若用户去跑步 
没带iPhone


614
00:30:59,993 --> 00:31:01,461
只带了Watch


615
00:31:02,829 --> 00:31:05,299
可达性就不会为True
设备将无法被连接


616
00:31:06,200 --> 00:31:07,167
第二个条件是


617
00:31:07,901 --> 00:31:10,404
WatchKit
外设必须处于前台运行状态


618
00:31:11,305 --> 00:31:13,674
提到WatchKit
外设处于前台运行状态


619
00:31:13,740 --> 00:31:15,275
是因为在不少示例中


620
00:31:15,342 --> 00:31:17,611
WatchKit外设可以在后台运行


621
00:31:18,245 --> 00:31:20,013
主要
与complication有关


622
00:31:20,080 --> 00:31:22,683
我们等下会谈到这个


623
00:31:23,584 --> 00:31:27,788
所以现在 当用户使用你的app时


624
00:31:27,855 --> 00:31:29,389
你的WatchKit外设


625
00:31:29,523 --> 00:31:31,692
也将被启动并被置于前台运行状态


626
00:31:31,792 --> 00:31:33,794
这也就是说
你可以使用交互信息传输


627
00:31:34,328 --> 00:31:36,163
并且可达性属性为True


628
00:31:37,731 --> 00:31:39,867
关于这个图表 还需要注意的是


629
00:31:40,267 --> 00:31:43,003
我们并没有
说iOS app当前正在运行


630
00:31:44,104 --> 00:31:49,276
iOS app必须处于运行状态 
 以对进来的信息作出反应


631
00:31:49,476 --> 00:31:50,711
并发出自己的信息


632
00:31:51,044 --> 00:31:53,780
所以当iOS app
在WatchKit外设之外运行时


633
00:31:53,847 --> 00:31:55,449
我们如何进入一个状态呢


634
00:31:56,083 --> 00:31:59,887
仅针对这个词典将信息
从Watch发送到iPhone


635
00:32:00,153 --> 00:32:03,857
或者允许iOS app


636
00:32:04,057 --> 00:32:06,460
在接收信息的基础上
在后台启动


637
00:32:07,261 --> 00:32:08,695
我们拿这个做例子


638
00:32:08,795 --> 00:32:10,297
你有一个运行追踪器app


639
00:32:10,764 --> 00:32:13,767
它需要发送信息到iPhone


640
00:32:13,834 --> 00:32:19,506
告诉CoreLocation
开始追踪用户的信息


641
00:32:20,641 --> 00:32:23,911
所以这个app将打包一个信息


642
00:32:23,977 --> 00:32:26,547
告诉iOS app开始运行
CoreLocation


643
00:32:27,281 --> 00:32:29,016
它将发出启动信息


644
00:32:29,082 --> 00:32:31,151
当系统受到这个信息时


645
00:32:31,218 --> 00:32:33,086
我们将在后台启动iOS app


646
00:32:33,554 --> 00:32:34,688
并传输那个信息


647
00:32:35,122 --> 00:32:38,258
现在 两个app都在运行 
 它们可以进行互动了


648
00:32:38,659 --> 00:32:41,461
这个示例中的app


649
00:32:41,528 --> 00:32:42,596
可以开始追踪用户位置


650
00:32:43,997 --> 00:32:46,466
所以那是交互信息传输流


651
00:32:47,801 --> 00:32:48,802
当你可以使用它时


652
00:32:48,869 --> 00:32:50,604
它如何和可达性有关系


653
00:32:50,771 --> 00:32:52,506
现在我们来具体讲讲


654
00:32:52,573 --> 00:32:53,941
如何在你的代码中使用它


655
00:32:55,509 --> 00:32:57,377
我提供两种不同类型的信息


656
00:32:57,978 --> 00:32:59,746
第一种发出一个词典


657
00:33:00,214 --> 00:33:02,516
你使用
词典调用Send Message


658
00:33:02,749 --> 00:33:03,984
这个调用携带词典


659
00:33:04,051 --> 00:33:06,420
加上一个回复处理器
和一个错误处理器


660
00:33:07,387 --> 00:33:10,057
这个词典
和我们先前说过的词典一样 


661
00:33:10,123 --> 00:33:12,359
里面有属性清单类型


662
00:33:14,561 --> 00:33:16,129
除了词典外


663
00:33:16,196 --> 00:33:18,999
我们还引入了发送数据的方法


664
00:33:19,533 --> 00:33:21,935
可调用Send
 Message Data发送数据


665
00:33:22,002 --> 00:33:24,605
这个携带数据 相同的回复处理器


666
00:33:24,805 --> 00:33:25,939
和错误处理器


667
00:33:26,807 --> 00:33:30,410
关于发送数据 


668
00:33:30,477 --> 00:33:32,079
如果你有存储自己信息的
自定义数据


669
00:33:32,412 --> 00:33:34,548
或你自己的序列化格式
我们建议你使用这个


670
00:33:35,983 --> 00:33:38,418
若你使用自己的序列化格式


671
00:33:38,485 --> 00:33:41,755
我们强烈建议你使用小而快的格式


672
00:33:42,155 --> 00:33:45,025
这样用户体验更快


673
00:33:45,092 --> 00:33:46,927
因为内容可以更快进行传输


674
00:33:48,729 --> 00:33:52,533
关于这些调用
 我想要指出一点 就是回复


675
00:33:53,100 --> 00:33:56,103
你或许注意
到了先前两个调用中有回复处理器


676
00:33:57,571 --> 00:33:59,173
这个处理器是可选的


677
00:33:59,673 --> 00:34:02,543
然而 在多数情况下
 我们建议你使用它


678
00:34:03,377 --> 00:34:05,746
原因是


679
00:34:05,812 --> 00:34:07,714
这可让接收者确认进来的信息


680
00:34:08,447 --> 00:34:10,551
接收者可以确认它接收到信息


681
00:34:10,650 --> 00:34:13,020
信息包含正确的内容


682
00:34:13,085 --> 00:34:14,321
它也可以处理那些内容


683
00:34:14,955 --> 00:34:18,525
这样一来 发送方就知道
它不需要再发送任何东西了


684
00:34:18,792 --> 00:34:20,293
它不需要在发送新信息了


685
00:34:20,360 --> 00:34:21,527
因为它发的是错误的信息


686
00:34:23,996 --> 00:34:27,601
回复需要谈到的另一部分是


687
00:34:28,302 --> 00:34:30,003
接收方这边的情况


688
00:34:31,938 --> 00:34:36,043
如果发送者说 我想要回复 
所以我将提供一个回复处理器


689
00:34:36,109 --> 00:34:38,712
与之相反的 如果发送者说


690
00:34:38,779 --> 00:34:41,614
我不想回复 不提供一个回复处理器 
这时会发生什么呢


691
00:34:42,616 --> 00:34:43,617
这种情况下


692
00:34:43,684 --> 00:34:46,920
接收方会收到单独指派回调


693
00:34:46,987 --> 00:34:49,022
这取决于
我们是否应该提供回复


694
00:34:51,058 --> 00:34:53,226
我们来说说这些指派回调


695
00:34:53,760 --> 00:34:56,797
第一种情况 发送者说


696
00:34:57,164 --> 00:34:59,032
我需要回复 
我为系统提供一个回复处理器


697
00:34:59,466 --> 00:35:01,969
意思是接收方将收到
这个指派回调


698
00:35:02,035 --> 00:35:06,039
Did Receive 
Message它有一个回复块


699
00:35:06,440 --> 00:35:10,277
你可以在接收者接收
并处理信息之后调用回复块


700
00:35:10,644 --> 00:35:12,346
接收者就可以决定


701
00:35:12,412 --> 00:35:14,281
是否发回一些内容


702
00:35:14,348 --> 00:35:17,184
或者如果信息是错误的 
 就发回一个错误


703
00:35:18,785 --> 00:35:19,953
现在 从另一方面来说


704
00:35:20,020 --> 00:35:24,124
倘若发送者
并未提供一个回复处理器


705
00:35:25,359 --> 00:35:26,493
接收者将获得


706
00:35:26,560 --> 00:35:29,930
指派回调
Did Receive Message


707
00:35:30,330 --> 00:35:31,932
它没有回复块


708
00:35:31,999 --> 00:35:34,134
接收方可以处理进来的内容


709
00:35:34,368 --> 00:35:35,269
然后就结束了


710
00:35:36,470 --> 00:35:37,638
关于这两个指派回调


711
00:35:37,704 --> 00:35:40,741
需要注意的
最后一件事是他们通过一个词典


712
00:35:41,842 --> 00:35:45,612
意思是说发送者使用发送信息


713
00:35:45,712 --> 00:35:49,249
从发送方这边发送出一个词典


714
00:35:49,783 --> 00:35:54,888
倘若 发送者使用发送信息数据
发送数据


715
00:35:55,522 --> 00:35:59,593
在接收方会收到
一个类似的回调通过数据


716
00:36:01,895 --> 00:36:05,499
现在 我们简单了解了交互信息传输


717
00:36:05,566 --> 00:36:08,402
将所有的这些放在一起
 并进行编码


718
00:36:09,203 --> 00:36:10,470
你首先要做的是


719
00:36:11,004 --> 00:36:12,105
检查可达性


720
00:36:12,573 --> 00:36:15,075
确保另一边是确实可达的


721
00:36:15,742 --> 00:36:20,147
然后 倘若可达性为True
那你就可以打包你的信息了


722
00:36:21,515 --> 00:36:23,050
一旦你有了信息


723
00:36:23,183 --> 00:36:25,419
你就可以使用词典
调用Send Message


724
00:36:26,486 --> 00:36:27,654
然后期待收到一个回复


725
00:36:27,721 --> 00:36:29,723
所以我们将提供回复处理器


726
00:36:31,124 --> 00:36:32,759
我们想要处理我们的错误


727
00:36:32,960 --> 00:36:34,528
所以我们将启动错误处理器


728
00:36:36,296 --> 00:36:38,232
使用
WatchConnectivity


729
00:36:38,298 --> 00:36:40,167
传输内容的不同方法


730
00:36:41,268 --> 00:36:42,369
来总结一下所讲的


731
00:36:42,436 --> 00:36:44,404
关于
WatchConnectivity


732
00:36:46,039 --> 00:36:47,374
首先要做的是


733
00:36:47,441 --> 00:36:48,775
设置会话


734
00:36:50,844 --> 00:36:53,347
为做到这个 你设置指派 
 调用Activate


735
00:36:53,747 --> 00:36:56,416
你需在app的使用周期里今早执行


736
00:36:56,683 --> 00:36:59,219
这样app就可以开始接收内容


737
00:36:59,553 --> 00:37:01,121
然后检查属性


738
00:37:02,923 --> 00:37:05,425
在检查这些属性时候 
你可以查看会话状态


739
00:37:06,226 --> 00:37:07,561
一旦一切都好了


740
00:37:07,628 --> 00:37:09,263
而且你知道Watch已经配对


741
00:37:09,630 --> 00:37:11,765
同时Apple Watch app
也安装了


742
00:37:12,199 --> 00:37:13,333
你就可以开始通讯了


743
00:37:15,235 --> 00:37:17,671
第一种沟通是后台传输


744
00:37:19,640 --> 00:37:21,241
我们提供三种类型


745
00:37:21,742 --> 00:37:23,477
第一种是应用上下文


746
00:37:23,810 --> 00:37:27,281
这是信息的单一子集


747
00:37:27,347 --> 00:37:28,882
这个子集是
为另一方app准备的


748
00:37:29,349 --> 00:37:30,951
或者 倘若你需要列队内容


749
00:37:31,151 --> 00:37:34,321
你可以使用用户信息传输
或文件传输


750
00:37:36,156 --> 00:37:37,724
除了后台传输


751
00:37:37,791 --> 00:37:39,560
在实时沟通方面


752
00:37:39,960 --> 00:37:41,395
我们还可以使用交互信息传输


753
00:37:42,996 --> 00:37:44,498
就是
WatchConnectivity


754
00:37:44,565 --> 00:37:47,034
它允许你的
app进行设备对设备的通讯


755
00:37:47,501 --> 00:37:49,703
我们非常期待


756
00:37:50,370 --> 00:37:52,806
你们会如何使用这个API进行通讯


757
00:37:52,873 --> 00:37:54,775
如何提供更棒的用户体验


758
00:37:55,843 --> 00:38:00,280
接下来...
将简要说说NSURLSession


759
00:38:01,381 --> 00:38:03,050
什么是NSURLSession


760
00:38:03,517 --> 00:38:05,485
它是一个现有的基础类


761
00:38:06,053 --> 00:38:08,755
它允许你为服务器提出HTTP请求


762
00:38:09,089 --> 00:38:10,824
从而读取内容


763
00:38:11,758 --> 00:38:14,895
它在watchOS 2上适用
倘若在你的服务器上


764
00:38:14,962 --> 00:38:17,331
有内容需要读取 
我强烈建议你使用它


765
00:38:17,865 --> 00:38:20,801
它利用了
Tetherless Wi-Fi特征


766
00:38:21,401 --> 00:38:24,137
在没带iPhone的时候
Tetherless Wi-Fi


767
00:38:24,204 --> 00:38:26,807
允许Apple Watch
连接到已知的Wi-Fi网络


768
00:38:27,774 --> 00:38:30,444
若Apple Watch
已经连接到已知Wi-Fi网络


769
00:38:30,511 --> 00:38:34,948
你可使用NSURLSession
通过Wi-Fi网络


770
00:38:35,015 --> 00:38:36,917
连接到你的服务器并获取信息


771
00:38:39,152 --> 00:38:41,488
所以你会如何
使用NSURLSession呢？


772
00:38:41,655 --> 00:38:44,925
当你的服务器有新内容时
你都可以使用它


773
00:38:45,592 --> 00:38:47,861
这个和你通过
iOS app进行的操作


774
00:38:47,928 --> 00:38:49,029
非常的相似


775
00:38:49,796 --> 00:38:54,735
我们建议
根据Apple Watch的需求


776
00:38:54,801 --> 00:39:00,674
定制发送到
Apple Watch的内容


777
00:39:01,108 --> 00:39:03,043
若你的服务器上有图片


778
00:39:03,844 --> 00:39:08,549
建议按照Apple Watch
屏幕尺寸按比例决定图片尺寸


779
00:39:08,815 --> 00:39:10,384
若是一个新app


780
00:39:10,450 --> 00:39:13,554
你只想在Apple Watch
上显示部分内容或许只是文本


781
00:39:13,754 --> 00:39:15,756
我们建议你
只截取你所需的部分


782
00:39:17,357 --> 00:39:20,827
以上是关于
NSURLSession的简要介绍


783
00:39:21,361 --> 00:39:26,466
在WWDC会议上 
有关于这个API的部分


784
00:39:26,533 --> 00:39:27,734
同样也有在线资源部分


785
00:39:28,335 --> 00:39:30,604
我们建议你看看这些


786
00:39:31,205 --> 00:39:32,706
关于NSURLSession


787
00:39:32,773 --> 00:39:35,676
最后要讲的是使用
WatchConnectivity


788
00:39:36,343 --> 00:39:37,778
NSURLSession


789
00:39:38,645 --> 00:39:41,081
再一次 我们有新app的示例


790
00:39:42,149 --> 00:39:45,719
这个新app从它的
服务器上读取一些内容


791
00:39:46,186 --> 00:39:47,254
而且它知道


792
00:39:47,321 --> 00:39:51,024
Apple Watch app
可能将读取这些相同内容


793
00:39:51,391 --> 00:39:54,228
下次用户启动
Apple Watch app时


794
00:39:54,595 --> 00:39:58,131
为了不让Apple Watch
app重新获取内容


795
00:39:58,732 --> 00:40:01,969
我将利用应用上下文


796
00:40:02,169 --> 00:40:04,671
将内容从iOS传输到Watch


797
00:40:06,874 --> 00:40:09,076
内容会不断被传输进来


798
00:40:09,142 --> 00:40:11,612
再启动Apple Watch
 app会被传输到它上


799
00:40:11,678 --> 00:40:13,547
Apple Watch app可以


800
00:40:13,614 --> 00:40:16,550
显示在iOS上看到的相同内容


801
00:40:16,917 --> 00:40:19,253
而且它提供更多的细微体验


802
00:40:20,754 --> 00:40:23,624
用户下次启动
Apple Watch app时


803
00:40:23,690 --> 00:40:25,993
可能是数小时后


804
00:40:26,193 --> 00:40:29,129
这也就说


805
00:40:29,196 --> 00:40:30,397
服务器有更新的内容要读取


806
00:40:30,797 --> 00:40:31,965
所以 我们建议


807
00:40:32,032 --> 00:40:35,602
除了在应用上下文
获取已经发送的内容外


808
00:40:36,403 --> 00:40:39,306
使用带NSURLSession
的HTTP请求


809
00:40:39,373 --> 00:40:43,076
从你的服务器上
读取绝对最新的内容


810
00:40:44,411 --> 00:40:47,447
这样
在用户等待新内容时


811
00:40:47,514 --> 00:40:50,450
他们将看到
在iOS上看到的相同内容


812
00:40:50,517 --> 00:40:53,954
这样将有更好的体验


813
00:40:55,756 --> 00:40:57,624
所以这是NSURLSession和


814
00:40:57,691 --> 00:40:59,526
WatchConnectivity


815
00:40:59,860 --> 00:41:03,530
现在 我们想要采用这两种API
我们想要为你展示


816
00:41:03,597 --> 00:41:06,633
如何使用它们获取数据 
放到complication中


817
00:41:07,067 --> 00:41:09,469
关于这部分


818
00:41:09,536 --> 00:41:11,605
有请克里斯上台为我们讲解


819
00:41:18,512 --> 00:41:20,781
谢谢你 亚历克斯
这些东西很酷 是吧


820
00:41:21,248 --> 00:41:24,618
我想你们使用
Watch Connectivity API


821
00:41:24,718 --> 00:41:26,720
和NSURLSession API


822
00:41:26,787 --> 00:41:28,856
做的东西 一定很棒


823
00:41:29,590 --> 00:41:31,592
现在我们来讨论
complications


824
00:41:31,658 --> 00:41:34,161
在深入讲解之前


825
00:41:34,228 --> 00:41:35,896
先确定大家看的是一个内容


826
00:41:36,763 --> 00:41:38,866
这些是在Apple Watch上的


827
00:41:38,932 --> 00:41:41,535
三个Watch表面 三个时钟画面


828
00:41:41,802 --> 00:41:43,470
若你移除时钟 


829
00:41:43,971 --> 00:41:45,806
剩下的就是
complications


830
00:41:46,707 --> 00:41:48,475
每次用户看时钟画面时


831
00:41:48,542 --> 00:41:53,647
他们会看到少量信息


832
00:41:54,281 --> 00:41:57,317
这将让用户可以快速获得


833
00:41:57,384 --> 00:41:59,853
最重要的信息


834
00:42:02,222 --> 00:42:04,157
当你使用complication时


835
00:42:04,224 --> 00:42:06,460
你将需要解决两个主要任务


836
00:42:07,494 --> 00:42:09,997
你需要知道如何更新时钟画面


837
00:42:10,430 --> 00:42:14,134
第二件事是 你需要拿到
用来更新时钟画面的内容


838
00:42:16,603 --> 00:42:18,872
我们来讨论一下 你如何
简单地更新时钟画面


839
00:42:18,939 --> 00:42:21,241
其他会议上 有深入讨论


840
00:42:22,176 --> 00:42:24,545
在这个示例中


841
00:42:24,611 --> 00:42:27,181
用一个天气app
有个月相complication


842
00:42:27,447 --> 00:42:29,750
这个月相complication
不需外部数据


843
00:42:29,816 --> 00:42:31,585
它已经有它所需的全部信息


844
00:42:31,652 --> 00:42:33,053
因为它只需要数据和时间


845
00:42:34,054 --> 00:42:37,758
所以它所关心的是如何更新时钟画面


846
00:42:38,892 --> 00:42:41,628
为做到这点
它将使用新ClockKit API


847
00:42:41,962 --> 00:42:44,064
watchOS 2
引进的ClockKit框架


848
00:42:46,500 --> 00:42:50,204
流程运作的方式是


849
00:42:50,270 --> 00:42:52,706
我们将在
后台启动WatchKit外设


850
00:42:55,008 --> 00:42:57,711
当这发生时 我们将获取到


851
00:42:57,811 --> 00:43:00,013
一个CLK 
complications服务器例


852
00:43:00,380 --> 00:43:02,449
你调用
Shared Instance来实现


853
00:43:02,616 --> 00:43:05,786
用Extend Timeline 
For Complication


854
00:43:06,186 --> 00:43:08,388
进入正在更新的
complication


855
00:43:10,624 --> 00:43:12,125
接下来会发生的是


856
00:43:12,192 --> 00:43:14,228
它们将调用ClockKit激发程序


857
00:43:14,428 --> 00:43:16,830
然后开始问一堆的问题


858
00:43:17,097 --> 00:43:19,099
它们询问现有时间轴项目


859
00:43:19,499 --> 00:43:21,201
这是即将显示的内容之一


860
00:43:23,003 --> 00:43:25,706
它们询问先前的时间轴项目


861
00:43:26,106 --> 00:43:29,877
未来的时间轴项目


862
00:43:30,043 --> 00:43:32,513
最后它们询问你的建议
什么时候这些数据才算过时


863
00:43:32,679 --> 00:43:35,349
这是给系统的建议


864
00:43:35,616 --> 00:43:37,851
这样我们才知道
你什么时候需要再次启动


865
00:43:38,752 --> 00:43:40,888
你可以进一步更新时间轴


866
00:43:42,256 --> 00:43:45,859
以上是更新时钟画面的 简要介绍


867
00:43:45,926 --> 00:43:48,996
你可用ClockKit来做上述事情


868
00:43:49,329 --> 00:43:50,964
你可以提供过去的


869
00:43:51,031 --> 00:43:52,566
现在的 以及未来的内容


870
00:43:54,501 --> 00:43:57,738
你的WatchKit外设将在后台
进行这些更新


871
00:43:58,238 --> 00:43:59,339
而且你可以规定


872
00:43:59,406 --> 00:44:01,775
所提供的的内容什么时候过时


873
00:44:02,876 --> 00:44:04,144
需要注意的一点是


874
00:44:04,278 --> 00:44:07,748
WatchKit外设更新


875
00:44:07,814 --> 00:44:09,583
complication动作是预设


876
00:44:09,950 --> 00:44:12,653
所以你尽可能使之尽快完成


877
00:44:12,719 --> 00:44:15,489
这样就可以
一整天保持启动状态


878
00:44:15,722 --> 00:44:17,457
以更新你的complication


879
00:44:19,026 --> 00:44:21,495
正如我提到的关于这个话题 
有个很棒的演讲


880
00:44:21,562 --> 00:44:23,664
Creating Complications 


881
00:44:23,730 --> 00:44:26,600
with ClockKit 
如果你还没看过 我们希望你去看一下


882
00:44:27,734 --> 00:44:29,436
下一个你必须做的事是


883
00:44:29,503 --> 00:44:32,005
如何将内容
放到你的complication


884
00:44:32,272 --> 00:44:35,843
有个特别的示例即初始激活


885
00:44:35,909 --> 00:44:39,746
用户首次进入时钟画面时


886
00:44:39,880 --> 00:44:41,181
他可以进入对其进行编辑


887
00:44:41,849 --> 00:44:43,550
会启动你的complication


888
00:44:43,617 --> 00:44:45,752
这里指的是
新app complication


889
00:44:45,986 --> 00:44:46,987
此刻


890
00:44:47,054 --> 00:44:50,023
那个
complication的时间轴上


891
00:44:50,090 --> 00:44:51,725
数据可能很少或甚至没有数据


892
00:44:52,392 --> 00:44:54,328
所以它对内容有大量的需求


893
00:44:56,230 --> 00:44:57,965
马上要做的是


894
00:44:58,031 --> 00:45:00,000
立即在后台启动WatchKit外设


895
00:45:00,667 --> 00:45:03,203
现在 你有很多方式可以获得内容


896
00:45:03,470 --> 00:45:06,473
所以 你可以初始化时间轴


897
00:45:09,009 --> 00:45:11,979
你可以调用NSURLSession
与服务器通讯


898
00:45:12,446 --> 00:45:14,248
从而获得内容


899
00:45:15,249 --> 00:45:17,618
或可选择使用
WatchConnectivity


900
00:45:18,352 --> 00:45:20,087
若你在这个特别情况下


901
00:45:20,153 --> 00:45:22,356
使用
WatchConnectivity


902
00:45:22,422 --> 00:45:26,226
设备是连接的
你会发现可达性为True


903
00:45:26,293 --> 00:45:28,328
这是亚历克斯先前提到的


904
00:45:28,629 --> 00:45:30,030
在特定情况下


905
00:45:30,097 --> 00:45:32,332
这时候的这个属性是True


906
00:45:32,399 --> 00:45:33,300
这是其中之一


907
00:45:33,934 --> 00:45:37,204
在这个示例中
另外可调用Send Message


908
00:45:37,471 --> 00:45:40,507
它将把信息传输到iPhone上


909
00:45:40,941 --> 00:45:44,845
我们将在后台启动天气app


910
00:45:45,646 --> 00:45:48,382
此时 iOS上的天气app


911
00:45:48,448 --> 00:45:52,119
可以使用任何
WatchConnectivity


912
00:45:52,186 --> 00:45:54,721
API返回信息并填充到时间轴


913
00:45:58,358 --> 00:45:59,226
总的来说


914
00:45:59,293 --> 00:46:01,295
当你运行初始激活时


915
00:46:01,528 --> 00:46:03,830
WatchKit外设将在后台启动


916
00:46:03,964 --> 00:46:06,733
你可以使用
NSURLSession或者


917
00:46:06,800 --> 00:46:09,736
因为这是非常特殊的情况


918
00:46:10,070 --> 00:46:13,207
WatchConnectivity
API启动iOS app


919
00:46:13,340 --> 00:46:14,775
因为可达性为True


920
00:46:15,442 --> 00:46:16,710
我建议你用这个


921
00:46:16,777 --> 00:46:19,780
尽可能多
的填充ClockKit时间轴


922
00:46:19,980 --> 00:46:22,316
因为开始时 里面没有数据


923
00:46:23,717 --> 00:46:26,854
接下来是如何保持最新状态


924
00:46:28,088 --> 00:46:29,656
你的时间轴现在已被填满


925
00:46:29,723 --> 00:46:31,758
而更新也即将开始


926
00:46:31,825 --> 00:46:33,794
如何
保持更新complication


927
00:46:35,295 --> 00:46:36,496
有很多不同的方法


928
00:46:36,563 --> 00:46:39,566
可以用来
更新你的complication


929
00:46:40,033 --> 00:46:42,436
你可以将
内容传输到complication


930
00:46:43,036 --> 00:46:45,372
也就是说 若你有个外部源


931
00:46:45,439 --> 00:46:48,175
比如说web服务器 
它知道新内容出现的具体时间


932
00:46:48,242 --> 00:46:51,144
而且是不定期更新的


933
00:46:51,812 --> 00:46:53,714
你将做的是


934
00:46:53,780 --> 00:46:55,849
将内容从云中拿出 放到iPhone


935
00:46:56,183 --> 00:46:57,985
然后传输到Apple Watch


936
00:46:58,952 --> 00:47:02,155
我们比较容易理解这点的
一个示例是比如体育app


937
00:47:02,356 --> 00:47:05,792
显示比赛
分数时就是complication


938
00:47:06,693 --> 00:47:07,561
多数时间里 


939
00:47:07,628 --> 00:47:10,697
分数只在一天当中
很短的一段时间内发生改变


940
00:47:10,764 --> 00:47:12,766
所以可以很快进行更新


941
00:47:13,066 --> 00:47:15,435
然后 接下来我们认为
更合理的方法是使用推送方法


942
00:47:15,569 --> 00:47:18,205
另一个方法是我正在调用请求间隔读取


943
00:47:18,672 --> 00:47:20,674
这个更多的是用在
你知道有定期更新的情况


944
00:47:20,774 --> 00:47:23,076
这样你可以保持
更新你的complication


945
00:47:23,143 --> 00:47:24,912
可用
像NSURLSession


946
00:47:24,978 --> 00:47:27,147
直接进入云


947
00:47:27,781 --> 00:47:32,152
有些冲浪app带有
潮汐complication


948
00:47:32,319 --> 00:47:34,454
显示潮汐模式


949
00:47:34,521 --> 00:47:37,724
这样你就可以知道
什么时候可以冲浪了


950
00:47:38,959 --> 00:47:40,961
我们先来看一下这个例子


951
00:47:44,665 --> 00:47:47,701
你想用NSURLSession
和ClockKit


952
00:47:47,768 --> 00:47:49,236
更新complication


953
00:47:49,303 --> 00:47:51,505
从时钟画面的角落可看到


954
00:47:51,572 --> 00:47:53,941
冲浪complication
已经启动


955
00:47:55,776 --> 00:47:58,045
这个流程看起来是这样的


956
00:47:58,111 --> 00:48:00,647
在后台启动的WatchKit外设


957
00:48:01,181 --> 00:48:04,084
你想创建一个
NSURLSession请求


958
00:48:04,151 --> 00:48:06,453
并将它发送到服务器
以获取内容


959
00:48:07,287 --> 00:48:09,056
服务器将生成一个响应


960
00:48:09,122 --> 00:48:11,625
并将传输回WatchKit外设


961
00:48:12,359 --> 00:48:15,229
现在你想打开并更新ClockKit


962
00:48:15,295 --> 00:48:18,732
你将要求他们
扩展你的时间轴


963
00:48:19,466 --> 00:48:22,002
它们将通过问问题开始


964
00:48:22,069 --> 00:48:24,538
你将提供过去 现在的
时间轴更新


965
00:48:24,638 --> 00:48:28,141
最后 你将给出一个建议时间


966
00:48:28,208 --> 00:48:29,610
什么时候应该再次启动


967
00:48:31,979 --> 00:48:35,282
最后一件事


968
00:48:35,349 --> 00:48:37,484
当你提供下次启动时间时


969
00:48:37,551 --> 00:48:39,419
系统会获得
你的工作已经做完的提示


970
00:48:40,020 --> 00:48:43,390
你的WatchKit外设也将被隔离


971
00:48:44,892 --> 00:48:47,060
现在 我们假设经过一段时间后


972
00:48:47,494 --> 00:48:50,898
系统根据你的提示和系统条件


973
00:48:51,031 --> 00:48:53,534
认为现在是
重启complication的


974
00:48:53,600 --> 00:48:55,502
最好时间


975
00:48:56,303 --> 00:48:58,405
再一次 你将在后台启动


976
00:48:59,106 --> 00:49:01,341
你将调用NSURLSession
生成一个请求


977
00:49:01,408 --> 00:49:03,043
你将把它发送到服务器


978
00:49:03,710 --> 00:49:05,479
服务器将生成一个响应


979
00:49:05,679 --> 00:49:09,650
你将使用ClockKit打开并
更新你的complication


980
00:49:14,154 --> 00:49:17,491
概括一下 我们建议你


981
00:49:17,558 --> 00:49:20,561
如果可能的话就使
NSURLSession后台会话


982
00:49:21,328 --> 00:49:23,931
这是因为 在下次外设运作之后


983
00:49:23,997 --> 00:49:25,866
NSURLSession
请求才会完成


984
00:49:26,099 --> 00:49:27,534
使用后台会话 


985
00:49:27,601 --> 00:49:29,603
可使它在下次运作时传输内容


986
00:49:32,172 --> 00:49:35,342
提供的请求时间只是给系统的一个建议


987
00:49:35,409 --> 00:49:36,577
并不能保证确实如此


988
00:49:37,010 --> 00:49:40,380
我们将尽可能逼近准确时间
而且使用条件


989
00:49:40,747 --> 00:49:43,116
在这时候也不一定总是满足


990
00:49:44,251 --> 00:49:46,553
我们建议你让运作时间
尽可能的短


991
00:49:46,887 --> 00:49:49,723
你调用ClockKit更新时钟画面


992
00:49:50,123 --> 00:49:52,059
你想让运行时间尽可能的短


993
00:49:52,459 --> 00:49:58,232
而且让下次更新请求的
时间间隔尽可能的大


994
00:49:58,298 --> 00:50:01,935
因为这是预设的 
你不想在一天结束之前就用完这些安排


995
00:50:03,437 --> 00:50:06,206
另一个获得内容的方法


996
00:50:06,273 --> 00:50:08,775
比如在使用体育app的示例中


997
00:50:09,176 --> 00:50:10,577
是推送这些内容


998
00:50:14,581 --> 00:50:16,383
我们将在不同数个阶段中查看内容


999
00:50:16,450 --> 00:50:19,820
因为这会用到两个非常独特的进程


1000
00:50:19,887 --> 00:50:23,590
首先 你用PushKit


1001
00:50:23,690 --> 00:50:26,660
将内容从云推送到iPhone


1002
00:50:29,897 --> 00:50:32,199
第二部分是用
WatchConnectivity


1003
00:50:32,266 --> 00:50:35,936
将内容从iPhone
推送到Apple Watch


1004
00:50:36,737 --> 00:50:37,871
我们分别来看一下


1005
00:50:39,173 --> 00:50:41,441
所以第一部分是


1006
00:50:41,575 --> 00:50:43,577
用PushKit
将内容传输到iPhone


1007
00:50:44,311 --> 00:50:46,780
你已更新PushKit框架


1008
00:50:47,648 --> 00:50:50,350
从而支持
complication推送


1009
00:50:50,417 --> 00:50:53,453
使用方法是创建一个
PKPushRegistry实例


1010
00:50:55,289 --> 00:50:57,791
接下来 你将自己设置成指派


1011
00:50:57,858 --> 00:51:00,427
这样 你就可以接收回调了


1012
00:51:01,695 --> 00:51:04,097
最后 你将设置推送类型


1013
00:51:04,164 --> 00:51:06,400
并传输新PK推送类型
complication


1014
00:51:06,466 --> 00:51:08,402
这是之前添加到iOS9中的


1015
00:51:09,102 --> 00:51:12,606
一旦完成 你将收到
带新Push记号的指派回调


1016
00:51:12,673 --> 00:51:16,310
之后上传到你的服务器


1017
00:51:16,376 --> 00:51:19,213
也将让服务器可以将推送发送到设备上


1018
00:51:20,013 --> 00:51:21,682
最后 当服务器发出推送时


1019
00:51:21,748 --> 00:51:23,283
将收到携带负载
Did Receive


1020
00:51:23,350 --> 00:51:24,751
Incoming Push回调


1021
00:51:24,818 --> 00:51:26,086
这是你可以返回来 


1022
00:51:26,687 --> 00:51:28,822
使用
WatchConnectivity


1023
00:51:28,889 --> 00:51:30,924
API 将内容发送到iPhone时


1024
00:51:36,697 --> 00:51:37,965
所以 第二部分 这时候


1025
00:51:38,031 --> 00:51:40,868
可以使用
WatchConnectivity


1026
00:51:40,934 --> 00:51:42,836
将在iOS app上收到的内容


1027
00:51:42,903 --> 00:51:44,638
发送到
Apple Watch app


1028
00:51:47,741 --> 00:51:49,376
首先要用到的是


1029
00:51:49,443 --> 00:51:52,880
亚历克斯先前说到的
传输用户信息API


1030
00:51:54,181 --> 00:51:56,517
这种方式可让你项目排队等候


1031
00:51:56,884 --> 00:51:59,853
Watchcomplication
可能需要的


1032
00:51:59,920 --> 00:52:02,789
为过去和未来的时间轴


1033
00:52:04,091 --> 00:52:06,660
一旦所有的时间轴项目排完队


1034
00:52:07,127 --> 00:52:09,496
在完成工作前需要做的
最后一件事是


1035
00:52:09,563 --> 00:52:11,732
调用一个专门的API


1036
00:52:12,099 --> 00:52:13,901
WatchConnectivity
的一部分


1037
00:52:13,967 --> 00:52:16,670
它调用了传输当前
complication用户信息


1038
00:52:16,770 --> 00:52:19,039
这是传输用户信息的专门版本


1039
00:52:19,106 --> 00:52:20,174
不管在什么时候


1040
00:52:20,240 --> 00:52:22,809
只允许存在一个当前
complication用户信息


1041
00:52:22,876 --> 00:52:24,611
若你调用两次


1042
00:52:24,678 --> 00:52:27,814
只有最后一次被标记为当前
complication用户信息


1043
00:52:29,349 --> 00:52:30,450
当你调用时


1044
00:52:30,517 --> 00:52:32,419
对于系统来说 意思是事情已经做完了


1045
00:52:32,886 --> 00:52:36,356
在接收方 所有的回调
将生成这个指派回调


1046
00:52:36,423 --> 00:52:38,358
Did Receive
User Info


1047
00:52:41,929 --> 00:52:44,998
所以 总体而言


1048
00:52:45,065 --> 00:52:47,434
这流程看起来像什么呢 好的


1049
00:52:48,268 --> 00:52:52,606
所以 当用户第一次启动
一个体育app时


1050
00:52:53,607 --> 00:52:55,843
app在其使用周期的知哦啊其


1051
00:52:55,909 --> 00:52:59,146
将建立PK推送注册表
并设置期待类型


1052
00:52:59,546 --> 00:53:02,482
然后注册该推送类型


1053
00:53:02,583 --> 00:53:04,785
即带Apple推送服务器的设备


1054
00:53:05,252 --> 00:53:07,287
然后类型推送到Apple服务器上


1055
00:53:08,088 --> 00:53:10,257
随后将反过来生成一个Push记号


1056
00:53:10,324 --> 00:53:12,693
然后你将在你的iOS app上
收到指派回调


1057
00:53:14,895 --> 00:53:17,998
你需要收到该记号
并上传到你的服务器


1058
00:53:18,765 --> 00:53:20,100
这样以后 你的服务器


1059
00:53:20,167 --> 00:53:21,902
就可以发送推送到这个设备了


1060
00:53:22,536 --> 00:53:25,839
这个时候 
PushKit初始化设置就已经完成


1061
00:53:26,707 --> 00:53:27,808
不需要用到你的app了


1062
00:53:28,675 --> 00:53:31,745
假设这一切开始了 服务器决定


1063
00:53:31,812 --> 00:53:33,514
更新complication


1064
00:53:33,580 --> 00:53:36,683
它将发送一个推送到你的设备上


1065
00:53:38,452 --> 00:53:40,721
设备将收到推送


1066
00:53:40,787 --> 00:53:43,624
我们将在后台启动体育app
传输推送


1067
00:53:43,790 --> 00:53:45,092
那是另一个指派调用


1068
00:53:46,426 --> 00:53:49,329
这时候 你需看看
推送负载上的数据


1069
00:53:49,463 --> 00:53:52,266
确定如果要使用
WatchConnectivity


1070
00:53:52,332 --> 00:53:53,700
需要发送些什么


1071
00:53:55,369 --> 00:53:57,070
你将调用
Transfer User Info


1072
00:53:57,137 --> 00:54:00,474
将过去和未来的时间轴项目加入列队


1073
00:54:00,874 --> 00:54:03,377
然后我们可以访问
未解决用户信息传输列队


1074
00:54:03,911 --> 00:54:07,581
然后调用专门传输当前


1075
00:54:08,048 --> 00:54:09,516
complication
用户信息的重要队列


1076
00:54:09,583 --> 00:54:11,852
这也是将在Watch表面显示的队列


1077
00:54:13,387 --> 00:54:15,455
它将进入
未解决用户信息传输队列


1078
00:54:15,522 --> 00:54:16,790
但会跳过开头


1079
00:54:16,890 --> 00:54:18,425
因为它是最重要的队列


1080
00:54:19,426 --> 00:54:22,963
而且被指定为紧急优先


1081
00:54:23,297 --> 00:54:25,899
我们将立即把它传输到
Apple Watch


1082
00:54:26,533 --> 00:54:29,036
然后在后台启动WatchKit外设


1083
00:54:29,303 --> 00:54:32,005
传输当前complication
用户信息


1084
00:54:33,473 --> 00:54:36,810
如满足相关条件 
部分内容也会同时传输


1085
00:54:36,877 --> 00:54:38,712
你将获得其他时间轴项目


1086
00:54:38,779 --> 00:54:41,248
但是最重要的队列一定会被传输


1087
00:54:42,916 --> 00:54:45,886
最后 可以使用ClockKit


1088
00:54:46,153 --> 00:54:48,388
更新你的complication


1089
00:54:55,562 --> 00:54:58,966
就是这样你已使用PushKit
更新了complication


1090
00:54:59,466 --> 00:55:02,302
我们已经添加新PK
推送类型complication


1091
00:55:02,369 --> 00:55:05,105
你可以使用服务器上的信息


1092
00:55:05,572 --> 00:55:07,808
快速更新complication


1093
00:55:08,609 --> 00:55:09,710
使用这些推送类型


1094
00:55:09,776 --> 00:55:11,245
还有很多限制条件


1095
00:55:11,311 --> 00:55:14,047
complication在时钟画面
必须是处于活跃状态


1096
00:55:14,448 --> 00:55:16,149
否则将无法进行推送


1097
00:55:17,284 --> 00:55:19,386
且每天的推送数量也是有限的


1098
00:55:19,453 --> 00:55:20,621
所以 请节约使用


1099
00:55:20,687 --> 00:55:23,156
平均大概是每小时1到2个推动


1100
00:55:23,223 --> 00:55:26,260
但体育app可能在很短的时间内
全部用光


1101
00:55:27,794 --> 00:55:29,229
你可使用传输用户信息


1102
00:55:29,296 --> 00:55:30,564
对时间轴项目进行列队


1103
00:55:30,631 --> 00:55:32,933
最后 你可以使用
传输当前complication


1104
00:55:32,999 --> 00:55:34,668
用户信息列队当前


1105
00:55:34,735 --> 00:55:36,136
或现有的时间轴项目


1106
00:55:37,137 --> 00:55:40,240
可使用ClockKit更新时钟画面


1107
00:55:40,874 --> 00:55:43,577
请记住 很多这些事都是有预算限制的


1108
00:55:43,644 --> 00:55:46,680
在iOS和WatchKit上执行的


1109
00:55:46,747 --> 00:55:49,583
complication
更新的任何操作 


1110
00:55:49,650 --> 00:55:50,951
都会消耗预算


1111
00:55:51,485 --> 00:55:54,354
我推荐 将你需要用来
更新complication的


1112
00:55:54,421 --> 00:55:56,657
任何信息都包括在推送中


1113
00:55:57,324 --> 00:56:01,662
complication
推送类型有4K有效负载


1114
00:56:01,728 --> 00:56:04,798
大于标准负载 
所以你可以将需要的大部分


1115
00:56:04,865 --> 00:56:05,732
信息放入其中


1116
00:56:05,799 --> 00:56:07,734
若你收到其中一个推送


1117
00:56:07,801 --> 00:56:11,004
并打开iOS app
提交NSURLSession请求


1118
00:56:11,238 --> 00:56:12,873
你将很快就消耗完预算


1119
00:56:12,940 --> 00:56:16,143
请确保所有你需要的内容都在推送中


1120
00:56:19,413 --> 00:56:20,981
这部分就到此结束


1121
00:56:22,049 --> 00:56:23,984
简要地讨论下我们今天所说的


1122
00:56:24,051 --> 00:56:26,353
我们说了框架
WatchConnectivity


1123
00:56:26,420 --> 00:56:27,321
和API


1124
00:56:27,754 --> 00:56:30,424
我们很期待看到
你们用这些API做出来的东西


1125
00:56:31,124 --> 00:56:33,560
简要地讨论了
NSURLSession和使用方法


1126
00:56:33,627 --> 00:56:35,796
还有其他部分


1127
00:56:35,929 --> 00:56:39,600
深入地讨论NSURLSession
及如何使用NSURLSession


1128
00:56:40,100 --> 00:56:43,103
最后 我们讨论了如何
把数据放到complication


1129
00:56:43,270 --> 00:56:44,605
这是个更为高级的话题


1130
00:56:46,540 --> 00:56:49,076
还有很多可以查看的重要资源


1131
00:56:49,142 --> 00:56:50,644
我们有一些很棒的样本代码


1132
00:56:50,711 --> 00:56:54,948
我们也有专员
他们已经准备好回答你的问题了


1133
00:56:56,950 --> 00:56:58,585
关于其他的内容


1134
00:56:58,886 --> 00:57:01,388
建议你看Creating 
Complications


1135
00:57:01,455 --> 00:57:04,124
with ClockKit以及
Networking with NSURLSession


1136
00:57:04,191 --> 00:57:06,326
因为他们
与我们今天讨论的内容紧密相关


1137
00:57:07,394 --> 00:57:08,495
谢谢

