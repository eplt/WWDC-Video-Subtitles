1
00:00:20,287 --> 00:00:23,423
以Model I/O
进行3D资源管理


2
00:00:24,958 --> 00:00:25,792
大家好


3
00:00:25,859 --> 00:00:28,495
欢迎来到这场关于以Model
I/O进行3D资源管理的演讲


4
00:00:28,562 --> 00:00:31,798
我是尼克 来自图像 媒体 和图形组


5
00:00:33,567 --> 00:00:38,505
今天我很高兴向大家介绍新的
Model I/O框架


6
00:00:38,972 --> 00:00:43,110
我们正在提高...
或者说我们其实是正在让大家


7
00:00:43,177 --> 00:00:46,580
能够提高交互式的真实感图形的品质


8
00:00:47,047 --> 00:00:53,720
到目前为止你们一直使用的
图形框架和硬件都是过去开发的


9
00:00:53,954 --> 00:00:56,957
当时的硬件与现在相比有太多的局限


10
00:00:57,558 --> 00:00:59,860
而现在你们口袋里的设备
拥有的功能绝对令人惊艳


11
00:01:00,160 --> 00:01:04,697
现在我们有了新的框架
使你们能够充分发挥硬件的作用


12
00:01:04,765 --> 00:01:08,468
为客户服务但是你们
必须不断给这个框架


13
00:01:09,002 --> 00:01:11,071
增添真正好看的元素


14
00:01:11,638 --> 00:01:16,410
所以既然现在有了高性能


15
00:01:17,411 --> 00:01:21,114
和低功耗图形应用程序接口
你们就需要一种方法来把


16
00:01:21,181 --> 00:01:24,985
图片制作得具有真实感真实感意味着
图片要基于现实存在源于现实存在


17
00:01:25,552 --> 00:01:29,890
那么你们需要做有很多的研究
还要有大量相关的知识


18
00:01:30,057 --> 00:01:31,158
才能实现这个目标


19
00:01:31,692 --> 00:01:33,760
你们需要了解相机的物理原理


20
00:01:33,827 --> 00:01:36,263
各种材料的物理特性光的物理特性


21
00:01:37,364 --> 00:01:39,633
当然你们也可以多读相关的资料


22
00:01:39,700 --> 00:01:41,034
我很赞成这种做法


23
00:01:41,468 --> 00:01:45,806
要有效运用那些材料和光需要
做大量繁琐的工作


24
00:01:46,440 --> 00:01:49,042
阅读大量的资料然后再进行集成运用


25
00:01:50,010 --> 00:01:53,747
那么我们对Model I/O所做的
就是我们已经着手进行这些工作


26
00:01:54,248 --> 00:01:57,484
我们已经进行了大量的研究
我们已做了一大堆的集成


27
00:01:57,985 --> 00:02:01,221
我们已经准备了一套统一的数据结构


28
00:02:01,288 --> 00:02:05,158
来连贯一致地描述这些性能我们还
开发了一个使用简便的应用程序接口


29
00:02:06,460 --> 00:02:10,030
所以说Model I/O是一个处理


30
00:02:10,097 --> 00:02:12,332
3D资源和数据的框架


31
00:02:12,999 --> 00:02:17,337
所以在最基本的层面上
你们可以利用Model I/O


32
00:02:17,604 --> 00:02:20,874
导入和输出常见格式的文件


33
00:02:21,675 --> 00:02:25,679
你们可以以现实的方式描述采光情况


34
00:02:25,913 --> 00:02:27,381
各种材料 环境条件


35
00:02:28,182 --> 00:02:31,351
你们可以将美工人员提供的资源和作品


36
00:02:31,785 --> 00:02:35,022
导入Model I/O
再进行一些有趣的处理


37
00:02:35,088 --> 00:02:37,858
在演讲过程中我们会讲到处理方法


38
00:02:38,492 --> 00:02:42,095
现在有很多可以运用的工具


39
00:02:42,229 --> 00:02:47,401
其主要关注点都是进行
基于物理特性的渲染和材料属性


40
00:02:47,835 --> 00:02:52,039
I/O模型让你们可以通过
自己的管道利用那些工具


41
00:02:54,141 --> 00:02:57,244
Model I/O已经集
成到Xcode 7里


42
00:02:57,311 --> 00:02:59,213
还有GameKit的应用程序接口里


43
00:02:59,279 --> 00:03:03,417
可以在iOS 9
和OS10.11中运行


44
00:03:04,785 --> 00:03:09,590
所以概括地说这个绿色的大盒子是


45
00:03:10,090 --> 00:03:12,192
Model I/O与你们的框架


46
00:03:12,593 --> 00:03:13,961
或应用程序想融合的地方


47
00:03:14,561 --> 00:03:17,831
我们就从联系创建工具讲起
首先美工人员制作一些很好的作品


48
00:03:18,465 --> 00:03:20,601
然后你们要将其
导入Model I/O


49
00:03:21,201 --> 00:03:26,607
接下来由Model I/O快速完成那些
原本繁琐乏味又容易出现错误的步骤


50
00:03:26,807 --> 00:03:32,112
为各种框架创建缓冲区进行快速渲染


51
00:03:32,646 --> 00:03:36,416
在这个盒子之外我们所支持的
框架有SceneKit


52
00:03:36,650 --> 00:03:37,885
Metal 和 OpenGL


53
00:03:40,621 --> 00:03:45,058
现在Model I/O不仅可以
加载文件和保存文件


54
00:03:45,692 --> 00:03:48,462
它还让你们能够进行原本有用


55
00:03:48,595 --> 00:03:50,731
但耗时太长或有其他弊端的操作


56
00:03:51,098 --> 00:03:53,534
来改善资源的外观


57
00:03:54,201 --> 00:03:56,470
你们可以选取一项资源


58
00:03:56,770 --> 00:03:59,339
对其进行接下来我会谈到
的各种热处理操作的其中一项


59
00:03:59,573 --> 00:04:02,342
再把这项资源恢复成统一
的表示形式导回Model I/O


60
00:04:03,076 --> 00:04:05,746
再把它放到硬件准备缓冲区


61
00:04:07,381 --> 00:04:12,786
你也可以先利用Model I/O


62
00:04:13,187 --> 00:04:15,222
提供的独特的功能对资源进行处理


63
00:04:15,322 --> 00:04:18,225
完成这里的循环然后把它发送回


64
00:04:18,291 --> 00:04:20,260
内容创作工具让美工人员


65
00:04:20,793 --> 00:04:24,398
进行调整也许再添加一些
比如细节处理或进行其他改进


66
00:04:24,865 --> 00:04:28,502
然后你可以不断重复这个循环
直到达到你的app 


67
00:04:28,635 --> 00:04:30,971
所需要的外观和质量水平为止


68
00:04:33,240 --> 00:04:37,611
那么我们今天要讲的是这些功能是什么


69
00:04:38,579 --> 00:04:39,446
其数据类型是什么


70
00:04:39,513 --> 00:04:41,982
那些数据类型的物理动机从何而来


71
00:04:42,683 --> 00:04:47,521
我们将谈论如何支持
各种几何功能三维像素


72
00:04:48,121 --> 00:04:52,726
和一些先进的光照技巧
以及我们的热处理步骤


73
00:04:56,897 --> 00:05:00,534
好的 我们开始面包和黄油资料读取中


74
00:05:01,435 --> 00:05:05,272
导入格式我们从


75
00:05:05,672 --> 00:05:09,109
一些最常用的格式开始


76
00:05:11,211 --> 00:05:14,915
蒸馏器是一种性能非常高的格式


77
00:05:15,148 --> 00:05:19,453
它来自电影行业现在
也大量在游戏中使用


78
00:05:20,020 --> 00:05:23,824
这这里所列出的格式中它是最现代的


79
00:05:23,891 --> 00:05:28,629
它包括了关于动画和材料绑定的信息


80
00:05:28,695 --> 00:05:30,797
还有其他各种各样的有趣的信息


81
00:05:31,331 --> 00:05:34,735
多边形是多边形的
标准格式使用这个格式


82
00:05:34,801 --> 00:05:36,770
需要进行大量的学术研究


83
00:05:37,271 --> 00:05:43,777
三角形通常用CAD和CAM这两种
应用程序制作和摄取


84
00:05:44,278 --> 00:05:47,681
而且Wavefront .obj
文件可以得到普遍的读写支持


85
00:05:48,382 --> 00:05:50,250
如果要在此刻进行导出


86
00:05:50,484 --> 00:05:54,521
你可以导出你的
CAD / CAM材料


87
00:05:57,758 --> 00:05:59,760
所以导入很容易


88
00:06:00,027 --> 00:06:02,930
你使用URL通过内核自行启动
得到一个MDL资源


89
00:06:03,430 --> 00:06:07,034
然后你可以用“输出资源到URL”
把它导出到其他位置


90
00:06:09,837 --> 00:06:12,706
关于物理真实感我还要再说几句


91
00:06:12,840 --> 00:06:16,376
但是不做太细致的解释


92
00:06:16,610 --> 00:06:20,280
光照一直以来都要有一个位置


93
00:06:20,547 --> 00:06:23,584
比如一个锥角衰减区


94
00:06:24,151 --> 00:06:26,420
还要有其他一些从物理
角度来看不真实的参数


95
00:06:26,486 --> 00:06:28,622
这些参数只是在数学上与过去的硬件和


96
00:06:28,689 --> 00:06:30,324
图形应用程序接口相统一


97
00:06:30,858 --> 00:06:36,029
我们现在要为大家提供的
是对IES概要文件的访问方法


98
00:06:36,263 --> 00:06:39,499
现在如果你去五金店并且发现


99
00:06:39,633 --> 00:06:41,068
比如你非常喜欢的一款灯具


100
00:06:41,168 --> 00:06:43,904
比如说我真的很喜欢那里的那款灯
而且我在商店里看到了它


101
00:06:44,204 --> 00:06:48,108
我可以先读一下旁边的标签
再去生产商的网站


102
00:06:48,609 --> 00:06:51,111
在网上我可以找到一个IES概要文件


103
00:06:51,178 --> 00:06:54,681
它是一个数据文件
里面有关于这种灯的各种数据


104
00:06:54,781 --> 00:06:57,851
我能了解每一个角度灯光的辐照度


105
00:06:58,919 --> 00:07:01,321
我们把那个文件读入到
一个所谓的轻型网络


106
00:07:01,655 --> 00:07:04,992
就是一组很容易加载到着色器里的数据


107
00:07:05,459 --> 00:07:09,029
那么如果你愿意你可以在你的着色器里


108
00:07:09,229 --> 00:07:11,832
亲自点亮可与真实世界的灯媲美的灯


109
00:07:12,466 --> 00:07:14,701
现在你在五金店里买灯时


110
00:07:15,002 --> 00:07:17,971
不会专门提出RGB值或类似的要求


111
00:07:18,038 --> 00:07:21,742
灯的特点通常由温度描述
比如4000开氏度或其他度数


112
00:07:22,309 --> 00:07:25,512
那么你也可以用开氏度来指定这些高度


113
00:07:26,046 --> 00:07:28,815
我们还可以提供基于那边正在工作的


114
00:07:28,949 --> 00:07:30,384
挖掘机的灯光的图像


115
00:07:31,084 --> 00:07:35,289
这些材料以前都需要使用传感器 


116
00:07:35,455 --> 00:07:38,325
这意味着随角度衰减现象


117
00:07:38,792 --> 00:07:40,594
并且在Blinn-Phong高光区


118
00:07:40,661 --> 00:07:42,896
会有可调节的亮点


119
00:07:43,430 --> 00:07:44,498
我们还为你们提供


120
00:07:44,598 --> 00:07:48,035
一个基线物理双向反射函数


121
00:07:48,101 --> 00:07:52,806
也可以叫做BRDF如果你想要取得


122
00:07:53,006 --> 00:07:54,641
绝对逼真的效果你绝度需要这个函数


123
00:07:55,075 --> 00:07:59,413
请注意那台挖掘机上就有BDRF


124
00:08:00,314 --> 00:08:03,350
相机历来是针孔相机


125
00:08:03,717 --> 00:08:06,820
描述相机时我们
从镜头一直介绍到传感器


126
00:08:07,221 --> 00:08:09,356
现在我们为你们提供一些实用程序


127
00:08:09,456 --> 00:08:12,926
来处理照片和程序中的各种环境元素


128
00:08:16,029 --> 00:08:19,600
现在你们会看到
用Xcode中的工具做热处理


129
00:08:19,967 --> 00:08:23,203
在这张幻灯片上我要告诉你们


130
00:08:24,238 --> 00:08:26,206
在Xcode中你可以用来


131
00:08:26,340 --> 00:08:29,943
执行这些操作的工具你也可以
通过框架在Model I/O中使用


132
00:08:30,511 --> 00:08:32,044
所以如果你想制作自己的管线


133
00:08:32,179 --> 00:08:35,682
你自己的离线管道以便对自己的资源


134
00:08:35,749 --> 00:08:39,019
进行彻底的热处理无论批次大小


135
00:08:39,419 --> 00:08:41,321
都可以通过应用程序接口框架


136
00:08:41,922 --> 00:08:43,056
使用那些工具


137
00:08:45,626 --> 00:08:47,561
我们已经介绍了三维像素


138
00:08:47,828 --> 00:08:50,864
你们可以选取一个又大又旧的网格
把它变成巨大的索引缓存


139
00:08:50,931 --> 00:08:52,666
你们可以把自己的数据与它关联起来


140
00:08:53,066 --> 00:08:54,168
稍后我们会就此多谈一些


141
00:08:55,002 --> 00:08:56,904
再说一次在资源的基础上


142
00:08:57,271 --> 00:09:01,441
创建三维像素以及
在特定区域找到三维像素非常简单


143
00:09:01,675 --> 00:09:03,610
你们可以运用实体几何构造法


144
00:09:03,677 --> 00:09:05,946
还可以把三维像素导回到一个网格


145
00:09:06,446 --> 00:09:07,948
期间可以利用数据平滑法


146
00:09:08,415 --> 00:09:09,249
类似的做法吧


147
00:09:11,118 --> 00:09:16,190
所以通过系统集成
将Model I/O直接集成到


148
00:09:16,990 --> 00:09:21,395
SceneKit中可以在
MetalKit和GLKit中使用


149
00:09:22,596 --> 00:09:26,600
在取景器和快速浏览功能中
Model I/O是用来做预览的


150
00:09:26,667 --> 00:09:30,470
所以你可以去找一个蒸馏器
abc缓存文件按下空格键


151
00:09:30,537 --> 00:09:32,806
然后会弹出取景器
你可反复查看你的资源


152
00:09:32,873 --> 00:09:36,643
甚至不用打开任何类型的
试镜环境对其进行预览


153
00:09:37,411 --> 00:09:39,646
您可以在Xcode中编辑资源


154
00:09:39,913 --> 00:09:43,750
这张图片中的挖掘机就是
用Xcode进行加载的


155
00:09:44,284 --> 00:09:48,021
Model I/O使用Swift
语言在Playgrounds中工作


156
00:09:50,757 --> 00:09:54,161
好 这一切可以归结到数据类型的本质


157
00:09:55,395 --> 00:10:00,601
所以从一个URL得到的是MDL资源


158
00:10:01,001 --> 00:10:04,071
它包含了你们往往会处理的所有对象


159
00:10:04,671 --> 00:10:08,242
它是一个你知道
快速列举素材资料的索引容器


160
00:10:08,709 --> 00:10:11,311
它有变换层次结构 网格


161
00:10:11,578 --> 00:10:14,748
相机和灯光 这些你可以
利用应用程序接口进行制作


162
00:10:15,148 --> 00:10:17,284
或通过URL加载


163
00:10:18,285 --> 00:10:20,754
所以一项典型的
你可以利用的asset


164
00:10:21,088 --> 00:10:24,958
比如一个又大又旧的蒸馏器文件
会包含很多有趣的东西


165
00:10:26,026 --> 00:10:31,098
这个举一个例子里面有几个摄像头


166
00:10:31,298 --> 00:10:34,234
一盏灯 一个根变换


167
00:10:34,301 --> 00:10:36,470
以及右上角的蓝色框


168
00:10:36,837 --> 00:10:39,740
下面是挖掘机的信息


169
00:10:39,806 --> 00:10:42,409
橙色的框显示 是的


170
00:10:42,476 --> 00:10:45,312
橙色的框只是表明你也可以显示
你的材料赋值情况


171
00:10:45,913 --> 00:10:47,581
这就是资源所包含的信息


172
00:10:48,015 --> 00:10:50,784
这都是逻辑上的应为一体的东西


173
00:10:50,851 --> 00:10:53,420
所以你就有了很多的资源
把它们组合成一个场景


174
00:10:55,756 --> 00:11:00,360
asset有内存分配器


175
00:11:00,794 --> 00:11:04,865
你需要的话可以添加分配器
自己管理内存


176
00:11:05,499 --> 00:11:10,470
Asset有内部事务描述符


177
00:11:10,971 --> 00:11:13,040
这是导入导出工具


178
00:11:13,407 --> 00:11:14,775
和大量子工具


179
00:11:15,342 --> 00:11:17,811
这些子工具都是MDL对象


180
00:11:19,713 --> 00:11:23,050
MDL对象自身可以组成一个层


181
00:11:24,685 --> 00:11:28,856
现在完成了一个典型的标准图
当然应该有转换层


182
00:11:30,490 --> 00:11:35,162
MDL对象有转换组件


183
00:11:36,296 --> 00:11:39,333
我们并没有执行转换


184
00:11:39,399 --> 00:11:41,368
你知道这是放置矩阵的标准步骤


185
00:11:41,435 --> 00:11:43,003
实际上我们有转换组件


186
00:11:43,537 --> 00:11:45,706
这种组件非常有意思


187
00:11:45,839 --> 00:11:47,741
因为它允许我们创建一种场景图


188
00:11:47,808 --> 00:11:52,479
这种场景图不必有父/子的类型关系


189
00:11:52,946 --> 00:11:55,349
另外可以定义自己的组件


190
00:11:56,717 --> 00:12:00,687
现在我想我应该已经提到了那个好东西


191
00:12:01,088 --> 00:12:04,691
编写自定义导入导出器的
API已经设计出来了


192
00:12:05,125 --> 00:12:08,629
你可以编写如果你有自定义的文件格式


193
00:12:09,363 --> 00:12:12,399
你可以编写倒入导出气让我们回来


194
00:12:12,866 --> 00:12:17,838
这里有个自定义的触发器组件


195
00:12:17,905 --> 00:12:21,241
它拥有了一组你自己的功能
会发生一系列相应的动作


196
00:12:21,708 --> 00:12:24,978
这个编写自定义导入导出器的API
可以让你自己创建功能


197
00:12:25,045 --> 00:12:28,515
并定义它的动作是什么定义它连接什么


198
00:12:29,383 --> 00:12:33,587
现在一个网格包含一个
或多个顶点缓冲区


199
00:12:33,954 --> 00:12:38,158
这是需要GPU进行位图化的位置


200
00:12:38,859 --> 00:12:41,228
法向下面是子网格


201
00:12:42,262 --> 00:12:45,999
要想知道子网格实际是什么


202
00:12:46,667 --> 00:12:50,637
你应该有一个驱动挖掘器的功能


203
00:12:51,071 --> 00:12:53,740
这个功能应该有些像
安全帽一样的可选组件


204
00:12:54,074 --> 00:12:55,876
这个组件不应该是可选的但它确实是


205
00:12:56,443 --> 00:13:01,181
在一个索引缓存中
我应该有整个没有可选组建功能


206
00:13:01,315 --> 00:13:03,417
在另一个索引缓存中


207
00:13:03,483 --> 00:13:05,953
我应该有所有指向
原始网格顶点缓存的索引


208
00:13:06,353 --> 00:13:08,222
它里面应该有可选组件


209
00:13:08,789 --> 00:13:10,791
所以通过渲染或者不渲染子网格


210
00:13:11,024 --> 00:13:12,759
网格会有可选组件或者没有可选组件


211
00:13:14,895 --> 00:13:17,130
子网格之间可以用顶点缓存共享数据


212
00:13:17,197 --> 00:13:20,000
所以这将会允许你向硬件单独提交


213
00:13:21,735 --> 00:13:26,039
因此网格除了有顶点和索引缓存


214
00:13:27,140 --> 00:13:30,511
还有功能函数以及产生


215
00:13:30,577 --> 00:13:32,913
常用事物的生成模板
例如盒子 球等等


216
00:13:34,214 --> 00:13:35,349
还有调节器


217
00:13:35,716 --> 00:13:39,419
如果一个网格没有法线或切线基值


218
00:13:39,486 --> 00:13:43,090
或是类似的东西 你可以在需求中生成


219
00:13:43,390 --> 00:13:47,561
回想一下烘焙和导出循环
我前面提到过的


220
00:13:48,362 --> 00:13:50,163
当然得有烘烤师


221
00:13:52,699 --> 00:13:57,437
现在一个网格缓存必须访问硬件


222
00:13:57,838 --> 00:13:59,540
因为它要去硬件取数据


223
00:14:00,807 --> 00:14:01,708
取硬件中的真实值


224
00:14:02,242 --> 00:14:04,645
缓存有多大取决于你如何分配它


225
00:14:06,313 --> 00:14:09,650
你必须描述这些顶点缓存


226
00:14:09,716 --> 00:14:13,887
你必须说出缓存的用途
比如是存储位置吗


227
00:14:14,354 --> 00:14:15,822
它有多大？


228
00:14:15,889 --> 00:14:18,091
它占用多少字节等等 等等


229
00:14:19,359 --> 00:14:23,864
最后从一个顶点切到另一个
硬件需要知道这些


230
00:14:24,364 --> 00:14:26,700
子网格也一样


231
00:14:26,900 --> 00:14:28,435
确定你需要什么样的索引


232
00:14:28,635 --> 00:14:30,971
是16s还是32s或是其它


233
00:14:31,205 --> 00:14:35,742
下面讲几何类型三角带？点？还是线？


234
00:14:36,376 --> 00:14:37,277
最后是材质


235
00:14:38,612 --> 00:14:45,519
如果你使用这些类库能生产积极性


236
00:14:46,053 --> 00:14:47,821
为了告诉你这意味着什么


237
00:14:48,088 --> 00:14:51,058
我们使用了双向反射函数


238
00:14:51,124 --> 00:14:55,362
它有十个简单参数这是
为了让艺术家有更加直观的感受


239
00:14:56,029 --> 00:15:01,535
一个更重要的功能是
设定物体是否贴合实际


240
00:15:01,602 --> 00:15:03,036
像黏土或是金属


241
00:15:03,604 --> 00:15:06,373
如果你向一头设定这个值


242
00:15:06,573 --> 00:15:07,875
它就会像是黏土


243
00:15:08,909 --> 00:15:10,110
如果向另一头调


244
00:15:10,477 --> 00:15:12,779
它就会表现得像是金属


245
00:15:15,349 --> 00:15:20,120
在这里我把这两者结合起来
把一个丙烯酸透明的外套


246
00:15:22,289 --> 00:15:27,194
放在金属底座上面我调整了
一个参数给出缎面的效果


247
00:15:31,031 --> 00:15:34,201
这是一个真正艺术家般的作品


248
00:15:34,268 --> 00:15:37,204
一个有着各种不同材料的太空船


249
00:15:37,471 --> 00:15:40,207
只是给你一点思路只需很少的


250
00:15:40,374 --> 00:15:43,010
参数就可以给出多种多样的外观


251
00:15:44,811 --> 00:15:50,951
那么材质应该有个名字类似于所有在
Model I/O中配置属性的东西


252
00:15:51,018 --> 00:15:54,121
无论你是否想要
Lambert Blinn-Phong


253
00:15:54,188 --> 00:15:55,822
都要设定散射函数


254
00:15:56,156 --> 00:16:00,794
因为需要向下兼容旧系统
并且真实可信


255
00:16:00,961 --> 00:16:04,331
当然如果你想进入真实可信的
勇敢新世界的话


256
00:16:05,465 --> 00:16:08,435
这些材质是单独继承的这意味着


257
00:16:08,902 --> 00:16:15,342
你可以通过改变每个功能的
一个值或是某些东西


258
00:16:15,409 --> 00:16:18,545
你可以指定基础材质和跨越属性


259
00:16:18,979 --> 00:16:20,747
以及子类材质


260
00:16:21,415 --> 00:16:24,718
材质属性有名称用来说明


261
00:16:24,785 --> 00:16:27,521
它们如何使用的释义


262
00:16:27,588 --> 00:16:30,324
以及说明它是浮动值或是颜色值的类型


263
00:16:31,725 --> 00:16:32,559
下面是光


264
00:16:33,026 --> 00:16:36,997
光有物理参数


265
00:16:37,164 --> 00:16:40,434
和物理属性以及几何形状


266
00:16:40,634 --> 00:16:42,436
它们有扩展度和宽度


267
00:16:42,836 --> 00:16:46,874
光以特定的方式传播


268
00:16:47,140 --> 00:16:49,343
你可以指定它的流明和色温


269
00:16:49,743 --> 00:16:52,513
在整个Model I/O中
真正让我激动的


270
00:16:52,779 --> 00:16:55,682
是得到了色彩方面的支持


271
00:16:56,016 --> 00:17:00,153
可以指定使用现代色彩


272
00:17:00,654 --> 00:17:04,290
如果你想用SRGB
我们有设定好的SRGB


273
00:17:04,358 --> 00:17:06,425
如果你想用Rec.709


274
00:17:06,492 --> 00:17:08,662
或者是新的Asus CG色彩配置


275
00:17:09,128 --> 00:17:11,198
这种色彩配置可以保证你的色彩


276
00:17:11,565 --> 00:17:14,535
以一定的方式在app的内容里加载


277
00:17:14,601 --> 00:17:17,704
它自始至终表现稳定


278
00:17:18,038 --> 00:17:21,742
不会发生奇特的变化这可能会给你
你知道意想不到的色彩


279
00:17:24,810 --> 00:17:28,782
我们现在有了类似物理光


280
00:17:29,516 --> 00:17:32,719
各种子类程序区光源


281
00:17:32,986 --> 00:17:35,556
应该说是程序描述的区域光源


282
00:17:36,089 --> 00:17:41,161
IES光度分析计


283
00:17:41,495 --> 00:17:44,498
反光贴图或发光贴图的光探测器


284
00:17:44,598 --> 00:17:49,102
你可以用它们来计算球面谐波
诸如此类的代表正在发生什么的东西


285
00:17:50,404 --> 00:17:57,077
我们的相机也不仅仅是
针孔无限聚焦相机


286
00:17:57,711 --> 00:18:01,982
我们描述的相机发生了巨大的变化


287
00:18:02,416 --> 00:18:08,222
我的照片这里应该有个镜头
这里应该有个传感器


288
00:18:08,589 --> 00:18:12,826
我们描述镜头可以看到的范围
描述镜头属性


289
00:18:12,893 --> 00:18:15,495
失真的种类 桶形失真


290
00:18:15,596 --> 00:18:18,532
或者是色差之类的东西镜头的几何形状


291
00:18:18,599 --> 00:18:21,201
镜片的有多大 镜筒有多长


292
00:18:21,702 --> 00:18:22,870
出口孔径


293
00:18:22,936 --> 00:18:27,040
你关了多少光圈 传感器有多大


294
00:18:27,341 --> 00:18:30,077
传感器的曝光功能是什么


295
00:18:30,644 --> 00:18:34,781
所有上述设置的结果是


296
00:18:34,848 --> 00:18:41,054
如果你装载了一个35或者
说50毫米F1.8光圈的相机


297
00:18:41,121 --> 00:18:45,392
去查维基百科


298
00:18:45,592 --> 00:18:47,928
一个这样的镜头有什么功能


299
00:18:47,995 --> 00:18:51,832
视野是多大 离焦光怎样


300
00:18:52,032 --> 00:18:55,602
突出尺寸及MDL相机的
实用功能等类似的东西


301
00:18:55,669 --> 00:18:59,006
这个相机将和你在书上看到的一样


302
00:18:59,173 --> 00:19:01,942
所以这是一个方便而且有趣东西


303
00:19:02,209 --> 00:19:06,880
我鼓励你把这一类的
计算整合到你的着色器和通道


304
00:19:08,348 --> 00:19:09,650
这里只是一个简短的例子


305
00:19:10,784 --> 00:19:13,153
当我第一次将它加载到我的查看器中


306
00:19:13,453 --> 00:19:15,389
使用默认的曝光设置


307
00:19:15,689 --> 00:19:18,692
有些细节的丢失


308
00:19:18,892 --> 00:19:23,463
挖掘机的黑暗区域很多细节看不到


309
00:19:24,431 --> 00:19:29,503
对不起 这里的亮度不好
我这图像曝光不足


310
00:19:29,570 --> 00:19:32,105
然后 使用闪关灯以


311
00:19:32,172 --> 00:19:36,577
给出阴影的细节在
减少炫光的同时提升整体水平


312
00:19:37,711 --> 00:19:39,246
就像一个摄影师做的那样


313
00:19:40,514 --> 00:19:43,150
如果你玩的是自己真正的相机


314
00:19:45,819 --> 00:19:46,653
现在 该天空了


315
00:19:47,888 --> 00:19:49,656
我们有两种方法创造天空


316
00:19:49,990 --> 00:19:53,927
第一种方法是使用一个程序天空发生器


317
00:19:54,194 --> 00:19:55,395
它使用物理学


318
00:19:56,496 --> 00:19:59,399
你给出当天的时间本质上太阳有多高


319
00:19:59,700 --> 00:20:03,403
天气如何有没有很多地面上来的背散射


320
00:20:03,470 --> 00:20:05,272
空气中是不是有很多垃圾


321
00:20:05,906 --> 00:20:09,643
我们通过大量的数学运算


322
00:20:09,943 --> 00:20:12,145
精确计算天空的样子


323
00:20:13,480 --> 00:20:15,015
另外一条路是


324
00:20:15,315 --> 00:20:19,853
它创建一个立方体你知道使用...


325
00:20:20,354 --> 00:20:24,491
现在你可以在这个基于物理的领域


326
00:20:24,591 --> 00:20:27,461
创造天空的另一种方法是摄影


327
00:20:27,828 --> 00:20:29,596
你可以用手机或DSLR


328
00:20:29,663 --> 00:20:33,200
摄制一个球形全景图
我用IPHONE制作了这张图


329
00:20:35,435 --> 00:20:39,606
你可以使用mdltexture
和initwithurl API


330
00:20:39,673 --> 00:20:44,711
创建一个立方体


331
00:20:45,045 --> 00:20:46,246
反射或发光地图


332
00:20:46,313 --> 00:20:48,549
从图像中我们可以推断出光是入射光


333
00:20:48,649 --> 00:20:51,818
所以这已经转换成一个立方体


334
00:20:54,254 --> 00:20:58,325
然后从这些里面你可以计算出辐照度


335
00:20:58,859 --> 00:21:02,863
这三条显示的是原始图像


336
00:21:03,163 --> 00:21:09,636
中间线是纹理贴图以一定的
卷积或水平的模糊度发光


337
00:21:10,237 --> 00:21:14,775
第三个真的很好玩
中间是一个纹理它使用大量的内存


338
00:21:15,142 --> 00:21:18,111
第三个实际是球谐系数


339
00:21:18,478 --> 00:21:24,418
所以他是27浮动重现的光照环境


340
00:21:24,484 --> 00:21:29,556
之前用数十个K代表中间线或中间地带


341
00:21:30,891 --> 00:21:32,059
把这些放在一起


342
00:21:32,559 --> 00:21:36,530
这个挖掘机和它周围的环境非常和谐


343
00:21:36,897 --> 00:21:41,902
我画的这些作品我认为
另人激动我希望你们可以


344
00:21:42,503 --> 00:21:44,705
用这些工具做出非常酷的作品


345
00:21:46,840 --> 00:21:49,276
现在我只是想多说一点


346
00:21:49,376 --> 00:21:51,678
关于如何整合Model I/O
和SceneKit


347
00:21:52,613 --> 00:21:55,349
本质上在Model I/O
和SceneKit元素的顶层


348
00:21:55,682 --> 00:21:59,219
有一对一的依赖关系


349
00:21:59,786 --> 00:22:02,556
mdlasset对
应SceneKit根节点


350
00:22:03,457 --> 00:22:07,127
MDLMesh 和SCNNode
通过SCN坐标联系起来


351
00:22:07,427 --> 00:22:11,365
MDLLight
有SCNLight的相机和材质


352
00:22:12,032 --> 00:22:16,203
在SceneKit参数
和Model I/O参数间


353
00:22:16,603 --> 00:22:19,806
没有一致的模型我们就通过翻译


354
00:22:20,040 --> 00:22:21,842
得到一个近似的模型


355
00:22:23,677 --> 00:22:26,747
现在Model I/O
实际上没有做渲染


356
00:22:26,813 --> 00:22:31,552
你可能收集了既然
我提到过其它渲染APIS


357
00:22:32,252 --> 00:22:35,088
所以在metalkit更接近金属


358
00:22:36,023 --> 00:22:39,126
你将MDLMesh作为


359
00:22:39,426 --> 00:22:46,133
MetalK
和Model I/O间的模型阵


360
00:22:46,733 --> 00:22:49,603
网格阵列一旦你有了网格阵列


361
00:22:49,903 --> 00:22:52,639
你就可以自己写阴影遍历网格


362
00:22:52,706 --> 00:22:55,409
和照明条件并做渲染


363
00:22:55,876 --> 00:23:00,180
但是得到这些为你准备的
金属缓存是绝对透明的


364
00:23:01,181 --> 00:23:06,353
说到这个我想把麦克风给
克劳迪娅·罗伯茨


365
00:23:06,520 --> 00:23:09,623
分享关于几何图形和体素的内容


366
00:23:18,332 --> 00:23:21,668
大家好 我的名字是
克劳迪娅·罗伯茨 尼克已经提到了


367
00:23:21,735 --> 00:23:25,339
我将概述一些不同的方法以便你可以


368
00:23:25,405 --> 00:23:28,208
描述和个性化
Model I/O中的几何图形


369
00:23:28,876 --> 00:23:35,148
帮助你创造更加有
真实外观和感觉的游戏和应用


370
00:23:37,351 --> 00:23:39,253
给你们讲一下我们将要分享的重点


371
00:23:39,520 --> 00:23:42,556
首先我将讨论Model I/O
如何支持正常平滑


372
00:23:43,090 --> 00:23:48,562
然后进入细分曲面
讨论体素和一个快速的演示


373
00:23:50,664 --> 00:23:52,566
好的 开始吧法线平滑


374
00:23:53,567 --> 00:23:55,202
法线平滑是非常酷的技术


375
00:23:55,402 --> 00:24:00,073
能让人相信你的模型有更多几何形状


376
00:24:01,008 --> 00:24:04,845
默认情况下
多边形的顶点都有相同的法线


377
00:24:05,412 --> 00:24:08,916
这样多边形的表面也有相同的法线


378
00:24:09,816 --> 00:24:12,886
这会造成相邻多边形之间的
一个明显的褶皱


379
00:24:13,187 --> 00:24:17,691
这是突然变化和顶点法线的
光栅化过程的结果


380
00:24:18,892 --> 00:24:21,128
这种颜色的强烈对比可以减轻


381
00:24:21,295 --> 00:24:24,298
通过引入一个共享的法线值


382
00:24:24,364 --> 00:24:27,901
其值是共享相同的
坐标位置顶点法线的平均值


383
00:24:28,836 --> 00:24:33,707
现在在GPU轻度计算下
多边形表面每个点的正常值


384
00:24:33,774 --> 00:24:36,643
将是顶点法线插值


385
00:24:36,710 --> 00:24:40,247
不再是同样的值展现出
很好的平滑明暗效果


386
00:24:41,982 --> 00:24:46,887
使用mdlmesh API你可以通过调用
addNormalsWithAttributeNamed方法


387
00:24:46,954 --> 00:24:50,324
给对象添加平滑法线


388
00:24:50,757 --> 00:24:53,193
你还可以通过设置皱纹阀值


389
00:24:53,493 --> 00:24:55,495
控制什么时候使用正常平滑


390
00:24:56,830 --> 00:25:01,869
在我们的飞船上我们看到左边有
默认的平面阴影网格


391
00:25:02,402 --> 00:25:03,904
右边有平滑阴影


392
00:25:06,373 --> 00:25:08,208
下面是细分曲面


393
00:25:09,109 --> 00:25:12,045
细分曲面是一项普通技术


394
00:25:12,246 --> 00:25:15,782
用来使用低细度的几何图形产生


395
00:25:15,849 --> 00:25:18,252
和渲染平滑表面


396
00:25:19,152 --> 00:25:22,489
这种技术可以让你使用
一个简单的多边形控制网格


397
00:25:22,689 --> 00:25:25,192
创建所需的不同级别的细节


398
00:25:25,859 --> 00:25:27,828
举例来说当一个物体远的时候


399
00:25:27,895 --> 00:25:30,664
它以少量的多边形来渲染


400
00:25:31,098 --> 00:25:34,034
当物体离镜头越来越近的时候


401
00:25:34,401 --> 00:25:35,769
它会提高颗粒度


402
00:25:36,970 --> 00:25:38,839
通过改变模型的细分层次


403
00:25:38,906 --> 00:25:40,908
你可以产生不同的网格


404
00:25:40,974 --> 00:25:42,276
不需要全部人工创建


405
00:25:43,544 --> 00:25:46,013
在Model I/O中
你可以通过调用新的


406
00:25:46,380 --> 00:25:51,818
SubdividedMesh程序
或者MDLMesh来创建细分层次


407
00:25:52,853 --> 00:25:55,489
在下面我们将细分级别设置为2


408
00:25:55,889 --> 00:25:58,325
实现了右边的光滑网格


409
00:25:58,625 --> 00:26:01,428
多边形数显著增加


410
00:26:04,398 --> 00:26:05,999
最后是体素


411
00:26:06,834 --> 00:26:09,636
除了提供各种以多边形展示


412
00:26:09,736 --> 00:26:12,072
3D模型的先进技术


413
00:26:12,573 --> 00:26:15,709
Model I/O还支持容量展示


414
00:26:17,044 --> 00:26:19,279
通过以物体近似真实世界


415
00:26:19,346 --> 00:26:24,318
的情况展示模型这是
一系列空间粒子或点


416
00:26:24,384 --> 00:26:28,155
有固有的性质 
如体积 质量 速度 颜色


417
00:26:28,689 --> 00:26:32,559
以一系列的物理现实技术分析和操作


418
00:26:32,759 --> 00:26:34,494
的大门向你敞开了


419
00:26:35,829 --> 00:26:38,832
与多边形网格一样很难建模


420
00:26:38,899 --> 00:26:42,536
和展现表面不规则的现象
如云 水 火


421
00:26:42,936 --> 00:26:45,706
有了体积表现就变得非常容易了


422
00:26:46,607 --> 00:26:49,643
现在与其试图混合和扭转


423
00:26:49,743 --> 00:26:52,646
多边形的刚性外壳
该模型成为一个变形的物质


424
00:26:52,713 --> 00:26:54,915
任何时间都可以改变它的属性


425
00:26:56,083 --> 00:26:58,819
沿着相同的路线 这表示


426
00:26:58,952 --> 00:27:02,122
允许程序生成建模意味着它可以制造


427
00:27:02,256 --> 00:27:04,658
让人兴奋和感到新奇的机会和游戏


428
00:27:05,125 --> 00:27:08,762
考虑修改和毁坏对象和飞地


429
00:27:11,665 --> 00:27:14,801
因为体素模型能更准确地表现


430
00:27:14,868 --> 00:27:18,138
真实世界它可以让自己以


431
00:27:18,205 --> 00:27:22,776
更自然和真实的方式
被探索和操纵就像是切片技术


432
00:27:23,944 --> 00:27:25,946
这事实上被证明在医学影像领域


433
00:27:26,013 --> 00:27:28,849
是特别有用的非常幸运


434
00:27:28,916 --> 00:27:34,354
科学家已经证明我们
头骨不是一个三角形空壳


435
00:27:36,089 --> 00:27:39,126
最后鉴于你已经有了固体体素模型


436
00:27:39,193 --> 00:27:41,628
你可以执行构造实体几何布尔


437
00:27:41,695 --> 00:27:43,797
操作以便创建大量


438
00:27:43,864 --> 00:27:45,933
更有趣复杂的模型


439
00:27:48,535 --> 00:27:50,437
在Model I/O中我们以


440
00:27:50,504 --> 00:27:53,507
MDLVoxelArray API
暴露体素


441
00:27:54,274 --> 00:27:56,276
我们的作品以稀疏网格表现


442
00:27:56,343 --> 00:27:59,146
空间模型稀疏网格可以


443
00:27:59,213 --> 00:28:01,048
使用简单的空间索引访问


444
00:28:02,249 --> 00:28:06,019
这个表现形式具有快速找到并
访问邻居的功能


445
00:28:07,588 --> 00:28:11,625
网格除了连接得每个体素外
还包含壳等级值


446
00:28:11,925 --> 00:28:16,230
壳等级值是表明体素在正外部方向


447
00:28:16,697 --> 00:28:21,301
和负内部方向离模型表面的远近


448
00:28:22,603 --> 00:28:24,638
Model I/O也支持


449
00:28:24,805 --> 00:28:28,308
创建封闭网格模型的清理
及转回多边形网格


450
00:28:29,510 --> 00:28:31,778
我将向你展示少量你需要的API调用


451
00:28:31,845 --> 00:28:34,281
以便能引入体素和Model I/O


452
00:28:36,083 --> 00:28:39,253
假设有一个初始化的
MDLVoxelArray


453
00:28:39,319 --> 00:28:42,055
你可以通过调用
setVoxelsForMesh方法


454
00:28:42,623 --> 00:28:44,925
从MDMMesh模型产生体素数据


455
00:28:45,993 --> 00:28:49,830
分离参数的作用是
设置分辨率设定层的数量


456
00:28:50,130 --> 00:28:54,201
将你的模型在垂直方向分开


457
00:28:55,269 --> 00:29:00,340
你也可以设置模型内墙和外墙的厚度
就用最后的这两个参数


458
00:29:02,442 --> 00:29:04,211
一旦你建立了体素数组对象


459
00:29:04,878 --> 00:29:06,947
你可以在它们上面执行各种各样的操作


460
00:29:07,014 --> 00:29:10,083
例如体素的交集合集及差分


461
00:29:10,150 --> 00:29:12,653
这些是基本布林操作


462
00:29:14,621 --> 00:29:16,823
要实际加工和处理


463
00:29:16,890 --> 00:29:20,527
检查体素数据只需调用
getvoxelindices方法


464
00:29:21,628 --> 00:29:24,565
做完了上面的操作
用meshUsingAllocator程序


465
00:29:24,631 --> 00:29:26,500
就可以将体素模型


466
00:29:26,733 --> 00:29:28,836
转换回多边形模型


467
00:29:31,104 --> 00:29:31,939
非常简单


468
00:29:32,673 --> 00:29:35,342
现在我将用快速
展示来展现一个动态的体素


469
00:29:54,728 --> 00:29:55,996
让我们看这个展示


470
00:29:56,463 --> 00:29:58,765
它会用一个小时的时间来展示


471
00:29:58,832 --> 00:30:00,934
如何使用
SceneKit editor来创建


472
00:30:01,001 --> 00:30:02,936
我们只需要在地面上拖拽


473
00:30:03,337 --> 00:30:08,308
同样地像昨天在华盛顿
看到的红色熊猫那样


474
00:30:08,642 --> 00:30:12,779
这是规则的多边形网格
你可以使用任意的网格来制作


475
00:30:13,747 --> 00:30:16,984
下面是使用MDLVoxelArray 
API它仅用两条线的代码


476
00:30:17,150 --> 00:30:19,486
就把网格变成了体素


477
00:30:20,354 --> 00:30:25,158
那么对于每个体素
我们都创建一个SCN盒子 就像这样


478
00:30:30,230 --> 00:30:32,666
现在我们有了在
SceneKit中的体素


479
00:30:33,066 --> 00:30:36,637
让人激动的是我们可以使用


480
00:30:36,703 --> 00:30:39,640
SceneKit所提供的
所有非常酷的东西


481
00:30:40,040 --> 00:30:42,910
举例来说使用一条线的代码


482
00:30:42,976 --> 00:30:45,846
我们可以把SCN盒子变成SCN球


483
00:30:47,614 --> 00:30:50,050
让大家开心下
我们将SceneKit体素


484
00:30:50,117 --> 00:30:52,386
提供给所有节点然后引爆它


485
00:30:53,921 --> 00:30:56,456
现在由Remi来接着讲


486
00:30:56,523 --> 00:30:59,293
关于照明和Xcode支持的高级主体


487
00:31:09,002 --> 00:31:10,704
大家好 谢谢克劳迪娅


488
00:31:11,271 --> 00:31:16,276
如克里斯所说我将分享关于烘焙


489
00:31:16,343 --> 00:31:18,946
以及Model I/O
工作原理的高级内容


490
00:31:20,113 --> 00:31:23,283
所以就是高级照明和烘焙目的是什么


491
00:31:23,884 --> 00:31:27,187
目的是介绍框架和喧染通道


492
00:31:27,254 --> 00:31:29,423
在你的游戏中叫做全局照明


493
00:31:30,290 --> 00:31:31,124
是什么呢？


494
00:31:31,592 --> 00:31:34,561
这么说不好立即 好吧
我这里有点的高度


495
00:31:34,628 --> 00:31:38,498
有三角形让我们用点工具照亮它就是了


496
00:31:39,099 --> 00:31:41,401
我们将试图让场景看上去是真的


497
00:31:41,635 --> 00:31:45,005
我们将要在光线因为不能穿过三角板


498
00:31:45,172 --> 00:31:47,441
而在墙上反射的和阻挡的场景中


499
00:31:47,741 --> 00:31:50,177
仿真光线实际移动


500
00:31:51,178 --> 00:31:53,647
问题是这消耗非常大


501
00:31:53,780 --> 00:31:58,185
在影片中会花费很长的时间
如果你想花费半个小时去重构的话


502
00:31:58,685 --> 00:32:00,120
但这不适合我们


503
00:32:00,487 --> 00:32:03,857
请看这张图片你可以看到举例来说


504
00:32:04,391 --> 00:32:07,528
这里的墙左边的红墙


505
00:32:07,594 --> 00:32:09,663
在球上投射了一些红色的光


506
00:32:10,197 --> 00:32:14,001
墙不是真的光但光在


507
00:32:14,201 --> 00:32:17,638
真实世界里是从墙上反射到球上的


508
00:32:18,438 --> 00:32:23,143
回到球上它有点暗
因为球吸收了墙上反射的光


509
00:32:23,210 --> 00:32:26,079
它不是真实的直接阴影
但是还有一些事情发生


510
00:32:27,848 --> 00:32:30,150
问题是很难做到实时


511
00:32:30,484 --> 00:32:32,886
所以我们将展示如何在


512
00:32:32,953 --> 00:32:36,557
预编译期间游戏运行之前做一些预运算


513
00:32:37,191 --> 00:32:40,127
这样你可以得到近似真实的景象


514
00:32:40,494 --> 00:32:42,429
而不用任何性能的回落


515
00:32:42,829 --> 00:32:44,298
我们将平衡性能和质量


516
00:32:44,631 --> 00:32:48,268
所以你可以用很少的性能开销
得到你想要的效果


517
00:32:49,770 --> 00:32:52,873
因此今天的全局照明将有两个点


518
00:32:52,940 --> 00:32:56,710
首先我们将展示环境遮挡


519
00:32:57,377 --> 00:32:58,679
然后是光照贴图


520
00:32:59,446 --> 00:33:01,949
为了介绍环境遮挡我会展示一个示例


521
00:33:03,350 --> 00:33:07,321
请看这个飞船它是默认的
SceneKit飞船 看上去不错


522
00:33:07,654 --> 00:33:11,225
是一个大飞船
我喜欢玩这个游戏但是它有点平


523
00:33:11,325 --> 00:33:12,960
如果你看看翅膀和发动机


524
00:33:13,627 --> 00:33:18,398
它的翅膀尾部
和发动机的开端部位有点不清楚


525
00:33:18,465 --> 00:33:20,734
如果你看右边图像的两翅片


526
00:33:21,602 --> 00:33:24,171
它有点怪异因为你给它的光


527
00:33:24,238 --> 00:33:26,974
和前面的飞船的光一样
但是翅片应该挡住光线


528
00:33:27,641 --> 00:33:30,277
如果你要添加环境遮挡 它会变成这样


529
00:33:31,778 --> 00:33:34,481
同样的渐变但是看上去更真实了


530
00:33:34,548 --> 00:33:37,484
因为现在在翅膀和发动机之间的


531
00:33:37,751 --> 00:33:38,986
遮挡有了阴影


532
00:33:39,520 --> 00:33:41,522
如果我在第二个上面添加环境遮挡


533
00:33:41,755 --> 00:33:43,423
它会这样 同样的


534
00:33:43,690 --> 00:33:46,527
但你可以看到光的遮挡


535
00:33:46,860 --> 00:33:49,162
这是更让人信服的体验


536
00:33:49,229 --> 00:33:53,200
这是一个更好看的图片
环境遮挡实际是什么


537
00:33:54,501 --> 00:33:58,739
环境遮挡是非常简单的
几何图形遮挡测量


538
00:33:59,039 --> 00:34:02,009
意思是我的点或是网格


539
00:34:02,442 --> 00:34:04,244
在我的世界里有多少光


540
00:34:04,311 --> 00:34:07,614
可以真正的落在我的点


541
00:34:07,681 --> 00:34:10,951
有多少光被我的网格
或是它周围的网格遮住了


542
00:34:11,752 --> 00:34:17,858
所以它基本上是一个信号 1
代表白色说明我完全无遮挡


543
00:34:17,991 --> 00:34:22,062
全部的光发散出去了大多的光不能到那


544
00:34:22,462 --> 00:34:23,630
如果我们看信号


545
00:34:23,964 --> 00:34:24,831
是这样的


546
00:34:25,532 --> 00:34:28,101
几何全白因为大多数光都不能到那儿


547
00:34:28,335 --> 00:34:30,904
但是你看一些...那里的物理数据


548
00:34:32,739 --> 00:34:33,774
我们如何计算？


549
00:34:34,507 --> 00:34:37,143
使用离线光线追踪


550
00:34:37,210 --> 00:34:41,882
网格变成...
我们把光线射向各个方向


551
00:34:42,081 --> 00:34:44,284
然后计算如果我在我的点周围照射光线


552
00:34:44,618 --> 00:34:46,520
有多少光线


553
00:34:46,786 --> 00:34:50,489
有多少光线射在网格上
有多少射在天空盒子上


554
00:34:50,791 --> 00:34:53,193
两者之间的区别在于我的环境遮挡信号


555
00:34:54,328 --> 00:34:55,728
我们需要什么？


556
00:34:56,530 --> 00:34:59,199
输入 网格 我的太空船


557
00:34:59,633 --> 00:35:00,701
一系列的遮挡网格


558
00:35:01,268 --> 00:35:02,703
这里它只是一个太空船


559
00:35:02,769 --> 00:35:05,439
举个例子如果我表现那个场景的光


560
00:35:06,039 --> 00:35:09,376
我想做地面场景的
它将计算地面的环境遮挡


561
00:35:09,610 --> 00:35:14,014
我还要所有的椅子 人 地板


562
00:35:14,515 --> 00:35:18,819
所有阻挡光线的东西
这样我就有了一个非常好看的网格


563
00:35:19,052 --> 00:35:19,887
这是非常好的设定


564
00:35:20,888 --> 00:35:21,955
我的输出是


565
00:35:22,523 --> 00:35:25,859
一组每个点的遮挡值


566
00:35:26,627 --> 00:35:27,728
点的遮挡


567
00:35:29,196 --> 00:35:30,397
我们如何存储


568
00:35:30,831 --> 00:35:34,168
2种方式顶点或纹理


569
00:35:34,668 --> 00:35:36,537
如果我的网格有很多顶点


570
00:35:36,637 --> 00:35:40,207
举例来说一个有大量三角形的太空船


571
00:35:40,507 --> 00:35:42,075
我们可以用顶点来存储非常好


572
00:35:42,309 --> 00:35:45,679
因为它非常节省资源
每个顶点只要一浮动


573
00:35:46,246 --> 00:35:52,286
栅格化你的金属或管道
非常节省的渲染


574
00:35:53,587 --> 00:35:57,024
举例来说太空船是少量三角形


575
00:35:57,391 --> 00:35:58,292
我们需要纹理来存储


576
00:35:59,693 --> 00:36:02,396
我们已经内建在Model I/O


577
00:36:02,796 --> 00:36:08,235
一个UV映射创建二维纹理
以其包裹3D网格


578
00:36:08,869 --> 00:36:12,506
这样这个纹理的每个
象素都有了环境遮挡


579
00:36:12,940 --> 00:36:15,442
我们要看看这个飞船的纹理是什么样子


580
00:36:15,709 --> 00:36:16,543
它是这样的


581
00:36:17,845 --> 00:36:20,814
你可以看到纹理环绕在太空船周围


582
00:36:21,415 --> 00:36:24,117
你可以看到翅膀和发动机的基座等等


583
00:36:26,887 --> 00:36:28,722
我们怎么计算 非常简单


584
00:36:28,922 --> 00:36:30,057
简单得不行


585
00:36:30,390 --> 00:36:32,693
举例来说你可以看最上边的这个船网格


586
00:36:33,260 --> 00:36:35,028
产生环境遮挡


587
00:36:35,896 --> 00:36:37,030
这是纹理


588
00:36:37,631 --> 00:36:41,001
我们有2个参数质量和衰减因子


589
00:36:41,668 --> 00:36:44,872
如果我们提升质量
它将会将会发射更多的光线


590
00:36:44,938 --> 00:36:48,408
得到更好看的信号 但是它
将会花费更多的时间去计算


591
00:36:49,276 --> 00:36:53,080
因为这是烘焙它会在游戏加载前运行
但问题还没解决


592
00:36:53,547 --> 00:36:56,550
如何我们做一个纹理烘焙
那么纹理会更大


593
00:36:56,683 --> 00:36:59,019
所以它会提升一点内存消耗


594
00:36:59,653 --> 00:37:01,755
那么衰减仅仅会衰减信号


595
00:37:01,822 --> 00:37:03,657
只有暗的部分仍然保持暗


596
00:37:04,925 --> 00:37:09,897
最酷的是我们与SceneKit团队
开发了在SceneKit甚至是


597
00:37:09,963 --> 00:37:12,366
SceneKit编辑器中的功能


598
00:37:12,432 --> 00:37:14,134
大家在华盛顿看到过了


599
00:37:14,701 --> 00:37:16,203
我将立刻向你展示这个


600
00:37:20,174 --> 00:37:22,876
它有效了


601
00:37:23,310 --> 00:37:26,747
这里我只加载了一点场景


602
00:37:27,080 --> 00:37:31,351
太空船和天空盒子


603
00:37:31,752 --> 00:37:33,787
太空船在太空飞得非常好


604
00:37:34,188 --> 00:37:40,961
我在这里没有加光
所以非常平唯一可见的是环境光


605
00:37:41,895 --> 00:37:45,199
你可以看到环境光线对


606
00:37:45,265 --> 00:37:47,067
太空船的外观没有作用


607
00:37:47,301 --> 00:37:49,937
它没有以几何图形位置的形式


608
00:37:50,003 --> 00:37:52,139
反馈给用户 所以它非常平


609
00:37:52,940 --> 00:37:53,774
我们要改变


610
00:37:54,241 --> 00:37:55,843
我先点击网格


611
00:37:55,909 --> 00:37:58,612
我将看到实际上这里有些顶点


612
00:37:58,812 --> 00:37:59,880
所以我们做个顶点烘焙


613
00:38:01,014 --> 00:38:02,349
我会带入几何选项卡


614
00:38:03,984 --> 00:38:06,854
我将在这儿在环境烘焙下面 选择顶点


615
00:38:07,721 --> 00:38:10,991
这些值非常好 点烘焙


616
00:38:11,725 --> 00:38:12,559
发生了什么


617
00:38:12,993 --> 00:38:16,530
对于船上的每一个小的顶点
我们将发送100


618
00:38:16,597 --> 00:38:20,334
到200光线到它的周围
看上去是这样


619
00:38:21,401 --> 00:38:23,170
看 更好的方式


620
00:38:24,771 --> 00:38:26,306
我们有了这个 现在又有了这个


621
00:38:27,241 --> 00:38:28,242
它感觉上更好了


622
00:38:28,375 --> 00:38:30,577
如果你看 例如 这 顶板


623
00:38:30,944 --> 00:38:34,314
在1号底部有遮挡
因为光线不能很容易的到达那里


624
00:38:34,815 --> 00:38:36,850
如果我们看这里面的窗户 在这里


625
00:38:37,718 --> 00:38:40,554
窗口的内口比外部有更多的遮挡


626
00:38:41,355 --> 00:38:42,890
如果我们看这


627
00:38:43,323 --> 00:38:44,157
缩小


628
00:38:44,725 --> 00:38:46,793
如果 我们看下面的大炮


629
00:38:47,160 --> 00:38:48,862
大炮的顶部非常暗


630
00:38:48,929 --> 00:38:51,532
因为整个船阻止光到达那里


631
00:38:51,965 --> 00:38:53,767
如果我们看底部


632
00:38:54,568 --> 00:38:55,936
都是白的 有意义 是吗


633
00:38:56,803 --> 00:39:00,407
所以每个顶点增加一浮动，我们能


634
00:39:00,474 --> 00:39:05,712
用环境光照亮我们的场景更好看了


635
00:39:07,247 --> 00:39:09,149
在SceneKit中是可用的


636
00:39:09,950 --> 00:39:12,586
让我们回到幻灯片


637
00:39:14,288 --> 00:39:15,122
这是环境遮挡


638
00:39:16,023 --> 00:39:20,227
今天关于以高级光贴图照射
就分享到这里


639
00:39:21,261 --> 00:39:22,829
光贴图是什么


640
00:39:23,330 --> 00:39:27,167
光贴图是一种方法让你的漫射照明


641
00:39:27,234 --> 00:39:30,204
进入游戏并预计算实时
还是非实时情况下


642
00:39:30,270 --> 00:39:33,207
扩散照明对纹理的影响


643
00:39:33,607 --> 00:39:35,976
正如你们知道的
如果你做了一些游戏编程


644
00:39:36,510 --> 00:39:38,579
光照是非常耗资源的


645
00:39:38,745 --> 00:39:41,815
如果你有十个光源那么每一帧


646
00:39:41,915 --> 00:39:46,553
你需要计算光的方面
以及它是如何干扰你的游戏的


647
00:39:46,920 --> 00:39:48,155
这非常耗资源


648
00:39:48,755 --> 00:39:52,693
这里我拖拽了仿真器中的一个飞机


649
00:39:52,759 --> 00:39:55,896
两只盒子八个光源


650
00:39:56,396 --> 00:39:58,298
然后 我计算 在我加载游戏前


651
00:39:58,365 --> 00:40:03,570
使用光贴图烘焙
光贴图如何照亮场景及照亮纹理


652
00:40:05,005 --> 00:40:08,141
如果我们看这个场景


653
00:40:08,642 --> 00:40:09,810
看上去这样


654
00:40:09,877 --> 00:40:11,211
非常真实


655
00:40:11,578 --> 00:40:13,113
我们有了阴影和光


656
00:40:13,480 --> 00:40:16,550
但是这实际耗费一个纹理获取


657
00:40:18,352 --> 00:40:19,186
这样


658
00:40:19,786 --> 00:40:22,289
通常渲染八个光特别是如果你有阴影


659
00:40:22,356 --> 00:40:23,690
阴影贴图非常耗资源


660
00:40:24,358 --> 00:40:25,325
纹理看上去这样


661
00:40:25,559 --> 00:40:29,096
很简单你看中间的箱子和阴影


662
00:40:31,698 --> 00:40:33,700
这非常酷 只是一个纹理获取 是吗？


663
00:40:34,201 --> 00:40:35,369
它支持非常多的光


664
00:40:35,636 --> 00:40:37,771
我能有100,000个光源


665
00:40:37,905 --> 00:40:41,508
它将具有相同的运行成本


666
00:40:41,675 --> 00:40:43,844
甚至阴影看上去也很酷


667
00:40:44,278 --> 00:40:47,481
当你象这样做出个点光源
它非常贴近地面


668
00:40:47,548 --> 00:40:50,784
你会遇到精确性问题
除非你这样做


669
00:40:50,951 --> 00:40:54,655
发送光线到这个东西上的每个象素


670
00:40:54,988 --> 00:40:58,225
看看哪个象素有光哪个象素没有光


671
00:40:58,492 --> 00:41:01,628
你的阴影看上去将非常真实离线计算


672
00:41:03,397 --> 00:41:07,100
我们支持超复杂的实时幻灯片


673
00:41:07,201 --> 00:41:11,138
你甚至无法想像 这非常酷


674
00:41:11,572 --> 00:41:14,842
举个例子我们实际的
光照在很长的时间里很难


675
00:41:14,908 --> 00:41:17,344
做到实时因为用一般的点光


676
00:41:17,411 --> 00:41:21,582
很难做到三角反射处理


677
00:41:21,882 --> 00:41:23,717
这里我们用的是光线追踪


678
00:41:23,784 --> 00:41:27,387
所以我们只要发出光线
看看哪些有光哪些没有光


679
00:41:28,055 --> 00:41:30,057
我们也支持冷IS光源


680
00:41:30,524 --> 00:41:31,892
尼克之前说过的


681
00:41:33,327 --> 00:41:34,261
这是光贴图


682
00:41:35,762 --> 00:41:38,665
让我们总结一下


683
00:41:39,233 --> 00:41:42,336
今天我们介绍了一种非常新的框架
对于它 我们非常高兴


684
00:41:43,270 --> 00:41:47,407
首先它做了基本的3D文件导入导出


685
00:41:47,875 --> 00:41:49,343
但是对你来说做得非常多


686
00:41:49,843 --> 00:41:52,479
它使用基于真实世界


687
00:41:52,880 --> 00:41:56,984
而不是以浮动定义的
模型 光 相机 物质和天空


688
00:41:57,317 --> 00:41:59,553
介绍了渲染的物理基础概念


689
00:42:00,387 --> 00:42:03,190
我们有系统集成在Xcode中


690
00:42:03,257 --> 00:42:05,392
的框架和工具中你可以玩 玩得很开心


691
00:42:07,160 --> 00:42:10,197
为得到更多的信息
我们邀请你看我们的文档


692
00:42:10,264 --> 00:42:12,432
视频 论坛和技术支持


693
00:42:12,866 --> 00:42:15,636
任何一般的查询
您可以联系艾伦·谢弗


694
00:42:16,603 --> 00:42:21,508
相关的会议有明天的
“SceneKit进阶”


695
00:42:21,575 --> 00:42:23,076
和周二的Metal新功能


696
00:42:23,510 --> 00:42:27,014
一会儿和明天早上9点


697
00:42:27,080 --> 00:42:28,782
我们将在
Model I/O实验室见面


698
00:42:29,349 --> 00:42:31,685
谢谢你们
希望你们有一个伟大的WWDC

