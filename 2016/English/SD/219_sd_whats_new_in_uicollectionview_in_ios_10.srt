1
00:00:07,516 --> 00:00:17,500
[ Music ]


2
00:00:21,556 --> 00:00:22,146
>> Good morning.


3
00:00:25,746 --> 00:00:27,556
My name is Steve Breen.


4
00:00:27,756 --> 00:00:31,026
>> And my name is Peter Hajas,
and we're both engineers


5
00:00:31,026 --> 00:00:32,836
on the UIKit Frameworks Team.


6
00:00:34,016 --> 00:00:35,426
>> We're really excited to share


7
00:00:35,426 --> 00:00:37,266
with what we're working
on in CollectionView.


8
00:00:37,926 --> 00:00:39,846
So let's get right into it.


9
00:00:41,176 --> 00:00:43,446
We've got three big topics
to talk about this morning.


10
00:00:43,876 --> 00:00:47,356
Our first topic is going
to be smooth scrolling.


11
00:00:48,396 --> 00:00:50,736
Now, every iOS app expects


12
00:00:50,736 --> 00:00:52,536
to have great scrolling
performance,


13
00:00:52,896 --> 00:00:55,026
and we got some great
additions to CollectionView


14
00:00:55,026 --> 00:00:58,536
to help your apps scroll better
than ever, and the best part


15
00:00:58,536 --> 00:01:00,976
about this is many of these
additions require little


16
00:01:01,216 --> 00:01:03,196
to no work in your applications.


17
00:01:03,636 --> 00:01:06,416
Next, we're going to talk


18
00:01:06,416 --> 00:01:09,056
about improvements
to self-sizing cells.


19
00:01:09,636 --> 00:01:12,556
Now this API was
introduced in iOS 8,


20
00:01:12,556 --> 00:01:15,396
and we're bringing some great
improvements to it in iOS X


21
00:01:15,396 --> 00:01:17,256
to make it easier to adopt.


22
00:01:18,266 --> 00:01:22,586
And, finally, we're going to
go over interactive reordering.


23
00:01:23,196 --> 00:01:26,126
This API was introduced
last year in iOS 9,


24
00:01:26,526 --> 00:01:27,866
and we've got some
great enhancements


25
00:01:27,866 --> 00:01:30,236
that we're going to
go over for iOS X.


26
00:01:30,886 --> 00:01:33,156
>> Let's start off
with smooth scrolling.


27
00:01:33,726 --> 00:01:39,326
A hallmark of the iOS device
experience is responding


28
00:01:39,326 --> 00:01:44,226
immediately to the user's
touch, and a big part


29
00:01:44,226 --> 00:01:47,966
of this responsive user
experience is making sure


30
00:01:48,636 --> 00:01:51,366
that as I scroll my
finger across the screen,


31
00:01:51,746 --> 00:01:53,546
the objects onscreen move


32
00:01:53,546 --> 00:01:55,696
as if they're moving
in the real world.


33
00:01:56,486 --> 00:01:59,686
This is really important
to keep your users immersed


34
00:01:59,996 --> 00:02:01,036
in their applications.


35
00:02:01,936 --> 00:02:03,946
We're going to talk
through smooth scrolling


36
00:02:04,136 --> 00:02:07,076
and some enhancements we've
made to UI CollectionView


37
00:02:07,836 --> 00:02:10,866
by talking through a demo app.


38
00:02:10,866 --> 00:02:14,376
As you'll see, this application
starts off not scrolling


39
00:02:14,376 --> 00:02:15,056
that great.


40
00:02:15,056 --> 00:02:17,466
We wanted to scroll like
butter, but right now,


41
00:02:17,466 --> 00:02:20,006
it's scrolling a lot more
like chunky peanut butter.


42
00:02:20,436 --> 00:02:21,476
So let's go to the iPad.


43
00:02:25,516 --> 00:02:26,986
I'm going to switch
over to the iPad.


44
00:02:29,196 --> 00:02:32,786
Just to clarify, blue squares
are usually pretty cheap,


45
00:02:32,816 --> 00:02:34,866
but we've intentionally
made these slow.


46
00:02:35,506 --> 00:02:36,996
So imagine they're
more complicated.


47
00:02:36,996 --> 00:02:39,026
For example, maybe they
have two colors in them.


48
00:02:40,336 --> 00:02:44,416
Anyways, we've got this
CollectionView, and we can see


49
00:02:44,416 --> 00:02:47,346
that scrolling already
loaded content is nice


50
00:02:47,346 --> 00:02:50,096
and fast, but check this out.


51
00:02:50,096 --> 00:02:51,346
Steve, watch closely.


52
00:02:51,946 --> 00:02:53,416
When I scroll a little bit more.


53
00:02:54,586 --> 00:02:55,576
>> Ooh, ouch.


54
00:02:56,016 --> 00:02:59,186
One star, do not buy.


55
00:02:59,406 --> 00:03:00,916
>> I wouldn't buy it either.


56
00:03:01,066 --> 00:03:04,266
This type of user experience
is something we really want


57
00:03:04,266 --> 00:03:04,706
to avoid.


58
00:03:05,236 --> 00:03:06,206
So what's going on here?


59
00:03:06,906 --> 00:03:10,236
Well, we said before that these
are some really expensive blue


60
00:03:10,236 --> 00:03:13,896
squares to simulate to really
expensive complicated cell


61
00:03:14,096 --> 00:03:17,576
in your app, and that's running
up against CollectionView


62
00:03:18,266 --> 00:03:21,226
and the fact that it loads cells
exactly when they're required.


63
00:03:21,336 --> 00:03:22,636
Let me show you what I mean.


64
00:03:24,046 --> 00:03:26,316
We'll reload our data
here, and I'm going to turn


65
00:03:26,316 --> 00:03:29,096
on a view that's going to show
all the cells that are loaded


66
00:03:29,096 --> 00:03:29,876
in the CollectionView.


67
00:03:30,906 --> 00:03:33,456
So you can see those bottom
cells are just peaking


68
00:03:33,456 --> 00:03:35,086
up beyond the visible bounds.


69
00:03:35,806 --> 00:03:37,726
Now watch what happens
when I scroll.


70
00:03:39,596 --> 00:03:42,916
We're bringing in an
entire row of cells at once.


71
00:03:43,346 --> 00:03:46,316
This is what's leading to that
stuttery scrolling performance.


72
00:03:47,316 --> 00:03:50,326
In performance terminology,
we would say


73
00:03:50,406 --> 00:03:52,806
that the app is dropping frames.


74
00:03:53,446 --> 00:03:55,616
Let's switch back to slides
to hear a little bit more.


75
00:03:56,016 --> 00:03:57,996
>> So what exactly do
we mean when we talk


76
00:03:57,996 --> 00:03:59,836
about dropping frames.


77
00:04:00,386 --> 00:04:02,206
Now, in your applications,


78
00:04:02,466 --> 00:04:04,836
the users expect a smooth
scrolling performance,


79
00:04:04,836 --> 00:04:07,606
which means your app wants
to hit that magical number


80
00:04:07,876 --> 00:04:09,376
of 60 frames per second.


81
00:04:10,546 --> 00:04:11,586
Now if we do the math,


82
00:04:11,736 --> 00:04:15,026
that means that for every time
we refresh the display we need


83
00:04:15,026 --> 00:04:17,466
to hit that window
in 16 milliseconds.


84
00:04:18,495 --> 00:04:20,406
OK. So let's look
at a couple frames.


85
00:04:20,406 --> 00:04:23,756
Here we have a diagram that
shows three distinct frames.


86
00:04:24,276 --> 00:04:29,506
In our first frame, we got
very little work to do.


87
00:04:29,836 --> 00:04:33,406
Now as Peter mentioned before,
we're moving existing content


88
00:04:33,406 --> 00:04:34,536
up and down the display.


89
00:04:34,956 --> 00:04:37,126
It's a highly optimized
situation on iOS.


90
00:04:37,126 --> 00:04:38,416
So it's superfast.


91
00:04:38,416 --> 00:04:41,656
Not much work to hit, and
we've got this great five-star


92
00:04:41,656 --> 00:04:42,646
scrolling performance.


93
00:04:43,086 --> 00:04:43,846
That's a good frame.


94
00:04:45,836 --> 00:04:48,996
However, in the demo, it
wasn't always so great.


95
00:04:50,436 --> 00:04:52,236
Occasionally, we'd
have this situation


96
00:04:52,346 --> 00:04:54,136
where we have a lot
of work to do.


97
00:04:54,356 --> 00:04:56,786
Not only do we fill
up our current frame,


98
00:04:57,136 --> 00:04:58,906
we went into the next frame.


99
00:05:00,456 --> 00:05:02,386
This is our ad frame.


100
00:05:02,386 --> 00:05:04,166
We drop a frame, one star.


101
00:05:04,166 --> 00:05:08,266
Let's look at this in a
little bit different light.


102
00:05:08,856 --> 00:05:12,626
Now on this graph, we can see
we've got two distinct regions.


103
00:05:13,196 --> 00:05:14,666
We have the region on the top,


104
00:05:14,666 --> 00:05:16,386
which we're going to
call the red zone.


105
00:05:16,386 --> 00:05:19,896
This is the area where we miss
a frame, and we're up above


106
00:05:19,896 --> 00:05:21,956
that magical 16 millisecond
line.


107
00:05:23,236 --> 00:05:25,116
Let's check out the labels
that we have on the axes.


108
00:05:25,756 --> 00:05:29,046
So on our y-axis, we're
going to graph the CPU time


109
00:05:29,046 --> 00:05:31,786
on the main thread,
and on the x,


110
00:05:32,096 --> 00:05:36,186
this is the display fresh events
as the scrolling's occurring.


111
00:05:36,486 --> 00:05:38,136
OK. So let's look at a graph.


112
00:05:39,396 --> 00:05:40,626
Alright. So in this graph,


113
00:05:40,986 --> 00:05:43,066
this shows what Peter was
demonstrating a second ago


114
00:05:43,066 --> 00:05:45,546
where we have these visits
up into that red zone


115
00:05:45,546 --> 00:05:48,246
where we're dropping
frames, but most importantly,


116
00:05:48,246 --> 00:05:49,706
look at these quiet times


117
00:05:49,996 --> 00:05:52,186
where the CollectionView's
doing very little work,


118
00:05:53,066 --> 00:05:54,066
but then we have
this other visit


119
00:05:54,066 --> 00:05:55,046
to the red zone at the end.


120
00:05:55,176 --> 00:05:59,596
So what if we could change this
behavior a little bit and smooth


121
00:05:59,596 --> 00:06:02,546
out the amount of work we're
doing as the user's scrolling.


122
00:06:02,986 --> 00:06:05,166
OK, cool. Look at this.


123
00:06:05,166 --> 00:06:08,776
So now instead of these
visits up into that red zone


124
00:06:09,586 --> 00:06:12,826
and those periods of quiescence,
we've got a nice even amount


125
00:06:12,826 --> 00:06:14,976
of work, and we're spreading
the work out across time.


126
00:06:16,336 --> 00:06:18,136
>> To help talk through
how we're going


127
00:06:18,136 --> 00:06:20,866
to flatten these peaks
and bring up this valley


128
00:06:21,176 --> 00:06:24,876
to create this nice, consistent
line of work, I'd like to talk


129
00:06:24,876 --> 00:06:29,106
through the life cycle of a
cell as it existed on iOS 9.


130
00:06:29,756 --> 00:06:32,516
We're going to go through the
whole circle of life of a cell.


131
00:06:32,956 --> 00:06:33,586
It's beautiful.


132
00:06:34,466 --> 00:06:36,036
Let's bring our CollectionView
cells,


133
00:06:37,116 --> 00:06:39,106
and we're scrolling along,
and let's say we need


134
00:06:39,106 --> 00:06:40,356
to bring in a new cell.


135
00:06:41,706 --> 00:06:43,086
We'll take it out
of the reuse queue,


136
00:06:43,086 --> 00:06:45,246
and we'll call prepareForReuse
on it.


137
00:06:46,246 --> 00:06:49,306
This gives the cell an
opportunity to reset itself


138
00:06:49,506 --> 00:06:53,326
to its default state, ready to
receive new data from your app.


139
00:06:54,246 --> 00:06:58,496
Next, we'll continue calling the
rest of cellForItemAtIndexPath.


140
00:06:59,376 --> 00:07:01,336
This is where you should
be doing the majority


141
00:07:01,336 --> 00:07:02,886
of your work populating
the cell.


142
00:07:03,356 --> 00:07:05,996
You'll access your data
models, set them on the cell,


143
00:07:06,226 --> 00:07:07,936
and return them back
to the system.


144
00:07:09,006 --> 00:07:11,956
Now, right before that
cell's about to go on screen,


145
00:07:12,246 --> 00:07:14,266
we'll call willDisplayCell.


146
00:07:15,476 --> 00:07:16,946
This will give your app a chance


147
00:07:17,236 --> 00:07:20,906
to do any other last-minute
work it needs to do before


148
00:07:20,906 --> 00:07:22,216
that cell goes on screen.


149
00:07:23,086 --> 00:07:26,456
And for any outgoing cells,
we'll call didEndDisplayingCell.


150
00:07:26,516 --> 00:07:31,636
>> OK. So that's the life
cycle of the cell before iOS X.


151
00:07:32,676 --> 00:07:35,066
Now let's check out what
this looks like in iOS X.


152
00:07:35,886 --> 00:07:37,456
So here we have the
same type of layout


153
00:07:37,456 --> 00:07:38,506
that Peter just talked about.


154
00:07:38,806 --> 00:07:39,626
The single column.


155
00:07:39,626 --> 00:07:41,496
It's simple for demonstration
purposes.


156
00:07:42,426 --> 00:07:44,706
So now as the user scrolls up,


157
00:07:44,776 --> 00:07:47,556
notice here that well
before this cell is needed


158
00:07:47,556 --> 00:07:49,796
to be displayed on screen,
we're going to bring it


159
00:07:49,796 --> 00:07:50,906
in from the reuse queue.


160
00:07:51,036 --> 00:07:54,166
And then following that familiar
pattern Peter was talking about,


161
00:07:54,476 --> 00:07:56,306
we're going to send
it a prepareForReuse,


162
00:07:56,736 --> 00:07:59,646
and then construct the rest
of the content in your cell


163
00:07:59,646 --> 00:08:01,116
with cellForItemAtIndexPath.


164
00:08:01,536 --> 00:08:05,236
Now as the user continues to
scroll, here's what's different.


165
00:08:06,026 --> 00:08:08,016
Now we didn't call
willDisplayCell right


166
00:08:08,016 --> 00:08:09,066
when we created this cell.


167
00:08:09,066 --> 00:08:12,476
We have a hesitant, hesitation,
and then right when it displays,


168
00:08:12,596 --> 00:08:14,426
we're going to call
willDisplayCell.


169
00:08:15,526 --> 00:08:17,696
OK. So now the user
continues to scroll.


170
00:08:18,976 --> 00:08:20,756
We're going to fade away
those other cells to focus


171
00:08:20,756 --> 00:08:23,706
on the lifetime of this
cell, and now the cell is


172
00:08:23,706 --> 00:08:26,226
about to exit the visible
bounds from the CollectionView.


173
00:08:26,666 --> 00:08:29,606
So we'll send it the
expected didEndDisplayingCell.


174
00:08:30,166 --> 00:08:33,285
Now what Peter was talking
about iOS 9, at this point,


175
00:08:33,405 --> 00:08:36,086
the cell entered the reuse
queue, and we'd be done with it.


176
00:08:36,616 --> 00:08:39,126
To display the data in
this particular cell again,


177
00:08:39,446 --> 00:08:41,206
we'd have to go through the
beginning of the life cycle


178
00:08:41,206 --> 00:08:43,905
to cell and call
cellForItemAtIndexPath.


179
00:08:44,686 --> 00:08:46,606
But in iOS X, we're
going to hold


180
00:08:46,606 --> 00:08:48,266
onto that cell just
a little bit longer.


181
00:08:49,086 --> 00:08:50,536
So if the user scrolls
up a little bit,


182
00:08:50,536 --> 00:08:51,576
and then says, "Oh,
wait a minute.


183
00:08:51,576 --> 00:08:53,336
That was a picture of
my sister's new kid.


184
00:08:53,336 --> 00:08:55,676
I'm going to scroll back
down," we're going to hang


185
00:08:55,676 --> 00:08:58,836
onto that cell, and send
it a willDisplayCell again.


186
00:08:59,016 --> 00:09:01,826
Now the content will
continue on in the cell.


187
00:09:02,516 --> 00:09:07,500
[ Applause ]


188
00:09:21,096 --> 00:09:24,446
>> So notice as Steve's showing
you here, this also applies


189
00:09:24,446 --> 00:09:26,006
to multicolumn layouts.


190
00:09:26,786 --> 00:09:29,926
We're going to be bringing in
the cells one at a time instead


191
00:09:29,926 --> 00:09:32,386
of all at once to get better
scrolling performance.


192
00:09:32,386 --> 00:09:33,976
>> That's right,
Peter, and notice here,


193
00:09:33,976 --> 00:09:36,476
these cells aren't actually
displayed on screen quite yet.


194
00:09:36,696 --> 00:09:37,986
They're still off the screen.


195
00:09:38,156 --> 00:09:40,846
And now that we sent the
second cell that we DQ'd,


196
00:09:41,096 --> 00:09:44,706
the cellForItemIndexPath,
and scroll up both cells,


197
00:09:44,796 --> 00:09:47,726
now we're going to send
the willDisplayCellMessage


198
00:09:47,726 --> 00:09:50,226
to both right before
they appear on screen.


199
00:09:51,416 --> 00:09:53,616
>> While this may seem
like a subtle change,


200
00:09:53,756 --> 00:09:55,786
it's actually a lot
bigger than that.


201
00:09:56,176 --> 00:09:59,066
By adopting this new
life cycle in iOS X,


202
00:09:59,416 --> 00:10:01,976
we get automatic faster
scrolling performance.


203
00:10:02,296 --> 00:10:03,166
Let's go back to iPad.


204
00:10:03,166 --> 00:10:11,656
So I'm going to switch back
to the iPad, and here you see


205
00:10:11,656 --> 00:10:15,076
that same CollectionView we
were just looking at in iOS 9.


206
00:10:15,696 --> 00:10:19,456
Remember, scrolling existing
content is nice and fast,


207
00:10:19,686 --> 00:10:21,186
but when we have to
bring in more cells,


208
00:10:22,436 --> 00:10:23,696
that's when things get choppy.


209
00:10:24,276 --> 00:10:26,196
Now, while preparing
this CollectionView,


210
00:10:26,416 --> 00:10:29,326
we also prepared one in the
oven cooking under iOS X.


211
00:10:29,326 --> 00:10:31,136
So I'm going to switch
over to that,


212
00:10:32,856 --> 00:10:35,746
and here we've got the
exact same CollectionView


213
00:10:35,976 --> 00:10:40,206
with those same really expensive
blue squares running on iOS X.


214
00:10:41,536 --> 00:10:45,496
We can see that scrolling
existing content is still nice,


215
00:10:45,496 --> 00:10:48,506
fast, and fluid, but
watch closely, Steve.


216
00:10:48,696 --> 00:10:48,976
>> Alright.


217
00:10:48,976 --> 00:10:50,546
>> When I scroll
a little bit more.


218
00:10:51,586 --> 00:10:52,766
>> Oh, that's great.


219
00:10:52,766 --> 00:10:53,616
Five stars.


220
00:10:54,176 --> 00:10:54,976
>> That's exactly right.


221
00:10:55,516 --> 00:11:00,766
[ Applause ]


222
00:11:01,266 --> 00:11:04,316
This is because we're using
this new cell life cycle.


223
00:11:04,606 --> 00:11:06,356
The application hasn't
changed at all.


224
00:11:06,356 --> 00:11:09,186
I'm going to turn on that
same view, which is going


225
00:11:09,186 --> 00:11:11,556
to show you all the cells
that CollectionView's loaded


226
00:11:11,556 --> 00:11:13,176
to help highlight
this difference.


227
00:11:14,676 --> 00:11:15,866
So let me turn that on.


228
00:11:16,666 --> 00:11:18,456
So here you can see
that bottom row


229
00:11:18,456 --> 00:11:20,386
of cells is just peaking above,


230
00:11:20,436 --> 00:11:22,606
but watch what happens
when I scroll faster.


231
00:11:23,326 --> 00:11:25,716
Instead of bringing in a
row of cells at a time,


232
00:11:26,606 --> 00:11:28,936
we're now spreading that
work out during the scroll.


233
00:11:29,226 --> 00:11:32,276
This is what leads to that much
smoother scrolling performance.


234
00:11:32,276 --> 00:11:33,056
Isn't that great?


235
00:11:38,816 --> 00:11:41,176
To learn more about this,
let's go back to slides.


236
00:11:44,836 --> 00:11:46,066
>> So this is pretty great.


237
00:11:46,586 --> 00:11:48,156
So today we're very pleased


238
00:11:48,156 --> 00:11:51,366
to announce UI CollectionView
Cell Pre-Fetching.


239
00:11:51,816 --> 00:11:54,136
Now this is enabled by default


240
00:11:54,136 --> 00:11:56,096
when you compile
your apps on iOS X.


241
00:11:57,576 --> 00:11:59,766
There's no step one.


242
00:11:59,946 --> 00:12:01,796
Now for any reason you need


243
00:12:01,796 --> 00:12:05,256
to use the old life
cycle behavior pre-iOS X,


244
00:12:05,306 --> 00:12:06,586
opting out is easy.


245
00:12:07,136 --> 00:12:09,546
Just set the new property
on UICollectionView


246
00:12:09,546 --> 00:12:11,926
to isPrefetchingEnabled
defaults.


247
00:12:11,926 --> 00:12:16,246
Now we've got some
best practices


248
00:12:16,246 --> 00:12:17,806
for adopting this
new technology.


249
00:12:19,066 --> 00:12:21,116
The first thing we want
to talk about is we want


250
00:12:21,116 --> 00:12:23,796
to do all the heavy lifting
in cellForItemAtIndexPath.


251
00:12:23,796 --> 00:12:25,966
All the, all the content
creation for your cell.


252
00:12:25,966 --> 00:12:28,886
Everything should be centered
in cellForItemAtIndexPath.


253
00:12:30,746 --> 00:12:33,396
Additionally, we want to
make sure we do minimal work


254
00:12:33,726 --> 00:12:36,516
willDisplayCell in
didEndDisplayCell.


255
00:12:38,336 --> 00:12:40,666
And, finally, it's
important to note


256
00:12:41,296 --> 00:12:44,486
that cellForItemaAtIndexPath
may prepare a cell that's never


257
00:12:44,486 --> 00:12:45,566
actually displayed.


258
00:12:45,696 --> 00:12:48,766
The user may scroll away before
the cell has an opportunity


259
00:12:48,766 --> 00:12:49,606
to be displayed.


260
00:12:51,016 --> 00:12:52,726
>> So this is great.


261
00:12:53,376 --> 00:12:55,076
By just recompiling in iOS X


262
00:12:55,076 --> 00:12:58,246
and doing what you're likely
already doing with the majority


263
00:12:58,246 --> 00:13:00,636
of your work in
cellForItemAtIndexPath,


264
00:13:01,056 --> 00:13:04,456
you automatically get better
scrolling performance for free.


265
00:13:05,646 --> 00:13:07,656
But we wanted to
go a step further.


266
00:13:08,236 --> 00:13:10,346
We understand that there's
a class of application


267
00:13:10,666 --> 00:13:13,666
which has a simple question for
preparing their CollectionViews.


268
00:13:13,976 --> 00:13:17,276
What do I do about my
expensive data models?


269
00:13:18,406 --> 00:13:19,796
The fact of the matter is


270
00:13:19,986 --> 00:13:23,436
that many CollectionView cells
require expensive data model


271
00:13:23,436 --> 00:13:25,156
access to create.


272
00:13:25,606 --> 00:13:28,526
I'm talking about things
like decoding images,


273
00:13:28,876 --> 00:13:30,916
talking to your database,
or loading things


274
00:13:30,916 --> 00:13:32,196
out of your core data store.


275
00:13:32,336 --> 00:13:35,536
And we understand that for
this class of application,


276
00:13:36,116 --> 00:13:37,156
we don't want to show things


277
00:13:37,156 --> 00:13:40,196
like template cells while we do
an asynchronous network request.


278
00:13:41,376 --> 00:13:44,346
To help solve this problem,
we're introducing new API


279
00:13:44,536 --> 00:13:48,946
in iOS X to help inform how
your data model loads content.


280
00:13:50,136 --> 00:13:51,466
Since its introduction,


281
00:13:51,606 --> 00:13:55,416
UI CollectionView has always
had two companion objects:


282
00:13:56,056 --> 00:13:58,036
The data source and
the delegate.


283
00:13:58,476 --> 00:14:02,286
And new in iOS X we have
this third companion object.


284
00:14:02,596 --> 00:14:05,796
It's optional, and it's
called the prefetchDataSource.


285
00:14:06,716 --> 00:14:08,696
There's just one
required method.


286
00:14:08,976 --> 00:14:10,696
It's really easy to implement.


287
00:14:11,476 --> 00:14:14,546
ColletionView prefetchItemsAt
indexPaths.


288
00:14:15,676 --> 00:14:18,456
This will be called on
your prefetch data source


289
00:14:18,756 --> 00:14:21,256
when it's time for
you to preload content


290
00:14:21,366 --> 00:14:22,936
from your asynchronous model.


291
00:14:23,866 --> 00:14:28,036
That argument index paths is
an ordered array of index paths


292
00:14:28,646 --> 00:14:31,676
so earlier items in that
array are coming up sooner.


293
00:14:32,386 --> 00:14:35,856
You can use this to influence
your asynchronous model reads.


294
00:14:36,756 --> 00:14:39,216
There's a second optional
method in this protocol.


295
00:14:39,676 --> 00:14:42,706
CollectionView
cancelPrefetcingForItemsAt


296
00:14:42,706 --> 00:14:43,536
indexPaths.


297
00:14:45,356 --> 00:14:48,216
This will be called on
your prefetch data source


298
00:14:49,366 --> 00:14:52,686
when we determine that we're no
longer scrolling towards a set


299
00:14:52,896 --> 00:14:53,656
of index paths.


300
00:14:54,586 --> 00:14:56,386
You can use this to cancel


301
00:14:56,806 --> 00:15:00,436
or lower the priority
of any pending loads.


302
00:15:00,436 --> 00:15:03,346
Now there's something really
important about this API


303
00:15:03,346 --> 00:15:04,776
that I want to highlight.


304
00:15:05,696 --> 00:15:07,816
This is not a replacement
for the data model


305
00:15:07,816 --> 00:15:08,866
that you've already written.


306
00:15:09,396 --> 00:15:13,646
Instead, it works alongside your
existing asynchronous solution


307
00:15:13,646 --> 00:15:16,386
that you've built for
loading data in your app.


308
00:15:17,766 --> 00:15:21,376
What you'll do is use this as
an additional hint for when


309
00:15:21,376 --> 00:15:23,146
to load content in
your CollectionView.


310
00:15:26,036 --> 00:15:28,466
>> So let's tie all this
together with a demo


311
00:15:28,466 --> 00:15:31,606
that shows all of the concepts
we've talked about so far,


312
00:15:31,696 --> 00:15:36,176
and we're going to introduce
a little science, too.


313
00:15:36,396 --> 00:15:36,996
>> Check this out.


314
00:15:36,996 --> 00:15:38,686
Steve's about to
do some real magic.


315
00:15:39,496 --> 00:15:40,256
>> Science, man.


316
00:15:44,056 --> 00:15:46,646
Alright. We're going to
switch back to our demo app,


317
00:15:46,646 --> 00:15:47,546
which we showed before.


318
00:15:48,046 --> 00:15:53,036
OK. So here's the demo app
we've been looking at so far,


319
00:15:53,036 --> 00:15:55,326
but we've hidden this really
great feature we call the


320
00:15:55,326 --> 00:15:56,246
science panel.


321
00:15:56,866 --> 00:15:58,456
Alright, so I'm going
to turn that on now.


322
00:15:59,436 --> 00:16:02,506
OK. So we have these two
distinct regions, right.


323
00:16:02,506 --> 00:16:03,516
We've got that red zone.


324
00:16:03,516 --> 00:16:05,406
That's the one star bad
zone, and then we've got


325
00:16:05,406 --> 00:16:07,316
that nice fat green
zone at the bottom


326
00:16:07,576 --> 00:16:10,436
where we get the super
smooth scrolling performance.


327
00:16:11,396 --> 00:16:13,226
So what I'm going to do
now is I'm going to run


328
00:16:13,226 --> 00:16:17,466
through with the iOS 9 version
of the app, and I'm going


329
00:16:17,466 --> 00:16:20,466
to play back a scrolling
session that I recorded earlier


330
00:16:20,466 --> 00:16:22,936
to show you what this looks
like and do the science.


331
00:16:24,126 --> 00:16:25,116
OK. So here we go.


332
00:16:26,196 --> 00:16:28,176
Scrolling along,
doing our science.


333
00:16:29,586 --> 00:16:30,106
Chop, chop.


334
00:16:30,106 --> 00:16:32,456
OK. What do we have here?


335
00:16:33,446 --> 00:16:34,696
So check out this graph.


336
00:16:35,166 --> 00:16:37,256
We got eight visits
up into that red zone.


337
00:16:37,716 --> 00:16:38,836
Eight dropped frames.


338
00:16:40,076 --> 00:16:42,526
But also we can see that
we've got these long periods


339
00:16:42,526 --> 00:16:44,176
of quiescence like we
talked about earlier.


340
00:16:44,846 --> 00:16:47,136
So the area on the graph
is this big spiky thing,


341
00:16:47,136 --> 00:16:48,916
and then going back
down to the valley.


342
00:16:49,456 --> 00:16:50,986
Let's see what this
looks like in iOS X.


343
00:16:51,396 --> 00:16:55,656
OK. I'm going to switch
back to that iOS X mode


344
00:16:55,656 --> 00:16:57,896
that Peter was talking about
earlier, and now I'm going


345
00:16:57,896 --> 00:17:01,496
to playback that same scrolling
session with [inaudible].


346
00:17:01,596 --> 00:17:02,186
Check it out, Peter.


347
00:17:02,186 --> 00:17:03,666
>> It's a lot smoother, Steve.


348
00:17:03,666 --> 00:17:05,026
>> Yeah, that definitely
looks better.


349
00:17:05,606 --> 00:17:06,626
See what we get.


350
00:17:07,116 --> 00:17:08,185
Hey, look at that.


351
00:17:08,626 --> 00:17:09,776
No missed frames.


352
00:17:13,205 --> 00:17:13,646
Pretty great.


353
00:17:16,106 --> 00:17:18,016
Now check out what we've
got under the curve


354
00:17:18,016 --> 00:17:19,386
on this particular graph.


355
00:17:19,866 --> 00:17:22,646
Instead of those peaks way up in
the air and the quiet periods,


356
00:17:22,945 --> 00:17:24,406
we've blended those together,


357
00:17:24,406 --> 00:17:26,276
and now we have this
smooth amount of work


358
00:17:26,576 --> 00:17:29,276
that makes your app much more
responsive on the main thread.


359
00:17:29,986 --> 00:17:32,286
OK. You ready for this, Peter?


360
00:17:32,766 --> 00:17:33,456
>> I'm set.


361
00:17:33,456 --> 00:17:34,256
>> Let's do it.


362
00:17:35,216 --> 00:17:38,136
OK. So now we're going to
look at the iOS X version,


363
00:17:38,136 --> 00:17:40,046
but we're going to have
the API, pre-fetch API's


364
00:17:40,046 --> 00:17:41,876
that Peter talked about earlier.


365
00:17:41,876 --> 00:17:43,806
We're going to adopt
those in this application.


366
00:17:44,056 --> 00:17:46,396
Alright. So I'm all
set in the demo app.


367
00:17:46,596 --> 00:17:48,596
I'm going to play back that
same scrolling session.


368
00:17:49,616 --> 00:17:50,816
Whoa, Peter, look at that.


369
00:17:50,816 --> 00:17:51,956
>> Now that's butter, Steve.


370
00:17:52,046 --> 00:17:52,816
>> That's looking pretty good.


371
00:17:53,806 --> 00:17:54,476
Five stars.


372
00:17:54,506 --> 00:17:56,976
And the science agrees.


373
00:17:57,516 --> 00:18:03,586
[ Applause ]


374
00:18:04,086 --> 00:18:06,716
OK. So, but, Peter, something's
different here, right.


375
00:18:06,716 --> 00:18:09,906
The area on the curve between
this main queue activity


376
00:18:10,206 --> 00:18:11,776
and the prior version
don't match.


377
00:18:11,776 --> 00:18:12,596
This is a lot lower.


378
00:18:12,596 --> 00:18:13,376
What's going on here?


379
00:18:14,066 --> 00:18:17,176
>> So if we're adopting the
pre-fetch API correctly,


380
00:18:17,486 --> 00:18:19,516
we're probably moving
that data model read


381
00:18:19,676 --> 00:18:22,306
onto a background queue
to free up the main queue.


382
00:18:23,256 --> 00:18:24,106
>> That's exactly right.


383
00:18:24,986 --> 00:18:25,796
That's what's going on.


384
00:18:25,796 --> 00:18:28,136
So now we've moved all that
work onto a background queue,


385
00:18:28,276 --> 00:18:30,906
and we no longer have to
clutter up the main thread.


386
00:18:31,426 --> 00:18:32,726
Let's switch back the slides.


387
00:18:39,696 --> 00:18:41,486
So next I'd like to
talk a little bit


388
00:18:41,486 --> 00:18:45,106
about some pre-fetching API tips
to make your apps adopt this API


389
00:18:45,106 --> 00:18:47,046
in the best possible way.


390
00:18:48,176 --> 00:18:51,066
The first, when you
get the pre-fetch call,


391
00:18:51,186 --> 00:18:52,546
you want to make sure
you do all the work


392
00:18:52,546 --> 00:18:54,116
on the background
[inaudible] right away.


393
00:18:54,276 --> 00:18:57,026
Now we've got two great
technologies for this:


394
00:18:57,346 --> 00:18:59,966
GCD and NSOperationQueue.


395
00:19:00,466 --> 00:19:05,196
Now it's also important
to remember


396
00:19:05,196 --> 00:19:07,666
that pre-fetch is an
adaptive technology.


397
00:19:07,666 --> 00:19:09,656
Now what do I mean by
adaptive technology?


398
00:19:10,276 --> 00:19:12,876
Well, remember when we talked
about those quiet periods


399
00:19:12,876 --> 00:19:14,706
and how pre-fetch takes
advantage of those


400
00:19:14,966 --> 00:19:16,066
by doing additional work.


401
00:19:17,316 --> 00:19:19,136
There are times in
an application


402
00:19:19,396 --> 00:19:21,256
where the user's
scrolling so fast


403
00:19:21,296 --> 00:19:22,696
that there's no quiet times.


404
00:19:23,216 --> 00:19:24,526
During these times when we have


405
00:19:24,526 --> 00:19:25,916
to update the display
very often,


406
00:19:25,986 --> 00:19:29,296
we will not do pre-fetching.


407
00:19:30,796 --> 00:19:34,456
[Inaudible] And, finally,
use the cancelPrefetchingAPI


408
00:19:34,456 --> 00:19:36,906
to adapt to your
user's shifting focus.


409
00:19:37,046 --> 00:19:39,196
Now it's possible that
the user is moving


410
00:19:39,196 --> 00:19:41,216
up in their CollectionView,
and they're scrolling along


411
00:19:41,216 --> 00:19:43,016
with the content, but then
they change their mind


412
00:19:43,016 --> 00:19:44,066
and move in another direction.


413
00:19:44,676 --> 00:19:47,216
We will notify you of this
event with a cancel message


414
00:19:47,536 --> 00:19:50,496
so you can deprioritize
those prior ones and focus


415
00:19:50,496 --> 00:19:54,636
on the new content that
the views are scrolling to.


416
00:19:54,866 --> 00:19:57,126
>> So this is really
great for CollectionView.


417
00:19:57,626 --> 00:20:01,026
By doing no work at all, you get
better scrolling performance,


418
00:20:01,266 --> 00:20:03,136
and by doing just a
little bit of work


419
00:20:03,436 --> 00:20:05,486
and using the classes
you've already written,


420
00:20:05,696 --> 00:20:07,646
you get even better
scrolling performance.


421
00:20:08,166 --> 00:20:10,546
And if you're using
UITableView, don't worry.


422
00:20:10,586 --> 00:20:11,556
You're not chopped liver.


423
00:20:11,936 --> 00:20:14,676
We've brought the exact
same API to TableView, too.


424
00:20:15,516 --> 00:20:21,646
[ Applause ]


425
00:20:22,146 --> 00:20:26,206
It's got a very similar optional
pre-fetch data source companion


426
00:20:26,206 --> 00:20:30,456
object with a similar
required method, just one.


427
00:20:31,336 --> 00:20:34,216
TableView prefetchRowsAt
indexPaths.


428
00:20:34,776 --> 00:20:39,226
Again, index paths is an array
ordered by their proximity


429
00:20:39,226 --> 00:20:40,986
to the table's visible area.


430
00:20:41,416 --> 00:20:43,926
So earlier index paths
are coming up sooner.


431
00:20:44,786 --> 00:20:46,296
Just like with the
CollectionView API,


432
00:20:46,296 --> 00:20:50,656
you can use this to inform your
asynchronous data model reads.


433
00:20:51,246 --> 00:20:54,776
And it's got that same second
optional delegate method.


434
00:20:55,596 --> 00:20:58,216
TableView
cancelPrefetchingForRowsAt


435
00:20:58,216 --> 00:20:58,886
indexPaths.


436
00:20:59,006 --> 00:21:02,896
As Steve just mentioned to
you earlier, you can use this


437
00:21:03,136 --> 00:21:07,646
to cancel or deprioritize
any pending data model loads.


438
00:21:08,516 --> 00:21:10,256
And this is what's really great.


439
00:21:10,716 --> 00:21:12,626
Just like with the
CollectionView API,


440
00:21:13,136 --> 00:21:16,116
this works alongside your
existing asynchronous


441
00:21:16,116 --> 00:21:16,976
model solution.


442
00:21:17,426 --> 00:21:18,836
You don't have to
throw anything away.


443
00:21:19,216 --> 00:21:22,776
Instead, use this to inform the
loads that you're already doing.


444
00:21:23,376 --> 00:21:25,976
So that's it for cell
pre-fetching in iOS X.


445
00:21:26,516 --> 00:21:32,016
[ Applause ]


446
00:21:32,516 --> 00:21:34,626
>> So we're really excited about
bringing this technology, guys.


447
00:21:34,626 --> 00:21:36,356
I mean, we can't wait
to see the actual build


448
00:21:36,356 --> 00:21:37,876
with the smoother
scrolling experience.


449
00:21:37,876 --> 00:21:41,896
So next up, we're going
to talk a little bit


450
00:21:41,896 --> 00:21:45,286
about improvements we've made
this year to self-sizing cells.


451
00:21:45,996 --> 00:21:47,946
This API was introduced in iOS 8


452
00:21:47,946 --> 00:21:50,046
and we're bringing some
additional enhancements this


453
00:21:50,046 --> 00:21:52,616
year to make it easier
to adopt in your apps.


454
00:21:53,546 --> 00:21:55,496
Now, before we get
into this, I want to go


455
00:21:55,496 --> 00:22:00,966
over the existing API,
chat a little bit about it.


456
00:22:01,206 --> 00:22:04,246
So we shift a concrete
layout class


457
00:22:04,246 --> 00:22:07,256
in CollectionView called
UICollectionViewFlowLayout,


458
00:22:07,256 --> 00:22:08,976
and we have full support


459
00:22:08,976 --> 00:22:10,946
for self-sizing cells
with this class.


460
00:22:11,996 --> 00:22:15,366
To enable this, we just need
to set estimated item size


461
00:22:15,366 --> 00:22:18,806
to some non-zero CG size,
and this tells Collection


462
00:22:18,806 --> 00:22:21,886
that you want to, you want to
calculate the layout dynamically


463
00:22:21,946 --> 00:22:23,416
as content is displayed.


464
00:22:23,416 --> 00:22:27,876
Now as far as getting the
actual sizes of your cells,


465
00:22:27,876 --> 00:22:30,026
there's three different
methods for doing this.


466
00:22:30,966 --> 00:22:33,136
The first method is
using auto layout.


467
00:22:33,136 --> 00:22:37,346
If you can fully constrain the
content view of your hierarchy


468
00:22:37,346 --> 00:22:39,376
to the content view of
the CollectionView cell,


469
00:22:39,746 --> 00:22:41,836
we'll ask the auto
layout system how large


470
00:22:41,836 --> 00:22:44,226
that cell should be
and use that value.


471
00:22:44,336 --> 00:22:47,356
Now if you don't
use auto layout,


472
00:22:47,356 --> 00:22:51,816
or you need more manual control,
you can override sizeThatFits.


473
00:22:52,326 --> 00:22:55,646
And, finally, for
the ultimate control,


474
00:22:56,166 --> 00:22:58,296
you can override
preferredLayoutAttributes


475
00:22:58,516 --> 00:23:01,566
FittingAttributes, and provide
not only the size information


476
00:23:01,796 --> 00:23:03,206
but also you can
tweak the attributes


477
00:23:03,206 --> 00:23:04,826
like alpha and transform.


478
00:23:06,216 --> 00:23:08,836
>> So specifying the
cell size using one


479
00:23:08,836 --> 00:23:11,326
of these three mechanisms,
it's pretty easy.


480
00:23:11,806 --> 00:23:14,816
Most apps will use auto layout,
but for those that don't,


481
00:23:14,816 --> 00:23:16,746
they can take on
more manual control


482
00:23:16,976 --> 00:23:18,476
with the second two
mechanisms there.


483
00:23:19,266 --> 00:23:22,186
But we found that
for types of layouts,


484
00:23:22,576 --> 00:23:24,956
picking a good estimated
item size turns


485
00:23:24,956 --> 00:23:26,406
out to be really challenging


486
00:23:27,026 --> 00:23:29,056
because sometimes it's
just hard to guess.


487
00:23:30,006 --> 00:23:32,086
I mean, sometimes
what do you use?


488
00:23:32,336 --> 00:23:35,216
50 by 50, 100 by 100, even more.


489
00:23:35,446 --> 00:23:36,376
It's hard to say.


490
00:23:37,386 --> 00:23:40,966
For these types of layouts,
what would be really cool is


491
00:23:40,966 --> 00:23:45,006
if flow layout could adapt
its estimate and do the math


492
00:23:45,006 --> 00:23:48,706
on your behalf and instead
compute that estimated size


493
00:23:48,886 --> 00:23:51,746
from actual sizes of
content that we've sized.


494
00:23:53,016 --> 00:23:56,596
So in iOS X, we've got new
API on flow layout to do that.


495
00:23:57,866 --> 00:24:01,016
All you have to do is set your
flow layout.EstimatedItemSize


496
00:24:01,016 --> 00:24:01,916
to a new constant,


497
00:24:02,356 --> 00:24:05,386
UICollectionViewFlowLayout
AutomaticSize.


498
00:24:11,836 --> 00:24:15,266
By setting your estimated
item size to automatic size,


499
00:24:15,546 --> 00:24:17,626
you'll indicate to the
CollectionViewFlowLayout


500
00:24:17,776 --> 00:24:19,296
that it should do
the math for you.


501
00:24:19,806 --> 00:24:22,376
It'll keep a running
tally of all the cells


502
00:24:22,376 --> 00:24:24,416
that it's already sized, and use


503
00:24:24,416 --> 00:24:27,486
that to influence its
future sizing estimates.


504
00:24:28,106 --> 00:24:29,106
As we'll see in a minute,


505
00:24:29,506 --> 00:24:32,576
this makes the flow layout much
more accurate while it's sizing


506
00:24:32,576 --> 00:24:35,346
your CollectionView cells
leading to better performance


507
00:24:35,476 --> 00:24:38,006
and a more accurate
layout while we're sizing.


508
00:24:38,746 --> 00:24:42,276
So we're going to do a demo
to show you the benefits


509
00:24:42,276 --> 00:24:45,566
of UICollectionViewFlowLayout
automatic size.


510
00:24:50,196 --> 00:24:51,966
So I'm going to switch
back to the iPad.


511
00:25:00,096 --> 00:25:02,956
Now here we've got a
CollectionView using a


512
00:25:02,956 --> 00:25:03,496
flow layout.


513
00:25:04,186 --> 00:25:07,556
Each cell represents a
word in a run of text.


514
00:25:08,476 --> 00:25:10,436
Just to clarify,
we're not recommending


515
00:25:10,436 --> 00:25:13,516
that you build a text viewer or
editor using UICollectionView,


516
00:25:14,376 --> 00:25:15,906
but this does make
a really good demo.


517
00:25:17,106 --> 00:25:18,976
I'm going to put
the app into a mode


518
00:25:19,396 --> 00:25:21,746
where we can watch
the flow layout


519
00:25:21,746 --> 00:25:24,086
as it sizes each
individual cell.


520
00:25:24,836 --> 00:25:27,626
No user would ever see
this, but it's really great


521
00:25:27,626 --> 00:25:30,436
for visualizing the
advantages of this new API.


522
00:25:31,376 --> 00:25:33,786
Let's start out with
fixed estimates


523
00:25:33,906 --> 00:25:35,516
like we'd use on iOS 9.


524
00:25:35,516 --> 00:25:37,646
So I'm going to turn
on the simulation.


525
00:25:38,936 --> 00:25:41,786
Here, you can see that
we've seeded each cell


526
00:25:41,946 --> 00:25:45,616
with that initial estimated
item size where we just guessed.


527
00:25:45,616 --> 00:25:50,426
And I'm going to size the first
word in this run of text, Lorem,


528
00:25:51,026 --> 00:25:52,066
and watch what happens.


529
00:25:54,276 --> 00:25:57,726
So we size Lorem, and now
it's the correct size,


530
00:25:58,056 --> 00:26:01,316
but notice the CollectionView
is really no closer


531
00:26:01,316 --> 00:26:03,846
to what its destination
layout size will be.


532
00:26:04,396 --> 00:26:07,246
We didn't use that estimate
to influence anything else,


533
00:26:07,616 --> 00:26:10,576
and everything else is still
this large initial estimate


534
00:26:10,576 --> 00:26:11,306
that we passed in.


535
00:26:11,836 --> 00:26:17,376
Now this continues as we
size each cell individually


536
00:26:17,576 --> 00:26:18,416
in this CollectionView.


537
00:26:19,786 --> 00:26:23,126
Notice how we're not actually
adopting, adapting any


538
00:26:23,126 --> 00:26:25,736
of the other cell sizes
to account for the sizes


539
00:26:25,736 --> 00:26:26,876
that we've already computed.


540
00:26:27,766 --> 00:26:31,066
This is especially obvious
when we size the last word


541
00:26:31,066 --> 00:26:35,336
in this run of text, Fusce,
and as we go to size this word,


542
00:26:36,516 --> 00:26:39,396
you'll notice that we slide
up all the other cells,


543
00:26:39,396 --> 00:26:41,096
invalidating their y-positions,


544
00:26:42,026 --> 00:26:44,556
and we haven't used the
information from that first line


545
00:26:44,556 --> 00:26:48,276
of text to influence the sizes
of any of the other cells.


546
00:26:49,536 --> 00:26:51,066
So now I'm going
to turn the device


547
00:26:51,096 --> 00:26:55,386
into iOS X mode using
UICollectionViewFlowLayout


548
00:26:55,826 --> 00:26:56,726
automatic size.


549
00:26:56,726 --> 00:26:58,136
So let's switch over.


550
00:26:59,396 --> 00:27:00,136e
OK, great.


551
00:26:59,396 --> 00:27:00,136
OK, great.


552
00:27:00,206 --> 00:27:02,896
So we've seeded this with
the same initial size


553
00:27:03,236 --> 00:27:04,796
to help you visualize
the difference.


554
00:27:05,516 --> 00:27:07,826
I'm going to size the
first word, Lorem,


555
00:27:08,246 --> 00:27:09,526
and watch what happens.


556
00:27:10,836 --> 00:27:15,816
Wow. So we size that first
cell, and use that cell size


557
00:27:16,126 --> 00:27:19,456
as a running estimate for all
the other CollectionView cells.


558
00:27:20,076 --> 00:27:22,216
Now the layout's not
totally accurate yet,


559
00:27:22,676 --> 00:27:25,626
but notice how it's a lot closer
to what it will eventually be.


560
00:27:26,046 --> 00:27:27,366
In fact, the heights


561
00:27:27,366 --> 00:27:29,736
in y-positions are
pretty much spot on.


562
00:27:30,636 --> 00:27:34,346
And notice that as I size this
run of text, we're adapting


563
00:27:34,346 --> 00:27:37,426
that estimated size, making
it more and more accurate


564
00:27:37,806 --> 00:27:39,896
for your CollectionView
cells holistically.


565
00:27:41,796 --> 00:27:44,896
And notice when we size the
last word in this run of text,


566
00:27:45,756 --> 00:27:47,996
we're no longer invalidating
the y-positions


567
00:27:48,096 --> 00:27:49,506
of all the other cells.


568
00:27:49,936 --> 00:27:52,436
This is really great
and can help out a lot


569
00:27:52,436 --> 00:27:55,296
when you're doing things like
scrollToItemAt indexPath.


570
00:27:55,796 --> 00:27:59,616
Now due to the nature of this
API, you'll get the most bang


571
00:27:59,616 --> 00:28:01,796
for your buck using
automatic size


572
00:28:02,266 --> 00:28:05,376
if your cells have
similar widths or heights.


573
00:28:06,046 --> 00:28:08,636
So that's it for self-sizing
improvements in iOS X.


574
00:28:08,636 --> 00:28:09,976
Let's go back to slides.


575
00:28:10,516 --> 00:28:15,596
[ Applause ]


576
00:28:16,096 --> 00:28:20,586
So that wraps up our
self-sizing cell segment,


577
00:28:20,586 --> 00:28:22,176
and now we're going
to talk a little bit


578
00:28:22,176 --> 00:28:26,336
about an API we introduced last
year, interactive reordering.


579
00:28:27,716 --> 00:28:30,126
Now, this is a familiar
user experience


580
00:28:30,126 --> 00:28:31,646
to users of TableView cells.


581
00:28:31,646 --> 00:28:34,886
They like to, users might grab
a piece of content and move it


582
00:28:34,886 --> 00:28:37,586
and rearrange it
vertically in your TableView.


583
00:28:38,066 --> 00:28:41,036
So we brought this technology
to CollectionView last year


584
00:28:41,356 --> 00:28:43,226
with a new interactive
reordering API.


585
00:28:43,646 --> 00:28:44,956
Let's run back over to the iPad


586
00:28:44,956 --> 00:28:46,966
and see what this might
look like in the demo.


587
00:28:57,296 --> 00:28:58,656
Switch back over to the iPad.


588
00:28:58,846 --> 00:28:59,236
>> Alright.


589
00:28:59,236 --> 00:28:59,656
>> Here we are.


590
00:29:00,316 --> 00:29:03,026
OK. So we've got this really
pretty looking custom layout.


591
00:29:03,026 --> 00:29:05,766
Oh, man, look at
that scroll, Peter.


592
00:29:05,766 --> 00:29:08,196
>> We probably adapted
pre-fetching,


593
00:29:08,236 --> 00:29:09,256
which is really easy.


594
00:29:09,476 --> 00:29:10,316
>> That's probably it.


595
00:29:10,636 --> 00:29:11,666
OK. So check it out.


596
00:29:11,666 --> 00:29:13,766
So let's say the user
loves this content,


597
00:29:13,766 --> 00:29:14,916
but they want to rearrange it.


598
00:29:15,346 --> 00:29:18,986
Might drag their finger around
and move the content smoothly


599
00:29:18,986 --> 00:29:20,116
around the CollectionView,


600
00:29:20,116 --> 00:29:22,396
and notice how it
reflows automatically.


601
00:29:22,456 --> 00:29:24,846
And not only that, if
we change to an item


602
00:29:24,846 --> 00:29:27,416
that has a different
size, let's you be able


603
00:29:27,416 --> 00:29:27,986
to do the right thing.


604
00:29:28,466 --> 00:29:31,286
Now when the user's done
reordering, they might let go.


605
00:29:31,686 --> 00:29:34,246
Smoothly animates into
place, and that's it.


606
00:29:35,066 --> 00:29:37,056
Let's switch back to slides, and
let Peter go through that API.


607
00:29:37,056 --> 00:29:41,586
>> So that's interactive
reordering as it existed


608
00:29:41,586 --> 00:29:44,896
on iOS 9, and this
API is really simple.


609
00:29:46,266 --> 00:29:48,606
To start an interactive
movement, you're going


610
00:29:48,606 --> 00:29:51,066
to call CollectionViews
beginInteractive


611
00:29:51,066 --> 00:29:53,056
MovementForItemat indexPath


612
00:29:53,696 --> 00:29:57,366
where index path represents
the index path of the cell


613
00:29:57,536 --> 00:29:58,796
that we'd like to move around.


614
00:29:59,626 --> 00:30:01,616
If you're doing this in
response to a gesture,


615
00:30:01,946 --> 00:30:05,866
you can hit test the
CollectionView using index path


616
00:30:06,126 --> 00:30:07,216
for item at location.


617
00:30:08,056 --> 00:30:11,536
Next, each time the gesture
updates, we're going to want


618
00:30:11,536 --> 00:30:14,786
to update the cell's position
in response to our finger.


619
00:30:15,136 --> 00:30:18,116
For this, we're going to call
updateInteractiveMovement


620
00:30:18,506 --> 00:30:19,386
TargetPosition.


621
00:30:20,006 --> 00:30:22,016
Passing in the location
of the gesture


622
00:30:22,196 --> 00:30:24,096
in the CollectionView's
coordinate space.


623
00:30:24,506 --> 00:30:28,766
Next, when we'd like to end
the interactive movement


624
00:30:28,946 --> 00:30:30,216
and confirm the reorder,


625
00:30:30,526 --> 00:30:33,066
we're going to call
endInteractiveMovement


626
00:30:33,066 --> 00:30:33,896
on the CollectionView.


627
00:30:35,136 --> 00:30:37,346
CollectionView will
put the cell down,


628
00:30:37,626 --> 00:30:39,676
handling all the layout
attributes correctly,


629
00:30:40,016 --> 00:30:42,336
and then message back to
your app's data source


630
00:30:42,406 --> 00:30:45,416
so that you could do the
actual rearrange in your model.


631
00:30:47,136 --> 00:30:49,836
Now, if the gesture cancels,


632
00:30:49,836 --> 00:30:52,126
or if you'd like to not allow
reordering at this time,


633
00:30:52,626 --> 00:30:55,606
you can call CollectionView's
cancelInteractiveMovement.


634
00:30:56,396 --> 00:30:58,876
Here, we'll put everything
back to where it was before,


635
00:30:59,446 --> 00:31:01,326
and we won't call
your data source.


636
00:31:02,396 --> 00:31:05,306
Now for those of you using
UICollectionViewController,


637
00:31:05,696 --> 00:31:07,576
this is even easier
for you to use.


638
00:31:08,296 --> 00:31:10,686
You just have to set the
install standard gesture


639
00:31:10,686 --> 00:31:13,266
for interactive movement
property to true,


640
00:31:14,016 --> 00:31:16,826
and CollectionViewController
will add a gesture


641
00:31:16,936 --> 00:31:19,816
that will call these
methods on your behalf.


642
00:31:20,126 --> 00:31:23,106
All you have to do is
implement the data source parts.


643
00:31:23,436 --> 00:31:27,896
>> So that's the API that we
shipped last year in iOS 9.


644
00:31:29,266 --> 00:31:31,476
This year we're very proud
to announce we're going


645
00:31:31,476 --> 00:31:33,276
to add paging support to this.


646
00:31:33,326 --> 00:31:37,216
Now there's no new API, which
is the best kind of API,


647
00:31:37,216 --> 00:31:39,976
and since CollectionView is
derived from UIScrollView,


648
00:31:40,426 --> 00:31:44,346
all you need to do is set
the isPagingEnabled property


649
00:31:44,346 --> 00:31:46,776
of the ScrollView's
inheritive property to true,


650
00:31:46,776 --> 00:31:48,446
and that'll enable the support.


651
00:31:48,446 --> 00:31:51,026
Let's switch back to the iPad
and check this out in a demo.


652
00:31:52,036 --> 00:31:53,846
>> And here, we've
got a horizontal


653
00:31:53,846 --> 00:31:55,326
scrolling CollectionView.


654
00:31:56,496 --> 00:31:59,006
This is currently
not using paging.


655
00:31:59,006 --> 00:32:00,636
It's just continuous, and look


656
00:32:00,636 --> 00:32:02,706
at that smooth scrolling
performance.


657
00:32:02,706 --> 00:32:04,086
>> Hey, hey.


658
00:32:04,286 --> 00:32:07,916
>> So in reordering when
we're scrolling continuously,


659
00:32:08,556 --> 00:32:11,326
we pick up the CollectionView
cell and move it to the edge


660
00:32:11,326 --> 00:32:14,656
of the screen, and then we
get this really nice auto


661
00:32:14,656 --> 00:32:15,516
scrolling behavior.


662
00:32:15,866 --> 00:32:17,816
This is familiar to users


663
00:32:17,946 --> 00:32:19,866
of many CollectionView
based applications.


664
00:32:19,866 --> 00:32:24,496
Now I'm going to turn on
paging support, and we'll see


665
00:32:24,496 --> 00:32:27,746
that CollectionView now advances
in page size increments.


666
00:32:28,236 --> 00:32:31,296
This is really natural for
some types of CollectionViews.


667
00:32:31,906 --> 00:32:33,086
Now here's what's new.


668
00:32:34,176 --> 00:32:35,916
We're calling the
same reordering API,


669
00:32:36,586 --> 00:32:38,006
but new in iOS X,


670
00:32:38,006 --> 00:32:41,006
that reordering works
alongside paging.


671
00:32:41,676 --> 00:32:43,996
So as I move my cell to
the edge of the screen,


672
00:32:44,496 --> 00:32:49,516
we're going to automatically
scroll in page size increments.


673
00:32:50,846 --> 00:32:53,546
This can give your app a
really home screen style


674
00:32:53,546 --> 00:32:54,736
reordering experience.


675
00:32:54,966 --> 00:32:56,876
I'm going to let
go, and that's it.


676
00:32:57,516 --> 00:33:03,306
[ Applause ]


677
00:33:03,806 --> 00:33:04,946
Let's go back to slides.


678
00:33:10,696 --> 00:33:12,476
>> So they're a little
[inaudible].


679
00:33:12,636 --> 00:33:15,816
So while we were developing
iOS X in the early phases,


680
00:33:16,246 --> 00:33:19,096
Pete would often come to my
office very enthusiastic.


681
00:33:19,856 --> 00:33:22,006
"Steve, I'm working
on this great feature.


682
00:33:22,006 --> 00:33:23,796
Developers are going to flip."


683
00:33:24,286 --> 00:33:24,846
He's like that.


684
00:33:25,316 --> 00:33:27,856
And I agree, it's
a great feature.


685
00:33:27,856 --> 00:33:29,736
I can't wait to show it
to developers everywhere.


686
00:33:30,536 --> 00:33:33,996
So during the run up to WWDC,
now he's looking for a place


687
00:33:33,996 --> 00:33:36,696
to land this particular
slide so we can talk about it


688
00:33:36,696 --> 00:33:37,566
and share it to people.


689
00:33:38,636 --> 00:33:40,396
So even a couple days ago,


690
00:33:40,546 --> 00:33:42,366
he made the pitch again,
"We've got to do it."


691
00:33:43,076 --> 00:33:44,206
So I said, "OK, fine."


692
00:33:44,766 --> 00:33:47,096
Two slides, ninety
seconds, Peter.


693
00:33:47,336 --> 00:33:48,466
Can you get it done?


694
00:33:48,466 --> 00:33:49,076
>> Thanks, Steve.


695
00:33:49,076 --> 00:33:50,216
It'll just take a minute.


696
00:33:50,736 --> 00:33:53,816
Another feature that I'm
really excited about that's new


697
00:33:53,816 --> 00:33:57,376
in CollectionView in iOS
X is UIRefreshControl!


698
00:33:58,026 --> 00:33:58,676
That's right!


699
00:33:58,716 --> 00:34:01,726
UIRefreshControl is now
directly supported inside


700
00:34:01,726 --> 00:34:02,456
of CollectionView.


701
00:34:05,866 --> 00:34:08,956
But not only that, it's also
directly supported inside


702
00:34:08,956 --> 00:34:12,346
of UITableView without
using UITableViewController!


703
00:34:12,346 --> 00:34:16,446
And not only that, it's also
supported inside of UIScrollView


704
00:34:16,616 --> 00:34:19,795
because RefreshControl is now
just a ScrollView property!


705
00:34:21,545 --> 00:34:27,436
It's really easy to use, too.


706
00:34:27,916 --> 00:34:30,795
All you have to use, do is
create the RefreshControl,


707
00:34:31,496 --> 00:34:33,876
add yourself as a target
to it with an action,


708
00:34:34,436 --> 00:34:35,835
and set it on your
CollectionView,


709
00:34:36,106 --> 00:34:38,416
and you'll be pulling
to refresh in no time.


710
00:34:38,726 --> 00:34:39,556
Thanks a lot, Steve.


711
00:34:39,556 --> 00:34:40,246
It means a lot to me.


712
00:34:40,246 --> 00:34:40,976
>> Hey, great job.


713
00:34:41,686 --> 00:34:42,106
Great job.


714
00:34:42,106 --> 00:34:48,726
It's like the summarizer
we talked about today.


715
00:34:48,726 --> 00:34:51,166
We went over the brand
new UICollectionView cell


716
00:34:51,166 --> 00:34:53,226
pre-fetching stuff,
and we can't wait


717
00:34:53,226 --> 00:34:55,235
to see what you guys are going
to do in your apps with this.


718
00:34:55,775 --> 00:34:58,846
And then we covered the new
pre-fetch data source API


719
00:34:58,846 --> 00:35:00,866
for Collection and TableView.


720
00:35:02,416 --> 00:35:04,066
Next, we covered
the improvements


721
00:35:04,066 --> 00:35:07,226
to self-sizing cells with the
new automatic size constant.


722
00:35:07,706 --> 00:35:10,116
And then we chatted a little bit


723
00:35:10,116 --> 00:35:13,196
about the iOS 9 introduced
API interactive reordering


724
00:35:13,196 --> 00:35:16,526
and the new paging
support we have in iOS X.


725
00:35:17,196 --> 00:35:19,506
You want to check out the
sample code and other resources


726
00:35:19,506 --> 00:35:22,476
for this app, for this session,
we can see the address there


727
00:35:22,476 --> 00:35:24,046
on the developer website.


728
00:35:24,756 --> 00:35:26,706
We got some great
related sessions


729
00:35:26,706 --> 00:35:27,626
with these technologies
[inaudible].


730
00:35:27,626 --> 00:35:29,896
We want to thank you
very much for coming out.


731
00:35:29,896 --> 00:35:30,536
Have a great --


732
00:35:30,676 --> 00:35:31,446
>> Thank you so much.

