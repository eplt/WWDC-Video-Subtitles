1
00:00:20,053 --> 00:00:22,823
Metal技术最新内容 第一部分


2
00:00:31,064 --> 00:00:31,899
下午好


3
00:00:32,499 --> 00:00:33,867
欢迎来到WWDC 2015


4
00:00:40,040 --> 00:00:40,874
欢迎参加


5
00:00:40,941 --> 00:00:42,843
《Metal技术最新内容》
讲座的上半场


6
00:00:44,411 --> 00:00:46,914
本周的三次讲座中


7
00:00:46,980 --> 00:00:48,482
有许多Metal的内容


8
00:00:49,550 --> 00:00:51,919
实际上 我们已经
在API中加入很多新内容


9
00:00:51,985 --> 00:00:54,288
所以决定要把
《Metal技术的最新内容》


10
00:00:54,354 --> 00:00:56,456
讲座分为两部分


11
00:00:58,258 --> 00:00:59,293
那么今天


12
00:00:59,359 --> 00:01:01,929
我主要
对过去12个月的Metal


13
00:01:02,196 --> 00:01:05,331
生态系统进行
扼要回顾


14
00:01:06,466 --> 00:01:09,536
像诸位这样的开发人员
已经运用Metal


15
00:01:09,603 --> 00:01:10,904
创造了很多应用


16
00:01:12,639 --> 00:01:14,541
我会介绍我们
今年推出的


17
00:01:14,842 --> 00:01:16,076
部分新功能


18
00:01:16,910 --> 00:01:18,912
最后 我们会
通过具体实例


19
00:01:19,213 --> 00:01:21,048
介绍
app瘦身技术


20
00:01:21,181 --> 00:01:22,349
将Metal如何与


21
00:01:22,749 --> 00:01:25,352
系统的其他部分
相整合


22
00:01:28,589 --> 00:01:30,691
在下半场《Metal
技术最新内容》讲座中


23
00:01:30,757 --> 00:01:32,960
丹·大汀和安娜·蒂科诺娃


24
00:01:33,026 --> 00:01:34,361
将详细介绍今年


25
00:01:34,661 --> 00:01:36,763
我们用Metal新推出的


26
00:01:36,830 --> 00:01:38,699
一款非常棒的支持库


27
00:01:39,666 --> 00:01:41,535
或是两个
这样的支持库


28
00:01:42,503 --> 00:01:45,906
MetalKit可为API
提供便捷


29
00:01:45,973 --> 00:01:48,575
让你可以生成出色的
Metal应用


30
00:01:49,576 --> 00:01:51,945
和MetalPerformance
Shaders


31
00:01:52,279 --> 00:01:54,715
我们高度优化的着色器库


32
00:01:55,082 --> 00:01:57,885
可以直接从
应用调用


33
00:02:00,754 --> 00:02:02,923
最后 在后一场讲座中


34
00:02:02,990 --> 00:02:03,924
菲尔·贝内特


35
00:02:03,991 --> 00:02:07,327
会深入介绍利用...
Metal应用


36
00:02:07,528 --> 00:02:10,097
实现
可能的最好


37
00:02:10,330 --> 00:02:11,698
表现的出色技巧


38
00:02:12,999 --> 00:02:14,768
在本次讲座中


39
00:02:14,835 --> 00:02:18,839
我们将
介绍最新GPU


40
00:02:19,072 --> 00:02:21,375
System Trace工具
所以一定要看看


41
00:02:25,879 --> 00:02:27,281
去年的WWDC上


42
00:02:27,347 --> 00:02:29,716
我们介绍了
iOS 8的Metal技术


43
00:02:31,518 --> 00:02:34,588
目标是
图形的重新实现


44
00:02:34,655 --> 00:02:37,191
并计算API
在我们的平台上


45
00:02:37,257 --> 00:02:41,395
给你提供最好的GPU表现


46
00:02:42,396 --> 00:02:46,266
我们通过让你和
GPU之间的软件


47
00:02:46,466 --> 00:02:48,402
发挥最大效用实现这些


48
00:02:51,638 --> 00:02:53,207
为更形象地说明


49
00:02:53,273 --> 00:02:55,275
我们现在来看


50
00:02:55,342 --> 00:02:57,878
在去年的WWDC
举的例子


51
00:02:57,945 --> 00:02:59,546
其中描述


52
00:02:59,613 --> 00:03:02,883
GPU和CPU每帧
完成的工作


53
00:03:04,251 --> 00:03:05,419
在本例中


54
00:03:05,485 --> 00:03:08,722
头部工具条
代表CPU所用时间


55
00:03:09,156 --> 00:03:12,192
底部工具条代表
GPU时间


56
00:03:13,227 --> 00:03:15,863
正如大家所见
目前CPU密集


57
00:03:16,930 --> 00:03:19,766
GPU在帧的部分位置
比较空闲


58
00:03:21,335 --> 00:03:22,469
有了Metal 我们可以


59
00:03:22,536 --> 00:03:26,340
大幅减少GPU
API开销


60
00:03:26,740 --> 00:03:28,008
有效地


61
00:03:29,576 --> 00:03:31,478
将GPU
作为高帧数的瓶颈


62
00:03:32,713 --> 00:03:35,549
这其中最棒的是
你可以利用CPU


63
00:03:35,616 --> 00:03:37,718
额外的空闲时间


64
00:03:38,285 --> 00:03:39,620
让游戏效果更好


65
00:03:41,088 --> 00:03:43,690
例如 可以增加
更多物理应用或AI


66
00:03:45,058 --> 00:03:47,160
如果你可以签署更多


67
00:03:47,561 --> 00:03:49,530
绘制调用来增加
场景的复杂性


68
00:03:52,132 --> 00:03:53,400
但是我们不会止步于此


69
00:03:54,301 --> 00:03:57,504
Metal还可以实现
成本较高的操作


70
00:03:57,971 --> 00:03:59,406
例如 着色器编译


71
00:03:59,840 --> 00:04:02,376dle
和状态确认


72
00:03:59,840 --> 00:04:02,376
和状态确认


73
00:04:02,743 --> 00:04:05,412
从每帧数千次的绘制时间


74
00:04:06,313 --> 00:04:08,815
到发生频率不高的


75
00:04:09,683 --> 00:04:11,885
加载时间均有涉及
更好的是在部分情况下


76
00:04:11,952 --> 00:04:12,786
是构建时间


77
00:04:13,520 --> 00:04:16,322
这样用户
根本不会发现任何影响


78
00:04:19,125 --> 00:04:20,260
此外


79
00:04:20,327 --> 00:04:21,894
在iOS 8中


80
00:04:21,962 --> 00:04:24,798
我们不仅为iOS设备


81
00:04:24,865 --> 00:04:28,068
引入了计算或首次
面对此类计算


82
00:04:28,802 --> 00:04:33,807
而且还提供了
图形和计算


83
00:04:34,107 --> 00:04:36,476
API之间的凝聚
整合性内容


84
00:04:37,244 --> 00:04:41,682
以便在支持Metal的设备上
有效交叉进行渲染


85
00:04:41,849 --> 00:04:43,417
和计算操作


86
00:04:47,521 --> 00:04:48,689
最后


87
00:04:48,755 --> 00:04:49,723
通过Metal


88
00:04:49,790 --> 00:04:51,258
你的应用可以


89
00:04:51,325 --> 00:04:53,794
更高效地
运用多线程


90
00:04:54,094 --> 00:04:55,929
而不会受到API的影响
可以实现


91
00:04:56,730 --> 00:04:59,466
多线程编码


92
00:05:02,035 --> 00:05:03,537
结果会
非常出色


93
00:05:04,605 --> 00:05:05,572
去年


94
00:05:05,639 --> 00:05:07,107
我们展示了


95
00:05:07,174 --> 00:05:10,711
Epic开发的《禅境花园》演示


96
00:05:10,944 --> 00:05:13,847
其中用到Metal
实现场景中十倍


97
00:05:13,914 --> 00:05:15,382
数量的绘画调用


98
00:05:17,451 --> 00:05:20,888
我们还展示了EA的
《植物大战僵尸》技术演示


99
00:05:21,421 --> 00:05:25,025
其中使用Metal
把控制台渲染引擎


100
00:05:25,459 --> 00:05:26,894
才能得到支持


101
00:05:28,328 --> 00:05:31,031
这就为开发界
设定了高标准


102
00:05:31,765 --> 00:05:34,501
在去年 我们见证了
充分利用Metal API


103
00:05:34,568 --> 00:05:36,470
而推出的部分


104
00:05:36,937 --> 00:05:39,640
水平极高的
作品


105
00:05:41,308 --> 00:05:43,644
诸如Super
Evil Mega Corp公司


106
00:05:43,710 --> 00:05:45,612
推出的MOBA
Vainglory游戏


107
00:05:46,513 --> 00:05:49,816
其中运用了Metal
实现每秒60帧的效果


108
00:05:51,718 --> 00:05:54,021
迪斯尼的《Infinity:Toy
Box 2》


109
00:05:54,488 --> 00:05:55,522
Metal使其


110
00:05:55,589 --> 00:05:57,925
可将控制器
图形和游戏


111
00:05:58,292 --> 00:06:00,527e
体验带到了iOS


112
00:05:58,292 --> 00:06:00,527
体验带到了iOS


113
00:06:02,629 --> 00:06:04,598
Gameloft的
《Asphalt 8》


114
00:06:04,998 --> 00:06:07,234
可以运用Metal


115
00:06:07,401 --> 00:06:10,270
提高游戏可玩性
将游戏中的渲染速度


116
00:06:10,337 --> 00:06:11,772
比对手高出3倍


117
00:06:13,874 --> 00:06:15,609
但还不仅是游戏方面


118
00:06:16,844 --> 00:06:18,679
随着用于iPhone的


119
00:06:19,546 --> 00:06:21,048
新版本Pixelmator推出


120
00:06:21,114 --> 00:06:22,249
Metal被用于
强大的


121
00:06:22,316 --> 00:06:23,917
变形工具中的


122
00:06:24,017 --> 00:06:26,587
加速图形
处理功能


123
00:06:28,288 --> 00:06:29,122
实际上


124
00:06:29,923 --> 00:06:31,625
相关反响非常强烈


125
00:06:32,226 --> 00:06:33,527
有相当数量的


126
00:06:33,594 --> 00:06:35,095
主要内容和
游戏开发人员


127
00:06:35,162 --> 00:06:36,396
在OS X上使用Metal


128
00:06:38,165 --> 00:06:41,301
因为我们对在iOS平台上


129
00:06:41,702 --> 00:06:42,769
推出领先的游戏


130
00:06:43,103 --> 00:06:45,606
控制台引擎所做承诺
大部分这样的内容


131
00:06:45,939 --> 00:06:47,441
才能得到支持


132
00:06:48,008 --> 00:06:49,743
这包括


133
00:06:49,810 --> 00:06:51,512
Unity
Epic的《虚幻引擎4》


134
00:06:51,912 --> 00:06:52,980
EA的《寒霜》


135
00:06:53,380 --> 00:06:55,516
移动引擎


136
00:06:59,019 --> 00:07:00,754
去年 我们还展示了


137
00:07:00,821 --> 00:07:01,989
Metal怎样在


138
00:07:02,055 --> 00:07:05,959
应用访问GPU的
全局图景中发挥作用


139
00:07:06,593 --> 00:07:09,963
一方面 我们有着
高水准的2D和


140
00:07:10,030 --> 00:07:12,232
3D场景图像API


141
00:07:12,599 --> 00:07:14,902
以提供难以置信的


142
00:07:14,968 --> 00:07:16,670
功能和便捷


143
00:07:16,970 --> 00:07:18,238
另一方面


144
00:07:18,305 --> 00:07:19,239
通过Metal


145
00:07:19,306 --> 00:07:22,109
我们提供了
GPU的直接访问路径


146
00:07:22,910 --> 00:07:24,912
这样你可以为


147
00:07:25,379 --> 00:07:27,414
应用所做的事情


148
00:07:28,415 --> 00:07:30,083
就会多了很多
如果选择使用


149
00:07:30,150 --> 00:07:31,585
更高级的API


150
00:07:32,085 --> 00:07:33,020
最棒的是


151
00:07:33,086 --> 00:07:35,722
我们可以在
幕后实现很多改进


152
00:07:36,223 --> 00:07:38,025
你可以从中受益


153
00:07:38,091 --> 00:07:40,861
而我们不需改动
一行代码


154
00:07:42,829 --> 00:07:43,931
今年


155
00:07:43,997 --> 00:07:46,466
我们很高兴
宣布了


156
00:07:47,000 --> 00:07:49,703
我们做到了这些
并让Metal


157
00:07:49,970 --> 00:07:51,672
在整个系统技术中表现得
更强大更高效


158
00:07:52,506 --> 00:07:55,275
我相信
这将会提升


159
00:07:55,342 --> 00:07:56,777
用户在我们的
平台上的体验


160
00:08:00,581 --> 00:08:04,184
这也是支持Metal
设备的很棒的一年


161
00:08:05,018 --> 00:08:09,556
iPhone 5S和iPad
Air在去年的WWDC上


162
00:08:10,524 --> 00:08:13,427
都是主打产品
随着iPhone 6


163
00:08:13,861 --> 00:08:16,663
6+和 iPad Air 2的推出


164
00:08:16,730 --> 00:08:18,866
我们现在有了支持Metal设备的


165
00:08:18,932 --> 00:08:21,068
难以置信的安装基础


166
00:08:22,035 --> 00:08:23,437
但是当然
还不止于此


167
00:08:24,838 --> 00:08:26,473
我们很高兴地宣布


168
00:08:26,540 --> 00:08:29,610
将Metal纳入了
OS X平台


169
00:08:33,113 --> 00:08:34,948
我们在所有的


170
00:08:35,015 --> 00:08:37,818
传送配置中
都广泛支持Metal


171
00:08:37,885 --> 00:08:42,789
实际上 自2012年起
所有的Mac就已支持Metal


172
00:08:44,024 --> 00:08:46,793
当然 这意味着
我们会支持所有


173
00:08:46,860 --> 00:08:50,364
三家GPU厂商：
Intel AMD和Nvidia


174
00:08:53,333 --> 00:08:55,569
其他好消息还包括


175
00:08:55,636 --> 00:08:58,071
我们将大家熟悉的


176
00:08:58,138 --> 00:09:00,908
iOS上的所有工具
也都加在了Mac平台


177
00:09:01,608 --> 00:09:03,310
这其中包括Frame


178
00:09:04,478 --> 00:09:06,680
Debugger
Shader Profiler


179
00:09:07,047 --> 00:09:09,283
和所有API分析工具


180
00:09:10,017 --> 00:09:11,451
这相当了不起


181
00:09:11,652 --> 00:09:14,121
我们了解调试复杂图形


182
00:09:14,188 --> 00:09:16,190
和计算
应用的难度


183
00:09:16,623 --> 00:09:19,860
并认为这对
大家在OS X上的


184
00:09:19,927 --> 00:09:20,928
开发工作
意义重大


185
00:09:22,362 --> 00:09:23,931
当然 所有这些在


186
00:09:23,997 --> 00:09:26,567
OS X El
Capitan版本


187
00:09:26,934 --> 00:09:28,936
搭建的种子中可以获得
如今这一版本可以下载


188
00:09:31,004 --> 00:09:32,406
OS X上的Metal


189
00:09:32,472 --> 00:09:35,042
是你所熟悉的同样API


190
00:09:35,509 --> 00:09:36,577
用的是iOS


191
00:09:37,044 --> 00:09:38,378
增加了几项主要功能


192
00:09:39,580 --> 00:09:42,316
新款API支持设备选择


193
00:09:43,150 --> 00:09:44,384
离散内存


194
00:09:44,718 --> 00:09:46,186
和新的纹理格式


195
00:09:46,687 --> 00:09:49,089
Metal可以让
你将iOS应用带入


196
00:09:49,156 --> 00:09:51,859
OS X变得异常容易


197
00:09:54,127 --> 00:09:55,529
这里有几个实例


198
00:09:55,596 --> 00:09:57,497
开发人员正是
这样做的


199
00:09:58,665 --> 00:10:01,768
大家从主题演讲中听到
我们在与Epic合作


200
00:10:02,236 --> 00:10:05,506
将其iOS Metal
开发代码带到


201
00:10:05,839 --> 00:10:07,474
Mac中的《虚幻引擎》


202
00:10:08,775 --> 00:10:10,544
Epic运用Metal


203
00:10:10,744 --> 00:10:13,180
和延迟渲染器


204
00:10:13,247 --> 00:10:16,350
在《堡垒之夜》游戏中
创建这种神奇的风格效果


205
00:10:18,452 --> 00:10:20,854
此外 Unity在几周内


206
00:10:20,921 --> 00:10:22,623
就推出了他们的引擎


207
00:10:23,123 --> 00:10:25,659
并展示了
他们的《海盗村》


208
00:10:25,726 --> 00:10:27,327
演示


209
00:10:27,761 --> 00:10:31,298
很高兴能在OS X的Metal中
看到这样的内容


210
00:10:33,600 --> 00:10:36,670
我们在与
若干Mac开发者合作


211
00:10:36,904 --> 00:10:40,474
帮助他们通过
Metal使用Metal的强大功能


212
00:10:43,977 --> 00:10:45,646
同样 大家从主题演讲中听到


213
00:10:45,712 --> 00:10:48,282
数字内容
生成应用的相关介绍


214
00:10:49,449 --> 00:10:50,784
Adobe这样的开发者


215
00:10:50,851 --> 00:10:52,953
在使用Metal访问GPU


216
00:10:53,020 --> 00:10:54,888
加速图像处理能力


217
00:10:57,357 --> 00:10:58,825
The Foundry公司


218
00:10:58,892 --> 00:11:00,594
也在运用Metal


219
00:11:00,661 --> 00:11:04,097
加速其3D
建模应用MODO


220
00:11:05,632 --> 00:11:06,900
今天


221
00:11:06,967 --> 00:11:10,270
来自The Foundry
公司的杰克•格里斯雷


222
00:11:10,604 --> 00:11:12,639
来谈谈他们在OS X
使用Metal的经验


223
00:11:14,741 --> 00:11:15,576
欢迎杰克


224
00:11:15,642 --> 00:11:16,476
谢谢 拉夫


225
00:11:19,913 --> 00:11:21,215
大家好我是杰克•格里斯雷


226
00:11:21,281 --> 00:11:23,817
在The Foundry公司
负责新技术部门


227
00:11:24,751 --> 00:11:28,121
在The Foundry 我们为
数码艺术家创建工具


228
00:11:29,656 --> 00:11:31,491
我们的软件在全世界


229
00:11:31,558 --> 00:11:33,994
用于游戏 影视等领域


230
00:11:34,561 --> 00:11:37,064
包括拍摄
真实的秘鲁熊


231
00:11:38,465 --> 00:11:39,566
变形怪物猎人


232
00:11:40,767 --> 00:11:42,102
但并非仅限于
虚拟世界


233
00:11:42,870 --> 00:11:44,571
我们的部分设计客户
如阿迪达斯是


234
00:11:44,638 --> 00:11:45,839
是在切实生产产品


235
00:11:47,140 --> 00:11:48,742
如果你询问设计师


236
00:11:49,476 --> 00:11:52,513
他们会告知你 任何产品都是
经过成千上万次试验才会成型


237
00:11:54,982 --> 00:11:56,283
我们理解这一过程


238
00:11:56,350 --> 00:11:57,417
我们创造的工具


239
00:11:57,484 --> 00:11:59,152
就是针对此类支持


240
00:12:01,355 --> 00:12:03,323
MODO是我们的著名3D


241
00:12:03,390 --> 00:12:05,526
建模动画和渲染系统


242
00:12:06,460 --> 00:12:08,762
它可用来制作游戏
电影和产品设计


243
00:12:09,129 --> 00:12:10,163
等等很多不同的应用


244
00:12:11,231 --> 00:12:13,100
我们的用户创造出


245
00:12:13,467 --> 00:12:15,869
非常精彩的画面和动画在真实世界和
虚幻世界中都有


246
00:12:18,138 --> 00:12:20,207
在我们的MODO 9.01
最新版本中


247
00:12:20,841 --> 00:12:23,277
对GPU渲染器做了修改


248
00:12:24,645 --> 00:12:27,581
旨在为设计者
提供尽可能


249
00:12:28,315 --> 00:12:30,317
高质量的
流畅互动体验


250
00:12:31,418 --> 00:12:34,054
这样做的好处在于
如果视口是实时


251
00:12:34,588 --> 00:12:36,256
你就可以完成
数十倍单个软件


252
00:12:36,323 --> 00:12:38,091
渲染器的决定


253
00:12:40,928 --> 00:12:43,864
在iOS中 我们已经
完成了部分早期工作


254
00:12:44,831 --> 00:12:47,868
但是在几个月前
我们有个绝好的机会


255
00:12:48,202 --> 00:12:49,803
可以在OS X上
开始使用Metal


256
00:12:50,404 --> 00:12:52,539
我们组织了一个小团队
让他们来接受挑战


257
00:12:53,207 --> 00:12:56,143
只给4周时间
来看他们可以将


258
00:12:56,510 --> 00:12:58,712
生成多少新的MODO视口
并在Metal上运行


259
00:12:59,313 --> 00:13:01,849
我们机会立刻会
得到一些很令人震惊的结果


260
00:13:05,853 --> 00:13:06,687
虽然


261
00:13:06,753 --> 00:13:08,155
这不过是
小三角


262
00:13:08,222 --> 00:13:10,057
但是这代表了
我们的一个巨大里程碑


263
00:13:10,757 --> 00:13:13,594
一旦我们可以做到这点
就可以很快的取得进步


264
00:13:14,228 --> 00:13:16,530
我们的进攻计划
其实是从下往上


265
00:13:17,130 --> 00:13:20,234
并开始将新视口的功能
带到了Metal


266
00:13:20,801 --> 00:13:22,135
第一天


267
00:13:22,202 --> 00:13:23,337
我们
是从环境开始入手


268
00:13:25,339 --> 00:13:27,708
我们添加了更多的三角


269
00:13:31,245 --> 00:13:32,813
加一点着色处理会


270
00:13:32,880 --> 00:13:34,748
让它看似更像是
真正的汽车


271
00:13:38,385 --> 00:13:39,887
加上柔和的阴影


272
00:13:39,953 --> 00:13:40,888
还有特殊的高光处理


273
00:13:40,954 --> 00:13:42,289
加上了闪闪发亮的效果


274
00:13:42,356 --> 00:13:43,490
人人都喜欢亮闪闪的东西


275
00:13:45,125 --> 00:13:47,327
就这样
四周后


276
00:13:47,394 --> 00:13:48,929
大家还记得那个
单一的三角形吗？


277
00:13:49,296 --> 00:13:50,697
结果难以置信


278
00:13:54,701 --> 00:13:56,370
把这些都放入Metal


279
00:13:56,436 --> 00:13:58,572
仅仅用四周时间


280
00:13:58,872 --> 00:14:00,440e
我们就实现了


281
00:13:58,872 --> 00:14:00,440
我们就实现了


282
00:14:00,507 --> 00:14:02,442
所有视口
都在Metal的MODO运行


283
00:14:03,977 --> 00:14:05,279
很棒的一点是


284
00:14:05,345 --> 00:14:08,749
这提供了跨iOS和OS X的
标准化渲染器


285
00:14:09,983 --> 00:14:13,353
我们在两个平台间
生成了WYSIWYG工作流


286
00:14:15,889 --> 00:14:17,324
那么我们学到了什么？


287
00:14:18,058 --> 00:14:20,227
首先我们了解到
使用Metal充满乐趣


288
00:14:20,861 --> 00:14:22,963
我使用OpenGL工作
已经20年时间


289
00:14:23,030 --> 00:14:25,065
我可以告知大家
API轻松易用


290
00:14:25,132 --> 00:14:27,067
就像是呼吸新鲜空气一般


291
00:14:29,002 --> 00:14:29,970
其次


292
00:14:30,437 --> 00:14:32,139
Metal中的
调试和


293
00:14:32,206 --> 00:14:33,807
优化工具
也非常神奇


294
00:14:34,908 --> 00:14:35,742
我刚说过


295
00:14:35,809 --> 00:14:37,411
如果你在
GPU上做过调试


296
00:14:37,477 --> 00:14:38,846
就会知道为什么这点很重要


297
00:14:40,214 --> 00:14:41,882
Metal的速度非常快


298
00:14:42,516 --> 00:14:44,585
在部分测试中
我们实现了3倍加速


299
00:14:45,252 --> 00:14:47,921
这是在同样的GPU
使用完全相同的数据的结果


300
00:14:49,590 --> 00:14:52,626
继续来看 我们对
新的视口有些很大的计划


301
00:14:52,693 --> 00:14:55,963
我们想将它整合到The
Foundry公司的所有工具中


302
00:14:56,463 --> 00:14:58,565
希望 能很快
看到Metal


303
00:14:58,632 --> 00:14:59,867le
出现在
有趣的地方


304
00:15:00,801 --> 00:15:03,136
请拉夫回到台上
非常感谢


305
00:15:10,511 --> 00:15:11,345
谢谢 杰克


306
00:15:14,515 --> 00:15:15,482
非常好


307
00:15:16,583 --> 00:15:19,720
接下来我会聊聊iOS 9和OS X
El Capitan


308
00:15:19,786 --> 00:15:22,890
引入的
新功能


309
00:15:24,691 --> 00:15:25,659
这样的功能有很多


310
00:15:27,027 --> 00:15:28,262
只能对我们


311
00:15:28,328 --> 00:15:29,796
今年新增的功能
选择性介绍一番


312
00:15:30,864 --> 00:15:33,500
实在没时间
各个都讲一遍


313
00:15:33,834 --> 00:15:35,536
我先来说说
子集问题


314
00:15:36,370 --> 00:15:38,472
包括GPU系列集


315
00:15:38,872 --> 00:15:40,307
我们的新内存模型


316
00:15:40,374 --> 00:15:41,675
纹理壁垒


317
00:15:41,742 --> 00:15:43,644
<br/>
和扩展的纹理支持


318
00:15:44,878 --> 00:15:46,213
当然 我之前提过


319
00:15:46,280 --> 00:15:47,514
在本周晚些时候的
讲座中


320
00:15:47,581 --> 00:15:48,415
大家可以
了解到


321
00:15:49,082 --> 00:15:50,717
MetalKit
MetalPerformance


322
00:15:50,784 --> 00:15:52,853
Shaders
新的Metal System


323
00:15:53,320 --> 00:15:54,888
Trace工具等更多内容


324
00:15:56,823 --> 00:15:58,325
我们现在就来详细介绍


325
00:15:59,393 --> 00:16:01,395
我想先从GPU开始


326
00:16:01,461 --> 00:16:02,896
这是我们的Metal功能集


327
00:16:03,397 --> 00:16:06,200
Metal定义了
专门针对生成GPU


328
00:16:06,266 --> 00:16:09,403
硬件的功能集合


329
00:16:10,003 --> 00:16:13,040
Metal调用这些GPU系列


330
00:16:14,741 --> 00:16:16,210
因此GPU功能集


331
00:16:16,276 --> 00:16:19,780
是由iOS或OS X平台所定义


332
00:16:20,981 --> 00:16:23,116
Family Name
主要针对


333
00:16:23,183 --> 00:16:24,384
硬件生成


334
00:16:25,152 --> 00:16:26,220
版本则可以


335
00:16:26,286 --> 00:16:29,156
让我们随着时间推移
增加功能


336
00:16:30,424 --> 00:16:32,926
询问功能集
意义不大


337
00:16:33,861 --> 00:16:36,797
只需在Metal设备上


338
00:16:36,864 --> 00:16:39,967
调用supportFeature
Set 来决定是否GPU系列即可


339
00:16:42,269 --> 00:16:45,072
这里是iOS
功能集矩阵


340
00:16:46,073 --> 00:16:48,642
大家会注意到
我们会支持


341
00:16:48,709 --> 00:16:50,777
两个主要GPU系列


342
00:16:50,844 --> 00:16:51,945
和版本来区分


343
00:16:52,012 --> 00:16:54,248
iOS 8


344
00:16:54,314 --> 00:16:56,383
和
iOS 9功能


345
00:16:59,019 --> 00:17:00,287
在OS X中


346
00:17:00,354 --> 00:17:02,990
GPUFamily1 v1
功能集代表


347
00:17:03,056 --> 00:17:07,227
我们将在OS X El
Capitan推出的新功能


348
00:17:07,828 --> 00:17:10,763
这在桌面平台
定义了支持Metal


349
00:17:10,830 --> 00:17:12,098
设备的基础


350
00:17:15,602 --> 00:17:16,603
现在 我想谈谈


351
00:17:16,670 --> 00:17:20,240
两个新的着色器常数
更新我们所添加的API


352
00:17:21,175 --> 00:17:22,476
首先来看看
背景


353
00:17:23,210 --> 00:17:25,878
对于在命令
缓冲区的每个


354
00:17:26,280 --> 00:17:28,715
绘画编码
都需要发送给


355
00:17:29,416 --> 00:17:30,684
着色器部分常数数据


356
00:17:30,751 --> 00:17:32,786
若要每个绘画
都有单独的


357
00:17:32,853 --> 00:17:34,354
常数缓冲区
那么效率就会变得极低


358
00:17:34,488 --> 00:17:36,490
所以一般来说 大多数
Metal应用


359
00:17:36,557 --> 00:17:39,026
会每帧分配
一个单独的常数缓冲区


360
00:17:39,092 --> 00:17:40,594
接着在为
绘画编码时


361
00:17:41,595 --> 00:17:46,099
将常数数据增加到缓冲区


362
00:17:47,267 --> 00:17:48,569
代码会是什么样呢？


363
00:17:49,803 --> 00:17:50,704
首先 我们为


364
00:17:50,771 --> 00:17:52,673
常数缓冲区
和数据设置


365
00:17:53,440 --> 00:17:55,876
正如示意图
在绘图环中


366
00:17:56,743 --> 00:17:59,880
你发送新的
常数数据


367
00:17:59,947 --> 00:18:02,416
或将新的常数数据
圈入常数缓冲器


368
00:18:03,483 --> 00:18:04,685
现在 值得注意的是


369
00:18:04,751 --> 00:18:06,887
setVertexBuffer调用


370
00:18:06,954 --> 00:18:09,056
实际上在做两件事


371
00:18:10,524 --> 00:18:12,059
它在设置
常数缓冲区


372
00:18:12,960 --> 00:18:14,862
也在更新
其中的偏移


373
00:18:15,629 --> 00:18:18,165
现在 在这两个
操作中 设置常数


374
00:18:18,899 --> 00:18:22,269
缓冲区的调用
造价最高


375
00:18:23,036 --> 00:18:24,571
Metald的API
可以实现


376
00:18:24,638 --> 00:18:26,974
分离这两个操作


377
00:18:27,341 --> 00:18:29,209
并将造价高的调用


378
00:18:29,276 --> 00:18:30,744
用来设置常数缓冲区


379
00:18:31,144 --> 00:18:33,347
或顶点缓冲
在绘画环之外


380
00:18:34,748 --> 00:18:37,317
如果每帧有数千
绘图调用


381
00:18:37,651 --> 00:18:39,319
这就会有大量
的节约


382
00:18:41,722 --> 00:18:44,291
但是如果你只有
少量的常数数据


383
00:18:44,491 --> 00:18:46,260
让Metal来管理
常数缓冲区效率


384
00:18:46,326 --> 00:18:47,995
也许
会更高


385
00:18:49,496 --> 00:18:52,266
Metal有setVertex
Bytes API


386
00:18:52,733 --> 00:18:54,835
你可以用它来为


387
00:18:54,902 --> 00:18:58,605
每个绘画调用增加新常数


388
00:19:00,841 --> 00:19:02,376
实际上 关于这一点
我还要补充一些


389
00:19:02,809 --> 00:19:04,511
我说过


390
00:19:04,578 --> 00:19:06,547
如果只有
少量常数


391
00:19:06,613 --> 00:19:08,982
API很好
可以有数十字节常数


392
00:19:09,917 --> 00:19:12,219
如果有更大的
常数集


393
00:19:12,286 --> 00:19:13,754
你想在


394
00:19:13,820 --> 00:19:15,455
其他API中使用


395
00:19:16,356 --> 00:19:18,325
很可能 这样会
效果更好


396
00:19:20,394 --> 00:19:22,362
好 我现在来谈谈
新的内存模型


397
00:19:24,631 --> 00:19:27,167
新内存模型的目标
是支持统一


398
00:19:27,234 --> 00:19:29,670
和离散的内存
系统 而无需


399
00:19:29,736 --> 00:19:32,105
做出
太多改变


400
00:19:32,739 --> 00:19:34,842
Metal现在支持
离散内存


401
00:19:34,908 --> 00:19:38,045
这是高速内存
部分桌面的


402
00:19:38,111 --> 00:19:41,014
GPU可以访问


403
00:19:42,182 --> 00:19:43,483
我们实现
这些的方式


404
00:19:43,951 --> 00:19:46,820
是通过新的存储模式


405
00:19:47,387 --> 00:19:49,022
你可以明确


406
00:19:49,323 --> 00:19:50,424
资源在
内存中的位置


407
00:19:51,124 --> 00:19:52,426
模式可以是共享


408
00:19:53,060 --> 00:19:55,128
专用和


409
00:19:55,562 --> 00:19:57,297
托管状态


410
00:19:58,398 --> 00:20:00,234e
在接下来的幻灯片中


411
00:19:58,398 --> 00:20:00,234
在接下来的幻灯片中


412
00:20:00,300 --> 00:20:01,802
我会依次来介绍


413
00:20:03,303 --> 00:20:05,939
先来看看
共享内存模式


414
00:20:06,740 --> 00:20:09,376
这就是在iOS 8


415
00:20:09,443 --> 00:20:10,744
现有执行的
模式


416
00:20:11,445 --> 00:20:13,447
在统一的内存系统
用于存储


417
00:20:13,514 --> 00:20:15,983
缓冲区或纹理的


418
00:20:16,049 --> 00:20:19,753
内存共享
于CPU和GPU之间


419
00:20:21,421 --> 00:20:22,956
内存只有
一份拷贝


420
00:20:23,524 --> 00:20:26,460
内存在命令
缓存区边界方面保持一致


421
00:20:26,894 --> 00:20:29,563
也就是说
在通过CPU访问之前


422
00:20:29,897 --> 00:20:31,865
需要用GPU
做此番处理


423
00:20:32,633 --> 00:20:34,501
这会令它易于使用


424
00:20:36,436 --> 00:20:38,505
但在iOS 9


425
00:20:38,572 --> 00:20:40,374
和OS X
El Capitan中


426
00:20:40,440 --> 00:20:43,777
我们
引入了专用存储模式


427
00:20:44,511 --> 00:20:45,812
专用内存


428
00:20:45,879 --> 00:20:48,148
只能
通过渲染 计算


429
00:20:48,482 --> 00:20:51,084
或传送操作
由GPU进行访问


430
00:20:52,052 --> 00:20:54,788
专用内存的优势
在于性能


431
00:20:55,455 --> 00:20:57,658
Metal可以用
最便于GPU


432
00:20:57,724 --> 00:21:00,260le
访问的方式存储数据


433
00:20:57,724 --> 00:21:00,260
访问的方式存储数据


434
00:21:01,528 --> 00:21:03,830
例如 使用
帧缓冲压缩


435
00:21:06,567 --> 00:21:10,938
专用存储模式
与离散内存系统


436
00:21:11,338 --> 00:21:14,107
配合很好
可以将资源


437
00:21:14,174 --> 00:21:16,743
放入GPU可以最快
访问的内存中


438
00:21:19,313 --> 00:21:21,615
现在 只有在OS X中


439
00:21:22,049 --> 00:21:24,151
我们引入了托管
存储模式


440
00:21:24,351 --> 00:21:27,921
有了托管内存
资源就可以在


441
00:21:27,988 --> 00:21:28,889
离散内存


442
00:21:28,956 --> 00:21:30,624
和系统
内存中进行存储


443
00:21:31,024 --> 00:21:34,361
Metal管理着两个
拷贝的一致性


444
00:21:36,029 --> 00:21:38,899
这样可以提供
分享存储模式的


445
00:21:38,966 --> 00:21:40,901
便捷性和灵活性


446
00:21:40,968 --> 00:21:42,135
在多数情况下


447
00:21:42,202 --> 00:21:44,338
是专用存储模式的性能


448
00:21:46,907 --> 00:21:49,610
如果你有统一内存系统的


449
00:21:50,244 --> 00:21:52,546
桌面系统


450
00:21:52,613 --> 00:21:54,047
就你不必担心


451
00:21:54,114 --> 00:21:55,749
托管额外的
开销


452
00:21:56,116 --> 00:21:59,119
只有Metal维护的资源的
一份拷贝


453
00:22:02,789 --> 00:22:05,225
如果要调整CPU
或GPU的数据


454
00:22:05,292 --> 00:22:07,461
还有另外
两方面需要


455
00:22:07,528 --> 00:22:09,596
考虑


456
00:22:10,464 --> 00:22:11,331
首先


457
00:22:11,398 --> 00:22:13,333
如果要用
CPU调整数据


458
00:22:13,767 --> 00:22:17,804
则要通过调用缓冲
didModifyRange


459
00:22:18,238 --> 00:22:21,008
或纹理replaceRegion
API 让Metal了解


460
00:22:22,342 --> 00:22:24,578
同样 如果要
读回数据


461
00:22:24,912 --> 00:22:27,915
则需要调用synchronize
Resource API


462
00:22:28,815 --> 00:22:29,983
还要注意的是


463
00:22:30,050 --> 00:22:32,386
在真正用CPU读取


464
00:22:32,452 --> 00:22:34,855
数据前 要等到
操作完成之后才行


465
00:22:38,492 --> 00:22:40,427
我们现在来看
之前展示的


466
00:22:40,494 --> 00:22:42,563
着色器常数升级实例


467
00:22:43,063 --> 00:22:46,266
这个实例正在
使用共享内存


468
00:22:47,901 --> 00:22:49,803
在离散内存系统中


469
00:22:49,870 --> 00:22:52,139
你很想让常数


470
00:22:52,506 --> 00:22:53,640
在离散内存中


471
00:22:54,107 --> 00:22:56,610
这就可能要用到
专用缓冲区


472
00:22:57,044 --> 00:22:59,613
还是必须要
将转移托管到缓冲区


473
00:23:00,480 --> 00:23:03,817
使用托管缓冲区
则要简单很多


474
00:23:03,884 --> 00:23:05,586
有它就会相当容易


475
00:23:05,652 --> 00:23:07,387
只需要
做两点


476
00:23:08,255 --> 00:23:09,223
首先


477
00:23:09,289 --> 00:23:11,959
在生成
常数缓冲区时


478
00:23:12,025 --> 00:23:13,627
必须明确
托管存储模式


479
00:23:14,862 --> 00:23:15,696
然后


480
00:23:15,762 --> 00:23:18,031
要调用
didModifyRange


481
00:23:18,098 --> 00:23:22,002
告知Metal 你已经用
CPU升级了常数


482
00:23:22,503 --> 00:23:23,470
就这样


483
00:23:23,537 --> 00:23:26,073
代码的其余部分
仍然保持不变


484
00:23:28,642 --> 00:23:30,677
值得注意的是
在默认情况下


485
00:23:30,744 --> 00:23:32,746
缓冲区可以在所有平台共享


486
00:23:34,047 --> 00:23:35,182
在iOS


487
00:23:35,249 --> 00:23:37,618
在默认状况下
纹理也是同样如此


488
00:23:38,118 --> 00:23:40,187
但是在OS X上


489
00:23:40,654 --> 00:23:43,290
我们选择为纹理托管


490
00:23:43,657 --> 00:23:45,025
制作默认模式
因为它可以允许


491
00:23:45,092 --> 00:23:47,828
编写携带版代码
而不影响性能


492
00:23:50,831 --> 00:23:53,133
但是在有些情况下
你不会想要


493
00:23:53,200 --> 00:23:54,434
使用托管纹理


494
00:23:54,635 --> 00:23:55,569
这就是其中之一


495
00:23:56,069 --> 00:23:57,371
当你有帧缓冲区


496
00:23:57,437 --> 00:23:58,839
或可渲染纹理时


497
00:23:58,906 --> 00:24:01,441
你想用专用
存储模式


498
00:24:01,508 --> 00:24:02,843
还获取最佳性能


499
00:24:03,510 --> 00:24:05,445
如果只有GPU可以


500
00:24:05,712 --> 00:24:07,381
访问数据
这就非常重要


501
00:24:09,016 --> 00:24:11,985
这就是我们在Metal中的
新内存模式


502
00:24:12,052 --> 00:24:14,588
我想来介绍Metal中的
两个部分功能


503
00:24:15,155 --> 00:24:18,058
都是OS X特有的
我觉得你会喜欢


504
00:24:19,026 --> 00:24:20,961
首先是分层渲染


505
00:24:21,495 --> 00:24:23,530
API的意图是要


506
00:24:23,597 --> 00:24:26,533
让你可以将绘制的


507
00:24:26,600 --> 00:24:28,969
每个三角形的纹理


508
00:24:29,036 --> 00:24:30,604
的具体层次
都能进行渲染


509
00:24:31,238 --> 00:24:34,041
因此这可以是
数组纹理的切片


510
00:24:34,641 --> 00:24:36,677
3D纹理的平面
或立体纹理的表面


511
00:24:37,077 --> 00:24:39,079
在每个三角形的基础上
你可以明确


512
00:24:40,714 --> 00:24:43,083
要渲染哪一层


513
00:24:43,450 --> 00:24:45,919
只要在顶点着色器中


514
00:24:45,986 --> 00:24:49,156
明确数组索引即可


515
00:24:50,424 --> 00:24:53,160
游戏《堡垒之夜》
就是用的这种技术


516
00:24:53,360 --> 00:24:56,230
为部分环境照明
渲染立方体


517
00:24:56,296 --> 00:24:58,131
贴图的表面


518
00:24:58,298 --> 00:25:01,001
我们认为 你也会
觉得这个功能同样有用


519
00:25:04,271 --> 00:25:06,840
第二个功能
也是OS X所特有


520
00:25:07,174 --> 00:25:09,409
就是纹理壁垒


521
00:25:10,644 --> 00:25:12,746
在默认状态
GPU会倾向于覆盖


522
00:25:12,813 --> 00:25:14,648
绘画调用的执行


523
00:25:15,382 --> 00:25:17,317
不能在随后的调用中


524
00:25:17,384 --> 00:25:19,620
可靠使用绘画
调用的输出


525
00:25:19,686 --> 00:25:22,189
而无需某种形式的显性同步


526
00:25:23,290 --> 00:25:24,992
Metal现有一个API


527
00:25:25,058 --> 00:25:26,360
可以在这些


528
00:25:26,426 --> 00:25:28,295
绘画调用之间插入壁垒


529
00:25:30,264 --> 00:25:31,398
对于在OS X


530
00:25:31,465 --> 00:25:34,935
执行有效的可编程
混合非常关键


531
00:25:37,337 --> 00:25:39,306
API很易于使用


532
00:25:39,740 --> 00:25:41,608
只是在你想要同步的
绘画操作中间


533
00:25:41,675 --> 00:25:44,378
插入壁垒


534
00:25:47,614 --> 00:25:49,616
最后 当然不是
最不重要的内容


535
00:25:49,683 --> 00:25:50,617
我谈谈


536
00:25:50,684 --> 00:25:53,787
今年Metal的扩展
纹理支持


537
00:25:55,122 --> 00:25:57,758
在默认条件下


538
00:25:57,824 --> 00:25:59,660
iOS中所有纹理的


539
00:25:59,726 --> 00:26:02,896
最大限制已经
增至8k


540
00:26:03,430 --> 00:26:06,266
我们还增加了
OS X的立方体数组支持


541
00:26:07,000 --> 00:26:08,936
在所有平台上
的各板中


542
00:26:09,002 --> 00:26:11,939
都能提高
防叠效果


543
00:26:13,440 --> 00:26:15,876
我们还大量
增加了像素格式


544
00:26:15,943 --> 00:26:18,412
便于在计算着色器
编写


545
00:26:18,478 --> 00:26:20,714
或读取数据


546
00:26:24,551 --> 00:26:27,321
还有是纹理
使用属性


547
00:26:28,188 --> 00:26:30,324
这可以实现
对纹理标签


548
00:26:30,791 --> 00:26:33,694
告知Metal 你准备
怎样使用它们


549
00:26:33,894 --> 00:26:36,697
Metal会对使用进行优化


550
00:26:37,531 --> 00:26:38,799
例如


551
00:26:38,866 --> 00:26:40,534
如果你有
可渲染纹理时


552
00:26:40,868 --> 00:26:42,769
想要设置renderTarget


553
00:26:42,836 --> 00:26:44,938
和shaderRead旗标


554
00:26:46,173 --> 00:26:47,374
这会告知Metal


555
00:26:47,441 --> 00:26:48,909
你计划在纹理上


556
00:26:48,976 --> 00:26:51,044
所渲染 然后还要
从中取样


557
00:26:53,146 --> 00:26:54,414
默认状态下


558
00:26:54,481 --> 00:26:56,416
使用是未知的


559
00:26:56,817 --> 00:26:59,987
Metal不会做任何假设
纹理会如何使用


560
00:27:00,320 --> 00:27:02,222
允许Metal在系统的
任何地方进行使用


561
00:27:05,893 --> 00:27:07,628
与iOS不同


562
00:27:07,694 --> 00:27:08,962
桌面
GPU 更喜欢


563
00:27:09,029 --> 00:27:11,565
单独境深
模板纹理


564
00:27:13,100 --> 00:27:16,370
我们添加了两个
新的组合境深模板格式


565
00:27:17,004 --> 00:27:18,238
32-8格式


566
00:27:18,305 --> 00:27:21,875
在所有
硬件


567
00:27:21,942 --> 00:27:23,911
iOS和OS X
都会支持


568
00:27:24,645 --> 00:27:27,981
不过只有部分会
支持24-8格式


569
00:27:28,549 --> 00:27:30,584
如果这意味着
是精度要求


570
00:27:30,651 --> 00:27:32,085
就需要检查
是否可用


571
00:27:37,090 --> 00:27:39,059
我们来谈谈
纹理压缩


572
00:27:40,027 --> 00:27:43,030
所以所用压缩格式类型
取决于所


573
00:27:43,096 --> 00:27:44,398
针对的设备


574
00:27:44,698 --> 00:27:46,733
以及编码的
数据类型


575
00:27:47,467 --> 00:27:48,569
在iOS


576
00:27:48,635 --> 00:27:50,404
我们支持
若干格式


577
00:27:50,470 --> 00:27:52,439
包括PVRTC


578
00:27:52,506 --> 00:27:54,074
ETC2


579
00:27:54,141 --> 00:27:55,609
和EAC


580
00:27:55,676 --> 00:27:58,512
对于GPUFamily2的
新增内容是


581
00:27:58,579 --> 00:28:01,014le
我们也支持ASTC


582
00:27:58,579 --> 00:28:01,014
我们也支持ASTC


583
00:28:03,317 --> 00:28:06,553
因此ASTC是高质量
压缩


584
00:28:07,221 --> 00:28:08,655
要比相同大小的


585
00:28:09,156 --> 00:28:11,859
PVRTC和ETC
要好很多


586
00:28:12,926 --> 00:28:16,129
它可以实现
对若干不同格式的


587
00:28:16,597 --> 00:28:18,465
图像内容


588
00:28:18,532 --> 00:28:19,733
高度图


589
00:28:19,800 --> 00:28:21,902
法线图等等进行编码


590
00:28:25,172 --> 00:28:29,076
它还提供了
尺寸和质量之间的


591
00:28:29,142 --> 00:28:30,544
细粒度控制


592
00:28:30,777 --> 00:28:32,312
每个像素为
1到8 bits


593
00:28:32,913 --> 00:28:33,981
在低端


594
00:28:34,047 --> 00:28:37,050
这是PVRTC
所需的一般存储


595
00:28:38,785 --> 00:28:39,920
最后


596
00:28:39,987 --> 00:28:41,722
如我之前提到


597
00:28:41,788 --> 00:28:44,224
这只在支持GPUFamily2的


598
00:28:44,291 --> 00:28:45,526
设备上可用


599
00:28:45,592 --> 00:28:46,760
所以 大家
要留意这点


600
00:28:51,098 --> 00:28:52,733
最后 在OS X中


601
00:28:52,799 --> 00:28:55,002
我们介绍了桌面GPU


602
00:28:55,068 --> 00:28:58,505
支持的所有原生纹理
压缩格式


603
00:28:59,840 --> 00:29:01,642
这些BCn格式


604
00:29:01,708 --> 00:29:03,076
大家
应该都很熟悉


605
00:29:03,744 --> 00:29:05,679
如果是在桌面平台


606
00:29:05,746 --> 00:29:07,281
或游戏控制台工作过


607
00:29:07,347 --> 00:29:10,717
你可能已经有了
这种格式的资产


608
00:29:12,252 --> 00:29:14,288
这是我们的扩展
纹理支持


609
00:29:14,788 --> 00:29:17,291
我今天就
介绍这些功能


610
00:29:19,493 --> 00:29:21,094
我想换个话题


611
00:29:21,161 --> 00:29:22,296
谈谈一种


612
00:29:22,362 --> 00:29:24,331
名为app瘦身的
新技术


613
00:29:24,531 --> 00:29:26,400
在上次讲座中
大家可能听到过一些


614
00:29:27,668 --> 00:29:30,003
这不是Metal特有的
功能


615
00:29:30,337 --> 00:29:31,638
但是它是基于


616
00:29:31,705 --> 00:29:35,509
以前我在讲座中之前介绍的
GPU系列


617
00:29:36,710 --> 00:29:38,512
首先 设定上下文


618
00:29:39,146 --> 00:29:41,582
开发人员典型的游戏开发


619
00:29:41,648 --> 00:29:44,184
和开发流程
在我们的平台上


620
00:29:44,251 --> 00:29:45,419
基本是
这个样子


621
00:29:46,820 --> 00:29:48,522
你一般会有
艺术管道


622
00:29:48,589 --> 00:29:49,690
来生成部分资产


623
00:29:51,491 --> 00:29:53,594
资产是通过Xcode搭建


624
00:29:53,660 --> 00:29:55,295
或自定义工具管道


625
00:29:55,362 --> 00:29:56,697
是二进制格式


626
00:29:57,865 --> 00:29:59,466
然后二进制格式再


627
00:29:59,533 --> 00:30:01,435
发送到App Store的某处
这个具体的


628
00:30:02,236 --> 00:30:04,538
或是相同的二进制
要部署到


629
00:30:04,605 --> 00:30:08,642
你的所有用户的
设备中


630
00:30:09,309 --> 00:30:10,377
这样很好


631
00:30:11,478 --> 00:30:13,146
但是一旦开始有了
具备具体设备


632
00:30:13,213 --> 00:30:15,148
功能的资产


633
00:30:15,215 --> 00:30:18,385
就会开始遇到
一些问题


634
00:30:22,055 --> 00:30:23,724
例如


635
00:30:23,790 --> 00:30:25,659
如果
有些资产是专门针对


636
00:30:25,726 --> 00:30:26,960
Metal设备


637
00:30:27,027 --> 00:30:29,930
有些资产
是特别用于旧式设备


638
00:30:31,198 --> 00:30:33,700
现在必须要下载
两种版本


639
00:30:33,767 --> 00:30:36,103
以便用于所有的用户设备


640
00:30:37,971 --> 00:30:39,473
显然 这并不理想


641
00:30:41,942 --> 00:30:44,378
App瘦身可以通过
允许按照功能


642
00:30:44,444 --> 00:30:47,748
为资产贴标签 来解决这个问题


643
00:30:48,115 --> 00:30:50,751
这样只有
设备需要的资产


644
00:30:50,817 --> 00:30:54,421
才会真正
下载到设备中


645
00:30:55,923 --> 00:30:56,990
具体怎么做呢？


646
00:30:58,225 --> 00:30:59,593
app瘦身


647
00:30:59,860 --> 00:31:02,095ddle
可以实现


648
00:30:59,860 --> 00:31:02,095
可以实现


649
00:31:02,162 --> 00:31:06,166
跨越两级来定义功能


650
00:31:06,733 --> 00:31:08,368
即GPUFamily版本


651
00:31:08,435 --> 00:31:10,237
和
设备内存大小


652
00:31:10,304 --> 00:31:12,906
这就会生成一个矩阵
可以用来针对


653
00:31:12,973 --> 00:31:14,942
具体设备


654
00:31:18,512 --> 00:31:21,281
我们现在来看
典型的法线图实例


655
00:31:22,783 --> 00:31:25,752
理想状态下 你希望将
法线图压缩存储


656
00:31:26,520 --> 00:31:28,322
EAC是不错的
格式


657
00:31:29,523 --> 00:31:31,358
但是因为部分


658
00:31:31,425 --> 00:31:33,894
就是设备不支持压缩纹理


659
00:31:33,961 --> 00:31:36,163
特别是EAC
你可能需要


660
00:31:36,230 --> 00:31:38,565
该资产的
未压缩格式


661
00:31:40,667 --> 00:31:43,837
app瘦身可以
为资产加标签


662
00:31:43,904 --> 00:31:45,038
并仅下载


663
00:31:45,105 --> 00:31:48,509
压缩格式到支持Metal的设备上


664
00:31:48,575 --> 00:31:51,879
未压缩版本到
旧式设备中


665
00:31:52,746 --> 00:31:55,115
但是app瘦身
的功能还不仅如此


666
00:31:55,182 --> 00:31:56,750
我们来继续扩展实例


667
00:31:57,918 --> 00:31:59,786
它可以支持
更多设备


668
00:31:59,853 --> 00:32:02,456
具体在本例中
我们将生成5个资产


669
00:32:03,190 --> 00:32:06,660
我们先从高分辨率的
ASTC版本


670
00:32:07,327 --> 00:32:10,230
用于最强大的2GB设备


671
00:32:10,364 --> 00:32:13,500
然后 我们会包括
稍低的分辨率


672
00:32:13,734 --> 00:32:16,270
用于1GB版本的
设备


673
00:32:16,603 --> 00:32:20,007
因为部分Metal设备
并不支持ASTC


674
00:32:20,741 --> 00:32:22,476
我们也会包括
EAC版本


675
00:32:23,510 --> 00:32:25,879
然后 对于
旧式设备


676
00:32:25,946 --> 00:32:28,115
我们有未压缩
版本的资产


677
00:32:29,183 --> 00:32:31,818
我们可以把这个
实例进一步扩展


678
00:32:31,885 --> 00:32:35,989
通过最低未压缩
资产的较低


679
00:32:36,590 --> 00:32:39,359
分辨率的版本
用于较低端的设备


680
00:32:39,459 --> 00:32:40,561
512MB的配置


681
00:32:42,196 --> 00:32:44,598
你可能不希望
生成5个资产


682
00:32:45,098 --> 00:32:46,834
但是我想要
说明的一点是


683
00:32:46,900 --> 00:32:49,236
你有着极大的
灵活度来


684
00:32:49,303 --> 00:32:51,205
锁定具体设备


685
00:32:51,271 --> 00:32:54,041
为用户生成
最佳体验


686
00:32:56,643 --> 00:32:59,112
Xcode整合了
很好的UI 可以


687
00:32:59,179 --> 00:33:01,648ddle
这样来为资产加标签


688
00:32:59,179 --> 00:33:01,648
这样来为资产加标签


689
00:33:03,116 --> 00:33:04,718
首先需要做的是
定义你要


690
00:33:04,785 --> 00:33:07,654
锁定的
设备功能


691
00:33:09,256 --> 00:33:10,991
这会生成
小矩阵


692
00:33:11,491 --> 00:33:13,293
然后只需要


693
00:33:13,360 --> 00:33:14,995
留下资产


694
00:33:15,062 --> 00:33:18,332
以便与GPUFamily系列的


695
00:33:18,398 --> 00:33:21,235
相互交叉和
准备锁定的设备内存大小相匹配即可


696
00:33:22,970 --> 00:33:24,137
这非常简单


697
00:33:25,539 --> 00:33:26,740
但是 当然我们


698
00:33:26,807 --> 00:33:28,709
意识到并非所有的
开发人员都有


699
00:33:28,775 --> 00:33:31,144
存在于Xcode的工具管道


700
00:33:31,211 --> 00:33:33,080
所以我们也包括了这些


701
00:33:33,614 --> 00:33:36,450
我们支持app瘦身的
JSON文件格式


702
00:33:36,517 --> 00:33:40,320
以便明确
资产分类


703
00:33:41,288 --> 00:33:42,856
正如在Xcode一样


704
00:33:42,923 --> 00:33:45,359
你需要明确GPUFamily版本


705
00:33:46,193 --> 00:33:48,562
以及希望包含在
分类中的各资产的


706
00:33:48,629 --> 00:33:50,264
设备类型


707
00:33:53,934 --> 00:33:56,203
一旦将资产分类
定义完毕


708
00:33:56,970 --> 00:33:58,906
怎样在运行时间
获取数据呢？


709
00:34:00,807 --> 00:34:03,577
答案就是
NSDataAsset类


710
00:34:03,944 --> 00:34:06,680
它可以提供
与运行设备的


711
00:34:06,747 --> 00:34:09,248
功能相匹配的
资产


712
00:34:10,317 --> 00:34:13,286
通过NSDataAsset
很容易做到


713
00:34:14,688 --> 00:34:15,688
只要


714
00:34:16,989 --> 00:34:19,025
用赋予
资产分类的名称


715
00:34:19,092 --> 00:34:21,929
分配NSDataAsset
对象即可


716
00:34:22,529 --> 00:34:23,730
然后在数据中使用


717
00:34:25,465 --> 00:34:28,635
通过我开始展示的
示意图和法线图


718
00:34:28,969 --> 00:34:30,469
实例来把它
接合在一起


719
00:34:31,638 --> 00:34:33,774
在这种情况下
你的艺术家可以


720
00:34:33,841 --> 00:34:36,476
生成一系列法线图
部分压缩 部分未压缩


721
00:34:36,543 --> 00:34:38,110
锁定你想要的
具体设备


722
00:34:39,980 --> 00:34:42,549
可以通过Xcode
或自定义工具管道


723
00:34:42,616 --> 00:34:45,485
做成二进制格式
包括很多资产的


724
00:34:45,552 --> 00:34:48,522
庞大二进制格式
上传到App Store


725
00:34:49,523 --> 00:34:51,324
最棒的是


726
00:34:51,391 --> 00:34:53,025
只有用户所需的法线图


727
00:34:53,092 --> 00:34:56,295
才会下载到
他们的设备中


728
00:35:02,903 --> 00:35:04,338
这就是app瘦身


729
00:35:05,439 --> 00:35:08,408
我们认为 这将会
改变大家


730
00:35:08,475 --> 00:35:10,644
在支持Metal的设备上


731
00:35:11,111 --> 00:35:12,746
生成和部署内容的方法


732
00:35:14,781 --> 00:35:16,650
这就是在过去12个月间


733
00:35:16,717 --> 00:35:19,386
Metal生态系统


734
00:35:19,453 --> 00:35:20,621
的旋风之旅


735
00:35:21,188 --> 00:35:23,290
我们看到像诸位这样的
开发人员 使用Metal


736
00:35:23,357 --> 00:35:24,825
生成非常出色的内容


737
00:35:25,659 --> 00:35:27,828
我们将Metal带入了OS X


738
00:35:28,161 --> 00:35:31,832
我们也将所有出色的
Metal GPU工具带入OS X


739
00:35:33,333 --> 00:35:35,602
我们引入了部分强大的
新款API


740
00:35:35,969 --> 00:35:37,337
相信大家
一定会喜欢


741
00:35:38,372 --> 00:35:40,541
最后 我们谈到了
Metal怎样与


742
00:35:40,607 --> 00:35:43,810
系统相整合
通过app瘦身技术来实现


743
00:35:45,212 --> 00:35:47,514
总之 这是
相当不错的一年


744
00:35:47,581 --> 00:35:50,450
我们非常渴望
看到大家


745
00:35:50,951 --> 00:35:52,886
在来年能对Metal
有怎样的出色应用


746
00:35:55,355 --> 00:35:57,858
请来访问我们的
在线文档资料


747
00:36:00,093 --> 00:36:02,095
还可以到支持论坛
看看


748
00:36:02,162 --> 00:36:04,064
如果问题没有
得到解答 当然还可以


749
00:36:04,131 --> 00:36:07,034
联系我们的
游戏技术开发顾问


750
00:36:07,100 --> 00:36:09,102
阿兰·斯卡夫


751
00:36:10,504 --> 00:36:12,306
本周还有两场讲座


752
00:36:12,873 --> 00:36:15,742
《Metal技术最新内容》下半场


753
00:36:15,809 --> 00:36:17,311
安排在周四上午


754
00:36:17,377 --> 00:36:20,581
《Metal性能优化技术》
讲座则是


755
00:36:20,647 --> 00:36:22,015
在周五


756
00:36:22,082 --> 00:36:23,684
请务必要记得参加


757
00:36:24,117 --> 00:36:24,985
非常感谢

