1
00:00:20,220 --> 00:00:23,056
《有关On Demand Resources之简介》


2
00:00:23,123 --> 00:00:23,957
下午好


3
00:00:25,859 --> 00:00:29,029
欢迎来到今天关于On Demand
Resources的介绍会议


4
00:00:29,096 --> 00:00:30,364
我是史蒂夫·列瓦伦


5
00:00:30,764 --> 00:00:32,299
我们今天将给你们准备了些什么呢


6
00:00:32,366 --> 00:00:34,301
嗯 我们还是先给你们说说


7
00:00:34,368 --> 00:00:37,471
On Demand Resources
或者是ODR的大致情况


8
00:00:37,871 --> 00:00:41,909
我们来比较一下使用ODR App
与没有使用它的区别吧


9
00:00:43,010 --> 00:00:45,345
我们将为ODR开发人员
以及用户们


10
00:00:45,412 --> 00:00:48,448
列出ODR App的
所有特性和优势


11
00:00:49,650 --> 00:00:52,753
然后我们将
深入研究ODR的细节


12
00:00:53,020 --> 00:00:55,989
结构以及如何构建等问题


13
00:00:56,957 --> 00:00:59,993
接下来我们将给你演示
使用Xcode


14
00:01:00,360 --> 00:01:03,130
并将新的ODR API添加到库里


15
00:01:04,565 --> 00:01:09,670
最后 我们将演示
和构建最优ODR API的最佳实践


16
00:01:09,736 --> 00:01:11,338
并整理成一个小片段


17
00:01:12,172 --> 00:01:13,006
咱们开始吧


18
00:01:13,874 --> 00:01:16,510
我们得先理解


19
00:01:16,577 --> 00:01:20,013
传统App的进展状况
才能理解ODR的进展


20
00:01:20,514 --> 00:01:23,383
这个App现在将会有一个
可执行的部分


21
00:01:23,450 --> 00:01:27,087
这是编译好的Swift
Objective-C C++


22
00:01:27,354 --> 00:01:29,089
以及一些基础资料


23
00:01:29,523 --> 00:01:32,292
和游戏等级资料
例如 假设这是一个游戏


24
00:01:33,327 --> 00:01:36,163
当开发人员对这个游戏
或App感到满意


25
00:01:36,230 --> 00:01:37,798
于是你们上传到App Store里


26
00:01:38,632 --> 00:01:41,134
这样 用户可以购买
这个App或游戏


27
00:01:41,335 --> 00:01:42,836
然后他们得到整个程序


28
00:01:43,003 --> 00:01:44,605
并下载到设备上


29
00:01:45,138 --> 00:01:46,773
然而他们下载的东西
并不单单如此


30
00:01:47,040 --> 00:01:52,713
其中也包含开发人员为所有用户编写的
其他有趣的东西包括App和游戏


31
00:01:53,480 --> 00:01:55,949
他们其实是如此有趣


32
00:01:56,183 --> 00:02:00,954
人们下载得再多也
觉得不够而事实亦如此


33
00:02:01,021 --> 00:02:03,690
设备上没有足够多的空间


34
00:02:04,157 --> 00:02:05,325
因此我们怎么要做呢


35
00:02:05,792 --> 00:02:08,695
好吧 我们能做的就是
观察每个App


36
00:02:08,762 --> 00:02:11,632
发现并非每个部分都被使用


37
00:02:11,899 --> 00:02:12,733
我举个例子


38
00:02:12,799 --> 00:02:15,435
我的游戏级别是7级


39
00:02:15,802 --> 00:02:17,871
我肯定不想再待在1级


40
00:02:17,938 --> 00:02:20,941
而且长时间内
我可能也到不了30级


41
00:02:21,341 --> 00:02:22,509
如此一来


42
00:02:22,576 --> 00:02:24,845
我们就开始考虑ODR


43
00:02:25,145 --> 00:02:27,614
现在让我们来看ODR的
一个App吧


44
00:02:28,682 --> 00:02:29,650
在这种情况下


45
00:02:29,850 --> 00:02:31,318
我们开始使用相同的比特


46
00:02:31,385 --> 00:02:32,886
没有去掉任何东西


47
00:02:32,953 --> 00:02:35,122
但我们要做的是梳理


48
00:02:35,189 --> 00:02:37,257
每个游戏级别的资料


49
00:02:37,991 --> 00:02:40,160
然后我们将整个东西
上传到商店


50
00:02:40,794 --> 00:02:43,530
现在当客户购买这个App时


51
00:02:44,264 --> 00:02:46,300
他们得到可操作的基础资料


52
00:02:46,433 --> 00:02:48,535
也许有Level 1的游戏装备


53
00:02:49,236 --> 00:02:50,270
这不是双关语


54
00:02:50,337 --> 00:02:51,839
我们已经在游戏中了


55
00:02:51,905 --> 00:02:55,142
因为他们能闯过
游戏的Level 1


56
00:02:55,342 --> 00:02:57,878
购买和使用App与
Level 1的时间


57
00:02:57,945 --> 00:03:01,515
比那些下载整个App更快


58
00:03:01,849 --> 00:03:04,484
而且使用更少的磁盘空间


59
00:03:06,119 --> 00:03:08,188
用户现在开始玩这个游戏


60
00:03:08,655 --> 00:03:10,257
并开始玩Level 1


61
00:03:10,991 --> 00:03:13,327
一个设计良好的ODR App


62
00:03:13,393 --> 00:03:15,929
需要能预测
比如下一个等级


63
00:03:16,063 --> 00:03:17,564
因此 需要进行下载资料


64
00:03:18,332 --> 00:03:19,967
用户继续玩


65
00:03:20,033 --> 00:03:21,869
打到Level 2


66
00:03:22,402 --> 00:03:25,439
然后ODR内置的缓存机制


67
00:03:25,506 --> 00:03:27,608
通知你不再使用Level 2


68
00:03:27,674 --> 00:03:29,209
并且作上标记


69
00:03:29,643 --> 00:03:30,544
资料还在那儿


70
00:03:30,611 --> 00:03:31,545
我们什么都不用做


71
00:03:31,612 --> 00:03:34,548
只需要记住不再用它


72
00:03:34,615 --> 00:03:37,217
但会一直保留设备上


73
00:03:37,284 --> 00:03:38,886
这样空间就慢慢少了


74
00:03:38,952 --> 00:03:40,487
无法储存下一个级游戏


75
00:03:40,721 --> 00:03:43,991
我们检查设备上
其他可能释放资源的空间


76
00:03:44,057 --> 00:03:46,393
仅剩下这个游戏的...


77
00:03:46,660 --> 00:03:49,630
ODR内容 仅此而已


78
00:03:49,696 --> 00:03:50,631
在这种情况下


79
00:03:50,697 --> 00:03:53,534
缓存机制可以一步释放空间


80
00:03:53,600 --> 00:03:55,802
比如 我有1级的内容


81
00:03:55,869 --> 00:03:57,771
我可以将它释放


82
00:03:57,971 --> 00:04:00,073
这样然后用户可以
继续玩下一级游戏


83
00:04:00,641 --> 00:04:03,210
这是ODR的基本理念


84
00:04:03,277 --> 00:04:04,344
从游戏的购买


85
00:04:04,411 --> 00:04:07,548
到玩游戏时间更短


86
00:04:07,748 --> 00:04:10,217
占据设备空间更小


87
00:04:10,284 --> 00:04:11,752
更易于...


88
00:04:11,818 --> 00:04:12,653
管理


89
00:04:15,489 --> 00:04:18,591
现在让我们谈谈ODR


90
00:04:18,825 --> 00:04:20,527
为开发人员提供的所有亮点


91
00:04:21,495 --> 00:04:25,365
首先 这显然是一个
动态加载的内容体系


92
00:04:25,432 --> 00:04:27,868
你们可能已经使用过
这样的系统


93
00:04:27,935 --> 00:04:30,070
但是我们添加了一些新特性


94
00:04:30,671 --> 00:04:32,272
首先我们可以在App Store中


95
00:04:32,339 --> 00:04:34,408
储存该App的内容


96
00:04:35,342 --> 00:04:39,513
第二 我们可以在安装
和请求安装App时


97
00:04:39,680 --> 00:04:42,883
下载内容
事实上我们可以


98
00:04:43,784 --> 00:04:45,819
随时自动化...


99
00:04:46,053 --> 00:04:47,554
操作下载


100
00:04:49,389 --> 00:04:52,526
最后还包括我提到的
智能缓存机制


101
00:04:52,593 --> 00:04:53,427
正如刚刚提到的


102
00:04:53,894 --> 00:04:56,763
所以 我们可以腾出空间来


103
00:04:56,964 --> 00:04:58,232
加载新的东西


104
00:04:59,933 --> 00:05:00,968e
最后


105
00:04:59,933 --> 00:05:00,968
最后


106
00:05:01,468 --> 00:05:05,072
App Store传统App
最大是4千兆字节


107
00:05:05,906 --> 00:05:07,508
但是ODR App


108
00:05:07,574 --> 00:05:09,977
现在可以达到20千兆字节


109
00:05:10,544 --> 00:05:12,546
当然 这些大多数
都是ODR的内容


110
00:05:13,914 --> 00:05:14,748
好的


111
00:05:15,048 --> 00:05:16,149
因此 这是开发者的优势


112
00:05:16,216 --> 00:05:17,985
但对于用户的好处又是什么呢？


113
00:05:19,186 --> 00:05:21,288
首先 我们可以...


114
00:05:21,655 --> 00:05:23,557
改善安装体验


115
00:05:24,558 --> 00:05:27,094
一个传统的DLC系统


116
00:05:27,160 --> 00:05:28,695
使用该技术的游戏


117
00:05:29,029 --> 00:05:30,931
会有这样的体验


118
00:05:30,998 --> 00:05:32,199
用户下载App时


119
00:05:32,266 --> 00:05:34,735
他们都非常期待玩这个游戏


120
00:05:34,801 --> 00:05:35,636
他们启动游戏


121
00:05:35,736 --> 00:05:38,939
然后 不是吧
游戏还需要下载一些新的内容


122
00:05:39,439 --> 00:05:43,710
有了ODR 我们可以确保
新内容就在设备上


123
00:05:43,777 --> 00:05:45,612
App只是看上去已经安装而已


124
00:05:45,679 --> 00:05:48,649
因此用户体验会更好


125
00:05:50,083 --> 00:05:50,918
第二


126
00:05:51,318 --> 00:05:53,287
由于我们在设备上占用的
空间更小


127
00:05:53,353 --> 00:05:56,190
在任何时候都更容易管理


128
00:05:56,256 --> 00:05:58,358
App占用的空间小


129
00:05:58,425 --> 00:06:02,629
我们就可以
存放更多的App在设备上


130
00:06:02,696 --> 00:06:04,998
这对用户来说
永远都是一件好事


131
00:06:06,733 --> 00:06:08,435
最后
对于用户来说


132
00:06:08,635 --> 00:06:10,370
同样的
由于有更多的空间


133
00:06:10,437 --> 00:06:12,706
我们可以在App Store云端


134
00:06:12,940 --> 00:06:14,675
存储更多App或是游戏


135
00:06:15,642 --> 00:06:19,279
例如 我们可以有更丰富和
昂贵的游戏等级


136
00:06:19,580 --> 00:06:22,349
对于用户
同样是一件好事


137
00:06:23,717 --> 00:06:24,551
好的


138
00:06:25,052 --> 00:06:27,988
现在让我们深究
一些关于ODR的细节


139
00:06:29,289 --> 00:06:32,092
首先
对于IOS 9系统是应用瘦身


140
00:06:33,227 --> 00:06:36,063
而且可以很好地与应用分割兼容


141
00:06:36,129 --> 00:06:37,898
如果你错过了之前


142
00:06:37,965 --> 00:06:39,433
关于应用分割会议


143
00:06:39,499 --> 00:06:43,871
讨论如何将App 下载到
特定设备


144
00:06:44,404 --> 00:06:45,539
让我给你举一个例子


145
00:06:45,739 --> 00:06:46,640
你编写一个App


146
00:06:46,707 --> 00:06:49,943
目标是各种不同型号的
iPhone和iPad


147
00:06:50,711 --> 00:06:52,579
当iPhone用户来到


148
00:06:52,646 --> 00:06:53,881
购买App后


149
00:06:54,114 --> 00:06:57,284
应用分割可以确保
他们所得到的资源是必须的


150
00:06:57,351 --> 00:06:58,986
而且是适合该
iPhone版本的


151
00:06:59,520 --> 00:07:01,321
在此之前
用户会下载所有的


152
00:07:01,388 --> 00:07:03,257
包括适合iPad的资源


153
00:07:03,924 --> 00:07:06,860
因此 现在结合应用分割


154
00:07:07,160 --> 00:07:08,829
和ODR之后


155
00:07:08,896 --> 00:07:10,330
彼此双方都收益


156
00:07:10,397 --> 00:07:12,566
它占用的空间更小


157
00:07:12,733 --> 00:07:15,536
我们使App运行更快


158
00:07:15,669 --> 00:07:18,205
App持续稳定性更好


159
00:07:18,272 --> 00:07:20,474
在设备上占用的空间更小


160
00:07:21,909 --> 00:07:22,743
好的


161
00:07:23,644 --> 00:07:24,478
那么


162
00:07:25,145 --> 00:07:26,980
一个ODR App是什么样的呢


163
00:07:27,047 --> 00:07:27,915
它是如何构建的呢


164
00:07:28,182 --> 00:07:30,284
它与如今的App很类似


165
00:07:30,617 --> 00:07:31,451
但是


166
00:07:31,919 --> 00:07:35,923
他能够将游戏里的等级
和资料梳理开


167
00:07:36,423 --> 00:07:37,891
我们把这叫做资料包


168
00:07:38,659 --> 00:07:41,128
剩余的App
仍是你的 .app


169
00:07:41,995 --> 00:07:46,366
现在 运用Xcode
和简单的标签进行分组


170
00:07:46,433 --> 00:07:49,002
例如 这些是我在游戏
Level 1中的所有资料


171
00:07:49,069 --> 00:07:50,103
假设的说


172
00:07:50,437 --> 00:07:51,438
这非常容易设置


173
00:07:53,440 --> 00:07:56,109
你可以将它标记为简单的文件
或一整个文件夹


174
00:07:56,176 --> 00:07:58,612
例如 这是Level 2的
整个文件夹


175
00:08:00,147 --> 00:08:02,082
现在 你可以标记什么呢


176
00:08:03,250 --> 00:08:05,919
几乎.app里的任何东西都可以


177
00:08:06,386 --> 00:08:07,221
例如


178
00:08:07,654 --> 00:08:08,488
图像


179
00:08:08,922 --> 00:08:09,756
声音


180
00:08:10,357 --> 00:08:11,825
数据和文字


181
00:08:12,059 --> 00:08:13,594
很多有脚本的游戏


182
00:08:14,595 --> 00:08:17,030
同样还有App内购买的内容


183
00:08:17,097 --> 00:08:19,900
那么现在你可以
将程序内购买的物品


184
00:08:20,367 --> 00:08:22,636
和通过ODR下载的
实际购买的内容


185
00:08:22,703 --> 00:08:24,338
相结合起来


186
00:08:24,404 --> 00:08:26,473
利用其它ODR API


187
00:08:26,540 --> 00:08:27,574
实现管理


188
00:08:28,775 --> 00:08:30,911
唯一无法获得的是可执行内容


189
00:08:30,978 --> 00:08:34,448
即编译好的Swift
Objective-C、C、C++


190
00:08:34,581 --> 00:08:35,716
这些会留在 .app里


191
00:08:37,083 --> 00:08:37,918
好的


192
00:08:38,818 --> 00:08:39,653
那么


193
00:08:40,187 --> 00:08:41,788
这些内容将存储在哪里


194
00:08:42,389 --> 00:08:43,789
好的 我提出其中一个位置


195
00:08:43,857 --> 00:08:45,158
显然它是在App Store


196
00:08:46,226 --> 00:08:48,762
我们存储在App Store
并且按需供应


197
00:08:49,596 --> 00:08:52,733
但在开发过程中
Xcode代替了App Store


198
00:08:52,799 --> 00:08:55,569
无论你是针对
设备还是模拟器进行开发


199
00:08:55,903 --> 00:08:58,572
它存储在你的App中
并根据需求传输


200
00:09:00,040 --> 00:09:03,010
现在 Xcode的另一款工具是
Xcode服务器


201
00:09:03,510 --> 00:09:05,445
你可以把它设置在自己部门中


202
00:09:05,946 --> 00:09:09,750
这样可以获取服务器上的
ODR和App


203
00:09:09,816 --> 00:09:11,351
例如 按照你所安排的


204
00:09:11,418 --> 00:09:13,320
Q/A工程组测试你的App


205
00:09:15,222 --> 00:09:18,992
正如你所期望Test
Flight完全整合了ODR


206
00:09:20,027 --> 00:09:22,563
最后 假如你要为公司部署一款App


207
00:09:22,930 --> 00:09:26,800
实际上你可以在公司的
网络服务器上存储ODR内容


208
00:09:26,867 --> 00:09:28,569
并设置安全登录


209
00:09:28,635 --> 00:09:31,071
以确保不是所有人
都可以获取该内容


210
00:09:32,472 --> 00:09:34,174
这ODR内容的存储位置了


211
00:09:35,843 --> 00:09:36,677
好的


212
00:09:36,844 --> 00:09:38,245
那么 该如何开始的呢


213
00:09:38,779 --> 00:09:40,614
嗯 作为一个开发者
你要做的第一件事情是


214
00:09:40,681 --> 00:09:43,650
看看你所有的App资料


215
00:09:43,817 --> 00:09:45,185
并且识别它们


216
00:09:45,352 --> 00:09:46,720
你需要对它们进行分类


217
00:09:47,821 --> 00:09:50,657
再次重复 你可以
用简单的字符进行标记


218
00:09:51,024 --> 00:09:53,160
这些是我游戏
Level 1的所有资料


219
00:09:53,794 --> 00:09:55,829
这些是我游戏
Level 2的资料


220
00:09:55,929 --> 00:09:58,532
而且你知道
等级间有一些共享的资料吗


221
00:09:59,233 --> 00:10:00,067e
它们就在那里


222
00:09:59,233 --> 00:10:00,067
它们就在那里


223
00:10:00,133 --> 00:10:02,569
你可用多重标签标记资料


224
00:10:02,669 --> 00:10:06,206
以显示共享内容 防止重复


225
00:10:07,374 --> 00:10:10,444
这部分是为准备好使用ODR的人
设计的首个部分


226
00:10:10,511 --> 00:10:12,145
作为开发者 这是你的工作


227
00:10:12,246 --> 00:10:15,382
现在Xcode起作用了
它将所有这些标签


228
00:10:15,749 --> 00:10:17,451
和组放到资料包中


229
00:10:18,085 --> 00:10:20,754
在这个案例中
我们用三个资料包做结尾


230
00:10:21,655 --> 00:10:23,257
资料包1为Level 1


231
00:10:23,757 --> 00:10:25,359
资料包2为Level 2


232
00:10:25,659 --> 00:10:27,861
最后以介于资料包1和2之间


233
00:10:27,928 --> 00:10:30,130
的资料包3作结尾


234
00:10:30,731 --> 00:10:32,266
再一次
请避免重复


235
00:10:33,767 --> 00:10:36,136
好了 Xcode起作用了


236
00:10:36,203 --> 00:10:37,771
现在轮到开发者了


237
00:10:39,306 --> 00:10:40,974
首先你要做的是


238
00:10:41,041 --> 00:10:42,509
请求资料


239
00:10:42,609 --> 00:10:44,444
我需要Level 1的所有东西


240
00:10:45,045 --> 00:10:46,914
出来两个资料包


241
00:10:47,214 --> 00:10:49,449
都属于Level 1


242
00:10:49,683 --> 00:10:52,819
然后是介于Level 1
和Level 2之间的共享资料


243
00:10:53,320 --> 00:10:55,522
因为已经接入共享资料包


244
00:10:55,923 --> 00:10:57,324
在我们请求Level 2时


245
00:10:57,791 --> 00:10:58,792
我们得到这些资料


246
00:10:59,259 --> 00:11:01,528
而这些共享资料
也已经在我的设备上了


247
00:11:02,629 --> 00:11:06,600
以上是关于ODR概念以及


248
00:11:06,967 --> 00:11:09,069
如何建立一个ODR请求的概述


249
00:11:09,136 --> 00:11:10,971
现在 有请托尼·帕克上台


250
00:11:11,238 --> 00:11:13,807
为我们展示使用API Xcode中
发生了什么


251
00:11:13,874 --> 00:11:14,708
托尼


252
00:11:20,547 --> 00:11:21,381
谢谢你 史蒂芬


253
00:11:21,915 --> 00:11:25,018
我叫托尼·帕克
我是Apple Foundation组的经理


254
00:11:25,385 --> 00:11:28,689
史蒂芬为大家介绍了
ODR系统如何工作的基本信息


255
00:11:29,022 --> 00:11:31,191
现在我们将详细讲API


256
00:11:31,592 --> 00:11:34,027
即在你的App 中
实际用来处理这些请求的API


257
00:11:35,362 --> 00:11:37,497
关于API你必须知道这个


258
00:11:37,564 --> 00:11:41,535
这是Foundation中的新类叫
NS Bundle Resource Request


259
00:11:43,070 --> 00:11:45,472
这个类遵照命令设计模式


260
00:11:45,539 --> 00:11:48,609
意思是你将用一组选择
建立一个对象


261
00:11:49,076 --> 00:11:51,778
包括你喜欢用的标签


262
00:11:52,246 --> 00:11:54,181
随后你告诉它开始它的请求


263
00:11:56,450 --> 00:11:58,452
这样 你就可以按需创建对象了


264
00:11:58,719 --> 00:12:01,388
因为系统会参照
高级选项计算标签


265
00:12:02,089 --> 00:12:05,125
所以 如果有不同部分
使用ODR App


266
00:12:05,325 --> 00:12:07,427
且可能有重叠标签


267
00:12:07,761 --> 00:12:09,596
你就不需要每次都创建管理类


268
00:12:09,663 --> 00:12:11,465
跟踪你已经用过的那些


269
00:12:11,532 --> 00:12:13,133
我们将为你处理这些问题


270
00:12:15,936 --> 00:12:18,705
最重要的一点 即设计出发点是


271
00:12:19,006 --> 00:12:23,076
请求与实际资料利用
不挂钩


272
00:12:23,777 --> 00:12:26,313
意思是说
那些你已在App 中使用的


273
00:12:26,380 --> 00:12:28,682
以及你已经非常熟悉的API


274
00:12:28,749 --> 00:12:31,185
比如NS Bundle
URL For Resource


275
00:12:31,451 --> 00:12:33,887
包含URL内容的NS Data数据


276
00:12:33,954 --> 00:12:35,923
或UI Image
imageNamed


277
00:12:36,123 --> 00:12:38,425
这些API将保持不变


278
00:12:38,792 --> 00:12:40,594
你只需事先告诉系统


279
00:12:40,661 --> 00:12:42,262
使用一个请求对象


280
00:12:42,462 --> 00:12:44,765
告诉系统 这个对象里
的资料是你想显示的


281
00:12:47,701 --> 00:12:49,603
这个对象组成一个
非常简单的状态机


282
00:12:49,670 --> 00:12:51,205
从初始化开始


283
00:12:52,272 --> 00:12:53,740
在预估资料需求时


284
00:12:53,807 --> 00:12:56,143
我们跳转到请求状态


285
00:12:57,611 --> 00:12:59,813
我们回到结束处理器回调


286
00:12:59,880 --> 00:13:03,350
它将告诉我们
那些资料可以获得


287
00:13:03,884 --> 00:13:06,887
以及你可以继续使用
刚讨论的API


288
00:13:07,521 --> 00:13:08,922
或告诉我们发生的错误


289
00:13:09,156 --> 00:13:11,124
当然 在使用ODR时


290
00:13:11,191 --> 00:13:14,061
会有一些错误
这些需要告诉用户


291
00:13:14,361 --> 00:13:16,430
错误可能包括
我们需要下载内容


292
00:13:16,496 --> 00:13:18,198
但没有适用的网络


293
00:13:18,565 --> 00:13:20,767
或尽管已经做了清理


294
00:13:20,834 --> 00:13:23,170
设备里仍没有足够的空间
储存这些内容


295
00:13:23,604 --> 00:13:25,906
不管是什么情况
你都需要告诉用户


296
00:13:25,973 --> 00:13:27,875
或许他们有办法解决这些问题


297
00:13:28,809 --> 00:13:30,644
所以若有适用的资料


298
00:13:30,777 --> 00:13:32,980
就像我说的请继续使用它们


299
00:13:33,480 --> 00:13:36,483
同样重要的是当你用完这些资料


300
00:13:36,683 --> 00:13:37,818
请告诉我们


301
00:13:37,885 --> 00:13:39,686
你可以用这两种方法告诉我们


302
00:13:39,987 --> 00:13:42,990
第一种
在这个类中调用明确的API


303
00:13:43,257 --> 00:13:45,225
告诉我们你已经完成这个内容


304
00:13:46,026 --> 00:13:48,462
第二种 允许种类解除分配


305
00:13:48,529 --> 00:13:50,030
允许对象解除分配


306
00:13:50,430 --> 00:13:51,832
在这种情况下


307
00:13:51,899 --> 00:13:54,201
我们将为你结束请求


308
00:13:56,537 --> 00:13:58,138
这是基本方法


309
00:13:58,605 --> 00:14:00,040
首先 初始化程序


310
00:14:00,274 --> 00:14:02,109
你可看到这里有字符串


311
00:14:02,209 --> 00:14:04,478
这就是正在请求
你所感兴趣的标签


312
00:14:05,512 --> 00:14:07,047
开始请求的方法叫做


313
00:14:07,114 --> 00:14:11,151
beginAccessingResources
WithCompletionHandler


314
00:14:11,218 --> 00:14:12,452
你可看到有个结尾


315
00:14:12,519 --> 00:14:13,954
里面有NSR Error证据


316
00:14:15,189 --> 00:14:16,356
最后 这种方法


317
00:14:16,423 --> 00:14:17,691
会告诉系统请求完成完成


318
00:14:17,891 --> 00:14:20,661
明确
endAccessing Resources调用


319
00:14:22,596 --> 00:14:24,131
接下来 我将展示


320
00:14:24,198 --> 00:14:25,899
已经在运行中的API


321
00:14:34,341 --> 00:14:35,175
好了


322
00:14:35,309 --> 00:14:38,846
这是演示app 叫做iTravel


323
00:14:39,012 --> 00:14:41,882
之所以叫这个名字


324
00:14:42,216 --> 00:14:44,618
是因为它是一本旅行手册
提供所有你感兴趣的


325
00:14:44,685 --> 00:14:46,954
以字母i开头的国家信息


326
00:14:47,621 --> 00:14:50,457
你可以看到
今天用到的两个国家是


327
00:14:50,724 --> 00:14:52,459
冰岛和意大利


328
00:14:52,993 --> 00:14:54,328
现在 这个App是说明


329
00:14:54,394 --> 00:14:56,897
On Demand Resources
用法的很好的例子


330
00:14:56,964 --> 00:14:57,998
原因是...


331
00:14:58,065 --> 00:15:00,300
用户购买这个app时


332
00:15:00,534 --> 00:15:04,972
或许对获取冰岛和意大利的
信息并不感兴趣


333
00:15:05,305 --> 00:15:07,274
或至少不需要同时获得
两个信息


334
00:15:07,407 --> 00:15:09,543
所以 我们可以通过


335
00:15:09,610 --> 00:15:11,678
只下载所需内容


336
00:15:11,745 --> 00:15:13,480
以减小安装和下载大小


337
00:15:14,081 --> 00:15:15,482
在使用ODR之前


338
00:15:15,549 --> 00:15:18,085
我想要简单的展示一下
如何使用它


339
00:15:18,452 --> 00:15:20,587
首先访问冰岛


340
00:15:21,788 --> 00:15:24,725
你可以看到我在这里拿到
兴趣点清单


341
00:15:25,225 --> 00:15:26,793
我从中选择一个


342
00:15:27,227 --> 00:15:29,429
里面可能有些优质的图片


343
00:15:29,496 --> 00:15:30,964
或指南文本


344
00:15:31,265 --> 00:15:34,134
兴趣点清单里的每一点
都有不少图片


345
00:15:34,535 --> 00:15:36,904
你可以看到
这些增加了不少数据信息


346
00:15:39,573 --> 00:15:41,675
而意大利 也是一样的


347
00:15:42,042 --> 00:15:44,011
但是内容不同


348
00:15:46,813 --> 00:15:48,682
我们来看看如何创建这个App


349
00:15:51,852 --> 00:15:53,620
我们今天将花大量的时间
来讲一个类


350
00:15:53,687 --> 00:15:56,323
就是
Album TableViewController


351
00:15:56,390 --> 00:15:58,992
这是个视图控制器


352
00:15:59,059 --> 00:16:01,361
控制这个兴趣点清单中的视图


353
00:16:02,062 --> 00:16:03,297
让我来展示下它如何工作的


354
00:16:04,498 --> 00:16:06,166
当我们继续这个视图


355
00:16:06,400 --> 00:16:09,570
会有这个函数 叫做loadAlbum


356
00:16:09,636 --> 00:16:11,572
接下来的问题是
我们想看那个相册


357
00:16:11,638 --> 00:16:13,540
意大利或冰岛


358
00:16:14,842 --> 00:16:15,809
设置标题


359
00:16:15,876 --> 00:16:18,512
我们把这项辅助函数
叫做populateTable


360
00:16:19,146 --> 00:16:21,048
现在 在populateTable
函数里


361
00:16:21,148 --> 00:16:24,351
我们将使用
NSBundle´s URLForResource


362
00:16:24,551 --> 00:16:26,053
寻找JSON文件


363
00:16:26,119 --> 00:16:29,823
这个文件介绍所有兴趣点和清单
以显示题注


364
00:16:30,791 --> 00:16:33,594
我们使用NSData的
contentsOfURL方法


365
00:16:33,660 --> 00:16:35,229
从磁盘里读取JSON文件


366
00:16:35,629 --> 00:16:38,365
我们使用NSJSONSerialization
对其进行解析


367
00:16:38,465 --> 00:16:40,467
我们在这里
创建一些更详细标签文本


368
00:16:40,701 --> 00:16:42,669
最后重载tableView


369
00:16:43,070 --> 00:16:45,105
tableView里的数据源


370
00:16:45,172 --> 00:16:47,374
使用UI Image.imageNamed


371
00:16:47,441 --> 00:16:49,476
显示信息 获取图片


372
00:16:51,178 --> 00:16:52,746
重点是


373
00:16:53,013 --> 00:16:55,148
在这个App中使用ODR


374
00:16:55,449 --> 00:16:57,918
植入Table中的功能无需变动


375
00:16:58,318 --> 00:16:59,152
再说一次


376
00:16:59,219 --> 00:17:02,256
现在你用来获取磁盘中文件内容


377
00:17:02,456 --> 00:17:07,394
或找出像NSBundles这种文件
所用的所有API保持不变


378
00:17:09,396 --> 00:17:10,364
我们首先要做的是


379
00:17:10,430 --> 00:17:12,665
在App中增加一些标签


380
00:17:12,999 --> 00:17:16,069
做到这点
我将在这里创建检测点


381
00:17:16,803 --> 00:17:19,506
你可以看到
我已经处理过我的App


382
00:17:19,573 --> 00:17:22,041
里面有个叫Resources的组


383
00:17:22,409 --> 00:17:25,212
以及包含部分内容的文件夹


384
00:17:25,345 --> 00:17:28,048
这个包含所有冰岛的图片


385
00:17:28,715 --> 00:17:30,417
这个包含所有意大利的图片


386
00:17:31,285 --> 00:17:33,754
和我刚才讨论的这些JSON文件


387
00:17:35,489 --> 00:17:36,456
接下来 我将接续


388
00:17:36,523 --> 00:17:40,661
并为冰岛选择JSON文件
和文件夹


389
00:17:41,195 --> 00:17:43,764
并查看检测点的右边


390
00:17:44,097 --> 00:17:47,201
你可以看到这里有个新的叫
On Demand Resource标签


391
00:17:47,367 --> 00:17:49,269
所以我所需做的是开始打字


392
00:17:50,304 --> 00:17:52,506
内容将被标记为冰岛


393
00:17:53,106 --> 00:17:54,908
用同样的方法
处理意大利的内容


394
00:17:56,443 --> 00:17:57,644
内容 好了


395
00:17:59,580 --> 00:18:02,449
接下来我们只需 以便
当然了


396
00:18:02,516 --> 00:18:05,752
正如Steve说过的
告诉Xcode如何将你的内容分开


397
00:18:06,086 --> 00:18:07,554
现在 下一部分是


398
00:18:07,788 --> 00:18:09,289
告诉运行中的系统


399
00:18:09,590 --> 00:18:11,091
我们预计什么时间


400
00:18:11,158 --> 00:18:12,893
需要这些内容备好可用


401
00:18:13,293 --> 00:18:15,262
我们将在视图控制器中
进行操作


402
00:18:15,762 --> 00:18:18,899
首先我要在我的类中
增加一个I var


403
00:18:18,966 --> 00:18:20,400
以保存我们刚说的类


404
00:18:20,467 --> 00:18:22,803
NSBundleResourceRequest


405
00:18:23,003 --> 00:18:25,105
当视图控制器进行拆分时


406
00:18:25,172 --> 00:18:27,007
我现在要做的是充分利用


407
00:18:27,441 --> 00:18:30,143
我们很好地控制这个对象


408
00:18:30,210 --> 00:18:31,812
这样 我们可以控制使用时间


409
00:18:32,079 --> 00:18:34,314
当它完成拆分时
我们知道请求也完成了


410
00:18:34,381 --> 00:18:36,650
我们允许系统对其解除分配


411
00:18:36,717 --> 00:18:39,353
这将告诉系统
我们处理好内容了


412
00:18:41,221 --> 00:18:44,324
下一步 在loadAlbum函数
调用populateTable前


413
00:18:44,558 --> 00:18:45,526
我们将先...


414
00:18:45,826 --> 00:18:46,827
创建请求


415
00:18:46,994 --> 00:18:49,263
进入一组标签
在这个情况下


416
00:18:49,329 --> 00:18:51,865
进入意大利
或冰岛中的一组标签


417
00:18:53,200 --> 00:18:54,034
我们称之为


418
00:18:54,101 --> 00:18:56,937
beginAccessingResources
WithCompletionHandler


419
00:18:57,004 --> 00:18:57,971
结果出来后


420
00:18:58,038 --> 00:18:59,373
这个结尾将被调用


421
00:19:00,140 --> 00:19:01,808
或许会产生错误


422
00:19:02,142 --> 00:19:04,778
在主线程中 这个完成处理程序


423
00:19:04,845 --> 00:19:06,113
将在非主线程中被调用


424
00:19:06,480 --> 00:19:08,949
我们首先检查
并确保错误是0


425
00:19:09,316 --> 00:19:10,918
若不是0
那就是出现错误了


426
00:19:10,984 --> 00:19:12,252
正如我们先前所讨论的


427
00:19:12,319 --> 00:19:15,689
这需要告诉使用者
我将在辅助函数里进行操作


428
00:19:16,590 --> 00:19:20,360
然后调用刚使用过的
populateTable函数


429
00:19:20,661 --> 00:19:22,029
再一次
没有变动任何东西


430
00:19:22,729 --> 00:19:24,231
继续 并再一次运行App


431
00:19:24,298 --> 00:19:25,299
看看会是什么样的


432
00:19:30,070 --> 00:19:32,039
现在 我访问冰岛


433
00:19:32,306 --> 00:19:34,708
可以看到我的内容在这边


434
00:19:35,142 --> 00:19:36,810
因为我们已经做了请求


435
00:19:36,877 --> 00:19:39,680
我可以选择一些图片或兴趣点


436
00:19:40,047 --> 00:19:42,115
所有的内容都准备就绪了


437
00:19:42,182 --> 00:19:44,384
就好像从一开始它们就是
App的一部分一样


438
00:19:45,185 --> 00:19:48,088
现在我们为你展示
Xcode新调试特征


439
00:19:48,155 --> 00:19:49,690
若你以你认为的方式


440
00:19:49,990 --> 00:19:51,592
使用这些请求对象


441
00:19:51,658 --> 00:19:52,960
它将帮助你更好的进行理解


442
00:19:53,627 --> 00:19:55,095
即新的调试计量器


443
00:19:55,762 --> 00:19:57,731
我将把调试计量器视图
放在这里


444
00:19:57,798 --> 00:19:58,799
选择磁盘


445
00:19:59,299 --> 00:20:01,835
你可以看到
在中间我们有一个新部分


446
00:20:01,969 --> 00:20:03,537
叫做
On Demand Resources


447
00:20:03,604 --> 00:20:05,873
它列出你App中所有的标签


448
00:20:06,740 --> 00:20:07,975
比如冰岛和意大利


449
00:20:08,108 --> 00:20:09,209
他们的大小


450
00:20:09,409 --> 00:20:10,777
和现在的状态


451
00:20:11,211 --> 00:20:13,680
你看到冰岛的状态是在使用中


452
00:20:13,981 --> 00:20:15,115
这就说得通了


453
00:20:15,182 --> 00:20:17,284
因为我们在这里查看冰岛内容


454
00:20:17,651 --> 00:20:19,887
在我看部分图片时
它保持使用中的状态


455
00:20:20,320 --> 00:20:22,556
但若我回到主内容目录


456
00:20:22,789 --> 00:20:25,626
它的状态由使用中变为已下载


457
00:20:25,926 --> 00:20:28,295
因为请求对象已解除
系统知道我们


458
00:20:28,562 --> 00:20:31,465
不再使用这些内容了


459
00:20:32,966 --> 00:20:35,702
我们并未立即
从磁盘中删除信息


460
00:20:35,769 --> 00:20:37,771
所以当你回到冰岛时
内容仍旧可用


461
00:20:38,005 --> 00:20:40,040
它的状态也变成使用中


462
00:20:41,141 --> 00:20:43,076
让我们看看访问意大利时
会出现什么


463
00:20:45,679 --> 00:20:47,414
现在
你看到需要花一些时间


464
00:20:47,648 --> 00:20:48,982
内容才会出来


465
00:20:49,449 --> 00:20:52,252
原因是...


466
00:20:52,419 --> 00:20:56,190
意大利标签远比冰岛的大


467
00:20:56,256 --> 00:20:57,691
有130兆字节


468
00:20:58,392 --> 00:21:00,994
这里需要做两件很重要的事


469
00:21:01,228 --> 00:21:05,465
首先需要减小标签内容大小


470
00:21:05,532 --> 00:21:07,401
将其分成小的组块


471
00:21:07,701 --> 00:21:10,838
随后我们会详细说明


472
00:21:11,305 --> 00:21:12,940
现在
我想要告诉你


473
00:21:13,006 --> 00:21:16,410
如何使用App中的进度报告


474
00:21:16,743 --> 00:21:17,578
并配合使用


475
00:21:17,644 --> 00:21:20,013
NS Bundle Resource Request


476
00:21:20,080 --> 00:21:23,383
这样在你下载内容时
就可以告诉用户一些信息


477
00:21:23,450 --> 00:21:25,519
以帮助他们理解接下来
会发生什么


478
00:21:27,254 --> 00:21:28,789
让我们回到


479
00:21:29,456 --> 00:21:32,559
AlbumTableViewController类


480
00:21:35,996 --> 00:21:37,764
接下来要做的是利用


481
00:21:37,831 --> 00:21:40,701
支持NS Progress的
NSBundleResourceRequest的优势


482
00:21:40,767 --> 00:21:41,869
这是个基础类


483
00:21:41,935 --> 00:21:47,207
你可在你的App中
用它来报告进程和构建进程


484
00:21:48,475 --> 00:21:50,844
NS Progress支持键值观察


485
00:21:51,211 --> 00:21:55,282
所以我们要做的是增加
视图控制器作为进度的观察点


486
00:21:55,649 --> 00:21:57,284
并更新


487
00:21:57,651 --> 00:22:00,387
改变屏幕上部分UI
一个UI进度视图


488
00:22:00,454 --> 00:22:02,055
并对一些详细标签文本
做出反应


489
00:22:03,724 --> 00:22:06,360
这里 在创建请求后


490
00:22:06,827 --> 00:22:08,795
调用addObserver


491
00:22:09,129 --> 00:22:10,464
这类将是观察者


492
00:22:11,098 --> 00:22:14,301
请求的进度属性
正是我们观察的对象


493
00:22:15,602 --> 00:22:18,338
进度中的关键路径是
fractionCompleted


494
00:22:18,872 --> 00:22:20,607
和往常一样 使用KVO时


495
00:22:20,841 --> 00:22:23,277
指定唯一的内容指示器很重要


496
00:22:23,577 --> 00:22:25,212
这个我已经在文件的某处
进行定义


497
00:22:25,979 --> 00:22:29,516
我将继续并显示一个
UI progressView


498
00:22:29,583 --> 00:22:31,752
这个进度视图已经
连接到我的故事板中


499
00:22:33,353 --> 00:22:36,757
当收到回应
就可以移除Observer了


500
00:22:36,823 --> 00:22:40,727
因为之后
我们不在对更新的进度感兴趣了


501
00:22:41,395 --> 00:22:45,132
然后在主线程中
我们将继续显示...


502
00:22:45,199 --> 00:22:47,467
不好意思
是继续隐藏UI 进程视图


503
00:22:47,534 --> 00:22:50,304
因为我们不想要用户
盯着完整的进度指示器一直看


504
00:22:50,971 --> 00:22:54,208
所以我们本身也是观察点


505
00:22:54,274 --> 00:22:55,309
随后在第二部分


506
00:22:55,375 --> 00:22:58,345
在数值变化时 采取一些行动


507
00:22:58,545 --> 00:23:00,480
这里采取的是传统的KVO方法


508
00:23:00,647 --> 00:23:02,649
observeValueForKeyPath


509
00:23:02,716 --> 00:23:03,884
首先需要检查


510
00:23:03,951 --> 00:23:07,087
通过检查内容指示器
和关键路径


511
00:23:07,154 --> 00:23:09,556
确保那就是我们感兴趣的
观察更新


512
00:23:10,057 --> 00:23:11,892
在主线程中 再一次


513
00:23:11,959 --> 00:23:14,461
因为更新将在非主线程中出现


514
00:23:14,528 --> 00:23:18,665
我们将通过设置进度属性
更新UI进度视图


515
00:23:18,832 --> 00:23:23,370
我们将通过使用它的
localizedDescription方法


516
00:23:23,437 --> 00:23:26,540
充分利用自动局部描述的
NS Progress支持


517
00:23:28,842 --> 00:23:30,644
让我们继续 并再次运行
看看它将如何工作


518
00:23:36,483 --> 00:23:38,485
所以这次 当我访问意大利时


519
00:23:38,619 --> 00:23:41,522
你可以看到在详细标签文本
底部已经更新


520
00:23:41,588 --> 00:23:45,359
可以显示完成百分比
随后 一旦下载完成


521
00:23:45,425 --> 00:23:48,161
UI进度视图将告诉用户


522
00:23:48,228 --> 00:23:49,263
已经发生的变化


523
00:23:50,163 --> 00:23:52,566
所以 再一次 我们并不着急
删掉这些内容


524
00:23:52,633 --> 00:23:54,568
这样当我们再次返回
访问意大利时


525
00:23:54,835 --> 00:23:56,737
你可以看到内容立马就显示了


526
00:23:57,171 --> 00:24:00,574
因为这些内容已经存储在
On Demand Resources系统中


527
00:24:02,009 --> 00:24:03,310
现在回到幻灯片


528
00:24:11,251 --> 00:24:13,654
关于展示中
进度报告部分的一些东西


529
00:24:14,121 --> 00:24:15,689
所以 再一次 通过查看进度


530
00:24:15,756 --> 00:24:18,992
你可以找到请求进度的信息


531
00:24:19,860 --> 00:24:23,197
我们同样支持取消 暂停


532
00:24:23,263 --> 00:24:24,965
重新开始请求
这些方法本身并不是请求


533
00:24:25,032 --> 00:24:27,401
它们可在NSProgress中找到


534
00:24:29,536 --> 00:24:32,539
现在 事实上在iOS 9
和 OS X 10.11中


535
00:24:32,606 --> 00:24:34,808
Foundation中
NSProgress类


536
00:24:34,875 --> 00:24:36,643
我们已经做了很多重大改进


537
00:24:37,077 --> 00:24:38,612
想知道如何使用它们


538
00:24:38,812 --> 00:24:42,616
如何大规模的将这类整合
到你的App


539
00:24:42,950 --> 00:24:43,917
和其他地方


540
00:24:43,984 --> 00:24:46,687
真的建议你
关注周五的演讲


541
00:24:46,753 --> 00:24:48,555
《进度报告的最佳范例》


542
00:24:51,225 --> 00:24:53,360
在内容还未准备就绪之前


543
00:24:53,627 --> 00:24:56,930
beginAccessing方法
将继续运行并下载内容


544
00:24:57,364 --> 00:24:58,799
然后 有时候你只想


545
00:24:58,866 --> 00:25:01,001
使用磁盘中已经有的内容


546
00:25:01,068 --> 00:25:02,302
不想再进行下载


547
00:25:02,669 --> 00:25:05,205
你可以使用假定请求做到这点


548
00:25:05,906 --> 00:25:06,773
方法如下


549
00:25:06,840 --> 00:25:10,010
conditionallyBeginAccessing
ResourcesWithCompletionHandler


550
00:25:10,077 --> 00:25:10,911
你可看到


551
00:25:11,178 --> 00:25:13,013
这里的结尾有布尔参数


552
00:25:13,080 --> 00:25:14,781
所以不管是是还是否


553
00:25:14,882 --> 00:25:17,150
答案取决于内容可用还是不可用


554
00:25:18,018 --> 00:25:21,121
所以根据状态机


555
00:25:21,355 --> 00:25:22,723
我们从初始化开始


556
00:25:23,323 --> 00:25:25,325
通过调用这个方法


557
00:25:25,392 --> 00:25:26,560
进入假定请求状态


558
00:25:27,194 --> 00:25:29,663
不管它是否可用
你都将得到回应


559
00:25:29,897 --> 00:25:32,165
若可用 资料也将可用


560
00:25:32,232 --> 00:25:33,667
就好像你已经调用了其他方法


561
00:25:33,734 --> 00:25:36,803
所以 再一次 确认调用
endAccessingResources


562
00:25:36,870 --> 00:25:38,438
或允许对象解除分配


563
00:25:38,872 --> 00:25:41,141
若不可用
此时你可以做选择


564
00:25:41,208 --> 00:25:42,209
你可以...


565
00:25:42,910 --> 00:25:43,744
什么都不做


566
00:25:43,810 --> 00:25:46,847
也可以调用
beginAccessingResources方法


567
00:25:46,914 --> 00:25:47,981
进行下载


568
00:25:50,017 --> 00:25:54,955
最后 我讲讲此类中
API两个优先权


569
00:25:55,122 --> 00:25:56,757
第一个叫做加载优先权


570
00:25:57,090 --> 00:25:58,625
这个是双重的


571
00:25:58,692 --> 00:26:02,162
它为你的App中
未解决的请求排序


572
00:26:02,663 --> 00:26:04,064
数值为从0到1


573
00:26:04,231 --> 00:26:06,867
所以数值1指最高优先权


574
00:26:06,934 --> 00:26:08,602
数值0指最低优先权


575
00:26:09,136 --> 00:26:10,804
当我们处理这些数值时


576
00:26:10,904 --> 00:26:15,709
它将提示系统哪个未解决的
请求应该优先处理


577
00:26:16,176 --> 00:26:19,112
因为数值只在
你的app中进行比较


578
00:26:19,179 --> 00:26:21,515
并未在系统中的App进行比较


579
00:26:21,615 --> 00:26:23,450
你可利用这些数值


580
00:26:23,517 --> 00:26:26,053
根据你的需要对请求进行排序


581
00:26:27,487 --> 00:26:29,423
这里有个常量可以使用


582
00:26:29,489 --> 00:26:31,491
它叫做紧急装载优先权


583
00:26:32,593 --> 00:26:34,761
当用户只需等待下载完成
而无需做其他事时


584
00:26:34,828 --> 00:26:36,430
就可以使用这个常量


585
00:26:36,697 --> 00:26:38,198
随后我们会详细讲到这点


586
00:26:40,200 --> 00:26:42,636
第二种优先权叫做保存优先权


587
00:26:43,136 --> 00:26:47,140
这个方法指的是
在app中未使用的标签清除排序


588
00:26:47,207 --> 00:26:49,209
这里并不需要特别的请求


589
00:26:49,276 --> 00:26:51,578
这是它成为NSBundle
延伸功能的原因


590
00:26:51,879 --> 00:26:54,681
由一个标签
或一组标签进行替代


591
00:26:55,082 --> 00:26:57,084
数值范围从0到1


592
00:26:57,384 --> 00:26:59,586
0数值表示最不需要保存


593
00:26:59,686 --> 00:27:01,388
1数值表示最需要保存


594
00:27:02,256 --> 00:27:05,125
所以在碰到磁盘存储空间问题时


595
00:27:05,192 --> 00:27:07,461
你可通过它告诉系统


596
00:27:07,861 --> 00:27:10,364
哪些数值最需要保存


597
00:27:10,797 --> 00:27:13,634
只在你自己的App中进行比较


598
00:27:13,700 --> 00:27:15,769
而不是在系统的App中进行比较


599
00:27:17,104 --> 00:27:18,906
以上就这些
有请史蒂芬上台


600
00:27:18,972 --> 00:27:21,341
说说使用ODR的最佳范例


601
00:27:23,810 --> 00:27:24,645
谢谢你 托尼


602
00:27:28,282 --> 00:27:31,485
好的 现在我们对ODR
有了整体的了解


603
00:27:31,552 --> 00:27:33,820
我们知道它是什么
并观看了如何使用它


604
00:27:34,254 --> 00:27:38,192
现在来说说
我们如何建立最佳ODR app


605
00:27:38,825 --> 00:27:41,695
现在开始对资料做标签之前


606
00:27:41,762 --> 00:27:44,798
首先需要考虑你的app的反应


607
00:27:45,232 --> 00:27:48,368
因为这将告诉你对资料做标签
需做到哪种程度


608
00:27:48,869 --> 00:27:51,605
关于你可能如何使用ODR内容


609
00:27:51,672 --> 00:27:54,308
这里我可以提供三种模式


610
00:27:55,142 --> 00:27:58,712
第一种模式
这个就像托尼的iTravel app


611
00:27:59,046 --> 00:28:02,282
我们无法预测用户将去哪里


612
00:28:02,716 --> 00:28:04,051
这是随机访问


613
00:28:04,484 --> 00:28:05,986
在随机访问app中


614
00:28:06,053 --> 00:28:09,590
特别是资料比较大的时候


615
00:28:09,656 --> 00:28:12,759
你想要的内容标记了很多资料


616
00:28:12,826 --> 00:28:14,328
并逐步读取


617
00:28:14,394 --> 00:28:16,530
所以一旦用户做出决定


618
00:28:16,830 --> 00:28:18,599
他们立即就可以在UI中


619
00:28:18,665 --> 00:28:20,367
看到那个决定的部分进度


620
00:28:21,435 --> 00:28:24,471
第二种模式叫做有限预测


621
00:28:24,538 --> 00:28:27,875
某种程度上来说
这就像开放式世界游戏


622
00:28:28,308 --> 00:28:32,012
它可能是无穷种可能性


623
00:28:32,079 --> 00:28:35,082
在具体时间点时
它只是有限的子集


624
00:28:35,148 --> 00:28:37,117
再次 你要做的是


625
00:28:37,184 --> 00:28:40,454
拥有许多标签
标记比少的内容


626
00:28:40,721 --> 00:28:42,222
逐步读取


627
00:28:42,289 --> 00:28:45,359
也需要准备好放弃那些


628
00:28:45,526 --> 00:28:48,262
用户选择不看的内容


629
00:28:48,328 --> 00:28:52,399
比如 就像游戏玩家
在世界范围移动


630
00:28:52,466 --> 00:28:54,468
他们离开一些地方一样


631
00:28:54,535 --> 00:28:55,636
你需停止使用索引资料


632
00:28:55,702 --> 00:28:58,672
去掉
NSBundleResourceRequest对象


633
00:28:59,706 --> 00:29:02,843
现在 第三种模式是
已经在我例子中使用的模式


634
00:29:02,910 --> 00:29:04,111
就是游戏中的等级


635
00:29:04,178 --> 00:29:06,280
这是直线型进度式游戏


636
00:29:06,346 --> 00:29:08,081
就像第一人称的射击游戏


637
00:29:08,448 --> 00:29:09,550
在这个案例中


638
00:29:09,616 --> 00:29:11,752
作为一名开发者


639
00:29:11,818 --> 00:29:15,522
你最大的任务是
提早预估下一步需求


640
00:29:16,023 --> 00:29:17,591
但是你非常肯定


641
00:29:17,658 --> 00:29:19,593
所有的内容都是必要的


642
00:29:19,660 --> 00:29:21,595
所以你将只开始加载那些


643
00:29:21,662 --> 00:29:26,567
在一定合理时间内
可被加载的内容


644
00:29:26,633 --> 00:29:27,467
好了


645
00:29:27,901 --> 00:29:29,169
说到时间


646
00:29:29,236 --> 00:29:32,206
这里有个插曲
讲到你如何使用ODR API


647
00:29:32,272 --> 00:29:34,041
所以我们给自己一个时间线


648
00:29:34,107 --> 00:29:36,977
即从app开始到退出


649
00:29:38,011 --> 00:29:40,180
现在 设计合理的ODR App


650
00:29:40,247 --> 00:29:43,250
应该可以很好的
提早预测需求资料


651
00:29:43,851 --> 00:29:45,285
请记住 这是网络型app


652
00:29:45,352 --> 00:29:47,321
它将必须从App Store


653
00:29:47,487 --> 00:29:49,456
或我们刚检查过的其他地方下载


654
00:29:49,590 --> 00:29:50,691
但这需要花些时间


655
00:29:51,291 --> 00:29:53,427
因此 在需要使用资料的时候


656
00:29:53,560 --> 00:29:56,897
且当调出
beginAccessing Resources


657
00:29:56,964 --> 00:29:58,532
如果还未安装到设备上


658
00:29:58,899 --> 00:30:00,767
那么会自动开始下载


659
00:30:01,969 --> 00:30:05,806
当前 这是善用网络资源


660
00:30:05,873 --> 00:30:08,475
和解决资料尚未准备就绪


661
00:30:08,542 --> 00:30:11,411
就需要使用的最佳办法


662
00:30:12,012 --> 00:30:14,848
而且 在这种情况下
你可以通过进度属性


663
00:30:14,982 --> 00:30:17,618
和NS Bundle
Resource Request


664
00:30:17,684 --> 00:30:19,219
加快托尼之前提到的进度UI


665
00:30:19,686 --> 00:30:22,689
分享一下屏幕
同时让下载继续进行


666
00:30:23,056 --> 00:30:25,292
这时候 已经完成下载了


667
00:30:25,592 --> 00:30:27,361
资料已经准备就绪


668
00:30:27,427 --> 00:30:28,962
你可以关闭下载界面


669
00:30:29,196 --> 00:30:31,064
然后开始使用资料了


670
00:30:31,932 --> 00:30:33,767
一旦资料使用完毕


671
00:30:33,834 --> 00:30:37,271
你们绝对会想要调出
endAccessingResources


672
00:30:37,671 --> 00:30:41,275
或者允许NS Bundle
Resource Request对象解除分配


673
00:30:41,441 --> 00:30:43,544
以便让系统知道你已经使用完毕


674
00:30:44,011 --> 00:30:47,214
另外 这不代表我们会关闭服务
并删除记录


675
00:30:47,281 --> 00:30:48,582
我们只是在这里提醒大家而已


676
00:30:49,349 --> 00:30:52,119
因此
这是需要清楚的基本时间线


677
00:30:52,186 --> 00:30:54,788
并且你们还可以同时发出多个请求


678
00:30:55,389 --> 00:30:57,891
只需要记得本部分的基本内容即可


679
00:30:58,659 --> 00:30:59,493le
好的


680
00:31:00,727 --> 00:31:01,562
现在


681
00:31:01,628 --> 00:31:03,664
我已经谈了ODR


682
00:31:03,730 --> 00:31:06,900
如何通过改善其安装体验
而提高用户体验


683
00:31:07,768 --> 00:31:09,203
因此 具体怎么完成呢？


684
00:31:09,269 --> 00:31:10,871
我们需要大家的帮助


685
00:31:11,738 --> 00:31:12,840
作为开发者


686
00:31:12,906 --> 00:31:14,975
你们需要做的是考虑用户


687
00:31:15,042 --> 00:31:17,644
在登录到app后所需要的资料


688
00:31:18,712 --> 00:31:21,248
当你们了解是什么之后
比如游戏Level 1


689
00:31:21,415 --> 00:31:22,316
已经准备就绪


690
00:31:22,683 --> 00:31:24,084
然后你们需要设置资料标签


691
00:31:24,151 --> 00:31:28,555
并放到Xcode的
初始安装标签UI


692
00:31:29,823 --> 00:31:31,959
这会通知ODR系统去确认


693
00:31:32,025 --> 00:31:33,994
所有资料的标签...


694
00:31:34,127 --> 00:31:35,295
在app被...


695
00:31:36,129 --> 00:31:38,432
完全安装好之前


696
00:31:38,498 --> 00:31:40,968
可以被下载


697
00:31:41,034 --> 00:31:43,103
这样 当显示完全安装好之后


698
00:31:43,170 --> 00:31:45,005
用户点击标签后就准备就绪了


699
00:31:45,072 --> 00:31:46,306
这时候准备开玩了


700
00:31:46,740 --> 00:31:49,776
在App Store看到的
App的大小


701
00:31:50,077 --> 00:31:52,212
是 .app大小


702
00:31:52,713 --> 00:31:56,450
以及初始ODR内容的大小之和


703
00:31:56,683 --> 00:31:58,018
因此 需要明白这点


704
00:31:58,085 --> 00:31:59,987
此外 我们将在之后会谈谈这点


705
00:32:00,787 --> 00:32:03,457
好的那么 现在我们可以谈谈


706
00:32:03,524 --> 00:32:05,292
自动化安装app和ODR内容


707
00:32:05,359 --> 00:32:10,297
但此时用户还未实际登录


708
00:32:10,430 --> 00:32:12,933
因为你们也可以
自动设定这段时间


709
00:32:13,534 --> 00:32:16,503
可以这么做
以确保游戏的Level 2


710
00:32:16,570 --> 00:32:19,439
或者教程之类可以开始下载


711
00:32:19,506 --> 00:32:21,708
也许某些用户想要看看教程


712
00:32:21,775 --> 00:32:22,809
其他人不会想看


713
00:32:22,876 --> 00:32:26,446
因此你应当确保app
即使没有教程


714
00:32:26,747 --> 00:32:28,182
也能够实际运行教程


715
00:32:28,248 --> 00:32:29,516
但是最好还是确保有教程


716
00:32:29,783 --> 00:32:30,884
为了这么做


717
00:32:31,552 --> 00:32:34,788
你们还可以使用Xcode
的资料标签UI


718
00:32:34,855 --> 00:32:38,592
然后将标签放进
预取标签命令部分


719
00:32:38,992 --> 00:32:41,261
在你放到该部分的命令顺序


720
00:32:41,328 --> 00:32:43,463
是实际上下载这些标签的顺序


721
00:32:44,765 --> 00:32:45,599
好的


722
00:32:46,867 --> 00:32:48,735
现在谈谈缓存


723
00:32:48,802 --> 00:32:50,437
我们之前提到缓存


724
00:32:50,504 --> 00:32:52,005
而且还展示了系统是


725
00:32:52,406 --> 00:32:55,876
如何为新等级腾出
Level 1的空间


726
00:32:56,710 --> 00:32:59,746
首先 需要了解的是
我们会清理内容


727
00:32:59,813 --> 00:33:01,782
但只在系统内存占用度
不高的情况进行


728
00:33:02,583 --> 00:33:06,086
另外 也只有ODR内容会被清理


729
00:33:07,020 --> 00:33:08,689
当我们这么做的时候


730
00:33:08,856 --> 00:33:11,692
这里有几个属性会发挥作用


731
00:33:11,758 --> 00:33:14,094
通知我们是否要


732
00:33:14,494 --> 00:33:17,364
删除哪个资料包


733
00:33:18,465 --> 00:33:19,499
很明显


734
00:33:20,067 --> 00:33:22,336
是删除上次使用的那个资料包


735
00:33:22,402 --> 00:33:23,303
因此 如果...


736
00:33:23,670 --> 00:33:25,873
玩游戏Level 1的时候是
上周周二


737
00:33:26,373 --> 00:33:30,244
那么 很可能会在前一天
完成Level 1的时候就被删除


738
00:33:32,145 --> 00:33:35,215
另外 正如托尼之提到的保留优先权


739
00:33:35,282 --> 00:33:37,518
这指的是对标签设置
的优先级


740
00:33:37,985 --> 00:33:40,821
因此 这是你自己的排序
我们也会加以考虑


741
00:33:42,589 --> 00:33:45,492
最后 我们会考虑
app的运行状态


742
00:33:45,993 --> 00:33:48,662
我们不会在资料包
正在使用的情况下


743
00:33:48,962 --> 00:33:51,131
删除运行中的app的
任何资料包


744
00:33:53,934 --> 00:33:56,870
现在有几种策略


745
00:33:57,137 --> 00:33:59,206
用于保留ODR内容


746
00:33:59,907 --> 00:34:02,109
其中之一是避免过度清理


747
00:34:02,543 --> 00:34:03,744
什么意思呢？


748
00:34:03,810 --> 00:34:05,045
我可以举个例子


749
00:34:05,379 --> 00:34:07,881
比如说系统需要100 MB空间


750
00:34:08,681 --> 00:34:09,949
那么系统在进行整机搜索


751
00:34:10,016 --> 00:34:11,618
然而没有找到够大的空间


752
00:34:12,452 --> 00:34:14,955
通过我们刚提及的属性


753
00:34:15,522 --> 00:34:17,224
系统会定位到你的资料包


754
00:34:17,291 --> 00:34:19,659
容量为512 MB


755
00:34:20,561 --> 00:34:22,429
我需要清理资料包


756
00:34:22,496 --> 00:34:23,797
以符合空间要求


757
00:34:24,031 --> 00:34:27,266
因此 我们需要
过度清理412MB


758
00:34:27,768 --> 00:34:30,337
所以你的资料包体积
最好是小一点


759
00:34:30,603 --> 00:34:33,040
正如我刚提及的 这也有好处


760
00:34:33,106 --> 00:34:35,909
因为想要快点下载好
而且享用内容


761
00:34:36,275 --> 00:34:38,078
因此体积越小就越好


762
00:34:38,212 --> 00:34:40,781
但是体积越小就越不容易被过度清理


763
00:34:42,748 --> 00:34:43,583
好的


764
00:34:44,351 --> 00:34:46,553
另一件你们可能想做的是


765
00:34:46,887 --> 00:34:49,790
对任何事设置1.0的优先权


766
00:34:50,324 --> 00:34:51,925
但这么做并无卵用


767
00:34:52,259 --> 00:34:55,195
这么做只会让系统认为


768
00:34:55,262 --> 00:34:57,397
更多的资料重要性是相等的


769
00:34:57,531 --> 00:35:00,300
特别是当系统在对app
进行清理的情况下


770
00:35:00,601 --> 00:35:03,437
因此 需要谨慎使用优先权设置


771
00:35:06,306 --> 00:35:08,108
最后请再次确认


772
00:35:08,175 --> 00:35:10,143
因为当你做完标注我们会看


773
00:35:10,410 --> 00:35:14,581
上次endAccessingResources
的使用日期


774
00:35:14,915 --> 00:35:18,051
确认允许NS Bundle
Resource Request对象


775
00:35:18,185 --> 00:35:19,520
尽快解除分配


776
00:35:19,820 --> 00:35:22,389
这会让系统知道
你将如何使用该资料


777
00:35:22,456 --> 00:35:24,258
这样系统会给出最佳决策


778
00:35:26,293 --> 00:35:28,195
好的
现在 我想开始谈谈


779
00:35:28,262 --> 00:35:30,330
性能方面的事情


780
00:35:31,498 --> 00:35:34,568
其中之一是我们在
本次会议想做的事


781
00:35:34,635 --> 00:35:38,939
是鼓励大家
提前在后台下载内容


782
00:35:40,040 --> 00:35:42,543
但是我们不想要让大家


783
00:35:43,010 --> 00:35:46,313
浪费更太多的系统资源


784
00:35:46,613 --> 00:35:48,081
超过app所能容纳的资源


785
00:35:48,582 --> 00:35:51,785
因此 我们平衡了
下载速度 资源


786
00:35:51,852 --> 00:35:53,086
CPU和其他属性


787
00:35:53,153 --> 00:35:55,022
这样我们只有在下载
和使用资料包的时候


788
00:35:55,088 --> 00:35:56,456
才会消耗系统资源


789
00:35:57,224 --> 00:35:58,058
这是预设情况


790
00:35:58,492 --> 00:36:01,762
但如果有需要
或者想要自行进行管理


791
00:36:01,828 --> 00:36:03,797
或者想要完全手动操作


792
00:36:03,864 --> 00:36:05,866
那么你可以在这里设置紧急优先


793
00:36:06,400 --> 00:36:08,435
系统会忽略平衡设置


794
00:36:08,502 --> 00:36:11,038
我们将会以最快速度下载内容


795
00:36:11,638 --> 00:36:15,542
正如托尼提到的
当你提供载入画面时


796
00:36:15,976 --> 00:36:17,177
那时候就是设置的好时机


797
00:36:17,611 --> 00:36:20,948
但实际上你的App
可能与CPU不兼容


798
00:36:21,014 --> 00:36:23,283
与我们在系统这样操作情况一样


799
00:36:24,451 --> 00:36:25,586
因此 这完全取决于你


800
00:36:27,821 --> 00:36:29,022
而且


801
00:36:29,223 --> 00:36:31,191
我们应该讨论性能测试


802
00:36:32,392 --> 00:36:35,362
你需要为ODR的App做
现世测试


803
00:36:35,629 --> 00:36:38,165
ODR App是一个
基于网络的App


804
00:36:38,832 --> 00:36:41,001
因此当你使用USB将你的设备


805
00:36:41,068 --> 00:36:43,904
连接到你的MacBook Pro


806
00:36:43,971 --> 00:36:44,972
并运行Xcode


807
00:36:45,038 --> 00:36:47,975
那不是真实的场景


808
00:36:48,041 --> 00:36:49,142
真是太快了


809
00:36:49,910 --> 00:36:51,144
所以你要做的是


810
00:36:51,445 --> 00:36:56,216
使用TestFlight或Xcode
服务器来测试你的App


811
00:36:57,518 --> 00:37:01,989
然后使用Developer Tools
Network Link Conditioner


812
00:37:02,689 --> 00:37:05,259
来测试各种网络条件


813
00:37:06,059 --> 00:37:08,362
你的App在ODR内容下载时


814
00:37:08,529 --> 00:37:10,564
可能会出问题


815
00:37:11,064 --> 00:37:12,999
事实上
我建议你在任何网络App上


816
00:37:13,066 --> 00:37:14,868
使用这个工具


817
00:37:14,935 --> 00:37:15,769
真的很好用


818
00:37:15,836 --> 00:37:17,271
如果之前你还没有使用过它


819
00:37:17,337 --> 00:37:19,439
那我现在做个简短说明


820
00:37:20,140 --> 00:37:21,675
当你把你的...


821
00:37:22,109 --> 00:37:23,243
设备通过USB连接到


822
00:37:23,310 --> 00:37:25,279
MacBook Pro上
运行Xcode时


823
00:37:25,546 --> 00:37:27,314
然后设置设备时候会看到这个条目


824
00:37:27,381 --> 00:37:29,583
一个开发者条目


825
00:37:29,883 --> 00:37:32,586
你点击后会看到大量的


826
00:37:32,653 --> 00:37:38,825
开发者设置
您可以使用日志等等


827
00:37:38,892 --> 00:37:41,762
中间有Network
Link Conditioner


828
00:37:42,162 --> 00:37:43,530
点击你看到的选项


829
00:37:43,897 --> 00:37:45,165
您可以看到


830
00:37:45,232 --> 00:37:47,501
你可以用来造成App断网时的


831
00:37:47,568 --> 00:37:51,839
各种情况的... 各选择


832
00:37:52,239 --> 00:37:56,009
要用它 启用Network
Link Conditioner


833
00:37:56,210 --> 00:37:59,012
然后决定你想要创建
什么类型的情况


834
00:37:59,413 --> 00:38:02,015
也许你想模仿100%的无网络状态


835
00:38:02,316 --> 00:38:03,851
或非常缓慢的网络


836
00:38:04,384 --> 00:38:07,154
或者高延时DNS查找


837
00:38:07,654 --> 00:38:10,591
或者你只是想重创
非常糟糕的网络


838
00:38:11,258 --> 00:38:15,696
这便是使用ODR App的最佳工具


839
00:38:17,364 --> 00:38:18,198
好的


840
00:38:18,699 --> 00:38:20,200
说到网络问题


841
00:38:20,267 --> 00:38:24,605
你可能会遇到几个网络错误


842
00:38:25,005 --> 00:38:26,173
其中一个


843
00:38:26,240 --> 00:38:27,741
没有网络


844
00:38:27,975 --> 00:38:31,078
如果你的App需要ODR内容
却没有网络


845
00:38:31,211 --> 00:38:33,714
那么你需要准备好处理这种情况


846
00:38:35,048 --> 00:38:38,719
您可能遇到的另一个问题
是资源不可用


847
00:38:38,785 --> 00:38:41,488
这基本上意味着
我们认为ODR的内容


848
00:38:41,555 --> 00:38:43,557
在一个特定的位置
然而不是那么回事儿


849
00:38:44,091 --> 00:38:47,227
一般的原因 例如在公司内部


850
00:38:47,294 --> 00:38:50,130
建立自己的服务器并有人管理


851
00:38:50,197 --> 00:38:52,366
移动服务器文件等


852
00:38:52,533 --> 00:38:55,702
但是还没准备好
让用户使用App


853
00:38:56,170 --> 00:38:58,172
所以要随时准备应对错误发生


854
00:38:59,907 --> 00:39:02,442
另一类错误可能会遇到


855
00:39:03,510 --> 00:39:05,012
就是存储空间有关的问题


856
00:39:06,280 --> 00:39:07,814
所以ODR在任何时候


857
00:39:07,881 --> 00:39:12,786
将允许你有最大的2G的应用空间


858
00:39:13,453 --> 00:39:15,489
这意味着你的App
正在运行的时候


859
00:39:15,689 --> 00:39:19,126
你已经调用标签2G的


860
00:39:19,459 --> 00:39:22,396
beginAccessingResources


861
00:39:22,696 --> 00:39:25,532
用完后却没调用
endAccessingResources


862
00:39:25,599 --> 00:39:28,702
你不允许NS Bundle
Resource Request


863
00:39:28,769 --> 00:39:30,304
进行终止处理


864
00:39:30,604 --> 00:39:32,339
所以占用2G空间


865
00:39:32,673 --> 00:39:34,241
然后你又去启动另一个请求


866
00:39:34,441 --> 00:39:36,944
你会再次得到一个请求错误


867
00:39:37,010 --> 00:39:37,845
回叫反馈


868
00:39:38,312 --> 00:39:39,646
所以要注意


869
00:39:41,348 --> 00:39:44,718
当然我们可能在
本地存储在设备上


870
00:39:44,785 --> 00:39:46,753
遇到空间不足的情况


871
00:39:46,820 --> 00:39:48,188
你就会收到通知


872
00:39:48,822 --> 00:39:51,158
这可能是因为你下载太多


873
00:39:51,225 --> 00:39:55,128
或者你发出该下载请求太久


874
00:39:55,762 --> 00:39:57,497
所以还是需要随时准备
处理这些问题


875
00:39:57,564 --> 00:39:59,333
这时候你可以采取一些处理步骤


876
00:39:59,399 --> 00:40:00,234
你可以停止任何


877
00:40:00,300 --> 00:40:03,504
不再需要的ODR内容的
Accessing Resources


878
00:40:04,671 --> 00:40:06,840
另外 你可以看看本地设备上
储存的是什么资料


879
00:40:06,907 --> 00:40:08,642
也许是一些缓冲数据


880
00:40:08,709 --> 00:40:10,444
或者一些已不在需要用到的文件


881
00:40:10,878 --> 00:40:12,946
你可以清理一下并进行删除


882
00:40:15,949 --> 00:40:17,885
那么 现在我们来谈谈蜂窝数据


883
00:40:18,852 --> 00:40:21,588
再次说明ODR App
是一款网络型应用


884
00:40:22,189 --> 00:40:25,025
因此需要使用到蜂窝数据开关


885
00:40:25,893 --> 00:40:28,028
用于控制其他App的网络连接


886
00:40:28,262 --> 00:40:30,097
因此 如果关闭开关


887
00:40:30,163 --> 00:40:32,165
那么就不能获取到ODR文件


888
00:40:33,467 --> 00:40:36,737
如果开启开关
并且你正在下载ODR内容


889
00:40:37,171 --> 00:40:39,773
那么通过蜂窝数据下载的任何数据


890
00:40:39,940 --> 00:40:42,843
将算是该App产生网络数据


891
00:40:43,577 --> 00:40:45,812
因此 我们鼓励大家一定确保


892
00:40:45,879 --> 00:40:48,415
什么是所需的 什么是不再需要的


893
00:40:49,016 --> 00:40:50,884
我们不希望用户
产生高额的网络费用


894
00:40:53,153 --> 00:40:54,021
最后


895
00:40:54,421 --> 00:40:56,123
100MB的蜂窝下载限制


896
00:40:56,190 --> 00:40:58,292
仍适用于ODR App 


897
00:40:58,926 --> 00:41:01,395
因此 要确认.app本身


898
00:41:01,461 --> 00:41:02,930
和初始ODR的数据


899
00:41:02,996 --> 00:41:05,666
是否超过App Store的
App体积限制


900
00:41:06,033 --> 00:41:08,135
如果超过100 MB


901
00:41:08,335 --> 00:41:10,704
那么你的App不会
通过蜂窝数据下载


902
00:41:10,771 --> 00:41:12,506
正如一般的App
超过100 MB的话


903
00:41:12,573 --> 00:41:14,174
就不会通过蜂窝数据下载一样


904
00:41:15,209 --> 00:41:16,043
因此


905
00:41:16,210 --> 00:41:18,645
需要注意App的大小


906
00:41:20,914 --> 00:41:24,017
最后 正如前面所说


907
00:41:24,084 --> 00:41:26,687
你们还需要注意一些
重要的统计数据


908
00:41:27,888 --> 00:41:29,022
首先


909
00:41:29,556 --> 00:41:32,025
虽然App Store现在可以储存


910
00:41:32,492 --> 00:41:35,162
超过20G的ODR App 


911
00:41:35,429 --> 00:41:37,030
但是对于.app而言...


912
00:41:37,965 --> 00:41:39,833
只有最高2g的空间


913
00:41:39,900 --> 00:41:41,335
那么 你的
.app本身如何呢？


914
00:41:41,401 --> 00:41:43,504
请记得
当我们分解.app中的资料时


915
00:41:43,570 --> 00:41:45,472
我们分解的资料包
那么.app本身呢？


916
00:41:45,572 --> 00:41:48,008
.app最高可以有2G


917
00:41:48,275 --> 00:41:50,878
剩下的ODR内容可以有20G


918
00:41:52,813 --> 00:41:58,018
另外 初始ODR和预取ODR内容
最高也是2G


919
00:41:58,085 --> 00:42:00,387
该内容是我们在
Xcode的UI中设置的


920
00:42:01,121 --> 00:42:04,758
用于在App安装过程中
和后续过程中下载数据


921
00:42:04,992 --> 00:42:06,593
你最高可以有2GB


922
00:42:06,827 --> 00:42:08,629
合起来 2GB


923
00:42:10,531 --> 00:42:12,399
正如我刚刚所说


924
00:42:12,466 --> 00:42:15,035
只能在同一时间使用最高2G


925
00:42:16,837 --> 00:42:18,705
最后 给定的资料包


926
00:42:19,039 --> 00:42:21,341
最高可以有512MB


927
00:42:22,743 --> 00:42:25,379
因此 如果使用一个标签
标记一堆资料


928
00:42:25,546 --> 00:42:29,716
且提及超过512M
那么Xcode将发出警告


929
00:42:29,783 --> 00:42:33,320
但是Xcode会允许你继续
开发App或者游戏


930
00:42:33,754 --> 00:42:36,623
但是当你提交到
App Store之时


931
00:42:36,924 --> 00:42:39,560
会收到提交失败的错误信息
并解释原因


932
00:42:41,395 --> 00:42:44,531
好的 总结一下
On Demand Resources


933
00:42:44,598 --> 00:42:47,034
是一款动态加载内容系统


934
00:42:47,835 --> 00:42:49,369
服务器在App Store之中


935
00:42:50,137 --> 00:42:51,438
这样可以允许app...


936
00:42:51,672 --> 00:42:55,242
在安装期间自动和在有要求提出下
下载其内容


937
00:42:56,210 --> 00:42:58,445
你可以对下载内容设置优先级


938
00:42:59,746 --> 00:43:01,181
我们有了智能缓冲机制


939
00:43:01,248 --> 00:43:06,553
因此当我们等级提升后
会为后面的级别腾出空间


940
00:43:07,387 --> 00:43:09,489
在App Store有
20G的空间供你使用


941
00:43:10,991 --> 00:43:14,461
因此 如果想知道更多信息
我们有关于ODR一份新文件


942
00:43:15,128 --> 00:43:16,296
还有简单的代码


943
00:43:17,030 --> 00:43:19,633
以及开发者论坛可为你答疑解惑


944
00:43:20,367 --> 00:43:21,468
如果你仍有疑问


945
00:43:21,535 --> 00:43:24,137
你可以联系我们的
App Frameworks专员


946
00:43:24,972 --> 00:43:26,740
如果你错过了


947
00:43:26,940 --> 00:43:30,611
关于ODR大会等其他技术的大会


948
00:43:31,144 --> 00:43:35,249
你可以到开发者网站去观看视频


949
00:43:35,883 --> 00:43:36,717
接下来


950
00:43:37,050 --> 00:43:40,754
会有一场托尼在星期五所说的
关于ODR进程


951
00:43:41,788 --> 00:43:45,726
和实验的大会
时间是明天11点到1点30


952
00:43:45,993 --> 00:43:49,329
托尼和我以及
ODR工程组将出席会议


953
00:43:49,396 --> 00:43:51,064
回答你们的任何疑问


954
00:43:51,131 --> 00:43:52,900
帮助你们开始使用ODR内容


955
00:43:53,800 --> 00:43:55,769
并听取大家的建议


956
00:43:56,670 --> 00:43:57,504
非常感谢

