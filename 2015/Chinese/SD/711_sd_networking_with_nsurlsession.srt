1
00:00:26,326 --> 00:00:29,730
《网络与NSURL会话》


2
00:00:32,299 --> 00:00:33,133
早上好！


3
00:00:34,101 --> 00:00:37,204
感谢您来到
《网络与NSURL会话》会议


4
00:00:37,704 --> 00:00:40,274
我是盧克·卡斯
我是一个CF网络组的工程师


5
00:00:40,641 --> 00:00:42,809
今天早上我为与
会的各位罗列了一些很棒的东西


6
00:00:44,578 --> 00:00:47,514
首先
我们要讲一些应用程序传输安全问题


7
00:00:48,148 --> 00:00:52,219
接着我们会讲在NSURL会话中
添加了哪些新的协议


8
00:00:54,121 --> 00:00:56,123
周一我们看到了WatchOS的发布


9
00:00:56,557 --> 00:01:01,662
我们将会介绍为WatchOS
添加的NSURL会话功能


10
00:01:02,029 --> 00:01:05,632
之后我们会梳理一下API有哪些变化


11
00:01:05,632 --> 00:01:07,534
以及我们在NSURL会话中
添加了哪些新功能


12
00:01:09,636 --> 00:01:15,475
首先我想要讲一下NSURL会话
和HTTP协议的背景


13
00:01:16,176 --> 00:01:18,779
NSURL会话是一个网络API


14
00:01:18,846 --> 00:01:23,650
主要用于从网站
下载内容或者HTTP内容


15
00:01:25,052 --> 00:01:27,154
它包含很多委托方法


16
00:01:27,387 --> 00:01:32,025
可以用来认证或者
处理一些其他的重要事情


17
00:01:32,626 --> 00:01:35,362
NSURL会话有一个非常强大的功能


18
00:01:35,662 --> 00:01:38,298
那就是它允许你的程序


19
00:01:38,365 --> 00:01:44,438
在没有后台下载API的情况下
做网络层任务


20
00:01:46,106 --> 00:01:48,709
如果你对NSURL会话不熟悉的话


21
00:01:49,042 --> 00:01:51,612
建议你可以回顾一下


22
00:01:51,945 --> 00:01:55,983
几年前的WWDC会议中
对NSURL会话的介绍


23
00:01:58,252 --> 00:02:01,522
现在让我们讨论一下超文本传输协议


24
00:02:01,755 --> 00:02:05,659
这是一个非常有名的协议
你们中的很多人可能都很熟悉


25
00:02:06,860 --> 00:02:11,365
基本上其核心就是
你向服务器发送请求


26
00:02:11,565 --> 00:02:14,401
然后你会拉回一个数据包作为回应


27
00:02:15,202 --> 00:02:18,338
现在HTTP其本身


28
00:02:19,540 --> 00:02:23,577
你们中间有些人可能知道发送的是明码
所以其从根本上来讲就不安全


29
00:02:24,912 --> 00:02:26,146
在今天的网络环境中


30
00:02:26,680 --> 00:02:32,653
有很多攻击团体追踪你的APP数据
并将其发布到网络上


31
00:02:38,492 --> 00:02:42,362
曾经有一段时间单独使用明码HTTP
这是完全合理的


32
00:02:42,729 --> 00:02:44,598
但是这段时间已经过去


33
00:02:45,232 --> 00:02:46,600
现在我们所有人都是幸运的


34
00:02:46,667 --> 00:02:50,904
这个问题在多年以前就被解决


35
00:02:51,104 --> 00:02:52,873
就是HTTPS


36
00:02:56,343 --> 00:03:01,048
但HTTPS本质上
是HTTPS的上一层协议


37
00:03:01,114 --> 00:03:02,749
属于传输层安全协议


38
00:03:03,417 --> 00:03:06,653
传输层安全协议会通过公钥密码学方式


39
00:03:07,120 --> 00:03:09,857
进行一个多点的信号交换之后


40
00:03:10,257 --> 00:03:11,792
会创建一个安全的连接


41
00:03:12,726 --> 00:03:16,797
这种连接的安全性
是基于三个属性来讲


42
00:03:17,564 --> 00:03:21,134
第一 从你的APP发出


43
00:03:21,568 --> 00:03:24,271
并在网络上传输的数据是加密过的
所以其不可读


44
00:03:25,138 --> 00:03:28,041
第二 其提供了消息完整性参数


45
00:03:28,675 --> 00:03:31,111
所以消息在检测之前是不可以修改的


46
00:03:31,912 --> 00:03:34,815
最后第三点 它支持身份验证


47
00:03:35,082 --> 00:03:38,552
所以你可以验证
到底是谁在和你会话


48
00:03:43,023 --> 00:03:47,528
现在NSURL会话
有非常好的HTTPS嵌入性支持


49
00:03:48,061 --> 00:03:51,098
通常在你的客户端代码中


50
00:03:51,398 --> 00:03:54,034
这就像使用HTTPS
代替HTTP一样简单


51
00:03:54,935 --> 00:03:58,038
现在请注意
需要一些额外的服务器支持


52
00:03:58,605 --> 00:04:02,075
但HTTPS是大多数服务器
供应商都支持的


53
00:04:04,211 --> 00:04:05,412
还请记住


54
00:04:06,880 --> 00:04:09,550
大多数数据都应该被标记为敏感数据


55
00:04:10,551 --> 00:04:13,287
那是因为即使你认为


56
00:04:13,921 --> 00:04:17,991
你在网络上传输的数据
并不属于敏感数据


57
00:04:18,825 --> 00:04:21,728
但是事实上
你的客户可能认为它是敏感数据


58
00:04:21,995 --> 00:04:24,631
假如你有一个TV流APP


59
00:04:26,099 --> 00:04:27,968
你可能认为这只是一个电视


60
00:04:28,101 --> 00:04:30,404
你知道吗？他只是看电视


61
00:04:30,771 --> 00:04:34,141
他或她仅仅是看电视
但是对他们来说...


62
00:04:36,610 --> 00:04:39,179
他们事实上并不想
让人们知道他们在看什么电视


63
00:04:39,246 --> 00:04:40,247
让我们用这种方式解释


64
00:04:42,950 --> 00:04:46,587
现在为什么说
使用HPPTS如此重要？


65
00:04:46,954 --> 00:04:49,089
事实上从本质上来讲


66
00:04:49,423 --> 00:04:52,359
你的客户相信你
能够保证他们的数据和个人隐私


67
00:04:53,527 --> 00:04:56,597
在Apple
我们非常想要和你们一起努力


68
00:04:56,597 --> 00:04:59,867
并确保我们能够
建立并维持这种信任关系


69
00:05:00,234 --> 00:05:03,570
所以今天我非常自豪能够介绍
App Transport Security


70
00:05:05,239 --> 00:05:07,941
App Transport Security


71
00:05:08,208 --> 00:05:12,012
是Apple在IOS 9和OS X
和EI旗舰版中的一个新功能


72
00:05:12,846 --> 00:05:19,720
从本质上来讲其核心是防止
用户的个人隐私数据被意外泄露


73
00:05:22,122 --> 00:05:26,193
现在ATS也加强了
NSURL会话的默认方法


74
00:05:27,327 --> 00:05:29,863
可以在默认设置下
最重要的增强的方面


75
00:05:30,831 --> 00:05:33,433
就是现在的NSURL会话


76
00:05:33,734 --> 00:05:36,270
它不允许明码HTTP进行加载


77
00:05:36,637 --> 00:05:38,772
它将只使用HPPTS连接


78
00:05:39,439 --> 00:05:42,509
现在这种连接方式
确实是当下最可靠且最好的实现方法


79
00:05:43,210 --> 00:05:46,213
所以ATS对TLS的版本进行了限制


80
00:05:47,014 --> 00:05:52,753
密码组合 信任证书 证书密钥的大小
等都是被作为限制条件


81
00:05:54,555 --> 00:05:58,825
现在ATS能很容易地通过应用程序的
Info.plist进行配置


82
00:05:59,693 --> 00:06:00,961
这里有一个例子


83
00:06:02,162 --> 00:06:07,601
事实上我们让你做的就是
声明你在应用程序中有目的的网络行为


84
00:06:10,838 --> 00:06:16,376
核心上来讲
ATS希望你能描述使用网络做什么


85
00:06:16,710 --> 00:06:21,648
我们真心希望你能够放心
你的应用程序安全问题


86
00:06:21,982 --> 00:06:23,617
并且做事情的时候更加信赖这个系统


87
00:06:23,917 --> 00:06:28,822
当网络交易是安全的时候
这些都是最简单的事情


88
00:06:30,757 --> 00:06:34,962
所以 如果你的程序只使用安全的连接


89
00:06:35,162 --> 00:06:37,264
并且其只使用最佳安全属性


90
00:06:37,931 --> 00:06:40,968
那么你就不需要做任何事情
来为你的应用程序配置ATS


91
00:06:42,936 --> 00:06:46,406
因此 如果你在编写一个新的应用程序
这就是我们想要你做的事情


92
00:06:47,241 --> 00:06:50,043
如果你有一个现成的应用程序
或者有一段遗留代码


93
00:06:50,511 --> 00:06:52,579
这就是你应该注意的地方


94
00:06:55,048 --> 00:07:00,554
现在我们明白实际情况
可能并不总是这样


95
00:07:00,554 --> 00:07:06,493
假如你有一个服务器可以遵守
这些TLS版本或者密码套件的新限制


96
00:07:06,960 --> 00:07:11,131
所以我们允许例外情况的出现


97
00:07:11,532 --> 00:07:14,968
事实上你可以通过ATS声明异常原因


98
00:07:16,003 --> 00:07:18,605
让我们知道你想
使用什么版本的TLS


99
00:07:18,605 --> 00:07:21,675
或者你也可以选择正向保密
或者其他的选项


100
00:07:24,011 --> 00:07:27,881
我们理解现存的程序可能有不同的限制


101
00:07:29,783 --> 00:07:32,686
假设大多数情况下你都使用安全连接


102
00:07:33,387 --> 00:07:35,322
但是特殊情况下


103
00:07:36,523 --> 00:07:41,228
你可能会使用一些并不支持HTTPS
或者最佳实践的服务器


104
00:07:42,095 --> 00:07:44,298
假如你有一个多媒体服务器


105
00:07:44,598 --> 00:07:47,367
它并不支持HTTPS
只支持HTTP


106
00:07:47,801 --> 00:07:52,039
你能够很方便地用异常来描述这种情况


107
00:07:53,273 --> 00:07:57,811
基本上所有你需要做的事情就是
声明哪些域名需要加载HTTP


108
00:07:58,145 --> 00:08:01,248
NSURL仍然允许明码加载


109
00:08:05,452 --> 00:08:09,122
现在我们了解到你们中一些人
可能会支持使用一个通用的网页浏览器


110
00:08:09,189 --> 00:08:12,993
或者一个基于
动态用户输入加载URL的程序


111
00:08:13,527 --> 00:08:14,962
现在我们已经允许了这种情况


112
00:08:15,395 --> 00:08:21,134
在这种情况下
你不可能提前描述的安全连接的种类


113
00:08:21,602 --> 00:08:25,606
所以你可以简单地
选择声明允许所有的方法


114
00:08:26,740 --> 00:08:28,709
现在这个允许所有的方法


115
00:08:29,576 --> 00:08:35,381
能够允许NSURL会话加载
任何的HTTP或者HTTPS资源


116
00:08:36,616 --> 00:08:40,087
我相信这是目前互联网上现有的工具中


117
00:08:40,520 --> 00:08:42,222
一个非常有用的调试工具


118
00:08:42,655 --> 00:08:44,725
所以我们希望


119
00:08:44,858 --> 00:08:48,829
如果你用它做调试
可以对显而易见的原因进行临时调试


120
00:08:51,498 --> 00:08:52,833
现在即使你就处于这种状态


121
00:08:52,833 --> 00:08:56,470
你仍然能够保护特定的服务器和域


122
00:08:57,771 --> 00:08:59,673
如果你的设置的是允许所有


123
00:08:59,907 --> 00:09:04,511
但是如果你有一个
用来拉取配置数据和元数据的服务器


124
00:09:05,179 --> 00:09:08,649
并且用ATS来做调试
这种情况是个例外


125
00:09:09,616 --> 00:09:13,153
当你对一种例外情况
进行允许所有的设置时


126
00:09:13,754 --> 00:09:16,056
只需要简单地声明
想要保护的域就行了


127
00:09:16,657 --> 00:09:23,030
这样允许NSURL会话 继续通过
只加载HTTPS或者最优方法


128
00:09:23,730 --> 00:09:25,265
来保护这些资源


129
00:09:29,069 --> 00:09:29,903
现在


130
00:09:30,771 --> 00:09:32,539
从周一开始
这个SDK已经发布了


131
00:09:33,807 --> 00:09:37,211
可能有一部分人
已经在这个糟糕的时间醒了


132
00:09:37,578 --> 00:09:41,415
仅仅就是想知道ATS是干什么用的
以及为什么你的网络会加载失败


133
00:09:42,282 --> 00:09:43,550
我们明白


134
00:09:43,617 --> 00:09:46,253
我们只是想和你一起工作
所以才把你叫起来


135
00:09:49,356 --> 00:09:53,994
所以请注意 ATS只有在你构建
当前SDK时是活跃的


136
00:09:54,828 --> 00:09:56,630
如果你针对的是之前的版本


137
00:09:57,064 --> 00:09:58,665
ATS规则不适用


138
00:10:00,934 --> 00:10:05,005
NSURL会话会将HTTP资源


139
00:10:05,472 --> 00:10:08,942
或者URL自动转换成HTTPS


140
00:10:11,879 --> 00:10:15,716
就像我之前说的
你们中有人已经对这个开关有所了解


141
00:10:16,683 --> 00:10:18,452
我们允许你暂时使用这个功能


142
00:10:18,685 --> 00:10:21,922
来判断你的程序中新发生的网络错误


143
00:10:22,155 --> 00:10:23,790
是不是因为ATS


144
00:10:24,358 --> 00:10:26,093
这能够帮助你将范围缩小


145
00:10:28,562 --> 00:10:32,332
接下来
如果你打开了允许所有的ATS


146
00:10:32,599 --> 00:10:33,867
允许所有开始加载


147
00:10:35,435 --> 00:10:37,571
那么你就能够确定问题出在ATS


148
00:10:38,438 --> 00:10:42,409
接下来就是
查找你看到的NSURL会话的错误


149
00:10:42,709 --> 00:10:44,344
所以你可以试着确定并缩小范围


150
00:10:44,344 --> 00:10:46,079
到底哪个加载过程失败了


151
00:10:46,413 --> 00:10:47,681
以及潜在的错误是什么


152
00:10:50,784 --> 00:10:53,554
还有一个很棒的调试工具


153
00:10:54,421 --> 00:10:57,057
是一个被叫做CF网络诊断的环境变量


154
00:10:58,692 --> 00:11:01,195
如果你将CF网络诊断设置为一级


155
00:11:01,929 --> 00:11:04,031
所有失败的URL开始加载


156
00:11:04,164 --> 00:11:07,201
所有加载失败的任务
都能被确定是URL错误


157
00:11:07,568 --> 00:11:09,436
或者是底层TLS错误


158
00:11:10,270 --> 00:11:11,705
这样接下来你能做的就是


159
00:11:12,005 --> 00:11:16,410
查找底层TLS错误并
确认transport.h的安全性


160
00:11:16,910 --> 00:11:19,746
确定究竟是什么底层问题


161
00:11:21,014 --> 00:11:26,153
通常是客户端和服务器端
在TLS层的协商失败


162
00:11:31,124 --> 00:11:35,863
所以现在弄明白这是一个新的API
它仍然在发展


163
00:11:36,463 --> 00:11:43,070
所以我们强烈建议你们
关注种子笔记和发行说明


164
00:11:43,170 --> 00:11:48,342
请将文件广播出来
这样方便我们跟踪你们碰到了什么问题


165
00:11:49,543 --> 00:11:51,612
帮助你们解决并运行起来


166
00:11:55,782 --> 00:11:58,652
所以我希望这是一个网络安全的时代


167
00:11:59,353 --> 00:12:03,056
并且我们非常希望能够与你合作
一起来保护客户的数据安全


168
00:12:04,391 --> 00:12:05,225
再说一遍


169
00:12:05,993 --> 00:12:10,163
如果你正在开发一个新程序
请使用HTTPS作为开头


170
00:12:10,631 --> 00:12:14,801
并尽可能地使你的服务器运行最优方法


171
00:12:16,737 --> 00:12:20,040
现在如果你使用的是现有的软件


172
00:12:20,174 --> 00:12:24,344
我们希望
你能先把能够移动的移动到HTTPS


173
00:12:24,611 --> 00:12:25,879
那些你不能够移动的地方


174
00:12:26,613 --> 00:12:31,118
可以通过使用例外情况和
你的Info.plist移动


175
00:12:32,286 --> 00:12:35,322
现在请牢记
你的客户相信你能够保护好其数据


176
00:12:35,956 --> 00:12:39,493
并且这些数据在任何时候都是敏感的


177
00:12:40,327 --> 00:12:42,262
所以Apple希望与你合作


178
00:12:43,230 --> 00:12:45,899
共同为你的客户创造
一个更加安全的网络环境


179
00:12:46,400 --> 00:12:47,234
所以再说一遍


180
00:12:48,836 --> 00:12:50,537
请通过雷达给我们反馈


181
00:12:51,171 --> 00:12:54,007
在这个会之后
明天就可以过来实验室拜访我们


182
00:12:54,541 --> 00:12:57,311
我们真的非常希望
与你一起保护我们客户的数据


183
00:12:58,178 --> 00:13:01,348
谢谢所有人的到来
接下来有请安德鲁


184
00:13:01,348 --> 00:13:03,951
他将会讲新的协议和NSURL会话


185
00:13:04,251 --> 00:13:05,285
祝你有一个愉快的会议


186
00:13:11,425 --> 00:13:12,326
谢谢 卢克


187
00:13:14,928 --> 00:13:16,063
早上好各位


188
00:13:16,330 --> 00:13:17,364
我叫安德鲁


189
00:13:17,431 --> 00:13:21,201
接下来我将介绍NSURL会话中
新的协议支持方法


190
00:13:23,737 --> 00:13:30,444
是的
NSURL会话支持HTTP/2协议


191
00:13:31,912 --> 00:13:35,048
你的程序
可以使用HTTP/2进行通信


192
00:13:35,182 --> 00:13:36,950
并且在适配上非常容易


193
00:13:37,651 --> 00:13:38,986
让我来演示一次


194
00:13:41,188 --> 00:13:42,022
好的


195
00:13:42,823 --> 00:13:45,659
如果在你的代码中
已经使用了NSURL会话


196
00:13:46,159 --> 00:13:48,729
你自动地就已经是其中的一部分了


197
00:13:49,229 --> 00:13:52,533
在网络的未来
网络革命中的重大里程碑中


198
00:13:52,933 --> 00:13:54,601
你的程序已经走在了前列


199
00:13:55,035 --> 00:13:56,770
你不需要修改你的源代码


200
00:13:57,070 --> 00:13:58,772
所有事情都是自动完成的


201
00:14:01,375 --> 00:14:04,244
所以今天我准备讲三件事情


202
00:14:05,612 --> 00:14:12,419
为什么我们需要一个新协议
HTTP/1.1协议有什么问题


203
00:14:13,554 --> 00:14:17,791
我们将要学习一下
HTTP/2最重要的功能


204
00:14:18,692 --> 00:14:23,997
最后我会讲一下HTTP/2协议
在你的程序中的适配性


205
00:14:27,935 --> 00:14:29,870
为什么需要一个新的协议？


206
00:14:32,739 --> 00:14:36,810
我们已经有很多协议
用于各种类型的通信


207
00:14:37,644 --> 00:14:44,284
原因是大多数协议都是在很多年前
响应那个时代的需要设计出来的


208
00:14:45,052 --> 00:14:47,754
看一下Apple的第一个网站


209
00:14:51,225 --> 00:14:56,597
今天需要的和十五年前
看起来是明显不同的


210
00:14:57,231 --> 00:14:58,765
所以是时候进行一次升级了


211
00:15:00,801 --> 00:15:03,303
HTTP从网络的最开始就已经存在了


212
00:15:03,871 --> 00:15:06,740
大家都知道它有很多问题


213
00:15:07,808 --> 00:15:09,877
最有名的HTTP的问题是


214
00:15:10,277 --> 00:15:14,515
每一个TCP连接只有一个优先请求


215
00:15:16,550 --> 00:15:19,152
这个问题的解决办法就是HTTP管道


216
00:15:19,820 --> 00:15:24,124
但是HTTP管道并不适用于
所有的服务器或网络


217
00:15:24,791 --> 00:15:29,329
事实上 大多数桌面主流网页浏览器上
它是被禁用的


218
00:15:31,665 --> 00:15:34,868
另一个解决办法
就是给一个主机开多个连接


219
00:15:35,802 --> 00:15:39,173
这样能够更快的得到多种资源


220
00:15:39,606 --> 00:15:43,610
综合其他情况例如文本协议开销


221
00:15:44,444 --> 00:15:45,979
缺乏头压缩


222
00:15:46,647 --> 00:15:47,814
它只是意味着


223
00:15:48,081 --> 00:15:54,521
对客户端和服务器
更高的系统需求和更低的性能


224
00:15:58,392 --> 00:16:01,562
去年我们在NSURL会话中
加入了SPDY支持


225
00:16:02,596 --> 00:16:04,865
SPDY是使网络更快的一种尝试


226
00:16:05,465 --> 00:16:07,234
它是一种实验性协议


227
00:16:07,534 --> 00:16:13,106
但是它被选作
新版HTTP协议的基础之一


228
00:16:14,208 --> 00:16:20,681
新协议的标准版本在上个月
通过了IETF标准


229
00:16:20,948 --> 00:16:24,551
并正式分配到了一个RFC编号


230
00:16:25,619 --> 00:16:27,688
所以今天
就像你已经知道的那样


231
00:16:28,589 --> 00:16:33,660
NSURL会话
扩展支持HTTP/2协议


232
00:16:36,063 --> 00:16:37,731
让我们看一下


233
00:16:37,731 --> 00:16:40,534
HTTP/1.1
和HTTP/2的主要区别


234
00:16:41,869 --> 00:16:43,770
与HTTP/1.1相对


235
00:16:44,171 --> 00:16:48,141
HTTP/2仅支持
一台主机开放一个TCP连接


236
00:16:49,476 --> 00:16:55,249
它是网络友好的
并且对客户端和主机要更少的系统资源


237
00:16:57,784 --> 00:17:00,254
HTTP/2完全多路复用


238
00:17:00,988 --> 00:17:01,822
这就意味着


239
00:17:01,889 --> 00:17:08,060
一个新的请求不需要等到服务器
对前一个请求回复之后


240
00:17:09,863 --> 00:17:12,833
HTTP/2有请求优先级


241
00:17:13,400 --> 00:17:18,939
所以更多重要的资源可以优先提供给
拥有更高权限的客户端


242
00:17:24,411 --> 00:17:25,279
让我们看一下


243
00:17:25,345 --> 00:17:30,684
HTTP/2多路复用
如何解决队首阻塞问题


244
00:17:32,085 --> 00:17:35,422
在一个服务器上
我们有三个对资源的请求


245
00:17:36,990 --> 00:17:40,861
我们发出第一个请求
并得到一个回复


246
00:17:41,995 --> 00:17:47,401
这之后我们发送第二个请求
并得到第二个回复


247
00:17:47,901 --> 00:17:51,004
对第三个请求也是一样


248
00:17:53,907 --> 00:17:55,709
现在启用通道


249
00:17:56,610 --> 00:17:58,579
我们同时发送所有的请求


250
00:17:59,213 --> 00:18:03,517
一个接一个
不需要等到收到之前的回复


251
00:18:05,285 --> 00:18:09,623
但是我们仍然按顺序得到了回复


252
00:18:10,724 --> 00:18:13,794
你能够看到
蓝色的图片是第一个回复


253
00:18:15,229 --> 00:18:17,097
阻塞了紧随其后的两个回复


254
00:18:20,667 --> 00:18:25,572
通过HTTP/2
我们给三个请求赋予不同的优先级


255
00:18:27,007 --> 00:18:30,844
我们仍然在开始的时候
同时发送所以的请求


256
00:18:32,246 --> 00:18:35,415
但是我们同时得到了回复


257
00:18:38,151 --> 00:18:42,089
此外 优先级更高的请求


258
00:18:43,490 --> 00:18:45,659
我得到以及发送给客户端的速度更快


259
00:18:46,860 --> 00:18:52,833
你可以看到第二个回复的是中等优先级


260
00:18:52,833 --> 00:18:56,603
并且第三个回复的是高优先级的请求


261
00:18:57,304 --> 00:19:02,209
到达得比第一个回复更早
即使他们在时间表中更靠后


262
00:19:02,910 --> 00:19:05,245
图片也不再阻塞他们


263
00:19:05,412 --> 00:19:08,782
这非常棒
且对你的程序和性能来说也非常棒


264
00:19:10,617 --> 00:19:12,719
让我们来继续对比


265
00:19:15,689 --> 00:19:18,192
HTTP/2是一个二进制协议


266
00:19:20,460 --> 00:19:24,398
这使得数据的处理和解析速度更快


267
00:19:25,599 --> 00:19:30,003
HTTP/1.1不使用头压缩


268
00:19:30,671 --> 00:19:35,409
因为安全漏洞的原因
SPDY同样也不能使用头压缩


269
00:19:36,243 --> 00:19:41,381
HTTP/2使用HPACK
这是一种更加安全的头压缩机制


270
00:19:43,851 --> 00:19:45,118
让我来介绍一下HPACk


271
00:19:48,021 --> 00:19:50,657
HPACK头压缩基于两个表


272
00:19:51,325 --> 00:19:53,760
一个静态表
一个动态表


273
00:19:55,329 --> 00:20:00,767
静态表包括最常用的HTTP信息头
并且不可修改


274
00:20:03,070 --> 00:20:08,876
包含在静态表中的信息头
可以添加到动态表中


275
00:20:10,210 --> 00:20:13,680
表中的信息头可以通过指针进行引用


276
00:20:15,582 --> 00:20:19,486
例如你可以看到
一个简单的HTTP/1.1请求


277
00:20:20,921 --> 00:20:23,991
突出显示的部分
是要发送到服务器的数据


278
00:20:26,460 --> 00:20:31,164
这里是一个基于
HTTP/2的相同的请求


279
00:20:32,232 --> 00:20:33,901
接下来让我们将这个请求编码


280
00:20:36,370 --> 00:20:42,209
伪信息头 方法 计划以及路径


281
00:20:43,377 --> 00:20:46,013
都可以通过静态表进行引用


282
00:20:47,748 --> 00:20:52,653
主信息头包括在静态表中
但是并不包含其值


283
00:20:53,687 --> 00:20:55,255
所以要编码这个请求


284
00:20:55,989 --> 00:21:01,094
我们需要三个字节用来存放第一组三头


285
00:21:01,328 --> 00:21:05,465
加上一个告诉你我们想要将主信息头


286
00:21:05,532 --> 00:21:08,669
添加到动态表中的字节


287
00:21:09,169 --> 00:21:13,006
以及主信息头的值和长度


288
00:21:16,677 --> 00:21:20,214
这就是要发送到服务器


289
00:21:20,614 --> 00:21:24,151
添加了额外开销的信息头框架


290
00:21:26,720 --> 00:21:28,055
现在对于第二个请求


291
00:21:30,290 --> 00:21:33,327
你可以看到主信息头存储在
动态表中


292
00:21:33,961 --> 00:21:35,195
所以对于第二个请求


293
00:21:35,395 --> 00:21:41,335
HTTP/1.1将会
一遍又一遍地发送相同的信息头


294
00:21:43,570 --> 00:21:46,974
但是在HTTP/2中
在通常情况下


295
00:21:47,241 --> 00:21:49,309
我们可以通过静态表和动态表


296
00:21:50,244 --> 00:21:53,213
引用所有的信息头


297
00:21:53,380 --> 00:21:55,582
我们只需要一个字节来存放一个信息头


298
00:21:56,149 --> 00:21:57,918
这相当节约带宽


299
00:21:58,285 --> 00:22:00,921
这只需要如此少的字节


300
00:22:01,355 --> 00:22:05,526
就能够使用HTTP/2编码
一个请求或者回复信息头


301
00:22:10,230 --> 00:22:11,365
接下来让我讲一下


302
00:22:11,431 --> 00:22:14,601
要为你的程序
适配HTTP/2协议需要做些什么


303
00:22:16,270 --> 00:22:17,738
其工作量并不大


304
00:22:18,772 --> 00:22:24,077
HTTP/2被无缝集成到了
NSURL会话的API中


305
00:22:25,345 --> 00:22:27,881
如果你已经在你的代码中
使用了NSURL会话


306
00:22:29,550 --> 00:22:34,521
你的程序和OS X程序
将会自动获得这种功能


307
00:22:35,756 --> 00:22:38,091
你不需要写另外的代码


308
00:22:38,358 --> 00:22:43,797
或者添加其他的结构来启动它


309
00:22:44,398 --> 00:22:46,400
让我们来看一下源代码实例


310
00:22:46,967 --> 00:22:51,638
这段源代码和你已经在程序中
使用的代码看起来非常相像


311
00:22:52,139 --> 00:22:55,943
可以看到
没有任何不同也没有新的结构标志


312
00:22:56,176 --> 00:22:57,311
这样就可以使用


313
00:23:06,053 --> 00:23:09,990
是的
你只需要一个HTTP/2服务器


314
00:23:11,725 --> 00:23:12,593
但是这不是问题


315
00:23:17,030 --> 00:23:22,135
你的应用程序已经准备好了
使用HTTP/2协议来进行通信


316
00:23:22,569 --> 00:23:25,639
如果你还没有
部署一个HTTP/2服务器


317
00:23:26,673 --> 00:23:30,777
那么你的应用程序
将会直接使用HTTP/1.1


318
00:23:31,512 --> 00:23:36,483
或者会自动选择最优的可选的协议
用来进行网络通信


319
00:23:37,284 --> 00:23:41,054
一旦你开始使用
支持HTTP/2的网络服务器


320
00:23:41,755 --> 00:23:43,924
你就不再需要做额外的工作


321
00:23:44,725 --> 00:23:48,061
你的应用程序将会
自动使用HTTP/2协议


322
00:23:56,503 --> 00:23:57,371
请记住


323
00:23:57,905 --> 00:24:03,577
NSURL会话只在加密连接上
支持HTTP/2协议


324
00:24:04,845 --> 00:24:07,414
这样你的HTTP/2服务器


325
00:24:07,748 --> 00:24:12,352
需要支持ALPN或者NPN
用来进行协议对接


326
00:24:16,990 --> 00:24:18,025
目前在Apple


327
00:24:18,292 --> 00:24:20,761
通过iCloud
远程访问HomeKit


328
00:24:20,827 --> 00:24:23,964
就是在HomeKit配件
和iCloud之间


329
00:24:23,964 --> 00:24:27,801
使用HTTP/2协议进行通信


330
00:24:29,036 --> 00:24:32,172
很多大公司已经
开始使用HTTP/2协议了


331
00:24:32,673 --> 00:24:35,175
Google为其服务
也配置了HTTP/2


332
00:24:35,909 --> 00:24:38,278
Twitter也使用了HTTP/2


333
00:24:39,413 --> 00:24:43,450
有非常多的HTTP/2
开放资源网络服务器


334
00:24:44,318 --> 00:24:51,024
最后一些CDN服务提供商
也在逐步提供HTTP/2协议支持


335
00:24:55,062 --> 00:24:59,132
我们努力使
HTTP/2能够支持NSURL会话


336
00:24:59,366 --> 00:25:03,270
这样你们就可以非常容易地配置
使用HTTP/2协议


337
00:25:04,137 --> 00:25:07,674
HTTP/2今天在
WWDC种子中也是可选的


338
00:25:08,208 --> 00:25:12,246
它无缝集成在NSURL会话API中


339
00:25:12,746 --> 00:25:17,818
并能够在OS X 10.11和
iOS 9中的Safari上使用


340
00:25:19,553 --> 00:25:20,387
谢谢


341
00:25:21,188 --> 00:25:24,091
现在我想邀请丹上台


342
00:25:24,591 --> 00:25:25,425
丹？


343
00:25:31,598 --> 00:25:32,432
早上好各位


344
00:25:32,733 --> 00:25:33,767
我叫丹


345
00:25:33,767 --> 00:25:36,303
我是一个软件工程师
在苹果公司CF网络项目组工作


346
00:25:36,637 --> 00:25:38,472
我想讲的第一件事情是


347
00:25:38,539 --> 00:25:41,041
今天已经可以在WatchOS上
使用NSURL会话了


348
00:25:42,276 --> 00:25:43,677
通过本周前几天


349
00:25:43,744 --> 00:25:47,281
与WatchOS 2测试版
一起发布的WatchKit SDK


350
00:25:47,614 --> 00:25:48,649
我很高兴能告诉大家


351
00:25:48,715 --> 00:25:51,518
WatchOS
完全支持HTTPS加载


352
00:25:52,686 --> 00:25:54,988
这就意味着
我们今天已经讲的所有的东西


353
00:25:55,055 --> 00:25:58,825
例如App Transport Security
和HTTP/2都支持HTTPS


354
00:26:00,661 --> 00:26:04,198
在WatchOS使用NSURL会话


355
00:26:04,264 --> 00:26:07,301
和在其他平台上使用的
主要区别是在后台运行


356
00:26:07,301 --> 00:26:11,271
事实上我们会选择所有选项中
最好的连接机制


357
00:26:12,005 --> 00:26:14,041
这就意味着
在大多数情况下


358
00:26:14,408 --> 00:26:17,778
如果用户的手表
靠近了配对的iPhone设备


359
00:26:18,212 --> 00:26:21,315
我们会利用他们之间的蓝牙连接


360
00:26:21,481 --> 00:26:27,187
通过手机本身的HTTP加载
并将结果通过蓝牙回传给手表


361
00:26:28,288 --> 00:26:34,394
如果带着手表的用户碰巧断开了
或者远离了他们的手机


362
00:26:34,661 --> 00:26:37,664
手表将会连接到已知的Wi-Fi网络
这样我们可以直接使用网络了


363
00:26:38,332 --> 00:26:42,369
好消息是
这些所有的工作都是脱离API进行的


364
00:26:42,369 --> 00:26:45,072
当你在其他平台上的时候
你可以使用API


365
00:26:45,072 --> 00:26:46,773
你不需要关心我们是如何连接的


366
00:26:47,040 --> 00:26:48,375
它就像魔法一样


367
00:26:50,444 --> 00:26:53,247
就如之前所说 在WatchOS
上使用NSURL会话时


368
00:26:53,247 --> 00:26:55,983
只需要关注
少数几个最佳方法和事情即可


369
00:26:56,717 --> 00:27:00,721
首先你应该尽可能的
只下载最小的安装包


370
00:27:00,721 --> 00:27:02,756
这其实是你的程序的功能的要求


371
00:27:03,390 --> 00:27:06,827
请注意 手表只有一个非常小的屏幕


372
00:27:07,160 --> 00:27:08,495
所以如果你要下载图片


373
00:27:08,562 --> 00:27:13,467
不需下载在iPhone6 Plus
或配有Retina显示屏的Mac上


374
00:27:13,534 --> 00:27:15,335
显示的完全分辨率图片


375
00:27:15,702 --> 00:27:18,272
它的屏幕太小了
你可以下载小一点的图片


376
00:27:18,939 --> 00:27:20,507
另外请记住


377
00:27:20,707 --> 00:27:26,046
手表比手机或电脑的处理能力要小很多


378
00:27:26,580 --> 00:27:31,785
并且会经常受到带宽
和与你手机的蓝牙连接的延迟的限制


379
00:27:32,019 --> 00:27:34,321
所以你并不能够真正
如同在其他平台上一样


380
00:27:34,321 --> 00:27:35,923
快速地下载字节到手表上


381
00:27:35,923 --> 00:27:37,124
所以也请记住这一点


382
00:27:38,859 --> 00:27:40,294
另一个需要注意的是


383
00:27:40,561 --> 00:27:44,431
手表上的程序运行时间


384
00:27:44,498 --> 00:27:46,800
比iPhone或Mac上的程序
运行时间短很多


385
00:27:47,201 --> 00:27:49,269
用户会受到严重的时间限制


386
00:27:49,269 --> 00:27:52,940
如果他想要坐着或者站着
并举起手腕盯着手表和它互动


387
00:27:54,408 --> 00:27:58,645
所以如果你使用的是默认会话配置
或者临时会话配置


388
00:27:59,112 --> 00:28:04,651
请记住这些网络传输
只会在你的程序真正运行的时候进行


389
00:28:05,352 --> 00:28:08,121
所以如果你要发送少量的数据
是完全没问题


390
00:28:08,121 --> 00:28:10,557
例如股票报价或者天气数据


391
00:28:10,924 --> 00:28:12,593
亦或者社交网络状态更新


392
00:28:13,093 --> 00:28:16,029
但是对于任何比较大的内容
例如视频


393
00:28:16,029 --> 00:28:18,165
你会想用后台上传或者下载


394
00:28:18,498 --> 00:28:22,035
这样就能在过程结束时继续


395
00:28:22,302 --> 00:28:24,171
要了解更多有关后台上传下载的信息


396
00:28:24,238 --> 00:28:29,309
我强烈建议你看看
前几年基础网络大会上的WWDC会话


397
00:28:33,347 --> 00:28:37,484
接下来我想讲一下
我们在今年发布的API中做的修改


398
00:28:38,585 --> 00:28:40,954
我要讲的第一件事情是NSURL连接


399
00:28:40,954 --> 00:28:42,890
这个东西我们到现在为止都还没有讲过


400
00:28:43,457 --> 00:28:44,291
所以今年


401
00:28:44,358 --> 00:28:49,196
我宣布OS X EI旗舰版及
IOS9将放弃使用NSURL连接


402
00:28:50,163 --> 00:28:52,599
让我们花一点时间
来想一下这意味着什么


403
00:28:52,666 --> 00:28:56,703
放弃使用并不意味着
NSURL连接将会被完全放弃


404
00:28:56,770 --> 00:29:00,040
我知道有很多程序
都在使用NSURL连接


405
00:29:00,240 --> 00:29:01,542
我们并不会损坏它们


406
00:29:01,942 --> 00:29:04,077
所以它仍然可以运行
这些传输方法仍然可以使用


407
00:29:04,945 --> 00:29:09,850
但是请记住
新功能只会添加到NSURL会话中


408
00:29:11,552 --> 00:29:14,855
我们强烈建议你
将现存的NSURL连接代码


409
00:29:15,155 --> 00:29:18,158
转换成NSURL会话代码
如果你还没有转换的话


410
00:29:19,393 --> 00:29:20,928
如果你正在写一段新代码


411
00:29:21,528 --> 00:29:24,364
我们真心希望你只使用NSURL会话
而不是NSURL连接


412
00:29:25,699 --> 00:29:26,834
另一件需要注意的事情是


413
00:29:26,834 --> 00:29:29,937
在WatchOS上
完全不支持NSURL连接


414
00:29:30,070 --> 00:29:33,073
所以如果你要从WatchKit
扩展程序上加载HTTP内容


415
00:29:33,140 --> 00:29:34,708
你只能使用NSURL会话


416
00:29:35,409 --> 00:29:37,544
但如果你还没有完成
那你是幸运的


417
00:29:37,544 --> 00:29:39,947
从NSURL连接到
NSURL会话的转换


418
00:29:39,947 --> 00:29:40,914
会非常简单


419
00:29:41,248 --> 00:29:43,083
现在我想通过一个例子向你们展示一下


420
00:29:44,618 --> 00:29:47,020
这是NSURL连接的一个简单使用


421
00:29:47,087 --> 00:29:49,256
<br/> 
用来实现一个异步的HTTP请求


422
00:29:49,256 --> 00:29:52,359
它可能和你的程序中
经常使用的方法有点相似


423
00:29:52,960 --> 00:29:57,931
现在我们通过HTTPS连接
www.example.com


424
00:29:57,965 --> 00:30:00,367
我们通过一个NSURL对象来表示


425
00:30:01,168 --> 00:30:04,805
然后我们构造一个
NSURLRequest对URL进行打包


426
00:30:05,672 --> 00:30:09,142
我们通过NSURL连接的
“发送异步请求”方法


427
00:30:09,510 --> 00:30:11,979
来出发这个异步请求


428
00:30:12,546 --> 00:30:15,949
之后我们以一个闭包的形式接收到结果


429
00:30:16,817 --> 00:30:21,889
接收到的结果包含一个NSURL
响应对象作为HTTP响应信息头


430
00:30:22,422 --> 00:30:26,360
这个相应对象作为HTTP响应信息头
和NSData对象作为响应的主体数据


431
00:30:26,560 --> 00:30:28,195
如果传输发生错误则接收到一个报错


432
00:30:29,263 --> 00:30:32,232
看一下如果使用NSURL会话
实现起来会是什么样子


433
00:30:33,634 --> 00:30:34,568
它非常相似


434
00:30:34,735 --> 00:30:38,972
你会注意到
NSURL和NSURL请求对象仍然在使用


435
00:30:38,972 --> 00:30:42,743
这对于很多其他的NSURL家族对象
来讲是正确的


436
00:30:42,743 --> 00:30:47,181
例如NSURL Credential Storage
和NSHTTP Cookie Storage


437
00:30:47,447 --> 00:30:48,582
其主要区别是


438
00:30:48,582 --> 00:30:51,885
我们不使用NSURL连接
来发送异步请求这种方法


439
00:30:52,252 --> 00:30:58,392
我们使用NSURL会话共享会话中的
 “数据任务请求”方法


440
00:30:59,560 --> 00:31:00,928
一旦我们恢复任务


441
00:31:01,028 --> 00:31:05,065
我们就能够再次接收到
异步地接收到事务处理的结果


442
00:31:05,432 --> 00:31:08,635
以回复数据的格式
回复信息头


443
00:31:08,635 --> 00:31:11,171
如果传输发生错误则接收到一个报错


444
00:31:12,272 --> 00:31:14,341
在你的程序中


445
00:31:14,408 --> 00:31:17,177
将NSURL连接转换成NSURL会话
非常简单


446
00:31:19,279 --> 00:31:20,514
接下来我想换个话题


447
00:31:20,514 --> 00:31:24,952
讲一下我们在API的
NSURL会话家族中添加的新功能


448
00:31:26,153 --> 00:31:29,022
我要讲的第一件
就是对cookie的处理


449
00:31:30,324 --> 00:31:31,859
在去年的WWDC上


450
00:31:31,925 --> 00:31:34,795
我们介绍了一个新的功能
叫做应用程序扩展


451
00:31:35,062 --> 00:31:38,599
它允许你在系统的其他地方
嵌入你应用程序的部分功能


452
00:31:38,599 --> 00:31:39,933
例如通知中心


453
00:31:41,602 --> 00:31:47,174
但是应用程序和他们的扩展
在默认情况下拥有不同的数据存储器


454
00:31:47,241 --> 00:31:49,476
这就意味着即使你使用NSURL会话


455
00:31:49,476 --> 00:31:53,213
且已经使用了
我们内置的cookie进行支持处理


456
00:31:53,480 --> 00:31:55,849
这些cookie实际上仍然被存储在
不同的地方


457
00:31:57,751 --> 00:32:00,087
但是你可以使用应用程序组


458
00:32:00,254 --> 00:32:03,090
来访问共享数据存储器


459
00:32:03,090 --> 00:32:05,692
这个存储器无论是你的应用程序
还是其扩展部分都可以访问


460
00:32:06,059 --> 00:32:08,328
今年我们发布了新的API


461
00:32:08,562 --> 00:32:11,632
你能够创建一个与组存储器
相关联的cookie存储


462
00:32:12,432 --> 00:32:14,034
我将要向你们展示一下怎样实现它


463
00:32:14,601 --> 00:32:19,173
这里你需要用到的
是NSHTTP cookie存储中


464
00:32:19,173 --> 00:32:22,009
新增的“共享cookie组存储器
标识符”方法


465
00:32:22,576 --> 00:32:24,778
你只需要简单地
创建一个cookie存储


466
00:32:24,845 --> 00:32:28,215
并输入你的应用程序组的名字


467
00:32:28,749 --> 00:32:33,086
在你用Xcode编辑工程的
编译设置选项和打开功能选项卡时


468
00:32:33,086 --> 00:32:34,188
程序组就已经被配置好了


469
00:32:35,622 --> 00:32:37,224
当你创建好cookie存储的时候


470
00:32:37,457 --> 00:32:43,330
你只需像设置NSURL会话配置对象中的
HTTP cookie存储属性一样设置它


471
00:32:43,964 --> 00:32:46,500
从配置中创建一个NSURL会话


472
00:32:46,533 --> 00:32:49,903
之后你在这个会话中进行的任何任务


473
00:32:50,070 --> 00:32:52,306
都会使用组存储器中的
cookie存储


474
00:32:56,476 --> 00:32:58,779
所以对于今天演示的所有内容


475
00:32:58,779 --> 00:33:03,183
我们讲解了
使用NSURL加载HTTP内容


476
00:33:04,218 --> 00:33:08,121
但是仍然有一些情况需要你使用一个
除了HTTP或者HTTPS之外的


477
00:33:08,188 --> 00:33:10,023
其他的协议


478
00:33:10,557 --> 00:33:13,594
所以如果你正在开发一个聊天软件


479
00:33:14,728 --> 00:33:20,434
一个视频调用软件
或一切这一类的其他软件


480
00:33:20,434 --> 00:33:23,637
你真的需要...
你可能需要一个非HTTP的协议


481
00:33:23,637 --> 00:33:28,242
你想要直接在
TCP/IP网络上做一些事情


482
00:33:28,775 --> 00:33:31,845
所以今年发布了一个新的API
叫做NSURL会话工作流


483
00:33:32,012 --> 00:33:35,449
这是一个底层提取文件
直接在TCP连接层上


484
00:33:36,550 --> 00:33:39,753
在过去你可能
直接使用NSInput流


485
00:33:39,753 --> 00:33:42,656
或者NSOutput
留来做一些相似的事情


486
00:33:42,890 --> 00:33:48,061
但是我们认为NSURL会话工作流
有在NSStream API的优点


487
00:33:48,662 --> 00:33:53,033
首先它提供了一个
非常简单方便的异步读写接口


488
00:33:53,767 --> 00:33:55,169
通过NSStream


489
00:33:55,235 --> 00:33:59,640
你需要设置一个委托来监听事件
或者何时读入或者何时屏蔽读写


490
00:33:59,640 --> 00:34:02,509
从前这样做会有点乱
但是现在变得简单清晰了很多


491
00:34:03,677 --> 00:34:04,511
第二


492
00:34:05,078 --> 00:34:09,449
NSURL会话内置了强大的支持功能
能够自动通过HTTP代理


493
00:34:09,850 --> 00:34:12,418
NSURL会话工作流
可以利用这种支持


494
00:34:12,418 --> 00:34:14,788
这样你就能够连接一个远程的服务器


495
00:34:15,022 --> 00:34:18,525
即使在这之间有一个HTTP代理
但是NSStream不能够这样做


496
00:34:19,359 --> 00:34:21,428
API还有一些其他的新的升级


497
00:34:21,428 --> 00:34:23,030
这些我也将随后进行介绍


498
00:34:24,498 --> 00:34:26,900
我们都知道NSStream
是一个非常流行的API


499
00:34:26,900 --> 00:34:32,306
也有很多其他的构架和API中
兼容并使用了NSStream对象


500
00:34:32,806 --> 00:34:35,809
所以我们也有一些与
NSStream相兼容的支撑部分


501
00:34:35,809 --> 00:34:37,411
这些我也将在之后为你们呈现


502
00:34:39,513 --> 00:34:43,650
所以就像我说的
MNSURL会话工作流支持TCP/IP连接


503
00:34:43,951 --> 00:34:47,020
你可以明确地通过一个主机名称和端口
创建一个连接


504
00:34:47,321 --> 00:34:50,157
或者你可以使用
NSNetService的API


505
00:34:51,291 --> 00:34:53,193
在你的应用程序中
查找Bonjour服务


506
00:34:53,527 --> 00:34:57,097
之后我们能够接受
NSNetService为你自动解决问题


507
00:34:58,632 --> 00:35:02,503
工作流使用了
现存的NSURL会话配置选项


508
00:35:02,503 --> 00:35:05,839
和委托方法来向你传达事件


509
00:35:07,374 --> 00:35:10,410
当然我们支持TLS安全连接


510
00:35:10,410 --> 00:35:14,214
一旦你确实与服务器建立了一个连接
你甚至能够进行动态修改


511
00:35:16,416 --> 00:35:20,287
所以让我们看一下
你怎样使用工作流来实现一个读取操作


512
00:35:20,854 --> 00:35:22,222
首先创建一个工作流


513
00:35:22,289 --> 00:35:26,493
这样你就能够简单地使用
“带有主机地址和端口的工作流”


514
00:35:26,627 --> 00:35:29,363
你只需要输入你想要连接的
主机名和端口号


515
00:35:30,330 --> 00:35:31,999
然后恢复任务后


516
00:35:32,432 --> 00:35:36,336
你可以使用“读取最短长度
最长长度、或者超时”等方法


517
00:35:37,137 --> 00:35:41,241
你需要做的就是
输入一个你要读取的字节范围


518
00:35:41,441 --> 00:35:42,943
或者操作超时的时限


519
00:35:43,343 --> 00:35:45,579
所以如果我们准备
读取范围内的东西


520
00:35:45,579 --> 00:35:49,416
或者我们遇到了一个EOF
或者发生了传输错误或者超时


521
00:35:49,416 --> 00:35:52,052
我们将会调用存储结果的闭包


522
00:35:53,253 --> 00:35:54,521
写入操作非常相似


523
00:35:55,556 --> 00:35:58,992
我们不像...通过NSStream
我们可以直接操作NSData


524
00:35:58,992 --> 00:36:01,195
你只需要输入
你想要我们写入的NSData对象


525
00:36:01,195 --> 00:36:03,263
以及再次输入一个超时门限


526
00:36:03,530 --> 00:36:05,732
在出现错误时
这个内容为零的闭包将会被调用


527
00:36:05,732 --> 00:36:09,870
当这个操作成功或者发生了超时错误
或者发生了传输错误


528
00:36:11,371 --> 00:36:16,276
启用TLS和对这个任务调用
“打开安全连接”的思想一样简单


529
00:36:19,112 --> 00:36:19,947
我之前提到了


530
00:36:20,013 --> 00:36:25,152
我们有配合NSStream工作的
内置支持NSURL会话工作流


531
00:36:25,586 --> 00:36:27,487
我们这样做的原因是


532
00:36:27,487 --> 00:36:30,591
有非常多的API已经
使用了NSStream对象


533
00:36:30,591 --> 00:36:33,360
我们希望为你提供一些东西
能够和这些API兼容


534
00:36:34,027 --> 00:36:38,065
事实上你可以将NSURL会话工作流
转换成NSStream


535
00:36:38,131 --> 00:36:40,834
在下一张幻灯片上我会用
非常简单的代码来为你们演示一下


536
00:36:41,335 --> 00:36:42,903
只需要记住当你做这些的时候


537
00:36:42,970 --> 00:36:48,041
任何你使用工作流加入队列中
挂起的异步读写任务


538
00:36:48,308 --> 00:36:50,210
都将在我们给
你NSStream之前完成


539
00:36:50,644 --> 00:36:53,647
这样的操作也会从会话中分离出任务


540
00:36:54,014 --> 00:36:55,082
所以这个链接


541
00:36:55,315 --> 00:36:58,619
底层链接将不再计入限制


542
00:36:58,619 --> 00:37:02,022
你可以为你的主机
设置一个会话链接的最大数量


543
00:37:03,056 --> 00:37:07,728
它也不再在会话设置中突出任务选项


544
00:37:08,729 --> 00:37:10,697
所以要将一个工作流转换成流


545
00:37:10,697 --> 00:37:13,800
你只需要在任务中简单地
调用‘Capture Streams’方法


546
00:37:14,168 --> 00:37:19,873
之后这些输入和输出流将会
给你的委托发送一个新的委托消息


547
00:37:22,042 --> 00:37:26,780
我们同样有许多已经添加到
工作流中的其他委托消息


548
00:37:26,847 --> 00:37:27,981
第一个很有意思


549
00:37:27,981 --> 00:37:30,517
这是一个为工作流寻找更优路径的方法


550
00:37:31,118 --> 00:37:36,023
所以如果你有一个工作流
通过蜂窝数据网络连接到了你的服务器


551
00:37:36,423 --> 00:37:39,259
如果用户新加入一个Wi-Fi网络


552
00:37:39,426 --> 00:37:43,163
之后我们会发送这个通知到你的程序
告诉你可能会有更好的连接路径


553
00:37:43,830 --> 00:37:46,099
在这种情况下你可能想要做的


554
00:37:46,300 --> 00:37:49,303
如果你想要做的话
就是清除你现存的工作流


555
00:37:49,369 --> 00:37:52,806
并创建一个新的工作流
到那台主机和端口


556
00:37:54,508 --> 00:37:56,610
并尝试通过更好的链接进行连接


557
00:37:56,877 --> 00:37:59,613
我们将这个决定权
留给你决定是否要这么做


558
00:38:00,280 --> 00:38:03,350
如果你在传输一个很大的数据
并已经完成了99%


559
00:38:03,417 --> 00:38:07,054
就没有必要清除现存的连接
并创建一个新的连接


560
00:38:08,021 --> 00:38:10,724
当读写双方的后台TCP连接
已经被关闭时


561
00:38:10,791 --> 00:38:13,861
我们也要告诉你一些信息委托方法


562
00:38:16,763 --> 00:38:21,468
我之前也提到了
通过工作流对HTTP代理的自动处理


563
00:38:21,902 --> 00:38:24,004
针对这种情况
你能够做的就是


564
00:38:24,304 --> 00:38:28,809
打开一个正在处理HTTP内容的
NSURL会话数据工作


565
00:38:29,109 --> 00:38:30,711
并将其转换成一个工作流


566
00:38:31,612 --> 00:38:35,015
当接收到数据工作的回复时
你可以做这些


567
00:38:36,216 --> 00:38:38,519
所以要将一个数据工作转换成工作流


568
00:38:38,519 --> 00:38:42,256
让你能不通过HTTP构架
直接在HTTP连接层直接通信


569
00:38:42,689 --> 00:38:46,126
通过“确实接到回复”委托方法


570
00:38:46,126 --> 00:38:48,161
你能够简单地
对这个完成处理器进行回复


571
00:38:48,161 --> 00:38:50,264
利用最新的“成为流”设置


572
00:38:50,931 --> 00:38:52,866
然后你会通知你的委托


573
00:38:53,166 --> 00:38:55,736
通过使用“URL会话数据任务
确实成为了工作流”方法


574
00:38:55,802 --> 00:38:59,206
数据任务已经转换成为工作流


575
00:39:02,009 --> 00:39:03,110
在结束今天的演讲前


576
00:39:03,177 --> 00:39:06,446
我想要回顾一下
今天早上讨论的几件事情


577
00:39:07,347 --> 00:39:11,018
第一件事情是怎样使用
App Transport Security


578
00:39:11,318 --> 00:39:14,555
来保证你的应用程序
能够只建立安全连接


579
00:39:14,555 --> 00:39:17,457
以及在需要的时候怎样申报异常情况


580
00:39:18,058 --> 00:39:20,127
之后我们讲了
通过服务器上支持HTTP/2


581
00:39:20,127 --> 00:39:22,029
怎样让你的应用程序能够更快


582
00:39:22,262 --> 00:39:25,599
其不需要对客户端进行额外的修改


583
00:39:26,433 --> 00:39:29,970
我们讲了在手表应用程序上
使用NSURL会话的最优方法


584
00:39:30,404 --> 00:39:33,941
以及这次发布的新API做了哪些修改


585
00:39:34,007 --> 00:39:37,144
NSURL连接的弃用
和如何迁移到会话


586
00:39:37,711 --> 00:39:40,280
怎样在应用程序
和扩展之间共享cookie


587
00:39:40,681 --> 00:39:44,151
以及如何获得一个很好的基础级别提取


588
00:39:44,151 --> 00:39:47,254
如果你需要一个没有HTTP的服务器


589
00:39:47,287 --> 00:39:49,122
使用TCP连接进行通信


590
00:39:51,758 --> 00:39:52,726
像往常一样


591
00:39:52,793 --> 00:39:57,364
我想提醒你们我们在
网站开放有参考文档


592
00:39:57,731 --> 00:40:00,801
并提醒你参加开发者论坛


593
00:40:00,801 --> 00:40:03,937
以及在这周的WWDC大会上
如果你有任何问题


594
00:40:04,104 --> 00:40:06,707
你可以向我们的传播者
Paul Danbold请教


595
00:40:07,508 --> 00:40:10,978
如果你想参加其他的相关会议的话


596
00:40:10,978 --> 00:40:12,546
我强烈建议你参加明天的


597
00:40:12,713 --> 00:40:15,215
“你的应用程序和下一代网络会议”


598
00:40:15,215 --> 00:40:17,584
这是一个低层次的关于网络的讨论会


599
00:40:18,118 --> 00:40:21,321
这周也将开放网络实验室


600
00:40:21,321 --> 00:40:23,357
如果你有任何问题
你都可以直接和我们讨论


601
00:40:23,824 --> 00:40:25,559
谢谢你们今天能够到来


602
00:40:25,993 --> 00:40:27,494
我们希望看到


603
00:40:27,561 --> 00:40:29,363
你们在IOS 9和OS X
和EI旗舰版和WatchOS 2上


604
00:40:29,429 --> 00:40:32,032
能够开发一些惊艳的应用程序


605
00:40:32,232 --> 00:40:33,066
谢谢

