1
00:00:19,887 --> 00:00:23,790
采用Metal技术 第二部分


2
00:00:30,797 --> 00:00:33,100
大家好 欢迎来到全球开发者大会


3
00:00:33,166 --> 00:00:34,935
希望目前为止 你们都过得很愉快


4
00:00:35,002 --> 00:00:36,336
你们已看过很多优秀的演讲


5
00:00:36,403 --> 00:00:38,505
我们为你们准备了非常棒的一周


6
00:00:38,572 --> 00:00:39,773
会非常有趣的


7
00:00:39,840 --> 00:00:40,707
我是Matt Collins


8
00:00:40,774 --> 00:00:42,543
这是我的同事Jared Marsau


9
00:00:42,609 --> 00:00:45,379
我们将为你讲解
采用Metal技术 第二部分


10
00:00:45,445 --> 00:00:47,548
这里是603号演讲


11
00:00:48,015 --> 00:00:50,951
如果你走错了 你也能看到一些图像


12
00:00:53,787 --> 00:00:54,721
所以 让我们回忆一下


13
00:00:55,189 --> 00:00:56,557
我们共有两部分
“采用Metal技术”演讲


14
00:00:56,623 --> 00:00:59,226
希望你们也参加了
Warren的第一部分演讲


15
00:00:59,293 --> 00:01:01,495
第一部分我们讲解了基本概念：


16
00:01:01,562 --> 00:01:04,998
基本绘图 光照 纹理
诸如此类的优秀功能


17
00:01:05,666 --> 00:01:08,135
在本次演讲中 我们会更上一个层次


18
00:01:08,202 --> 00:01:09,703
我们会绘制很多对象


19
00:01:09,770 --> 00:01:12,272
我们将会讲解如何管理动态数据


20
00:01:12,339 --> 00:01:13,907
大量的动态数据


21
00:01:14,308 --> 00:01:15,909
GPU-CPU同步


22
00:01:16,443 --> 00:01:18,879
我们将会以多线程编码的话题结束


23
00:01:20,414 --> 00:01:22,649
明天我们还有精彩的演讲


24
00:01:22,950 --> 00:01:24,718
我们会讲解Metal的新特性


25
00:01:25,085 --> 00:01:28,689
明天的第一个演讲
将讲解细分曲面 资源堆


26
00:01:28,755 --> 00:01:30,157
无记忆帧缓冲


27
00:01:30,490 --> 00:01:32,326
和关于我们改进后的工具


28
00:01:32,392 --> 00:01:34,895
以真正帮助大家做出最好的应用


29
00:01:35,128 --> 00:01:37,631
第二部分 我们将要讨论函数专用化


30
00:01:37,831 --> 00:01:39,633
以及函数资源读写


31
00:01:40,033 --> 00:01:42,169
丰富的色彩和纹理资产


32
00:01:42,870 --> 00:01:45,239
此外还有Metal性能着色器


33
00:01:46,540 --> 00:01:47,941
如果你还想继续深入


34
00:01:48,008 --> 00:01:50,978
我们还会有关于高级着色器优化的
精彩讨论


35
00:01:51,044 --> 00:01:53,947
着色起性能基础 调整着色器代码


36
00:01:54,281 --> 00:01:56,617
及更多关于硬件工作原理的细节
将会十分精彩


37
00:01:56,683 --> 00:01:59,019
如果你对调整着色器代码非常感兴趣


38
00:01:59,086 --> 00:02:01,722
想让它们达到最佳效果
请关注明天的讲座


39
00:02:04,458 --> 00:02:06,860
这里是采用Metal技术的第二部分


40
00:02:07,394 --> 00:02:09,729
我们将在第一部分的所学基础上继续


41
00:02:10,030 --> 00:02:11,765
我们弄清楚如何启动和运行


42
00:02:12,266 --> 00:02:14,067
让我们看一下你所需要的概念


43
00:02:14,134 --> 00:02:16,637
能让Metal在真实世界
得到最大的应用


44
00:02:17,337 --> 00:02:20,541
我们有一个演示
将会把很多内容绘入一个简单的场景


45
00:02:20,807 --> 00:02:23,944
在今天的演讲中
我们都会使用该演示作为上下文


46
00:02:24,011 --> 00:02:26,313
并从中学到很多内容


47
00:02:27,281 --> 00:02:29,983
我们将会讲解数据的理想组织流程


48
00:02:30,050 --> 00:02:32,352
如何管理大批量动态数据


49
00:02:32,553 --> 00:02:36,156
CPU和GPU同步的重要性


50
00:02:36,290 --> 00:02:39,026
以及如我之前所说 一些多线程编码


51
00:02:39,693 --> 00:02:41,595
希望你已对Metal的基础有所熟悉


52
00:02:41,662 --> 00:02:42,996
因为我们不会再次讲解


53
00:02:43,063 --> 00:02:46,233
我们预设你已经理解
如何新建Metal队列


54
00:02:46,433 --> 00:02:48,902
新建Metal命令缓冲
如何编码指令


55
00:02:49,970 --> 00:02:51,672
我们在此基础上进行下一步


56
00:02:53,240 --> 00:02:57,177
我们先来看演示
看看我们的目标是什么


57
00:02:58,879 --> 00:03:01,348
现在我们有10,000个立方体


58
00:03:01,982 --> 00:03:04,418 line:1
它们都在四处旋转 在空中加载


59
00:03:04,651 --> 00:03:05,853 line:1
很有趣的画面


60
00:03:06,653 --> 00:03:08,689 line:1
Metal允许我们展开无数绘图调用


61
00:03:08,755 --> 00:03:09,957 line:1
开销却很小


62
00:03:10,224 --> 00:03:13,293 line:1
所以在此有10,000个立方体和
10,000个绘图调用


63
00:03:14,061 --> 00:03:16,029 line:1
你可以看到在底部 有一点阴影


64
00:03:16,096 --> 00:03:17,331 line:1
我们正使用一个阴影映射


65
00:03:17,664 --> 00:03:19,933 line:1
它被放在底部
是一些美观的反锯齿线


66
00:03:20,000 --> 00:03:21,235 line:1
产生一些深度暗示


67
00:03:23,003 --> 00:03:24,471 line:1
当然是所有的立方体


68
00:03:25,272 --> 00:03:27,508 line:1
所以怎样才能渲染这样的画面？


69
00:03:27,941 --> 00:03:29,543 line:1
我们有很多对象


70
00:03:29,610 --> 00:03:33,146 line:1
每一个对象都有自身相关联的唯一数据


71
00:03:33,413 --> 00:03:36,617 line:1
我们需要位置 旋转和颜色


72
00:03:37,150 --> 00:03:39,386
每一帧都必须要更新
因为我们在动画显示它们


73
00:03:39,453 --> 00:03:42,256
所以这是我们不断在改变的一组数据


74
00:03:42,623 --> 00:03:45,225
不断重新通知GPU我们正在绘制什么


75
00:03:46,159 --> 00:03:47,861
我们还可以绘制更多的对象


76
00:03:49,096 --> 00:03:50,097 line:1
还可以再多一点


77
00:03:51,098 --> 00:03:52,666 line:1
你可以把它们转动起来


78
00:03:52,733 --> 00:03:54,668 line:1
看到它们正漂浮在空中


79
00:03:56,703 --> 00:04:00,541 line:1
所以我们有一个立方体的绘图调用
和相关数据


80
00:04:00,774 --> 00:04:03,577
我们得想想该如何更好地思考这些数据


81
00:04:03,644 --> 00:04:04,645
如何管理它们


82
00:04:04,811 --> 00:04:06,880
以及如何让它和GPU通讯


83
00:04:08,215 --> 00:04:09,316
让我们深入看一下


84
00:04:09,883 --> 00:04:10,784
谢谢你 Jared


85
00:04:14,755 --> 00:04:16,089
管理动态数据


86
00:04:16,490 --> 00:04:18,992
这是每一帧都在变化的大量数据


87
00:04:19,059 --> 00:04:21,361
可以想像 在一个现代应用里
比如一个游戏


88
00:04:21,495 --> 00:04:24,531
你也需要每帧都要更新的大量数据


89
00:04:25,399 --> 00:04:27,434
所以我们的绘图基本看上去是这样


90
00:04:27,668 --> 00:04:29,937
我们想遍历所有在绘图中感兴趣的对象


91
00:04:30,003 --> 00:04:30,871
并更新它们


92
00:04:31,772 --> 00:04:34,441
然后我们想为每一个对象编码绘图调用


93
00:04:35,008 --> 00:04:37,277
然后我们必须提交所有这些GPU指令


94
00:04:37,678 --> 00:04:38,946
我们有很多对象


95
00:04:39,012 --> 00:04:41,448
我们从10,000个开始 不断增加


96
00:04:41,748 --> 00:04:43,417
直到10万 20万个


97
00:04:44,117 --> 00:04:46,119
每一个对象都有自己的数据集合


98
00:04:46,720 --> 00:04:48,989
我们要找到更新数据的最好方法


99
00:04:50,924 --> 00:04:53,360
过去 你可能做过类似这样的事情


100
00:04:54,261 --> 00:04:55,929
你把更新好的数据推送到GPU


101
00:04:55,996 --> 00:04:57,564
可能是统一形式或其他


102
00:04:58,098 --> 00:05:00,567
绑定一个着色器 一些缓冲 一些纹理


103
00:05:00,634 --> 00:05:01,535
然后开始绘制


104
00:05:02,002 --> 00:05:03,370
然后你推送更多的数据


105
00:05:03,770 --> 00:05:05,506
绑定着色器 缓冲 纹理


106
00:05:05,572 --> 00:05:06,740
绘制下一个对象


107
00:05:07,007 --> 00:05:09,877
在我们的场景里 重复1万 2万次


108
00:05:10,410 --> 00:05:12,579
但是我们想跳出这样的模式


109
00:05:12,646 --> 00:05:13,680
尝试新的方法


110
00:05:16,016 --> 00:05:18,252
如果我们可以预先加载所有数据


111
00:05:18,552 --> 00:05:22,055
所有发出的指令 以及数据引用
都已经存在


112
00:05:22,623 --> 00:05:24,992
GPU是一个非常强大的处理器


113
00:05:25,058 --> 00:05:26,393
它不愿意等待


114
00:05:27,127 --> 00:05:30,831
如果所有数据都已经就位
只需把GPU指向它即可


115
00:05:31,064 --> 00:05:32,599
它会很高兴地开始处理


116
00:05:32,666 --> 00:05:34,101
为我们处理所有的渲染


117
00:05:36,603 --> 00:05:38,071
我们发出的每一个绘图调用


118
00:05:38,138 --> 00:05:41,141
都可以引用合适的数据
都已经存在了


119
00:05:41,742 --> 00:05:43,744
在我们的示例中 这一切很简单易懂


120
00:05:43,810 --> 00:05:46,280
我们有一个绘图调用 引用了一组数据


121
00:05:46,580 --> 00:05:49,216
第一个绘图调用引用第一组数据


122
00:05:49,283 --> 00:05:51,885
第二个 第二组 依此类推


123
00:05:52,486 --> 00:05:53,921
但并不是只有这种方法


124
00:05:54,221 --> 00:05:55,656
实际上可以重复使用数据


125
00:05:56,456 --> 00:05:58,892
我们有一些数据
如前面的这些 帧数据


126
00:05:59,693 --> 00:06:01,762
可以从所有的绘图调用中引用


127
00:06:01,895 --> 00:06:03,197
或者 我们可以有一个绘图调用


128
00:06:03,263 --> 00:06:05,732 line:1
在不同的地方引用两组数据


129
00:06:06,133 --> 00:06:08,902
如果你熟悉实例化的概念
其理念是很相近的


130
00:06:09,203 --> 00:06:12,172
开始渲染的时候
所有的数据已经准备好


131
00:06:15,142 --> 00:06:16,577
Metal是如何做到的？


132
00:06:17,377 --> 00:06:20,848
在我们的应用里
新建一个单一Metal缓冲


133
00:06:21,014 --> 00:06:22,516
这是我们的常量缓冲


134
00:06:22,616 --> 00:06:25,085
它拥有我们需要用来渲染框架的
所有数据


135
00:06:25,552 --> 00:06:28,722
我们想事先就新建好 在渲染循环之外


136
00:06:28,789 --> 00:06:30,490
并且在每一次绘制中重新使用


137
00:06:31,058 --> 00:06:32,459
我们不需要复制任何数据


138
00:06:32,893 --> 00:06:35,495
再次强调
任何绘图调用可以引用任何数据


139
00:06:35,996 --> 00:06:37,598
所以没有必要复制


140
00:06:38,465 --> 00:06:41,201
每一个绘图调用都会
把一个偏移引用到缓冲


141
00:06:41,602 --> 00:06:45,105
它会作一小部分跟踪处理
从而知道哪个绘图代表了哪个偏移


142
00:06:46,106 --> 00:06:48,775
你可以运用一切绘图 一切都已经就位


143
00:06:49,176 --> 00:06:50,811
我们来看看这部分代码


144
00:06:53,213 --> 00:06:54,515
这是应用里的代码


145
00:06:54,781 --> 00:06:56,750
你可以认为我们有两个数据集合


146
00:06:56,817 --> 00:06:59,319
如我之前所讲 有一个帧数据集合


147
00:06:59,887 --> 00:07:01,054
将在这里进行更新


148
00:07:03,357 --> 00:07:05,926
这是每个对象都发生改变的数据集合


149
00:07:06,293 --> 00:07:08,562
这是唯一旋转位置 等等


150
00:07:09,796 --> 00:07:11,765
我们需要把两组数据都准备好


151
00:07:16,870 --> 00:07:18,539
我所说的每帧数据是什么意思呢？


152
00:07:19,473 --> 00:07:22,509
这是每次进行绘图调用时
都保持一致的数据


153
00:07:23,377 --> 00:07:26,480
比如 在本例中 有一个视图投影矩阵


154
00:07:26,547 --> 00:07:28,782
这是个4X4的矩阵 很直观


155
00:07:28,849 --> 00:07:30,384
如果你熟悉图像处理


156
00:07:30,450 --> 00:07:32,953
它代表了照相机变换和投影


157
00:07:33,420 --> 00:07:35,255
在框架范围内将不会发生改变


158
00:07:35,322 --> 00:07:36,757
所以我们只需要一份副本


159
00:07:38,091 --> 00:07:39,993
我们想要尽可能多地重复使用数据


160
00:07:40,894 --> 00:07:43,564
所以我们新建一个副本 放入缓冲内


161
00:07:43,931 --> 00:07:45,265
开始填充


162
00:07:47,234 --> 00:07:50,037
在这里 是常量缓冲


163
00:07:50,103 --> 00:07:52,005
也就是新建的Metal缓冲


164
00:07:52,072 --> 00:07:54,775
通过Contents函数
我们有了一个指向它的指针


165
00:07:58,545 --> 00:08:01,281
我们的应用有一个帮助函数
也就是取出帧数据


166
00:08:01,548 --> 00:08:04,418
它将返回我刚演示过的主通路结构


167
00:08:04,484 --> 00:08:06,119
里面有视图转换


168
00:08:06,186 --> 00:08:08,188
视图投影转换
不好意思


169
00:08:08,922 --> 00:08:11,859
之后只需简单地把它复制到缓冲的前端


170
00:08:12,826 --> 00:08:13,994
然后一切就绪


171
00:08:15,028 --> 00:08:16,496
我们的缓冲看上去将会是这样


172
00:08:16,563 --> 00:08:19,466
我们有一个主通路 含有合适的帧数据


173
00:08:20,133 --> 00:08:22,669
并且把它放到巨大的常量缓冲的前端


174
00:08:23,837 --> 00:08:25,973
所以后面会有这一片空白区域


175
00:08:26,039 --> 00:08:29,543
如之前所见
我们需要做1万次 2万次的绘图调用


176
00:08:29,776 --> 00:08:32,479
所以需要开始在里面填充很多信息


177
00:08:35,249 --> 00:08:37,183
然后我们有了一组每个对象数据


178
00:08:37,618 --> 00:08:40,153
这是绘制单一对象所需要的唯一数据


179
00:08:40,888 --> 00:08:43,789
在我们的例子里
有一个“局部空间到世界空间”转换


180
00:08:43,857 --> 00:08:46,493
它是位置和旋转的串联


181
00:08:46,727 --> 00:08:47,761
还有颜色


182
00:08:48,595 --> 00:08:50,931
这就是每一个绘图调用所需的数据集合


183
00:08:56,403 --> 00:08:58,872
我们会遍历想要渲染的每一个对象


184
00:08:59,673 --> 00:09:01,808
记录偏移位置到缓冲


185
00:09:02,309 --> 00:09:04,344
我们有“更新数据”实用工具函数


186
00:09:04,411 --> 00:09:06,747
它将更新旋转数据


187
00:09:06,813 --> 00:09:08,348
然后更新偏移数据


188
00:09:08,649 --> 00:09:11,652
这样将数据紧密封装
一边遍历一边填充


189
00:09:11,919 --> 00:09:14,588
看看“更新数据”函数是什么样子


190
00:09:16,456 --> 00:09:17,391
它非常简单


191
00:09:19,359 --> 00:09:22,329
动画效果似乎不是本次演讲的范围


192
00:09:22,996 --> 00:09:26,600
有一个小帮助函数 “更新动画”函数
带有“增量时间”参数


193
00:09:26,867 --> 00:09:28,969
在你的应用里
可以按照自己的意愿编码


194
00:09:29,036 --> 00:09:30,204
而且确实应该这样做


195
00:09:30,270 --> 00:09:31,939
但是也要看你需要什么样的动画


196
00:09:33,507 --> 00:09:35,943
在我的例子里
它返回一个对象数据对象


197
00:09:36,276 --> 00:09:38,478
它有局部空间到世界空间转换和颜色


198
00:09:39,513 --> 00:09:43,283
和之前一样 把它复制到常量缓冲


199
00:09:48,722 --> 00:09:50,123
看上去是这个样子


200
00:09:50,624 --> 00:09:52,125
帧数据已经准备完毕


201
00:09:55,996 --> 00:09:57,097
还有别的数据


202
00:09:59,099 --> 00:10:01,635
其他的数据 还有其他的


203
00:10:02,603 --> 00:10:05,439 line:1
所有的数据都到位了 我们准备好渲染


204
00:10:05,939 --> 00:10:07,307
但是不是还缺了点什么？


205
00:10:10,377 --> 00:10:13,046
确实缺了什么
我想要提醒你们注意的是


206
00:10:13,113 --> 00:10:14,615
我们有一个常量缓冲


207
00:10:14,815 --> 00:10:17,551
我说过新建一个Metal缓冲
然后反复使用


208
00:10:18,619 --> 00:10:19,753
这样做有一个问题


209
00:10:19,820 --> 00:10:23,724
CPU和GPU实际上是
两个不同的平行处理器


210
00:10:24,057 --> 00:10:26,693
它们可以同时对同一内存进行读写


211
00:10:27,127 --> 00:10:28,562
会发生什么 如果有函数


212
00:10:28,629 --> 00:10:31,532
正在读一块内存 而另外有函数在写？


213
00:10:35,135 --> 00:10:36,236
资源争用


214
00:10:39,039 --> 00:10:40,407
看上去有点像这样


215
00:10:40,974 --> 00:10:43,911
CPU准备好一个帧数据
写入一个缓存


216
00:10:45,779 --> 00:10:47,447
GPU开始处理


217
00:10:49,516 --> 00:10:50,717
它从缓存里读取数据


218
00:10:51,385 --> 00:10:53,387
而CPU对这一切一无所知


219
00:10:53,453 --> 00:10:55,422
它决定 我要准备下一帧数据


220
00:10:55,489 --> 00:10:57,291
然后它开始覆盖相同的数据


221
00:10:59,526 --> 00:11:01,094
现在结果变成未定义


222
00:11:01,161 --> 00:11:02,963
我们不知道读入了什么


223
00:11:03,030 --> 00:11:05,832
读出什么 或者写入什么
数据状态会是什么


224
00:11:08,769 --> 00:11:12,206
所以认识到在Metal里
这不是隐式处理 这点很重要


225
00:11:12,573 --> 00:11:16,543
CPU和GPU可以随意
同时写同样的数据


226
00:11:16,944 --> 00:11:18,779
必须自己同步访问权限


227
00:11:19,613 --> 00:11:22,049
就好像编写多线程的CPU代码


228
00:11:22,649 --> 00:11:25,052
必须得确保没有踩到自己


229
00:11:28,388 --> 00:11:31,692
这把我们带到了
CPU-GPU同步的主题


230
00:11:32,259 --> 00:11:33,260
让我们从简单的开始


231
00:11:35,195 --> 00:11:38,131
最简单的方法就是 等待


232
00:11:38,198 --> 00:11:40,367
把指令提交给GPU之后


233
00:11:41,068 --> 00:11:43,036
CPU绘图函数做好所有的工作


234
00:11:43,103 --> 00:11:45,239
提交指令 然后就坐在那儿等


235
00:11:45,305 --> 00:11:47,441
直到它确保GPU的工作完成


236
00:11:48,709 --> 00:11:50,644
这样我们就知道永远不会覆盖


237
00:11:50,711 --> 00:11:53,981
因为我们试图生产下一帧数据时
GPU是空闲的


238
00:11:55,115 --> 00:11:56,917
这种做法不够快 但很安全


239
00:11:57,284 --> 00:12:00,220
所以需要有某种机制
让GPU通知我们


240
00:12:00,287 --> 00:12:02,322
嘿 我工作完成 你开始做你的吧


241
00:12:04,391 --> 00:12:06,660
Metal提供了这种机制
以回调的形式


242
00:12:06,860 --> 00:12:09,596
我们称为处理程序 其中两种很有意思


243
00:12:10,697 --> 00:12:11,832
“添加计划处理程序”


244
00:12:12,266 --> 00:12:16,703
当命令缓冲被计划在GPU上运行时
将执行该处理程序


245
00:12:18,739 --> 00:12:22,075
对我们来说 更有意思的是
“完成处理程序”


246
00:12:22,442 --> 00:12:23,577
它将被调用


247
00:12:23,644 --> 00:12:26,246
当GPU结束执行一个命令缓冲时


248
00:12:26,580 --> 00:12:28,615
命令缓冲完全退休时


249
00:12:28,782 --> 00:12:31,952
此时我们确定修改任何资源都是安全的


250
00:12:32,019 --> 00:12:33,120
正在使用的任何资源


251
00:12:34,021 --> 00:12:34,922
这样非常完美


252
00:12:34,988 --> 00:12:37,057
我们只需要采用某种方法告诉自己


253
00:12:37,124 --> 00:12:39,026
嘿 我们完成了 继续下一步


254
00:12:41,929 --> 00:12:44,665
你们当中有多少人熟悉信号量的概念？


255
00:12:45,232 --> 00:12:46,133
有谁知道？


256
00:12:47,034 --> 00:12:47,935
很好


257
00:12:48,735 --> 00:12:50,270
快速介绍一下信号量的背景


258
00:12:50,337 --> 00:12:51,638
它们是同步基元


259
00:12:51,705 --> 00:12:54,575
被用来控制有限资源的访问权限


260
00:12:54,641 --> 00:12:56,076
应用在此堪称完美


261
00:12:56,510 --> 00:13:00,214
我们有一个常量缓存
它是一个有限资源


262
00:13:00,280 --> 00:13:03,317
我们将会新建一个信号量 初始值为1


263
00:13:03,383 --> 00:13:04,918
信号量的值代表


264
00:13:04,985 --> 00:13:06,653
有多少想要保护的有限资源


265
00:13:08,589 --> 00:13:09,756
新建一个信号量


266
00:13:09,823 --> 00:13:12,392
它应该建立在渲染循环以外


267
00:13:13,360 --> 00:13:15,362
一旦开始绘图 第一件要做的事情


268
00:13:16,363 --> 00:13:17,698
就是等待信号量


269
00:13:19,266 --> 00:13:21,168
Apple里的信号量
称为“等待”


270
00:13:21,235 --> 00:13:23,403
有人称它为“占据”
有人称之为“倒数”


271
00:13:23,470 --> 00:13:24,471
无关紧要


272
00:13:24,838 --> 00:13:26,473
理念就是等着它


273
00:13:26,540 --> 00:13:28,542
把超时设置为遥远的未来


274
00:13:28,775 --> 00:13:30,644
也就是说我们会永远等待下去


275
00:13:30,744 --> 00:13:32,946
如果没有资源可用 线程会进入休眠


276
00:13:33,046 --> 00:13:34,381
等着做点什么


277
00:13:36,483 --> 00:13:37,484
我们结束后


278
00:13:37,751 --> 00:13:40,120
在完成处理程序里 我们会通知信号量


279
00:13:41,021 --> 00:13:44,024
那将会告诉我们 修改资源又安全了


280
00:13:45,092 --> 00:13:47,494
工作已全部完成 可以进行下一步


281
00:13:50,397 --> 00:13:52,833
这是一个有点幼稚的同步方法


282
00:13:52,900 --> 00:13:54,268
看上去有点像这个样子


283
00:13:55,335 --> 00:13:57,004
我们会把帧数据0写入缓冲


284
00:13:58,372 --> 00:14:01,041
GPU从缓冲读取


285
00:14:01,108 --> 00:14:02,276
CPU将会等待


286
00:14:02,809 --> 00:14:05,212
当GPU处理完帧数据0


287
00:14:05,279 --> 00:14:08,815
它将发送完成处理程序
帧数据1开始工作


288
00:14:09,816 --> 00:14:11,685
并将在CPU上新建一帧数据


289
00:14:12,953 --> 00:14:14,888
GPU上会对其进行处理 依此类推


290
00:14:15,989 --> 00:14:19,193
这种方法可行 但如你所见
有这么多等待时间


291
00:14:19,726 --> 00:14:22,496
CPU和GPU实际上都有
一半的时间处于空闲


292
00:14:22,896 --> 00:14:25,265
看上去并没有好好利用计算资源


293
00:14:27,568 --> 00:14:30,637
我们想要做的是
重叠CPU和GPU的工作时间


294
00:14:31,338 --> 00:14:34,308
这样就可以利用系统固有的并行机制


295
00:14:35,008 --> 00:14:37,344
但还是需要想办法避免踩到数据


296
00:14:40,314 --> 00:14:42,716
所以我们理想的工作量看上去是这样


297
00:14:44,017 --> 00:14:47,521
第0帧将会在CPU上做好准备
推到GPU


298
00:14:47,588 --> 00:14:49,256
当GPU处理它时


299
00:14:49,323 --> 00:14:54,595
CPU开始新建帧数据1 等等
反复如此


300
00:14:56,597 --> 00:14:58,065
在此谨记一点


301
00:14:58,632 --> 00:15:01,568
CPU实际上要比GPU超前一点


302
00:15:01,768 --> 00:15:03,937
请注意 当帧数据2在CPU上时


303
00:15:05,572 --> 00:15:07,574
GPU上只有帧数据0是完成的


304
00:15:07,641 --> 00:15:08,609
所以CPU有一点超前


305
00:15:08,675 --> 00:15:10,577
也请你一直记住这点


306
00:15:12,446 --> 00:15:15,415
来看看演示里的解决方案
看我们是怎么做的


307
00:15:16,683 --> 00:15:19,853 line:1
我们想要重叠CPU和GPU
但我们知道无法做到


308
00:15:19,920 --> 00:15:21,722 line:1
用一个常量缓冲 而不等待很长时间


309
00:15:21,989 --> 00:15:24,525 line:1
所以解决方案是新建一个缓冲池


310
00:15:26,927 --> 00:15:28,228 line:1
所以新建帧数据0


311
00:15:28,929 --> 00:15:30,197 line:1
把它写入一个缓冲


312
00:15:31,198 --> 00:15:32,332 line:1
然后CPU开始工作


313
00:15:32,399 --> 00:15:35,235 line:1
新建下一个帧数据 写入另一个缓冲


314
00:15:36,336 --> 00:15:38,639 line:1
此时 GPU可以自由从缓冲中读取


315
00:15:38,705 --> 00:15:40,274 line:1
之前的那个缓冲


316
00:15:41,742 --> 00:15:43,477 line:1
我们没有无限的缓冲


317
00:15:43,544 --> 00:15:45,078 line:1
因为没有无限的内存


318
00:15:45,145 --> 00:15:46,647 line:1
所以缓冲池必须得有个限额


319
00:15:47,047 --> 00:15:48,882 line:1
在我们的应用中 我们选择了3个


320
00:15:49,316 --> 00:15:51,151 line:1
这部分你得自己决定


321
00:15:51,218 --> 00:15:52,486 line:1
我们无法告诉你怎么做


322
00:15:53,320 --> 00:15:55,856 line:1
因为要考虑延迟的问题


323
00:15:56,323 --> 00:15:57,858
想要用多少内存


324
00:15:58,225 --> 00:16:00,894
所以我们建议你测试自己的应用
了解多少是最合适的


325
00:16:01,929 --> 00:16:03,697
本例中 我们选择3个


326
00:16:06,033 --> 00:16:08,669
在这里 可以看到缓冲池用完了


327
00:16:08,735 --> 00:16:10,204
我们准备好3帧数据


328
00:16:10,270 --> 00:16:11,805
但GPU只处理完成了一帧


329
00:16:12,105 --> 00:16:13,207
所以得等一会儿


330
00:16:15,609 --> 00:16:17,144
现在 帧数据0已经完成


331
00:16:17,211 --> 00:16:20,747
所以可再次使用池里的缓冲 如此继续


332
00:16:28,388 --> 00:16:29,590
来看一下代码


333
00:16:30,490 --> 00:16:32,492
同步常量缓冲的访问权限


334
00:16:32,759 --> 00:16:34,328
我们已经有了一个信号量


335
00:16:34,394 --> 00:16:37,130
它可以很好地控制有限资源的访问权限


336
00:16:37,197 --> 00:16:38,565
在本例中 我们的限制是3


337
00:16:39,099 --> 00:16:40,234
但这个数字可随意设定


338
00:16:41,335 --> 00:16:43,637
在这里按照限制数字
新建了一个信号量


339
00:16:44,605 --> 00:16:46,673
我们不再只新建一个常量缓冲


340
00:16:46,740 --> 00:16:48,041
而是新建一个缓冲数组


341
00:16:50,344 --> 00:16:51,278
最后


342
00:16:52,179 --> 00:16:53,380
需要一个索引


343
00:16:53,847 --> 00:16:55,516
我们用这个索引表示


344
00:16:55,582 --> 00:16:57,851
当前可用的常量缓冲数


345
00:16:58,318 --> 00:17:00,521
我们可以遍历数组并回返


346
00:17:00,587 --> 00:17:03,123
信号量会控制我们的访问权限
和保护我们


347
00:17:07,227 --> 00:17:10,364
所以在绘图函数里
我们会立即等待信号量


348
00:17:11,031 --> 00:17:12,900
如果没有可用缓冲 就进入休眠


349
00:17:14,101 --> 00:17:15,903
一旦取得信号量 就开始工作


350
00:17:15,969 --> 00:17:18,204
我们知道获取当前的
常量缓冲是安全的


351
00:17:18,906 --> 00:17:22,108
在索引中 “当前常量缓冲”
记录哪个资源可用


352
00:17:23,710 --> 00:17:26,413
然后正常填写帧数据 编码所有命令


353
00:17:26,480 --> 00:17:29,283
进行更新 添加完成处理程序


354
00:17:30,751 --> 00:17:33,320
然后我们通知信号量
说嘿 该帧数据处理完了


355
00:17:33,554 --> 00:17:34,488
你可以进行下一步了


356
00:17:35,522 --> 00:17:38,225
最后要做的是更新索引


357
00:17:39,293 --> 00:17:41,562
我们加上1 我们取模进行环绕


358
00:17:42,196 --> 00:17:44,364
我们不用担心覆盖自身


359
00:17:44,431 --> 00:17:45,899
因为信号量会保护我们


360
00:17:48,802 --> 00:17:50,437
这就是演示中的常量缓冲


361
00:17:51,138 --> 00:17:52,940
演示里有一个3个缓冲的数列


362
00:17:53,407 --> 00:17:55,509
但我也看过有些应用会跟踪缓冲


363
00:17:55,576 --> 00:17:59,079
把它们标记为
该缓冲正在被帧数据7读取


364
00:17:59,146 --> 00:18:00,881
该缓冲正在被帧数据5写入


365
00:18:01,215 --> 00:18:03,317
在本模式下 我们不需要这么做


366
00:18:03,383 --> 00:18:05,819
信号量为你做所有同步的工作


367
00:18:06,987 --> 00:18:08,355
而且如果你取得了信号量


368
00:18:08,422 --> 00:18:11,158
你可以确认最后正在使用
该资源的帧数据已经结束


369
00:18:11,225 --> 00:18:12,426
否则你还会处于休眠


370
00:18:14,728 --> 00:18:17,698
所以现在数据都已经准备好
并且受到保护


371
00:18:19,533 --> 00:18:22,169
我们想要发出一些绘图调用


372
00:18:22,236 --> 00:18:23,570
在屏幕上显示一些图像


373
00:18:27,140 --> 00:18:29,510
这就是本演示的基本渲染循环


374
00:18:30,911 --> 00:18:33,547
我们有两个通路：
一个通路绘制阴影映射


375
00:18:33,981 --> 00:18:35,549
一个通路读取该阴影映射


376
00:18:36,016 --> 00:18:38,852
我们决定把它们分成
两个独立的命令缓冲


377
00:18:39,319 --> 00:18:40,554
这样做有一个很好的理由


378
00:18:40,921 --> 00:18:43,123
它让我们有两个编码函数


379
00:18:43,190 --> 00:18:44,591
是独立和唯一的


380
00:18:45,025 --> 00:18:46,493
它们不依赖于彼此


381
00:18:46,793 --> 00:18:49,229
你编码阴影通路 你把它传到命令缓冲


382
00:18:49,296 --> 00:18:51,498
以及你已经填写的常量缓冲


383
00:18:51,932 --> 00:18:54,501
它会编码所有的命令 渲染阴影映射


384
00:18:55,302 --> 00:18:58,272
然后你有了一个独立的编码函数
可以编码主通路


385
00:18:58,338 --> 00:19:00,908
把它传到主命令缓冲
以及其他所需数据


386
00:19:00,974 --> 00:19:02,643
编码所有其他的命令


387
00:19:03,410 --> 00:19:04,878
编码结束时


388
00:19:05,145 --> 00:19:07,748
调用提交两个命令缓冲


389
00:19:07,981 --> 00:19:10,384
输出 帧数据处理完毕


390
00:19:14,221 --> 00:19:17,291
那么 如何真正编码绘制
其中一个立方体？


391
00:19:17,791 --> 00:19:20,561
我们需要一组数据
而不仅仅是旋转数据


392
00:19:21,295 --> 00:19:23,330
我们需要立方体的一些几何数据


393
00:19:23,530 --> 00:19:24,898
这非常简单 你知道


394
00:19:24,965 --> 00:19:27,968
把立方体想成是8个顶点
也许还有一个索引缓冲


395
00:19:29,102 --> 00:19:32,239
在本例中 我们不需要任何复杂的材料


396
00:19:32,306 --> 00:19:33,974
只需用到很简单的漫反射着色


397
00:19:34,408 --> 00:19:36,777
因此我们可以重复使用管道状态对象


398
00:19:36,844 --> 00:19:38,011
在所有立方体范围内


399
00:19:39,046 --> 00:19:40,681
我们之前提到过每帧数据


400
00:19:40,747 --> 00:19:41,915
我们需要它的一份副本


401
00:19:42,282 --> 00:19:44,117
我们更新它 准备好


402
00:19:44,818 --> 00:19:46,687
当然我们还需要 每光学数据


403
00:19:47,020 --> 00:19:50,457
以及我们动画里展示
的 LocalToWorld和颜色信息


404
00:19:52,559 --> 00:19:54,094
所以当发出绘图调用时


405
00:19:54,895 --> 00:19:56,663
我们想确保引用了正确的数据


406
00:19:57,364 --> 00:19:59,433
所以编码器会产生命令


407
00:19:59,499 --> 00:20:00,801
把它们放入命令缓冲


408
00:20:01,168 --> 00:20:02,236
绘图调用0


409
00:20:02,302 --> 00:20:05,873
将会引用帧数据和我们感兴趣的对象


410
00:20:06,907 --> 00:20:09,576
绘图调用1 同样 将会引用帧数据


411
00:20:10,410 --> 00:20:12,913
和对象1数据 依此类推


412
00:20:14,248 --> 00:20:15,349
这样一切都会准备好


413
00:20:15,415 --> 00:20:18,452
发出调用 GPU开始处理


414
00:20:20,888 --> 00:20:22,756
现在我们有很多调用要发出


415
00:20:22,923 --> 00:20:25,526
你知道 在演示中 至少有1万个


416
00:20:26,360 --> 00:20:28,629
我们想尽可能高效地发出调用


417
00:20:29,530 --> 00:20:31,632
我们想避免重复的工作


418
00:20:31,698 --> 00:20:33,667
不想每一次绘制就进行重设


419
00:20:33,967 --> 00:20:37,371
所有共享资源 几何 管道状态


420
00:20:37,504 --> 00:20:40,140
我们只想设一次 然后保持


421
00:20:40,974 --> 00:20:42,843
这样就可以避免重复的状态更新


422
00:20:43,143 --> 00:20:45,045
并且避免重复的变量表格更新


423
00:20:46,146 --> 00:20:48,315
还有一点值得注意


424
00:20:48,382 --> 00:20:51,151
顶点和片段变量表是完全分开的


425
00:20:52,052 --> 00:20:54,021
你可以将缓冲绑定在顶点阶段


426
00:20:54,087 --> 00:20:55,989
而不是片段阶段 反之同理


427
00:20:56,590 --> 00:20:58,325
但若必须要把所有绑定到两个阶段


428
00:20:58,392 --> 00:21:02,062
调用“设置顶点缓冲”函数时
可能会调用两次


429
00:21:02,129 --> 00:21:03,564
“设置片段缓冲”函数也是如此


430
00:21:03,630 --> 00:21:06,633
这就是为什么在本例
没有使用“设置顶点字节”函数


431
00:21:07,267 --> 00:21:09,803
你可以想像
我们有50,000个对象


432
00:21:10,137 --> 00:21:12,973
必须把所有那些数据复制两遍


433
00:21:13,040 --> 00:21:15,342
一遍在顶点阶段 一遍在片段阶段


434
00:21:15,576 --> 00:21:16,810
很快工作量会变得很大


435
00:21:17,678 --> 00:21:19,847
而如果把所有数据放入一个缓冲
只需引用它


436
00:21:19,913 --> 00:21:21,181
我们就不用担心该问题了


437
00:21:22,182 --> 00:21:23,884
最后我想指出的是


438
00:21:24,718 --> 00:21:25,919
使用新函数


439
00:21:26,887 --> 00:21:30,224
“设置顶点缓冲偏移”和
“设置片段缓冲偏移”


440
00:21:31,091 --> 00:21:34,328
这只是把指针指向其中一个缓冲


441
00:21:36,830 --> 00:21:38,699
可以看到 在调用这些函数时


442
00:21:38,765 --> 00:21:41,034
它们并没有把引用放入Metal缓冲


443
00:21:41,401 --> 00:21:44,438
它们只取出了一个偏移和一个索引


444
00:21:45,072 --> 00:21:48,375
因为你肯定已经设置该指针指向缓冲


445
00:21:48,876 --> 00:21:50,677
这样缓冲内部的指针也随之改变


446
00:21:50,944 --> 00:21:52,279
这就是我们想要实现的


447
00:21:52,713 --> 00:21:55,282
我们有一个常量缓冲 正在遍历


448
00:21:55,782 --> 00:21:57,451
所以可以在一开始只设置一次


449
00:21:57,918 --> 00:22:00,988
然后每一次绘制时
就调用“设置顶点缓冲偏移”函数


450
00:22:01,488 --> 00:22:04,458
并且把下一个绘图调用
指向缓冲中正确的位置


451
00:22:05,092 --> 00:22:06,460
看上去有点像这样


452
00:22:07,294 --> 00:22:08,762
绑定该常量缓冲


453
00:22:09,329 --> 00:22:11,164
然后调用“设置顶点缓冲偏移”函数


454
00:22:12,199 --> 00:22:13,200
用该偏移量作为参数


455
00:22:14,601 --> 00:22:16,937
然后再次调用 继续往前


456
00:22:18,238 --> 00:22:19,606
再一次往前


457
00:22:20,274 --> 00:22:22,809
我们并没有修改该索引指定的缓冲


458
00:22:22,943 --> 00:22:24,945
我们只是修改了缓冲里的偏移值


459
00:22:28,148 --> 00:22:29,683
记住这些原则


460
00:22:29,750 --> 00:22:31,585
编码其实非常简单


461
00:22:33,654 --> 00:22:35,289
可以事先设置好一组数据


462
00:22:35,589 --> 00:22:37,524
每帧常量是很显然的


463
00:22:37,591 --> 00:22:39,059
因为我们知道会修改它


464
00:22:39,126 --> 00:22:40,027
所以一起来设置


465
00:22:41,395 --> 00:22:44,698
我们将一次设定常量缓冲
因为它必须要准备好


466
00:22:44,765 --> 00:22:47,267
我们才能使用设置顶点缓冲偏移函数


467
00:22:49,102 --> 00:22:51,705
还会设置几何缓冲 和管道状态


468
00:22:51,772 --> 00:22:53,874
我们知道整个立方体范围内
它们是共享的


469
00:22:55,609 --> 00:22:58,512
然后终于可以开始循环
通过想要绘制的对象


470
00:22:59,980 --> 00:23:01,982
设置当前绘图调用


471
00:23:02,049 --> 00:23:02,916
常量缓冲的偏移值


472
00:23:05,052 --> 00:23:06,420
然后我们真正开始绘图


473
00:23:11,325 --> 00:23:14,061
这里是 "编码主要通路"
函数的代码


474
00:23:14,261 --> 00:23:15,095
在例子里的


475
00:23:16,463 --> 00:23:18,432
首先设置顶点缓冲


476
00:23:18,498 --> 00:23:20,901
那是几何和渲染管道状态


477
00:23:21,235 --> 00:23:22,870
也就是光照阴影管道


478
00:23:25,138 --> 00:23:26,373
我们将会设置常量缓冲


479
00:23:26,440 --> 00:23:28,408
在之后调用
“设置顶点缓冲偏移”函数


480
00:23:28,575 --> 00:23:32,179
在本例中把它传给顶点和片段阶段


481
00:23:34,715 --> 00:23:36,116
然后设置每帧数据


482
00:23:38,352 --> 00:23:40,287
你现在看到
我已设置了一个常量缓冲


483
00:23:40,354 --> 00:23:43,323
有两个分开的索引 和不同的偏移


484
00:23:43,390 --> 00:23:45,225
Metal允许你随意这样做


485
00:23:45,826 --> 00:23:48,529
可以把同样的常量缓冲设给每一个索引


486
00:23:48,595 --> 00:23:51,231
带有不同的偏移 如果你愿意的话
完全取决于你


487
00:23:54,001 --> 00:23:55,502
接下来马上看看缓冲池


488
00:23:56,436 --> 00:23:59,106
我们需要追踪偏移 因为我们不是


489
00:23:59,173 --> 00:24:00,774
在常量缓冲的开始部分开始的


490
00:24:00,841 --> 00:24:02,142
还有一些帧数据在那里


491
00:24:02,609 --> 00:24:04,945
所以偏移将会被推回 经过帧数据


492
00:24:06,747 --> 00:24:09,950
然后将调用“设置顶点缓冲偏移”
及“设置片段缓冲偏移”函数


493
00:24:10,884 --> 00:24:13,687
来把该绘图调用指向要绘制的正确数据


494
00:24:15,422 --> 00:24:16,623
发出绘图调用


495
00:24:17,357 --> 00:24:22,095
然后再次设置偏移 一次完成一个对象


496
00:24:25,065 --> 00:24:26,400
绘图都准备好了


497
00:24:27,301 --> 00:24:28,569
这仍然是非常线性


498
00:24:28,669 --> 00:24:30,304
我答应做一些多线程编程


499
00:24:30,671 --> 00:24:31,972
并且Warren提过


500
00:24:32,039 --> 00:24:34,208
可以在Metal里进行平行编码


501
00:24:34,808 --> 00:24:36,009
该怎么做？


502
00:24:37,244 --> 00:24:38,912
一个理想框架看上应该是这样


503
00:24:38,979 --> 00:24:41,982
渲染线程正在埋头苦干
然后它意识到 嘿


504
00:24:42,049 --> 00:24:44,518
我得渲染一个阴影映射
还得渲染一个主通路


505
00:24:44,885 --> 00:24:46,587
要是我能并行编码就好了


506
00:24:47,087 --> 00:24:48,555
我有很多CPU


507
00:24:49,056 --> 00:24:52,059
如果能调度一些工作出去
进行一些编码


508
00:24:53,227 --> 00:24:54,795
然后回来继续参与渲染线程


509
00:24:54,862 --> 00:24:57,497
然后渲染线程把它推给GPU


510
00:24:57,564 --> 00:24:58,665
让GPU做接下来的工作


511
00:24:58,966 --> 00:24:59,933
这种方法一定非常好


512
00:25:03,570 --> 00:25:05,572
你们中有多少人
用过GCD（大中央调度）？


513
00:25:07,040 --> 00:25:09,076
此时非常适合使用大中央调度


514
00:25:09,142 --> 00:25:12,813
大中央调度是
Apple的多处理API


515
00:25:13,280 --> 00:25:15,282
该API让你新建队列


516
00:25:15,782 --> 00:25:17,818
这些队列管理计算资源


517
00:25:18,252 --> 00:25:19,152
在你的机器上


518
00:25:19,720 --> 00:25:21,188
可以新建两种类型的队列


519
00:25:21,655 --> 00:25:22,823
一种是串行队列


520
00:25:23,357 --> 00:25:25,192
当你通过串行队列调度工作时


521
00:25:25,259 --> 00:25:27,594
可以保证所有工作都按照顺序处理


522
00:25:28,629 --> 00:25:31,832
但对我们来说更有意思的是并发队列


523
00:25:32,833 --> 00:25:34,701
当你把工作调度给并发队列


524
00:25:35,102 --> 00:25:36,537
大中央调度会查看系统


525
00:25:36,603 --> 00:25:38,539
为你做出最好的安排


526
00:25:39,273 --> 00:25:40,107
这非常完美


527
00:25:40,174 --> 00:25:42,109
我们有两个需要并行的作业


528
00:25:42,809 --> 00:25:45,812
所以我们新建这一个队列
把工作推送给它


529
00:25:46,213 --> 00:25:47,247
它会帮我完成


530
00:25:48,515 --> 00:25:51,084
有另一个对象你想新建一次
并可以重复使用


531
00:25:51,518 --> 00:25:53,754
这里是一些新建并发调度队列的代码


532
00:25:54,254 --> 00:25:55,789
你应该始终为队列加上标签


533
00:25:55,856 --> 00:25:57,925
在此我使用了
非常具有创造性的标签队列


534
00:25:58,592 --> 00:25:59,993
但你也许想称呼它别的名称


535
00:26:03,730 --> 00:26:05,499
所以我们修改了部分代码


536
00:26:06,533 --> 00:26:08,468
一开始还是新建命令缓冲


537
00:26:09,870 --> 00:26:13,440
但是既然我们如此聪明
会使用两个命令缓冲


538
00:26:13,674 --> 00:26:16,577
并把编码函数分成两个不同的函数


539
00:26:16,777 --> 00:26:19,379
我们除了调度工作外
没什么别的事情可做


540
00:26:20,480 --> 00:26:22,115
所以dispatchQueue.async


541
00:26:22,549 --> 00:26:25,519
是大中央调度中用来调度工作的主调用


542
00:26:25,853 --> 00:26:27,154
这是一个异步调用


543
00:26:27,554 --> 00:26:30,357
它将推送工作 线程将会继续


544
00:26:31,425 --> 00:26:34,294
在这里我们调度了阴影通路


545
00:26:36,163 --> 00:26:37,598
然后我们调度了主通路


546
00:26:39,299 --> 00:26:40,934
我们得想办法提交该工作


547
00:26:41,535 --> 00:26:43,203
所以我们调用“调度障碍同步”


548
00:26:43,837 --> 00:26:47,007
这将确保此时所有的工作都已经完成


549
00:26:48,675 --> 00:26:52,012
最终我们重新加入 提交工作


550
00:26:52,779 --> 00:26:54,281
在这里 顺序是很重要的


551
00:26:54,882 --> 00:26:57,417
阴影映射必须在我们要引用的时候完成


552
00:26:57,885 --> 00:27:00,187
所以必须首先提交阴影命令缓冲


553
00:27:00,554 --> 00:27:02,122
之后是主命令缓冲


554
00:27:04,892 --> 00:27:06,593
在这里我还想提出一点


555
00:27:07,427 --> 00:27:09,630
你们之中有多少人熟悉“闭包”的概念


556
00:27:12,232 --> 00:27:13,066
很好


557
00:27:13,300 --> 00:27:16,737
有多少人曾经在闭包捕获自身时
遇到过问题


558
00:27:16,904 --> 00:27:18,839
你以为自己在引用别的？


559
00:27:20,507 --> 00:27:22,142
你们可诚实作答
我们都会发生


560
00:27:22,943 --> 00:27:24,311
我只是想提出这一点


561
00:27:24,478 --> 00:27:25,846
闭包捕获自身


562
00:27:25,913 --> 00:27:29,349
如果你正在引用一个成员变量
或其中的成员变量


563
00:27:29,616 --> 00:27:32,019
而你并没明确指定self.iVar


564
00:27:32,286 --> 00:27:34,555
它还是会引用那个变量


565
00:27:35,122 --> 00:27:38,792
如果你想确保引用正确的数据


566
00:27:39,493 --> 00:27:43,263
在外部捕获它是一个好方法
我将会马上对此进行演示


567
00:27:45,732 --> 00:27:47,734
这两样东西做的事情不一样


568
00:27:48,468 --> 00:27:50,604
第一个调用中 编码阴影通路的地方


569
00:27:50,671 --> 00:27:52,639
可以看到正在获取的常量缓冲


570
00:27:52,706 --> 00:27:55,142
独立于self.constantBufferSlot之外


571
00:27:55,843 --> 00:27:58,745
我实际上并不知道它执行时会怎么样


572
00:27:59,046 --> 00:28:00,747
这是真正的异步编程


573
00:28:00,814 --> 00:28:04,017
所以当调度正在运行时


574
00:28:04,351 --> 00:28:05,786
它已经背着我发生了改变


575
00:28:06,386 --> 00:28:08,989
也许是对的 也许不对 我无法保证


576
00:28:13,260 --> 00:28:15,195
所以请谨记这点 不要那样做


577
00:28:16,029 --> 00:28:17,865
相反 我们想捕捉一个引用


578
00:28:17,931 --> 00:28:19,600
到我们感兴趣的常量缓冲中


579
00:28:20,167 --> 00:28:22,135
所以在这里 取出常量缓冲


580
00:28:22,536 --> 00:28:23,770
把它从数列里拿出去


581
00:28:24,972 --> 00:28:26,607
然后再发出调度


582
00:28:26,974 --> 00:28:29,510
引用已经获取的缓冲


583
00:28:29,576 --> 00:28:32,379
这样就能保证
确切知道读取的是哪个数据


584
00:28:37,651 --> 00:28:39,052
这就是多线程编程的趣味


585
00:28:39,553 --> 00:28:41,555
示例中的实际代码看上去是这样


586
00:28:42,956 --> 00:28:44,391
捕捉常量缓冲


587
00:28:46,593 --> 00:28:50,297
当使用它时 保证用的是正确的那个


588
00:28:50,364 --> 00:28:51,798
是已经捕捉的那个


589
00:28:52,399 --> 00:28:54,268
知道正在使用该帧数据的常量缓冲


590
00:28:56,003 --> 00:28:58,539
我之前提过“排序”以及它非常重要


591
00:29:00,007 --> 00:29:02,242
当新建一个命令缓冲 提交


592
00:29:03,043 --> 00:29:05,312
GPU上执行的顺序


593
00:29:06,480 --> 00:29:08,348
通过你提交到GPU上的顺序来表示


594
00:29:08,415 --> 00:29:10,617
所以如果先提交阴影命令缓冲


595
00:29:10,684 --> 00:29:12,286
再提交主命令缓冲


596
00:29:12,553 --> 00:29:15,722
可以确保在GPU先执行阴影


597
00:29:15,789 --> 00:29:17,457
接着再执行主命令缓冲


598
00:29:17,758 --> 00:29:20,294
有时我们把这称为 隐式命令缓冲排序


599
00:29:22,529 --> 00:29:24,565
但是可以变得显式一点


600
00:29:25,766 --> 00:29:27,634
Metal提供了“排队”函数


601
00:29:27,701 --> 00:29:29,436
强制执行命令缓冲排序


602
00:29:30,237 --> 00:29:32,806
如果有一组命令缓冲 可以把它们排队


603
00:29:33,207 --> 00:29:35,242
这样可以确保它们按照那个顺序被执行


604
00:29:35,309 --> 00:29:37,611
不论提交方法和提交时间


605
00:29:38,579 --> 00:29:40,681
这是非常酷的方法 因为它允许你


606
00:29:40,747 --> 00:29:43,383
从多重线程上提交命令缓冲
按任何顺序


607
00:29:44,017 --> 00:29:45,285
而你完全不用为此操心


608
00:29:45,619 --> 00:29:48,422
运行时将会确保运行顺序是正确的


609
00:29:49,890 --> 00:29:51,658
我们来看看如何在代码里实现


610
00:29:52,926 --> 00:29:54,127
新加了一些内容


611
00:29:54,561 --> 00:29:56,163
当新建命令缓冲时


612
00:29:56,230 --> 00:29:57,898
马上按照顺序把它们排队


613
00:29:58,265 --> 00:29:59,266
顺序很重要


614
00:29:59,333 --> 00:30:02,035
所以我们还是会让阴影命令缓冲先排队


615
00:30:02,536 --> 00:30:03,904
然后是主命令缓冲


616
00:30:05,572 --> 00:30:06,907
但是现在 当我们调度时


617
00:30:07,241 --> 00:30:09,810
我们可以从别的线程上提交


618
00:30:10,277 --> 00:30:12,112
再次强调 运行时候将会确保


619
00:30:12,980 --> 00:30:13,814
顺序正确


620
00:30:13,881 --> 00:30:15,616
所以我们不用为此担心


621
00:30:16,316 --> 00:30:19,052
这实际上移除了之前的障碍


622
00:30:19,286 --> 00:30:22,155
因为不必重新加入 再提交命令缓冲了


623
00:30:22,222 --> 00:30:23,724
它们已经自己提交了


624
00:30:26,527 --> 00:30:28,962
我似乎跳过了所有的同步内容


625
00:30:29,029 --> 00:30:30,297
不久前我刚说起过


626
00:30:30,764 --> 00:30:32,466
我们还是需要了解 因为我们还是


627
00:30:32,533 --> 00:30:34,268
会自我覆盖 如果我们不同步的话


628
00:30:34,801 --> 00:30:37,604
所以能否把同样的同步原理


629
00:30:37,938 --> 00:30:39,840
应用到这个多线程世界？


630
00:30:42,109 --> 00:30:45,112
答案是可以 并且实际上它非常直观


631
00:30:46,180 --> 00:30:49,349
回到友善的信号量 还有常量缓冲数列


632
00:30:49,416 --> 00:30:51,652
记住取出你想要的正确缓冲


633
00:30:52,819 --> 00:30:56,123
一开始 等待信号量
如果没有可用缓冲就进入休眠


634
00:30:57,457 --> 00:31:01,662
我们已用排队强制执行了顺序 推出去


635
00:31:03,430 --> 00:31:07,067
我们知道 主命令缓冲是
框架里最后的命令缓冲


636
00:31:07,768 --> 00:31:10,470
且我们知道要通知帧数据已经处理完毕


637
00:31:11,171 --> 00:31:14,575
所以应把完成处理程序加到主命令缓冲


638
00:31:14,641 --> 00:31:16,944
可以在调度内部完成


639
00:31:18,579 --> 00:31:20,914
主命令缓冲是最终命令缓冲


640
00:31:20,981 --> 00:31:24,017
我们为它添加上完成处理程序
用来通知信号量


641
00:31:24,084 --> 00:31:27,054
在调度内部提交它 如之前所做的那样


642
00:31:28,121 --> 00:31:31,124
现在你可能注意到
我引用self.semaphore


643
00:31:31,391 --> 00:31:33,527
不久前我刚告诉你要注意这点


644
00:31:33,961 --> 00:31:34,995
所以发生了什么？


645
00:31:35,596 --> 00:31:38,665
结果是信号量是一个同步图元


646
00:31:39,233 --> 00:31:41,502
我们确实想要用同一个


647
00:31:41,568 --> 00:31:42,836
和所有其他线程一样


648
00:31:43,403 --> 00:31:45,172
所以需要知道信号量的值


649
00:31:45,239 --> 00:31:46,907
在线程正在执行的时候


650
00:31:48,141 --> 00:31:50,944
所以在本例中确实
需要self.semaphore


651
00:31:51,011 --> 00:31:52,679
需要时刻注意


652
00:31:56,283 --> 00:31:58,585
这是渲染的方法


653
00:31:59,419 --> 00:32:02,122
在渲染函数的开始 等待信号量


654
00:32:03,390 --> 00:32:05,192
选择并发常量缓冲


655
00:32:06,426 --> 00:32:08,462
把数据写入常量缓冲


656
00:32:08,529 --> 00:32:10,697
也代表了所有的对象


657
00:32:11,565 --> 00:32:13,767
把命令编码到命令缓冲


658
00:32:13,834 --> 00:32:16,937
可以单线程编码
也可以多线程 随你所愿


659
00:32:17,704 --> 00:32:20,641
在最终命令缓冲里
加上一个完成处理程序


660
00:32:21,008 --> 00:32:24,344
用它来通知信号量 完成时通知我们


661
00:32:24,945 --> 00:32:26,513
然后提交命令缓冲


662
00:32:27,548 --> 00:32:29,183
GPU接过所有


663
00:32:29,249 --> 00:32:31,018
开始处理帧数据


664
00:32:33,020 --> 00:32:35,289
我们再看看演示 看看最后呈现结果


665
00:32:38,892 --> 00:32:42,362 line:1
可以看到在左上角
这是单线程编码模式


666
00:32:42,429 --> 00:32:44,998 line:1
可以看出正在进行
多少绘图调用 10,000个


667
00:32:45,732 --> 00:32:49,303 line:1
右上角 可以看到编码
一个帧数据的时间


668
00:32:50,137 --> 00:32:51,939 line:1
我们看到是5毫秒


669
00:32:53,540 --> 00:32:55,342 line:1
我们可以增加绘图的数量


670
00:32:55,876 --> 00:32:58,846 line:1
绘制的东西越多 时间越长


671
00:33:00,113 --> 00:33:01,648 line:1
这就是单线程模式


672
00:33:01,715 --> 00:33:04,718 line:1
你们想想看 我们在绘制一个阴影映射


673
00:33:04,785 --> 00:33:09,056
也就是说必须在阴影映射内
发出40,000个绘图


674
00:33:09,323 --> 00:33:11,325
当绘制主通路时
意味着我们必须再发出


675
00:33:11,391 --> 00:33:14,328
另外的40,000个绘图来引用


676
00:33:15,729 --> 00:33:17,531
但是再次强调 我们可以并发操作


677
00:33:17,598 --> 00:33:19,566
所以在演示里 加了一个并行模式


678
00:33:22,236 --> 00:33:24,137 line:1
可以看到速度有多么快


679
00:33:25,873 --> 00:33:27,574 line:1
看一看正在发生的一切


680
00:33:29,176 --> 00:33:30,444 line:1
你可再让它们飞起来一点


681
00:33:36,650 --> 00:33:40,654 line:1
在这里 我们有4万个立方体
独一无二 各自分离


682
00:33:40,721 --> 00:33:41,889 line:1
它们随时都在更新


683
00:33:42,689 --> 00:33:46,093 line:1
我们使用大中央调度
并行编码了许多内容


684
00:33:47,294 --> 00:33:48,262 line:1
我们有两个命令缓冲


685
00:33:48,328 --> 00:33:50,364 line:1
一个产生地上的阴影地图


686
00:33:50,898 --> 00:33:52,733 line:1
一个为所有的立方体渲染上色


687
00:33:54,268 --> 00:33:57,237 line:1
光照很简单 即漫反射着色 基本上是


688
00:33:57,304 --> 00:33:59,973 line:1
沃伦之前说过的N.L光照


689
00:34:02,976 --> 00:34:03,977 line:1
这就是我们的演示内容


690
00:34:04,044 --> 00:34:06,713 line:1
这些都会作为示例代码 供大家参考


691
00:34:07,214 --> 00:34:09,483 line:1
希望你们可以把它拆开
取得其中的一些想法


692
00:34:09,550 --> 00:34:11,685 line:1
和思路
并且能够应用到自己的代码当中


693
00:34:12,686 --> 00:34:14,087
所以我们今天讲了什么？


694
00:34:15,455 --> 00:34:16,723
你们走进来的时候


695
00:34:16,889 --> 00:34:18,625
希望你们也听过沃伦的演讲


696
00:34:18,692 --> 00:34:20,226
可能稍微了解一点图形的知识


697
00:34:20,293 --> 00:34:22,161
或者以前有相关编程经验


698
00:34:22,795 --> 00:34:25,098
但带你们一起了解了
Metal里的一切


699
00:34:25,966 --> 00:34:29,069
Metal的概念性的概览
它的相关原理


700
00:34:29,402 --> 00:34:32,438
是运用API 和硬件相近的API


701
00:34:32,505 --> 00:34:33,639
及和驱动相近的API


702
00:34:35,007 --> 00:34:36,610
我们学习了Metal设备


703
00:34:36,677 --> 00:34:39,313
即Metal的根对象
也是一切的来源


704
00:34:41,047 --> 00:34:42,783
稍微讨论了加载数据到Metal


705
00:34:42,850 --> 00:34:45,719
以及不同的资源类型 和如何使用它们


706
00:34:46,719 --> 00:34:49,556
Metal着色语言 即C++的变体


707
00:34:49,623 --> 00:34:51,024
可以在GPU上编程


708
00:34:52,592 --> 00:34:54,494
我们讨论了建立管道状态


709
00:34:54,561 --> 00:34:58,565
事先验证过的对象 包含两种函数


710
00:34:58,632 --> 00:35:00,834
顶点或片段 或某个计算函数


711
00:35:01,235 --> 00:35:03,437 line:1
和其他在预先验证状态的对象


712
00:35:03,504 --> 00:35:04,872 line:1
能在运行时节省时间


713
00:35:05,973 --> 00:35:07,875 line:1
然后我们讨论了发出GPU命令


714
00:35:07,941 --> 00:35:11,178 line:1
创建Metal队列
创建该队列的命令缓冲


715
00:35:11,745 --> 00:35:14,114 line:1
还有创建编码器填入命令缓冲


716
00:35:15,215 --> 00:35:17,718 line:1
然后该工作发送给GPU


717
00:35:18,485 --> 00:35:20,754
我们带你了解了动画和纹理


718
00:35:20,988 --> 00:35:24,091
以及使用设置顶点字节 发送小位数据


719
00:35:24,157 --> 00:35:25,325
以支持动画效果


720
00:35:26,994 --> 00:35:28,795
之后当小位数据不够时


721
00:35:28,862 --> 00:35:31,532
我们讲解了管理大批量动态数据


722
00:35:31,598 --> 00:35:35,102
使用一个大常量缓冲
以及在不同的地方对其进行引用


723
00:35:35,402 --> 00:35:38,038
在系统外反复使用数据


724
00:35:38,872 --> 00:35:42,976
我们讨论了CPU-GPU同步
以及确保


725
00:35:43,043 --> 00:35:45,279
CPU和GPU不彼此覆盖


726
00:35:45,746 --> 00:35:46,880
及互相协作的重要性


727
00:35:47,681 --> 00:35:48,849
最后


728
00:35:48,916 --> 00:35:51,285
我们讨论了一点关于多线程编码的内容


729
00:35:51,351 --> 00:35:55,289
你如何利用Metal的大中央调度
编码多命令缓冲


730
00:35:55,355 --> 00:35:57,090
同时编码队列中的所有缓冲


731
00:35:59,092 --> 00:36:00,494
这就是采用Metal技术


732
00:36:01,028 --> 00:36:02,129
希望你喜欢本次讲座


733
00:36:02,196 --> 00:36:03,931
也希望你把其中一部分
应用到自己的应用里


734
00:36:03,997 --> 00:36:05,532
让应用变得比现在更好


735
00:36:06,934 --> 00:36:10,504
如果想了解更多信息 可以访问网站


736
00:36:11,104 --> 00:36:14,308
developer.apple.com/wwdc/603


737
00:36:15,843 --> 00:36:18,912
明天我们还有更多的演讲
我大力鼓励你们能够参与


738
00:36:19,112 --> 00:36:21,682
上午11点
有“Metal的新特性 第一部分”


739
00:36:22,115 --> 00:36:25,252
晚些 下午1点40分
有“Metal的新特性 第二部分”


740
00:36:25,319 --> 00:36:27,921
这两个讲座将告诉我们
Metal世界里所有新特性


741
00:36:27,988 --> 00:36:30,524
你可在应用里加入很棒的内容
让应用更优秀


742
00:36:31,491 --> 00:36:34,194
之后 为了你们当中的着色狂人


743
00:36:34,261 --> 00:36:37,231
下午3点
有“高级Metal着色器优化”演讲


744
00:36:37,698 --> 00:36:39,533
如果你想知道如何更好地利用着色器


745
00:36:39,600 --> 00:36:41,768
我建议你们参与该话题
非常棒的演讲


746
00:36:42,836 --> 00:36:44,471
感谢你们前来听我们的讲座


747
00:36:44,538 --> 00:36:47,174
欢迎来到全球开发者大会
希望你们剩下几天过得愉快


748
00:36:47,908 --> 00:36:48,809le
再次感谢

