1
00:00:20,220 --> 00:00:23,857
改善全屏窗口体验


2
00:00:23,924 --> 00:00:24,758
嗨！


3
00:00:25,392 --> 00:00:27,895
欢迎莅临《改善全屏窗口体验》
专题讲座


4
00:00:28,495 --> 00:00:31,298
我叫 Corbin Dunn
是一名 AppKit 软件工程师


5
00:00:31,365 --> 00:00:34,568
今天我将与我的同事Taylor Kelly一起
完成这个讲座


6
00:00:34,701 --> 00:00:36,069
就让我们直入主题吧！


7
00:00:36,637 --> 00:00:38,405
那么我们今天要讲些什么呢?


8
00:00:38,472 --> 00:00:40,240
首先我要讲的是全屏幕


9
00:00:40,307 --> 00:00:42,276
它将包括三个部分


10
00:00:42,676 --> 00:00:44,711
我将讨论全屏幕的采用


11
00:00:44,778 --> 00:00:45,979
以及如何正确采用


12
00:00:46,313 --> 00:00:49,183
我将谈到标题栏附件视图控制器


13
00:00:49,316 --> 00:00:50,884
它们是什么以及如何使用它们


14
00:00:51,318 --> 00:00:53,720
然后我将讲一下全屏幕平铺 API


15
00:00:53,787 --> 00:00:55,556
查看并利用一些大家已在


16
00:00:55,622 --> 00:00:57,524
Mac OS 10.11中
看到的新特性


17
00:00:58,292 --> 00:01:00,294
Taylor将会上台 并讲一下


18
00:01:00,360 --> 00:01:03,530
Split View控制器内的
灵活布局 自动布局 堆叠视图


19
00:01:03,997 --> 00:01:06,099
并在最后讲下
关于集合视图方面的内容


20
00:01:07,668 --> 00:01:09,036
那么 全屏幕


21
00:01:09,903 --> 00:01:11,138
全屏幕的目的是什么？


22
00:01:11,205 --> 00:01:14,641
它是为了让您的用户将注意力
集中到某个单一任务上


23
00:01:14,875 --> 00:01:16,944
您可以充分利用您的屏幕空间


24
00:01:17,311 --> 00:01:18,946
其他一切都靠边站


25
00:01:19,012 --> 00:01:21,882
您要全神贯注于一个窗口


26
00:01:23,083 --> 00:01:26,019
那么我们为何使其
成为一个系统特性呢？


27
00:01:26,687 --> 00:01:27,988
我们使其成为一个系统特性


28
00:01:28,055 --> 00:01:31,291
因为它一种非常一贯的用户体验


29
00:01:31,625 --> 00:01:33,026
你进入全屏幕的方式


30
00:01:33,093 --> 00:01:35,462
你退出全屏幕的方式
都是一样的


31
00:01:35,729 --> 00:01:37,898
你在不同的位置之间
导航定位的方式等等


32
00:01:39,166 --> 00:01:42,636
那么 什么是
“可全屏化的窗口”？


33
00:01:43,036 --> 00:01:45,172
这里有一个Safari窗口的例子


34
00:01:45,606 --> 00:01:48,542
我肯定您知道
只要点击绿色按钮


35
00:01:48,809 --> 00:01:50,110
它就会把您带入全屏状态


36
00:01:51,345 --> 00:01:53,814
一旦您进入全屏状态
您可以将鼠标移到窗口的上方


37
00:01:53,881 --> 00:01:56,717
标题栏和工具栏将会向下展开


38
00:01:57,251 --> 00:01:59,019
而你可以再次点击绿色按钮


39
00:01:59,086 --> 00:02:00,687
它将把你带回全屏状态


40
00:02:02,890 --> 00:02:05,125
那么为了采用全屏幕
需要做些什么呢？


41
00:02:05,325 --> 00:02:06,793
希望大家已经对此有所了解


42
00:02:07,060 --> 00:02:08,228
不过它是相当容易的


43
00:02:08,529 --> 00:02:11,698
您将指定哪些窗口
是您希望可以全屏化的


44
00:02:11,765 --> 00:02:13,967
您将为它增加一个菜单项


45
00:02:14,034 --> 00:02:16,503
而且你很可能会
做些额外的事情


46
00:02:16,570 --> 00:02:17,638
你可能希望做的额外的事情


47
00:02:17,704 --> 00:02:21,708
是自动隐藏您的工具栏
修改您的内容


48
00:02:21,842 --> 00:02:25,746
以便更充分地利用
全屏幕带来的空间


49
00:02:25,812 --> 00:02:28,048
利用新的标题栏


50
00:02:28,115 --> 00:02:28,982
辅助视图控制器


51
00:02:29,049 --> 00:02:31,118
而我将谈一下如何
以及为何我要那么做


52
00:02:31,852 --> 00:02:33,987
当然 您希望进行很好的全屏平铺操作


53
00:02:34,254 --> 00:02:36,557
因此我将讨论一些我们已有的API
来实现那种效果


54
00:02:37,424 --> 00:02:40,627
首先 有两种类型的窗口


55
00:02:41,562 --> 00:02:44,932
或者实现全屏化有两种可选窗口


56
00:02:45,699 --> 00:02:47,401
通常当一个窗口是全屏时


57
00:02:47,935 --> 00:02:49,503
就不允许对其进行进一步操作了


58
00:02:49,570 --> 00:02:52,272
而那样的窗口也是
我们所谓的“主窗口”


59
00:02:52,673 --> 00:02:55,309
它是您的应用的


60
00:02:55,375 --> 00:02:56,210
主文件窗口


61
00:02:56,643 --> 00:02:59,012
它是您能够使其全屏化的东西


62
00:02:59,880 --> 00:03:02,349
然而还有另一种选择
如果你已经看到它的话


63
00:03:02,583 --> 00:03:05,886
那就是“辅助窗口”
通常你并不需要这个


64
00:03:06,086 --> 00:03:09,189
它的目的是什么？
如果你在某个应用中有一个窗口


65
00:03:09,256 --> 00:03:11,758
想要占据另一个应用的全屏空间


66
00:03:11,825 --> 00:03:12,993
它允许你那么做


67
00:03:13,060 --> 00:03:15,095
我不会讨论这方面


68
00:03:15,696 --> 00:03:18,599
而我鼓励您查阅几年前的
AppKit  版本说明


69
00:03:18,665 --> 00:03:20,801
了解关于它的一些细节


70
00:03:21,368 --> 00:03:23,971
那么您如何采用全屏窗口呢？


71
00:03:24,037 --> 00:03:27,341
在Xcode和Interface
Builder中它非常简单


72
00:03:27,407 --> 00:03:30,410
您选择您的窗口有一个Full
Screen(全屏)部分


73
00:03:30,477 --> 00:03:31,612
您将菜单项下拉


74
00:03:31,678 --> 00:03:33,814
就有主窗口和辅窗口的选项


75
00:03:33,881 --> 00:03:35,782
那么您将很可能希望


76
00:03:35,849 --> 00:03:38,285
在您作为主窗口的全屏窗口上
设置主窗口


77
00:03:39,486 --> 00:03:43,490
当然您也可以用代码实现,而在Int
erfaceBuilder选项下


78
00:03:43,557 --> 00:03:46,193
它所做的不过是修改


79
00:03:46,260 --> 00:03:48,529
window.collectionBehavior


80
00:03:48,695 --> 00:03:51,398
而它将向窗口添加
.FullScreenPrimary


81
00:03:51,498 --> 00:03:53,600
或.FullScreenAuxiliary


82
00:03:53,667 --> 00:03:57,371
以便让那些选项进入窗口
并让窗口实现全屏化


83
00:03:59,239 --> 00:04:02,142
一旦您进入全屏状态
您可能需要


84
00:04:02,209 --> 00:04:05,012
做各种基于全屏幕的事情


85
00:04:05,512 --> 00:04:08,415
而且您可以通过查看样式蒙板
进行检查


86
00:04:09,049 --> 00:04:10,584
就是当您的窗口进入全屏的时候


87
00:04:10,918 --> 00:04:12,653
我们添加


88
00:04:12,719 --> 00:04:14,988
NSFullScreen
WindowMask


89
00:04:15,055 --> 00:04:16,757
而且您可以在样式蒙板中查看


90
00:04:16,822 --> 00:04:18,492
您的窗口是否处于全屏状态


91
00:04:18,926 --> 00:04:20,226
并有可能做其他的事情


92
00:04:22,663 --> 00:04:25,966
现在让我们谈下
如何自动隐藏工具栏


93
00:04:26,433 --> 00:04:28,035
通常如果您在窗口内
有一个工具栏


94
00:04:28,202 --> 00:04:30,537
它总是可见的
就像这里显示出来的一样


95
00:04:31,104 --> 00:04:33,407
当您把鼠标移到窗口的上部


96
00:04:33,473 --> 00:04:35,075
菜单栏会向下展开


97
00:04:35,142 --> 00:04:36,710
标题栏的控制按钮向下展开


98
00:04:37,211 --> 00:04:38,946
从而露出了工具栏


99
00:04:40,147 --> 00:04:42,549
有一个选项可以让您
将工具栏自动隐藏


100
00:04:42,916 --> 00:04:45,452
所以当你进入全屏的时候
其他什么都看不到


101
00:04:45,519 --> 00:04:47,588
而你可以最充分
利用您的屏幕的空间


102
00:04:48,856 --> 00:04:50,457
当您将鼠标
向上移动到菜单栏的时候


103
00:04:50,858 --> 00:04:54,228
工具栏会与菜单栏
和标题栏一起


104
00:04:54,294 --> 00:04:55,929
同时向下展开


105
00:04:55,996 --> 00:04:57,764
这确实是很容易做的


106
00:04:58,298 --> 00:04:59,900
有一个
windowdelegate方法


107
00:04:59,967 --> 00:05:04,438
Window.WillUse
FullScreenPresentationOptions


108
00:05:04,671 --> 00:05:06,340
再加上 
proposedOptions


109
00:05:06,440 --> 00:05:11,211
您选择那些建议的选项并且增加
AutoHideToolbar并将其返回


110
00:05:11,278 --> 00:05:12,946
而工具栏将自动隐藏


111
00:05:13,413 --> 00:05:15,115
因此是非常容易的


112
00:05:16,550 --> 00:05:20,354
那么然后是自定义动画
您可以创建全屏进入和退出


113
00:05:20,420 --> 00:05:22,523
自定义动画


114
00:05:22,589 --> 00:05:24,525
我们有两种
delegate方法实现它


115
00:05:24,591 --> 00:05:26,593
customWindows
ToEnter


116
00:05:26,660 --> 00:05:28,829
FullScreen
ForWindow


117
00:05:28,896 --> 00:05:31,098
这种方法可以返回一系列的窗口
来实现您的动画


118
00:05:31,231 --> 00:05:33,433
然后我们把您叫回来
说 嗨！


119
00:05:33,500 --> 00:05:35,469
开始您的自定义动画
进入全屏状态吧


120
00:05:35,702 --> 00:05:36,837
并请指定持续时间


121
00:05:37,571 --> 00:05:40,307
关于这些操作
我们需要注意的一点是


122
00:05:40,374 --> 00:05:42,809
在 Mac OS 10.11 中
通过我们进入全屏的方式


123
00:05:42,876 --> 00:05:44,411
您可能不会让这些参数得到调用


124
00:05:44,478 --> 00:05:46,446
因此重要的一点是


125
00:05:46,513 --> 00:05:49,349
不要依赖这些参数一直被调用
并设置状态


126
00:05:49,716 --> 00:05:52,586
相反 有更好的方式实现
过一会儿我将讲到这些方式


127
00:05:55,355 --> 00:05:58,892
好了 关于全屏幕以及
如何正确采用就讲这么多


128
00:05:59,259 --> 00:06:00,594dle
让我们继续往下进行


129
00:05:59,259 --> 00:06:00,594
让我们继续往下进行


130
00:06:01,094 --> 00:06:03,363
谈一下标题栏辅助视图控制器


131
00:06:05,032 --> 00:06:08,335
那么在我讲标题栏
辅助控制器之前


132
00:06:08,602 --> 00:06:10,604
让我们先看一下全屏幕窗口


133
00:06:10,871 --> 00:06:14,474
而且我将对标题栏区域突出显示
以便于您觉察到它


134
00:06:14,942 --> 00:06:16,410
那么这就是全屏中的标题栏


135
00:06:17,144 --> 00:06:19,546
在标题栏下面是工具栏


136
00:06:19,613 --> 00:06:24,184
而在工具栏下面是我们所谓的
“辅助视图”


137
00:06:24,585 --> 00:06:27,788
那么您可以在窗口中的这个位置
增加您自己的标题栏


138
00:06:27,855 --> 00:06:29,990
辅助视图控制器


139
00:06:30,357 --> 00:06:33,694
好在窗口不是全屏状态下


140
00:06:33,760 --> 00:06:35,329
也能添加它们


141
00:06:35,863 --> 00:06:38,699
那么这就是在窗口不是全屏状态下
它们看上去的样子


142
00:06:39,032 --> 00:06:40,767
然后它们被自动地反复管理


143
00:06:41,535 --> 00:06:44,171
为了理解这种模式的重要性


144
00:06:44,238 --> 00:06:47,574
最好先理解
我们为什么会用这种模式


145
00:06:47,674 --> 00:06:49,443
那么让我们看下您的窗口


146
00:06:50,143 --> 00:06:54,515
通常 在工具栏和标题栏
下方的区域


147
00:06:54,581 --> 00:06:57,150
是内容被替换的地方


148
00:06:57,384 --> 00:06:58,719
您的内容就在它下面


149
00:06:59,620 --> 00:07:01,755
但是从Mac OS X.10 开始


150
00:07:02,556 --> 00:07:07,361
您可实际利用一个完整的内容区


151
00:07:07,961 --> 00:07:11,164
它可以在标题栏
和工具栏下面扩展


152
00:07:11,498 --> 00:07:12,599
那么您的标题栏


153
00:07:12,666 --> 00:07:16,537
和工具栏将会在它后面
自动为您进行模糊化处理


154
00:07:16,603 --> 00:07:18,772
而您可以在这个位置为您的视图


155
00:07:18,839 --> 00:07:21,441
放置全屏辅助视图控制器


156
00:07:23,210 --> 00:07:25,913
那么您怎样才能实现
那种全屏蒙板效果呢？


157
00:07:25,979 --> 00:07:28,482
它真的是很容易的
您只需在window.styleMask后面


158
00:07:28,549 --> 00:07:30,918
加上NSFullSize
ContentViewWindowMask


159
00:07:30,984 --> 00:07:34,421
而那将让您的内容在标题栏下
以全尺寸显示


160
00:07:35,622 --> 00:07:38,825
用于使用标题栏
辅助视图控制器的实际API


161
00:07:38,892 --> 00:07:41,228
这些控制器是
NSViewController的


162
00:07:41,295 --> 00:07:42,362
一个非常简单的子类


163
00:07:42,696 --> 00:07:44,765
因此所有的标准视图控制器


164
00:07:44,831 --> 00:07:46,333
将会与它互动
决定如何加载它们


165
00:07:46,400 --> 00:07:49,603
而它增加了两个属性一个是
layoutAttribute


166
00:07:49,670 --> 00:07:51,972
另一个是FullScreenMin
Height


167
00:07:52,039 --> 00:07:53,907
过一会我将谈到它们


168
00:07:53,974 --> 00:07:55,475
但是让我们看一下


169
00:07:55,542 --> 00:07:58,278
标题栏辅助视图控制器
能为您做的几件事情


170
00:07:58,946 --> 00:08:00,113e
正如我以前所说的


171
00:07:58,946 --> 00:08:00,113
正如我以前所说的


172
00:08:00,180 --> 00:08:04,484
它们将自动为您模糊化处理
它们后面的一切东西


173
00:08:04,551 --> 00:08:05,953
您无须做任何特别的事情


174
00:08:06,687 --> 00:08:08,789
它自动以某种视觉效果为您呈现


175
00:08:08,989 --> 00:08:10,691
那就是实际的模糊化处理


176
00:08:11,191 --> 00:08:13,227
它们自动以全屏状态显示


177
00:08:13,594 --> 00:08:15,729
因此当您的窗口进入全屏
或退出全屏时


178
00:08:15,796 --> 00:08:17,264
它们被放置在正确的位置


179
00:08:17,965 --> 00:08:20,200
而且在某种程度上
它的大小也是自动为您管理的


180
00:08:20,267 --> 00:08:22,569
而我们稍后将讨论这个内容


181
00:08:23,370 --> 00:08:27,975
那么让我们看一下第一个属性layo
utAttribute（布局属性）


182
00:08:29,743 --> 00:08:34,313
那么这里就是布局属性
当它被设置为“.bottom”时


183
00:08:34,881 --> 00:08:36,783
“.bottom”的意思是您的视图


184
00:08:36,850 --> 00:08:39,720
将被放在标题栏的下方


185
00:08:40,554 --> 00:08:43,590
它的高度是您在NIB文件中
为该视图实际指定的任何高度


186
00:08:43,657 --> 00:08:45,859
或者是您以任何方式指定的高度


187
00:08:45,926 --> 00:08:48,962
而宽度会随着窗口大小的更改
而自动变化


188
00:08:51,365 --> 00:08:52,900
另一个选项是 “.right”


189
00:08:53,467 --> 00:08:55,269
这是一个 Safari 的例子


190
00:08:55,669 --> 00:08:57,871
他们在使用 “.right” 选项


191
00:08:57,938 --> 00:09:00,274
以便当Safari窗口
处于非全屏或全屏时


192
00:09:00,340 --> 00:09:02,543
向Safari窗口添加 
“+” 按钮


193
00:09:03,477 --> 00:09:06,213
宽度是视图已经指定的任何宽度


194
00:09:06,580 --> 00:09:10,350
而高度则是自动设定为
标题栏或工具栏的高度


195
00:09:11,852 --> 00:09:16,557
Mac OS 10.11 的新特性
还包括指定一个“.left”的能力


196
00:09:17,191 --> 00:09:20,093
通过它 你可以把项目


197
00:09:20,160 --> 00:09:21,862
放在窗口按钮旁边


198
00:09:22,029 --> 00:09:24,998
所以您可以在这里
添加一个注册按钮


199
00:09:25,065 --> 00:09:27,734
或者您希望
向用户展示的其他备注


200
00:09:28,569 --> 00:09:32,806
而这就是X.11的另一个新特性


201
00:09:34,274 --> 00:09:36,910
接下来我们有全屏幕最小高度


202
00:09:38,145 --> 00:09:39,446
让我们看一下那个属性


203
00:09:40,380 --> 00:09:42,749
那么全屏幕最小高度
是什么意思呢？


204
00:09:43,016 --> 00:09:45,519
这个属性仅当您


205
00:09:45,719 --> 00:09:47,855
已处于全屏状态时才适用


206
00:09:48,388 --> 00:09:50,524
而这就是您在全屏状态下


207
00:09:50,724 --> 00:09:52,125
能够看见的最小高度


208
00:09:53,093 --> 00:09:55,529
当您将鼠标移动到
工具栏之上时


209
00:09:55,596 --> 00:09:58,232
任何未被显示的内容
将被自动显示


210
00:09:58,298 --> 00:10:00,601
过一会儿我将向您展示
那种情况的一些屏幕快照


211
00:10:01,068 --> 00:10:02,669
工具栏的默认高度为 0


212
00:10:03,670 --> 00:10:05,372
那么让我们看一下
它的意思是什么


213
00:10:06,173 --> 00:10:07,908
那么 全屏幕最低高度为 0


214
00:10:08,442 --> 00:10:09,576
这里是一个工具栏


215
00:10:09,943 --> 00:10:13,914
那里是一个辅助视图控制器
但它是隐藏的


216
00:10:13,981 --> 00:10:15,215
因为高度为 0


217
00:10:15,849 --> 00:10:17,184
如果高度不是 0


218
00:10:17,451 --> 00:10:20,821
您在那里将总是会看到
您设定的任何值


219
00:10:21,788 --> 00:10:23,023
用户让其显示的方式是


220
00:10:23,090 --> 00:10:27,160
当你把鼠标移到菜单栏上部时
标题栏将被显示


221
00:10:27,594 --> 00:10:31,798
而您的全屏辅助视图也将随其
自动显示


222
00:10:33,834 --> 00:10:35,202
那样将把该部位突出显示


223
00:10:37,471 --> 00:10:40,841
如果您已经用过 NSToolbar
您可能已经熟悉了


224
00:10:40,908 --> 00:10:43,110
NSToolbar实现的
全屏辅助视图


225
00:10:43,477 --> 00:10:47,548
而这个新的标题栏辅助视图控制器
取代了这个旧的 API


226
00:10:47,814 --> 00:10:50,050
因此我们不鼓励您再使用它


227
00:10:50,684 --> 00:10:53,120
但是最小高度和最大高度属性的
工作原理


228
00:10:53,187 --> 00:10:56,123
与标题栏辅助视图控制器里面的
非常类似


229
00:10:58,926 --> 00:11:00,460
那么您如何实际添加它们呢?


230
00:11:00,527 --> 00:11:02,863
我们在 NSWindow 
上有四种方法


231
00:11:02,930 --> 00:11:06,200
我们有一系列的
标题栏辅助视图控制器


232
00:11:06,266 --> 00:11:08,068
您可以读取窗口的附件


233
00:11:09,036 --> 00:11:09,870
您可以添加它们


234
00:11:10,871 --> 00:11:12,372
您可以将它们
作为特殊索引插入


235
00:11:13,106 --> 00:11:15,008
而且您也可以将其
作为特殊索引删除


236
00:11:15,142 --> 00:11:17,611
但它确实是容易
添加和删除的


237
00:11:17,678 --> 00:11:19,913
那么这里是您通常将要做的事情


238
00:11:20,247 --> 00:11:23,383
您将调用Window.AddTitleBar
AccessoryViewController


239
00:11:23,717 --> 00:11:26,987
将您的辅助视图控制器传递给它
然后当您希望去掉它时


240
00:11:27,054 --> 00:11:29,857
您将使用默认的
NSViewController API


241
00:11:29,923 --> 00:11:32,593
将其从父视图控制器中移除
父视图控制器自动确定它的位置


242
00:11:32,659 --> 00:11:34,795
并将其移除


243
00:11:36,897 --> 00:11:40,067
关于标题栏辅助视图控制器
就讲那么多


244
00:11:40,133 --> 00:11:41,969
让我们谈一下全屏幕平铺


245
00:11:42,336 --> 00:11:45,072
以及 Mac OS 10.11
里面的一些新特性


246
00:11:46,406 --> 00:11:49,243
那么全屏幕平铺的目的是什么？


247
00:11:49,576 --> 00:11:51,512
它们仍然让您或用户的注意力


248
00:11:51,578 --> 00:11:53,680
集中在某个单一任务上


249
00:11:53,747 --> 00:11:55,782
但是它可能涉及到多个窗口


250
00:11:56,617 --> 00:11:58,552
您必须利用屏幕的全部空间


251
00:11:58,952 --> 00:12:01,889
那么在这个屏幕快照上
我们有Safari浏览器窗口


252
00:12:01,955 --> 00:12:06,293
在边上有提示信息
让我们同时关注几个任务


253
00:12:06,360 --> 00:12:09,196
那么让我们看一下
当您实际处于这一状态


254
00:12:09,263 --> 00:12:12,366
并调整分割器大小的时候
会发生些什么


255
00:12:12,766 --> 00:12:16,637
请注意 随着我改变其大小
Safari窗口达到了最小状态


256
00:12:17,204 --> 00:12:18,639
并且提醒栏也达到最小状态


257
00:12:18,705 --> 00:12:23,577
而且对于一个给定窗口
不会让它收缩得太厉害


258
00:12:23,744 --> 00:12:26,547
因此它有一个可以达到的
最小和最大状态


259
00:12:27,915 --> 00:12:29,149
那么我将谈一下如何实现


260
00:12:29,716 --> 00:12:30,717
以及您需要做些什么


261
00:12:31,485 --> 00:12:34,988
但是让我们先讨论一下
什么样的窗口


262
00:12:35,055 --> 00:12:36,323
可以进行全屏幕平铺


263
00:12:37,724 --> 00:12:40,827
我们将明确允许任何窗口


264
00:12:40,894 --> 00:12:46,033
进入全屏平铺
只要它的大小可调并且不是面板


265
00:12:46,200 --> 00:12:48,302
那意味着你的窗口不必


266
00:12:48,368 --> 00:12:49,903
一定是可全屏化的


267
00:12:50,270 --> 00:12:52,439
但是它仍可以被添加并平铺到


268
00:12:52,673 --> 00:12:54,474
另一个可全屏化的窗口内


269
00:12:55,008 --> 00:12:57,244
具体我们做些什么


270
00:12:57,311 --> 00:12:59,246
以及如何确定都会随时间改变


271
00:13:00,013 --> 00:13:02,449
因此您可能希望
让这个过程更明确


272
00:13:03,417 --> 00:13:06,587
那么让我们假定
您有一个可调整大小的窗口


273
00:13:06,687 --> 00:13:09,289
它无法被放入平铺窗口
而你希望将它放入平铺窗口


274
00:13:09,356 --> 00:13:12,025
您可以在collection 
Behavior后


275
00:13:12,092 --> 00:13:15,162
明确添加FullScreenAll
owsTiling


276
00:13:15,229 --> 00:13:17,297
使其能够被放入平铺窗口


277
00:13:18,465 --> 00:13:21,034
类似地 您可能有一个窗口


278
00:13:21,101 --> 00:13:22,669
您希望它永远不被放入平铺


279
00:13:23,136 --> 00:13:26,139
那么我们就规定...
它可以被放入平铺


280
00:13:26,206 --> 00:13:27,508
但是您不希望它被放入平铺


281
00:13:27,774 --> 00:13:30,143
因此您可以让
FullScreenDisallowsTiling


282
00:13:30,210 --> 00:13:31,044
来防止它被平铺


283
00:13:32,112 --> 00:13:35,148
此外 您可能有一个窗口
您让它全屏化


284
00:13:35,215 --> 00:13:37,751
而且希望它总是独立状态
您可以在那个窗口上设置


285
00:13:37,818 --> 00:13:40,654
FullScreen
DisallowsTiling


286
00:13:40,721 --> 00:13:43,657
以防止任何其他窗口
与它放在一起


287
00:13:45,025 --> 00:13:47,995
那么现在您了解了如何


288
00:13:48,061 --> 00:13:49,062
让一个窗口进入平铺


289
00:13:49,463 --> 00:13:50,797
让我们谈一下那个窗口的


290
00:13:50,864 --> 00:13:52,633
最小和最大尺寸


291
00:13:52,999 --> 00:13:55,836
通常 当您的窗口
未处于全屏状态时


292
00:13:56,136 --> 00:13:59,540
您可以调整其大小
并且自动受到


293
00:13:59,606 --> 00:14:00,574
其最小和最大尺寸限制


294
00:14:00,641 --> 00:14:04,778
而当你使用 AutoLayout 
时那通常是由 AutoLayout


295
00:14:04,845 --> 00:14:06,146
自动确定的


296
00:14:06,980 --> 00:14:08,982
如果您没有使用
 AutoLayout


297
00:14:09,349 --> 00:14:12,486
那么窗口的最大和最小尺寸
就发挥作用了


298
00:14:12,553 --> 00:14:13,987
那些只是显示的


299
00:14:14,054 --> 00:14:15,455
您在窗口内设置的属性


300
00:14:15,522 --> 00:14:17,858
或者是内容的最小尺寸
或者是内容的最大尺寸,


301
00:14:17,925 --> 00:14:19,459
都取决于您使用的API


302
00:14:19,993 --> 00:14:22,229
如果您选中一个窗口
并准备将其全屏化


303
00:14:22,296 --> 00:14:26,066
或者您准备全屏平铺
那些就是您


304
00:14:26,133 --> 00:14:27,568
通常应该使用的API


305
00:14:28,101 --> 00:14:29,803
但是那个规则也会有例外


306
00:14:29,870 --> 00:14:32,339
而我们有更多的API来解决例外


307
00:14:33,073 --> 00:14:36,176
首先让我们谈一下该规则的一个例外
以及您将做些什么


308
00:14:36,376 --> 00:14:38,011
那么这里是可能是一个小的


309
00:14:38,078 --> 00:14:39,479
计算器应用


310
00:14:39,546 --> 00:14:41,215
它的尺寸是不可调整的


311
00:14:41,648 --> 00:14:44,351
那么这位开发者就可能说
好吧 我们将让它


312
00:14:44,418 --> 00:14:45,385
放入平铺


313
00:14:46,320 --> 00:14:49,756
但是当它被放入平铺的时候
如这里所示


314
00:14:50,123 --> 00:14:52,926
现在那个计算器应用的高度
比以前高了很多


315
00:14:52,993 --> 00:14:55,796
即使它是不可调整大小的


316
00:14:56,196 --> 00:14:58,532
因此它需要对其进行处理
并做些特殊的事情


317
00:14:59,333 --> 00:15:02,202
您可能还会在那里加些额外视图
以便在其全屏平铺时


318
00:15:02,269 --> 00:15:04,771
向用户显示更多信息


319
00:15:05,372 --> 00:15:06,874
因此您可以动态实现这种效果


320
00:15:06,940 --> 00:15:09,643
而且您只是使用一些
window delegate方法


321
00:15:09,710 --> 00:15:12,246
WindowWillEnter
FullScreen


322
00:15:12,312 --> 00:15:14,548
而在这种特定情况下
当我们进入全屏模式时


323
00:15:14,615 --> 00:15:16,383
我们将取消一些视图的隐藏状态


324
00:15:16,450 --> 00:15:17,951
更改一些约束优先级


325
00:15:18,018 --> 00:15:20,153
当窗口处于全屏化时
它们让系统对窗口大小


326
00:15:20,220 --> 00:15:21,688
实际进行调整


327
00:15:22,022 --> 00:15:24,525
而当它退出全屏幕时
它再将那些工作取消


328
00:15:24,591 --> 00:15:27,160
重要的一点是知道
你实际可能必须


329
00:15:27,227 --> 00:15:31,832
使用这些 delegate 方法
即使您的窗口


330
00:15:31,899 --> 00:15:33,700
通常并不构成一个全屏幕主窗口


331
00:15:34,168 --> 00:15:36,270
因此这可能是为一个平铺窗口调用


332
00:15:38,305 --> 00:15:42,576
现在那些窗口
在进入全屏状态之前


333
00:15:42,643 --> 00:15:43,944
它们的尺寸是尤其厚的


334
00:15:44,011 --> 00:15:46,013
但是当它们处于全屏状态时
尺寸就不同了


335
00:15:46,747 --> 00:15:49,783
当它将进入全屏状态时
您很可能


336
00:15:49,883 --> 00:15:51,351
需要告诉系统那些尺寸


337
00:15:51,418 --> 00:15:53,187
那么我们有一个
显式API来实现


338
00:15:53,253 --> 00:15:56,190
我们有一个minFull
ScreenContentSize


339
00:15:56,356 --> 00:15:59,526
和一个maxFullScreen
ContentSize来实现


340
00:15:59,593 --> 00:16:02,095
您需要及早设置这些参数
因为如果您


341
00:16:02,162 --> 00:16:04,865
曾经尝试 Mac OS 10.11
您可能注意到当您点击并


342
00:16:04,932 --> 00:16:07,568
按住绿色按钮不放的时候
系统会为您提供


343
00:16:07,634 --> 00:16:10,771
尺寸符合可用空间的
其他备选窗口供您选择


344
00:16:11,538 --> 00:16:14,808
因此 作为开发者
您需要及早设置这些最小值


345
00:16:15,409 --> 00:16:16,476
以便让系统能够确定


346
00:16:16,543 --> 00:16:18,879
适合该区域的潜在备选窗口


347
00:16:20,013 --> 00:16:22,049
正如我以前所言
通常您不需要使用这些设置


348
00:16:22,115 --> 00:16:24,117
当您的窗口正好
是通常的尺寸可调窗口的话


349
00:16:24,184 --> 00:16:25,986
它们在很大程度上是自动的


350
00:16:26,787 --> 00:16:28,555
那么这就会导致一种两难困境


351
00:16:28,722 --> 00:16:32,292
如果您的窗口尺寸
比如说是1200


352
00:16:32,359 --> 00:16:36,563
而另外一个窗口
窗口 B 的尺寸是 300


353
00:16:36,630 --> 00:16:38,699
会发生什么?


354
00:16:40,100 --> 00:16:41,201
那么系统将不会


355
00:16:41,268 --> 00:16:44,137
让这两个窗口在一起


356
00:16:44,538 --> 00:16:48,108
它们的minFullScreenC
ontentSize值太大


357
00:16:48,342 --> 00:16:49,409
而无法实现


358
00:16:50,511 --> 00:16:52,980
那么作为开发者
您需要做些什么呢？


359
00:16:54,515 --> 00:16:56,950
对于这方面我将请上我的同事
Taylor Kelly


360
00:16:57,017 --> 00:16:59,253
他将会讨论如何通过灵活布局


361
00:16:59,319 --> 00:17:00,420le
而解决那个问题


362
00:16:59,319 --> 00:17:00,420
而解决那个问题


363
00:17:00,487 --> 00:17:01,922
谢谢大家！


364
00:17:14,201 --> 00:17:15,035
大家好！


365
00:17:15,102 --> 00:17:16,603
在这下半个环节中
我们将讨论


366
00:17:16,670 --> 00:17:19,106
如何让您的布局更灵活


367
00:17:19,173 --> 00:17:22,409
尤其当它们处于新的Split
View中时可以被调整到多窄


368
00:17:23,609 --> 00:17:26,713
在 Mac 平台上我们有
多种显示尺寸


369
00:17:26,780 --> 00:17:27,948
供您的应用在其上运行


370
00:17:28,015 --> 00:17:31,251
而在全屏状态下
用户能够将其自身全部浸入


371
00:17:31,451 --> 00:17:32,686
占据整个显示空间


372
00:17:33,820 --> 00:17:36,390
在Split View下
用户现在可以让另外一个窗口


373
00:17:36,456 --> 00:17:39,326
进入这个环境
从而营造一种更丰富的体验


374
00:17:40,093 --> 00:17:43,163
但是这要求两个窗口灵活的


375
00:17:43,263 --> 00:17:45,499
其尺寸大小可以调整


376
00:17:45,966 --> 00:17:47,334
以防止出现冲突的情况


377
00:17:47,401 --> 00:17:49,102
Corbin 早些时候
也谈到了这一点


378
00:17:49,803 --> 00:17:52,739
这对于较小显示尺寸
如Retina MacBook


379
00:17:52,940 --> 00:17:54,241
可能是尤其严格的


380
00:17:55,008 --> 00:17:58,579
它的默认分辨率为1280*800


381
00:17:59,046 --> 00:18:00,747
表示在Split View中


382
00:18:00,814 --> 00:18:03,917
当平均分割时
每个窗口大约被分配638


383
00:18:03,984 --> 00:18:05,552
每个窗口大约被分配638个点


384
00:18:05,619 --> 00:18:07,955
如果您的应用的最小宽度


385
00:18:08,021 --> 00:18:10,791
目前比这个大
这些显示尺寸的用户


386
00:18:10,858 --> 00:18:12,459
通常将不能将您的应用平铺


387
00:18:13,727 --> 00:18:17,030
因此我将谈一下
您可以使用的四种技巧


388
00:18:17,097 --> 00:18:19,566
以确保您的窗口在全屏状态下
有令人满意的表现


389
00:18:20,400 --> 00:18:22,636
首先 是使用自动布局和优先条件


390
00:18:23,504 --> 00:18:26,306
其次是自动折叠的新侧栏行为


391
00:18:27,341 --> 00:18:30,110
然后是使用 NSStackView
轻易地构建


392
00:18:30,177 --> 00:18:32,679
您的界面的各个部分
同时将灵活性内置其中


393
00:18:33,213 --> 00:18:35,849
最后是更新过的
NSCollectionView


394
00:18:35,916 --> 00:18:37,918
它有了强大的布局支持


395
00:18:40,954 --> 00:18:43,223
那么自动布局是一个
我们在OSX Lion和iOS 6中


396
00:18:43,290 --> 00:18:45,926
推出的基于约束条件的布局系统


397
00:18:46,360 --> 00:18:49,062
它让您声明不同的
UI 元素之间的关系


398
00:18:49,129 --> 00:18:51,398
比如它们的间隔或者对齐


399
00:18:52,266 --> 00:18:53,634
而它确实是强大的


400
00:18:53,700 --> 00:18:55,369
窗口的视图尺寸被动态调整


401
00:18:55,636 --> 00:18:56,770
比如在进行本地化的时候


402
00:18:57,771 --> 00:18:59,740
您可以在这些约束条件之间
建立优先顺序


403
00:18:59,806 --> 00:19:01,975
让级别高的优先于级别低的


404
00:19:03,043 --> 00:19:04,811
对此我将不去过多讨论细节


405
00:19:04,878 --> 00:19:06,346
今天早些时候有两个讲座


406
00:19:06,413 --> 00:19:08,282
《自动布局的奥秘》的
第一和第二部分


407
00:19:08,348 --> 00:19:10,117
不管您在自动布局方面
是初次接触还是已有接触


408
00:19:10,184 --> 00:19:11,652
它都有一些确实不错的内容


409
00:19:12,186 --> 00:19:14,054
相反 在这个 UI 例子中


410
00:19:14,121 --> 00:19:15,222
我将重点关注优先顺序


411
00:19:16,190 --> 00:19:18,625
我们在中部有一个标签
它的左右两侧


412
00:19:18,692 --> 00:19:20,127
都有固定按钮


413
00:19:20,360 --> 00:19:22,829
这些可能是您会用来创建
那种效果的水平约束


414
00:19:23,630 --> 00:19:26,466
仅仅使用这些约束的话
如果视图的尺寸动态调整


415
00:19:26,800 --> 00:19:29,369
您最后可能会
让标签和较宽的按钮相互重叠


416
00:19:30,037 --> 00:19:31,371
这是非常容易解决的


417
00:19:31,438 --> 00:19:34,107
您可以在按钮和标签之间
增加一个最小间隔约束


418
00:19:34,741 --> 00:19:36,310
而现在
当容器的尺寸调整时


419
00:19:36,510 --> 00:19:37,744
它的尺寸只能调整到


420
00:19:37,811 --> 00:19:41,081
它能同时满足
居中对齐和最小间隔的程度


421
00:19:41,882 --> 00:19:44,518
这是一个完美的布局
除非这个视图


422
00:19:44,585 --> 00:19:46,486
能够变得更紧凑


423
00:19:46,720 --> 00:19:49,590
去掉较窄按钮和标签之间的
	那些空白就太好了


424
00:19:50,958 --> 00:19:54,194
回过来 我们可以让这个
居中对齐成为可选条件


425
00:19:54,494 --> 00:19:56,864
意思是它可以
被更优先的约束条件打破


426
00:19:57,531 --> 00:19:59,600
此外 我们将会
在标签和较窄按钮之间


427
00:19:59,666 --> 00:20:02,302
增加一个最小间隔
以防在那一侧出现重叠


428
00:20:03,170 --> 00:20:05,639
这次 标签尽可能居中


429
00:20:05,973 --> 00:20:08,008
直到它触及了最小间隔的填充


430
00:20:08,075 --> 00:20:11,044
而如果我们继续调整容器的大小
我们可以打破居中条件


431
00:20:11,111 --> 00:20:12,813
以便最大化地压缩布局


432
00:20:12,880 --> 00:20:17,484
直到我们
满足两侧的最小填充


433
00:20:18,185 --> 00:20:20,187
您可以仅仅
通过设置优选顺序属性


434
00:20:20,254 --> 00:20:21,955
来为您的约束条件
进行这样的设置


435
00:20:22,022 --> 00:20:24,992
而这也通过Interface
Builder暴露出来


436
00:20:25,726 --> 00:20:27,761
默认情况下 
需要满足约束条件


437
00:20:27,928 --> 00:20:29,096
就是说它们必须被满足


438
00:20:29,162 --> 00:20:32,132
但是任何低于那个的
约束条件将成为可选的


439
00:20:32,933 --> 00:20:35,002
我们有些要点
帮您决定您的约束条件


440
00:20:35,068 --> 00:20:36,303
优先顺序应该是什么样子


441
00:20:36,370 --> 00:20:38,572
另外还有Default Low
它是一个优先条件


442
00:20:38,639 --> 00:20:41,074
通常您的约束条件
弱于大多数其他约束软件


443
00:20:41,141 --> 00:20:43,944
还有DragThatCannot
ResizeWindow


444
00:20:44,011 --> 00:20:45,112
它是一个特定的优先条件


445
00:20:45,179 --> 00:20:47,648
在此条件下一个Split
View分割线会被拖动


446
00:20:47,714 --> 00:20:49,216
如果您希望自己的约束条件


447
00:20:49,283 --> 00:20:51,618
比这种行为更加强大
您应让您的优先条件级别更高,


448
00:20:51,685 --> 00:20:52,886
否则更低


449
00:20:52,953 --> 00:20:55,689
您通常永远不会
设置跟这个完全一样的优先条件


450
00:20:55,756 --> 00:20:58,458
此外还有WindowsSize
StayPut


451
00:20:58,525 --> 00:21:00,427
这个优先条件规定
一个窗口维持当前的尺寸


452
00:21:00,494 --> 00:21:03,730
最后是DragThatCanRes
izeWindow


453
00:21:03,797 --> 00:21:05,432
在这个条件下一个窗口被拖拽


454
00:21:05,499 --> 00:21:08,702
但是还有 Default High
它是另外一个优先条件


455
00:21:08,769 --> 00:21:10,571
在此条件下您的约束条件


456
00:21:10,637 --> 00:21:11,972
通常高于多数其他条件


457
00:21:12,539 --> 00:21:14,608
那么这就是Auto Layout的
优先条件


458
00:21:14,675 --> 00:21:16,844
在此后的几个部分内


459
00:21:16,910 --> 00:21:18,579
我将回过头来
参考一下优先权的概念


460
00:21:18,645 --> 00:21:22,082
但是接下来我想谈一下NSSplit
ViewController


461
00:21:22,149 --> 00:21:24,985
这是我们在Yosemite中
推出的一个容器视图控制器类


462
00:21:25,052 --> 00:21:27,187
它让您的子视图控制器


463
00:21:27,254 --> 00:21:28,989
被安排在
 NSSplitView 内


464
00:21:29,389 --> 00:21:31,525
并且暴露了
NSSplitView 项目的概念


465
00:21:31,692 --> 00:21:34,828
它概括了那些在Split
View中的子类的状态


466
00:21:34,895 --> 00:21:37,064
这些子类包括
holdingpriority


467
00:21:37,130 --> 00:21:41,235
Collapsed状态而且它允许以
一种真正简单的方式获得动态折叠效果


468
00:21:41,301 --> 00:21:44,505
去年的OSX Storyboard
和控制器讲座更多地讨论了


469
00:21:44,571 --> 00:21:46,373
这个特性以及其他
视图控制器特性


470
00:21:46,440 --> 00:21:49,176
但是我想重点谈一下
OS 10.11中的新内容


471
00:21:50,143 --> 00:21:52,479
首先是侧边栏的显式概念


472
00:21:52,546 --> 00:21:54,281
及其伴随的特殊行为


473
00:21:54,815 --> 00:21:57,184
以及spring loading
它是当一个项目


474
00:21:57,251 --> 00:22:00,053
被在Split View中拖拽时
可能发生的行为


475
00:22:00,387 --> 00:22:02,089
以及几个新的度量指标


476
00:22:02,155 --> 00:22:06,026
它们让您在调整大小期间
精确地声明


477
00:22:06,093 --> 00:22:07,361
Split View的行为


478
00:22:08,662 --> 00:22:11,198
我们看一个例子
这里是 Safari 中的侧边栏


479
00:22:11,899 --> 00:22:14,835
随着窗口尺寸的调整
一旦它达到某个点


480
00:22:14,902 --> 00:22:16,436
侧边栏将会自动折叠


481
00:22:16,603 --> 00:22:19,306
而如果它在全屏状态被重新显示


482
00:22:19,373 --> 00:22:21,842
它将覆盖其他窗口内容


483
00:22:22,543 --> 00:22:24,945
这个过程是短暂的
类似于弹出框


484
00:22:25,012 --> 00:22:26,914
因此点击其外侧将使其自动消失


485
00:22:26,980 --> 00:22:28,282
这真的是容易理解的


486
00:22:28,348 --> 00:22:30,417
您只须在
NSSplitViewItem上


487
00:22:30,484 --> 00:22:33,921
使用sidebarWithView
Controller这一构造函数


488
00:22:33,987 --> 00:22:36,924
或者在Interface
Builder中将行为传递给侧边栏


489
00:22:36,990 --> 00:22:39,359
这将返回给您
一个split view项目


490
00:22:39,426 --> 00:22:41,762
您可以把它添加到
您的split view控制器上


491
00:22:41,828 --> 00:22:44,531
而且它也伴随一些特殊行为
比如 Yosemite 中将推出的


492
00:22:44,598 --> 00:22:47,134
内置的半透明材质背景
和醒目的分割线


493
00:22:47,201 --> 00:22:48,969
您不必再加入您自己的
视频效果视图


494
00:22:49,036 --> 00:22:50,637
才能获得这种效果


495
00:22:50,871 --> 00:22:53,607
NSSplitViewItem
将会为您进行添加和管理


496
00:22:53,774 --> 00:22:55,609
此外还有您刚才看到的


497
00:22:55,676 --> 00:22:58,712
autocollapse
和autouncollapse行为


498
00:22:58,779 --> 00:23:00,514
通过它 覆盖层将占据整个屏幕


499
00:23:01,915 --> 00:23:03,851
此外还有另外几个默认属性


500
00:23:03,917 --> 00:23:05,352
以及侧边栏的标准值


501
00:23:05,686 --> 00:23:08,288
因此您的侧边栏对系统的行为
正如其他要素一样


502
00:23:09,022 --> 00:23:11,325
伴随它的
还有一个split view方面的


503
00:23:11,391 --> 00:23:13,393
新的行为方法
即 toggleSidebar


504
00:23:13,460 --> 00:23:15,562
它将具有动画效果地折叠或


505
00:23:15,629 --> 00:23:17,564
展开它包含的第一个侧边栏


506
00:23:18,532 --> 00:23:20,667
通过这种方式 
无须书写一行代码


507
00:23:20,734 --> 00:23:24,004
您就可以关联菜单项
使其具有这种效果 或切换按钮


508
00:23:25,539 --> 00:23:28,408
另外一个确实很酷的行为
是spring loading


509
00:23:28,475 --> 00:23:31,144
这是当用户在您的split
view边缘上存在折叠窗格


510
00:23:31,211 --> 00:23:34,781
并将一个项目向该边缘拖拽时
发生的行为


511
00:23:35,516 --> 00:23:38,085
我们将平移并让侧边栏展开


512
00:23:38,151 --> 00:23:41,154
让它们与其互动在它们的动作完成之后
让侧边栏再次折叠


513
00:23:41,221 --> 00:23:44,591
您可通过将springLoaded
设为True来达到此效果


514
00:23:44,658 --> 00:23:47,160
在您的split view项目中
您将获得此行为效果


515
00:23:47,227 --> 00:23:49,830
且对侧边栏和非侧边栏同样适用


516
00:23:50,163 --> 00:23:52,566
区别在于
侧边栏将默认为 True


517
00:23:52,866 --> 00:23:54,635
我们认为大多数的侧边栏
将希望这种行为


518
00:23:54,701 --> 00:23:58,572
接下来我想谈一下我们在NSSpli
tViewItem控制器上的


519
00:23:58,739 --> 00:24:00,374dle
几个新的度量指标


520
00:23:58,739 --> 00:24:00,374
几个新的度量指标


521
00:24:00,440 --> 00:24:02,042
我将每次讲两个


522
00:24:02,109 --> 00:24:04,478
首先是
minimumThickness


523
00:24:04,545 --> 00:24:06,413
和maximumThickness


524
00:24:06,480 --> 00:24:08,649
这些与split view项目
正在自我管理的


525
00:24:08,715 --> 00:24:10,217
约束条件直接相关


526
00:24:10,284 --> 00:24:13,287
它们描述了这个项目
可以实际变得多大或多小


527
00:24:14,021 --> 00:24:15,989
侧边栏将默认将这些值
设为标准值


528
00:24:16,290 --> 00:24:17,424
但这的确是一个


529
00:24:17,491 --> 00:24:20,694
您自己设置约束条件的
非常方便的方式


530
00:24:22,262 --> 00:24:25,632
HoldingPriority是OS 10.11中
惟一的一个不是新的度量指标


531
00:24:25,832 --> 00:24:26,900
它描述了split view 项目


532
00:24:26,967 --> 00:24:29,002
维持其当前大小的一个优先权


533
00:24:29,636 --> 00:24:31,305
在本例中
侧边栏被默认设置为


534
00:24:31,371 --> 00:24:33,640
一个略高的值
因此这意味着它们比其他项目


535
00:24:33,707 --> 00:24:35,375
被调整尺寸的可能性更小


536
00:24:36,243 --> 00:24:38,212
那么作为一个例子
当它调整此窗口大小时


537
00:24:38,312 --> 00:24:40,280
尺寸调整的全部权重
都分配给了内容区


538
00:24:40,347 --> 00:24:42,316
而侧边栏的宽度保持不变


539
00:24:43,884 --> 00:24:45,085
回顾一下 你可能也将这个


540
00:24:45,152 --> 00:24:46,820
设置为在两个项目间


541
00:24:46,920 --> 00:24:48,021
具有同样的保持优先权


542
00:24:48,722 --> 00:24:50,691
如果您熟悉自动布局
您可能将这种情况


543
00:24:50,757 --> 00:24:51,959
认为是一种模棱两可的情况


544
00:24:52,025 --> 00:24:54,595
但是NSSplitView
会对这种情况进行特殊处理


545
00:24:54,661 --> 00:24:55,996
这次当您调整其大小时


546
00:24:56,430 --> 00:24:58,365
两个视图会根据
它们在尺寸调整之前的大小


547
00:24:58,432 --> 00:25:00,701le
按比例地调整大小


548
00:24:58,432 --> 00:25:00,701
按比例地调整大小


549
00:25:00,767 --> 00:25:02,803
因此两个视图都尺寸
都被调整得稍微大一点


550
00:25:03,270 --> 00:25:05,339
那就是
 holdingPriority


551
00:25:05,405 --> 00:25:08,876
下一个度量指标是preferred
ThicknessFraction


552
00:25:08,942 --> 00:25:11,645
它描述了某个split
view项目希望占据的空间


553
00:25:11,712 --> 00:25:13,313
占split view的理想百分比


554
00:25:13,380 --> 00:25:15,582
例如 侧边栏被默认为15 %


555
00:25:16,383 --> 00:25:18,986
当用户进入全屏状态
或双击分割线的时候


556
00:25:19,052 --> 00:25:21,722
该项目将自动跳到那个首选厚度


557
00:25:21,922 --> 00:25:24,091
它们的确非常容易地
就能恢复到那一标准值


558
00:25:25,459 --> 00:25:28,195
作为一个限值 自动最大厚度
对所有这些尺寸调整行为


559
00:25:28,262 --> 00:25:30,197
都发挥作用


560
00:25:30,631 --> 00:25:32,866
如果15%对应于350的话


561
00:25:32,933 --> 00:25:35,335
那么它将被限制为不超过280


562
00:25:35,802 --> 00:25:38,172
那些是NSSplit
ViewItem度量指标


563
00:25:38,238 --> 00:25:41,508
在NSSplitViewContr
oller上还有另一个度量指标


564
00:25:41,575 --> 00:25:46,346
那就是用于内嵌侧边栏的
minimumThicknessForinlineSidebars


565
00:25:46,413 --> 00:25:49,483
它描述了您的split view
控制器中侧边栏将自动折叠的宽度


566
00:25:49,550 --> 00:25:51,752
因此 将尺寸调整到那一数值
将让它们保持内嵌状态


567
00:25:51,818 --> 00:25:55,122
进一步拖拽将让您的侧边栏折叠


568
00:25:55,189 --> 00:25:57,124
这也适用于全屏幕状态


569
00:25:57,624 --> 00:25:59,593
关键区别在于
当处于全屏幕状态时


570
00:25:59,660 --> 00:26:02,162
如果它总是被明确重新显示
它就被显示为叠加状态


571
00:26:03,163 --> 00:26:05,065
这说明了全屏状态下的
一个重要概念


572
00:26:05,132 --> 00:26:07,534
在全屏状态下
我们希望避免让窗口运行


573
00:26:07,634 --> 00:26:09,303
以防止和相邻元素的可能的冲突


574
00:26:09,903 --> 00:26:11,872
在您的窗口内重新安排各个元素


575
00:26:11,939 --> 00:26:14,508
总是比扩大窗口要好


576
00:26:14,575 --> 00:26:17,444
为支持NSSplit
ViewController中的


577
00:26:17,511 --> 00:26:19,880
这样一些新特性
我们已经对 NSSplitView


578
00:26:19,947 --> 00:26:23,150
做出了一些改进
具体而言是通过对子视图的排列


579
00:26:24,651 --> 00:26:25,953
在 El Capitan 之前


580
00:26:26,220 --> 00:26:29,122
split view中的所有子视图
都被视为分割开来的窗格


581
00:26:30,090 --> 00:26:31,358
这意味着管理它的 API


582
00:26:31,425 --> 00:26:33,894
只是从NSView继承来的
子视图 API


583
00:26:34,428 --> 00:26:36,997
这是方便的但是也带来了
两个确实很大的问题


584
00:26:37,831 --> 00:26:39,967
一个问题是您不能增加


585
00:26:40,033 --> 00:26:41,768
您不希望被视为分割窗格的子视图


586
00:26:42,436 --> 00:26:43,904
例如 分割线


587
00:26:44,204 --> 00:26:46,340
在此模型中
分割线不可以由视图表示


588
00:26:47,307 --> 00:26:49,676
此外 您不能将 Z-顺序


589
00:26:49,977 --> 00:26:51,512
与子视图的排列顺序区别开来


590
00:26:51,845 --> 00:26:55,215
因此您的零索引子视图
是按Z顺序的第一个也是最下的


591
00:26:55,282 --> 00:26:57,651
而没有办法将它们区别


592
00:26:58,385 --> 00:27:00,721
因此 现在在10.11中
您可以指定一定的子视图


593
00:27:00,787 --> 00:27:04,324
作为使用NSSplitView的新
API而创建的split view


594
00:27:04,391 --> 00:27:05,559
所排列的子视图


595
00:27:05,626 --> 00:27:09,062
在管理已被排列的子视图方面这个AP
I与NSStackView的API


596
00:27:09,363 --> 00:27:11,732
和UIStackView的
API精确匹配


597
00:27:11,798 --> 00:27:14,568
此外还有这个属性ArrangesA
llSubviews


598
00:27:14,635 --> 00:27:16,270
它默认是 True


599
00:27:16,336 --> 00:27:18,438
意思是说您的子视图
仍总与被排列的子视图相同


600
00:27:18,505 --> 00:27:20,908
并且匹配那种遗留行为


601
00:27:21,742 --> 00:27:24,912
即使您将此属性设为False
NSSplitView 仍会确保


602
00:27:24,978 --> 00:27:27,047
您的已被排列的子视图


603
00:27:27,114 --> 00:27:29,149
永远是子视图的一个子集


604
00:27:29,783 --> 00:27:32,119
例如 如果您添加了
一个还不是子视图的


605
00:27:32,186 --> 00:27:35,255
被排列的子视图
它将被添加为子视图


606
00:27:36,823 --> 00:27:39,693
最后 我们鼓励您开始使用
被排列的子视图


607
00:27:39,760 --> 00:27:41,795
并将ArrangesAllSubviews
设为False


608
00:27:41,862 --> 00:27:42,829
因为当您那么做的


609
00:27:42,896 --> 00:27:44,798
时候NSSplitView
现在能够使用视图


610
00:27:44,865 --> 00:27:48,001
代表分割线
并为分割线的醒目性


611
00:27:48,235 --> 00:27:50,470
和特殊的窗口拖拽行为
创造条件


612
00:27:51,572 --> 00:27:53,340
您可通过Interface 
Builder控制它


613
00:27:53,407 --> 00:27:55,709
选中这个Arranges
All Subviews 复选框


614
00:27:56,009 --> 00:27:58,879
更新后的 NIB 文件
将选中此复选框以匹配遗留行为


615
00:27:59,279 --> 00:28:02,549
但是从对象库里面拖拽出来的
新的split view将不会将其选中


616
00:28:02,616 --> 00:28:04,351
这也是将来我们鼓励的行为


617
00:28:07,054 --> 00:28:10,457
为了帮研究您目前在split view
上可能有的问题或试图理解


618
00:28:10,524 --> 00:28:11,792
您的split view的工作机制


619
00:28:11,859 --> 00:28:14,561
我们已经改进了对调试的描述
以便告诉您


620
00:28:14,628 --> 00:28:16,396
诸如它如何执行布局


621
00:28:16,463 --> 00:28:18,599
以及它将用什么
代表它的分割线


622
00:28:19,299 --> 00:28:20,968
关于布局 有几种可能性


623
00:28:21,268 --> 00:28:24,004
但是我们建议
确保split view使用约束条件


624
00:28:24,605 --> 00:28:27,641
这让它简单地描述
它的分割窗格之间的关系


625
00:28:27,708 --> 00:28:29,743
并与您在窗口中的
其他约束条件互动


626
00:28:30,377 --> 00:28:34,248
此外 它将允许对您的
split view窗格的


627
00:28:34,548 --> 00:28:35,616
从右到左的翻动


628
00:28:37,184 --> 00:28:39,920
而且我们也建议...


629
00:28:40,387 --> 00:28:43,790
开始使用视图代表分割线


630
00:28:44,358 --> 00:28:45,759
原因如我以前所述


631
00:28:46,827 --> 00:28:49,763
为了帮助弄清楚为何您的split view
可以或不可使用约束条件


632
00:28:49,830 --> 00:28:51,865
我们已经添加了
这个DebugReasonForLayoutMode


633
00:28:51,932 --> 00:28:55,903
它将给您提供具有可读性的描述以便了
解它是否会使用约束条件及其原因


634
00:28:56,737 --> 00:28:59,306
最常见的原因是
Delegate将优先于特定的


635
00:28:59,373 --> 00:29:00,607
与自动布局不相容的方法


636
00:29:00,674 --> 00:29:02,976
而且将准确地告诉您
那些方法是什么


637
00:29:03,977 --> 00:29:05,779
它是否在一个
使用自动布局的窗口内


638
00:29:05,846 --> 00:29:07,881
还将决定它是否可以使用约束条件


639
00:29:07,948 --> 00:29:11,451
最后如果它正在被NSSplitVi
ew Controller使用


640
00:29:11,952 --> 00:29:13,554
则要求它使用约束条件


641
00:29:15,389 --> 00:29:18,125
而如果您曾试图调试split
view的一些布局问题


642
00:29:18,192 --> 00:29:20,060
并已输出约束条件


643
00:29:20,127 --> 00:29:21,962
它很可能看上起像是这样


644
00:29:22,563 --> 00:29:23,697
它是很难解读的


645
00:29:23,764 --> 00:29:25,699
如果您确实希望理解它
您必须画一张图


646
00:29:26,166 --> 00:29:28,535
您无法很好地辨别
哪些约束条件是您的app添加的


647
00:29:28,635 --> 00:29:30,971
哪些约束条件是框架添加的


648
00:29:31,538 --> 00:29:35,342
在OS10.11中NSSplitView
目前为所有它添加的约束条件


649
00:29:35,409 --> 00:29:36,276
给出识别符


650
00:29:36,343 --> 00:29:38,645
因此您不仅可以辨别
您在使用哪些约束条件


651
00:29:38,712 --> 00:29:41,048
而且还可知道它在试图
用那个约束条件做些什么


652
00:29:41,114 --> 00:29:42,182
您可以快速地辨别


653
00:29:42,249 --> 00:29:43,917
您的app添加了哪些约束条件


654
00:29:43,984 --> 00:29:46,086
或者是否有怪异的
您无法确定在发生什么的


655
00:29:46,153 --> 00:29:48,422
尺寸调整行为
您可以快速地看出


656
00:29:48,488 --> 00:29:50,891
哪些约束条件可能会
解决那一问题


657
00:29:50,958 --> 00:29:53,627
NSStackView有适用于
其每个约束条件的


658
00:29:53,961 --> 00:29:55,028
类似的识别符


659
00:29:55,829 --> 00:29:58,065
现在我想谈一下
NSStackView


660
00:29:58,765 --> 00:30:00,868
这是一个我们
在 Mavericks中引入的类


661
00:30:00,934 --> 00:30:02,836
它确实简化了


662
00:30:02,903 --> 00:30:05,806
使用自动布局进行的
水平或垂直视图堆叠


663
00:30:06,006 --> 00:30:08,709
它完全与您在窗口中使用的
其他约束条件相容


664
00:30:08,775 --> 00:30:10,777
但是它会管理它使用的所有约束条件


665
00:30:10,844 --> 00:30:13,013
来创建堆叠


666
00:30:13,080 --> 00:30:15,115
因此您可以添加或移除视图
而不必担心


667
00:30:15,182 --> 00:30:16,583
对那些约束条件的更新


668
00:30:17,484 --> 00:30:19,987
它内置了对齐和分布的概念


669
00:30:20,053 --> 00:30:22,189
因此您可以控制您的视图


670
00:30:22,256 --> 00:30:24,391
在堆叠视图内的放置方式


671
00:30:24,458 --> 00:30:26,793
以及剪裁和附加行为
因此当堆叠视图


672
00:30:26,860 --> 00:30:28,862
试图建立比它所包含的视图
更小的视图时


673
00:30:28,929 --> 00:30:30,831
您可以控制发生的事情


674
00:30:31,031 --> 00:30:33,100
此外 在 10.11 中
我们做出了一系列性能改进


675
00:30:33,166 --> 00:30:34,968
降低了它使用的约束条件的数量


676
00:30:35,035 --> 00:30:39,606
并且从使用内部专用视图
转换到使用 NS 布局指南


677
00:30:40,307 --> 00:30:42,709
而我们已经看到一些
非常不错的性能改进


678
00:30:43,677 --> 00:30:45,712
《自动布局的奥秘》的第一部分
谈到了这一点


679
00:30:45,779 --> 00:30:47,915
和新的UIStackView 在 iOS


680
00:30:47,981 --> 00:30:49,850
以及对我们现在所拥有的


681
00:30:49,917 --> 00:30:52,619
新的Interface
Builder的很好的支持


682
00:30:52,686 --> 00:30:54,721
我的确想重点谈一下
新的分配形式


683
00:30:54,988 --> 00:30:58,258
它们描述了堆叠视图
如何沿着堆叠轴排列


684
00:30:58,325 --> 00:31:02,095
您可以通过NSStackView的
Distribution属性


685
00:31:02,162 --> 00:31:04,531
对此进行设置我将逐一说明
它们是如何工作的


686
00:31:04,598 --> 00:31:07,935
那么GravityAreas匹配
10.11 版本之前的行为


687
00:31:08,001 --> 00:31:10,938
通过它您可以指定特定的视图
被吸引到split view的


688
00:31:11,004 --> 00:31:12,139
特定的边缘


689
00:31:12,206 --> 00:31:14,208
对于水平方向
有领先 居中和尾随


690
00:31:14,575 --> 00:31:16,210
对于垂直方向
有顶部 居中和底部


691
00:31:16,276 --> 00:31:18,445
那么在本例中
随着我们让堆叠视图的增加


692
00:31:18,912 --> 00:31:20,848
这些视图将趋向于朝边缘移动


693
00:31:22,349 --> 00:31:25,052
.Fill 是一个新的行为
它要求各个视图


694
00:31:25,118 --> 00:31:26,420
将堆叠视图完全填充


695
00:31:26,520 --> 00:31:29,957
而通过使用其他约束条件
您可以决定它们的增长方式


696
00:31:30,023 --> 00:31:30,991
或尺寸分配方式


697
00:31:31,892 --> 00:31:35,395
在本例中 Tiny 已经设置了
最低的拖拽优先权


698
00:31:35,462 --> 00:31:37,164
因此随着我们让堆叠视图的增长


699
00:31:37,364 --> 00:31:39,032
它获得了全部的尺寸调整权重


700
00:31:39,499 --> 00:31:41,502
.FillEqually 是类似的


701
00:31:41,568 --> 00:31:43,670
只是现在堆叠视图
将增加约束条件


702
00:31:43,770 --> 00:31:45,472
各个视图将有相同的尺寸


703
00:31:46,206 --> 00:31:48,275
在本例中 我们将增加
更强的约束条件


704
00:31:48,342 --> 00:31:49,443
以便将堆叠视图向下挤压


705
00:31:49,510 --> 00:31:51,311
而且它将优先于
这些均等填充的约束条件


706
00:31:51,378 --> 00:31:53,847
但是随着我让堆叠视图增长


707
00:31:54,248 --> 00:31:56,216
它们趋向于朝着尺寸均等化发展


708
00:31:58,285 --> 00:32:01,188
.FillProportional
ly也是类似不过它们是


709
00:32:01,255 --> 00:32:03,757
根据其自身内容的尺寸
按比例增长


710
00:32:04,324 --> 00:32:06,393
那么在本例中
较大的视图增长得更大


711
00:32:06,460 --> 00:32:08,962
而更小的视图增长不多


712
00:32:10,230 --> 00:32:13,233
.EqualSpacing是一种分
配方式根据此方式


713
00:32:13,300 --> 00:32:15,302
获得额外尺寸的并不是视图


714
00:32:15,569 --> 00:32:17,104
而是视图之间的间隔


715
00:32:17,905 --> 00:32:20,541
在本例中
随着我们让边缘之间的间隔增大


716
00:32:20,674 --> 00:32:22,543
各个视图之间的距离
都被调整到相同大小


717
00:32:24,244 --> 00:32:27,047
.EqualCentering也是
类似不过在这里


718
00:32:27,514 --> 00:32:30,417
不是视图边缘之间的间隔


719
00:32:30,751 --> 00:32:32,553
而是视图中心的间隔
被调整到相同


720
00:32:33,720 --> 00:32:35,489
有了这些新的分配行为


721
00:32:35,556 --> 00:32:38,192
我们认为您可以将堆叠视图
用于您的 UI 中的更多地方


722
00:32:38,258 --> 00:32:40,827
而且真正从
它所带来的变化中获益


723
00:32:42,329 --> 00:32:45,832
堆叠视图的另一个方面是
剪裁行为


724
00:32:46,200 --> 00:32:48,936
堆叠视图可被默认增大到


725
00:32:49,002 --> 00:32:51,471
包含所有其他项目
所需的最小尺寸


726
00:32:52,239 --> 00:32:54,308
但是您可能也需要
设置剪裁抵抗优先权


727
00:32:54,408 --> 00:32:57,277
让视图根据该优先权剪裁其内容


728
00:32:57,978 --> 00:33:01,315
所以 现在我们的堆叠视图
可以被调整到小于它的容器


729
00:33:03,584 --> 00:33:05,686
通常您并不希望对视图
进行这种部分剪裁


730
00:33:05,752 --> 00:33:08,188
但这比视图被完全丢弃
的情况要好


731
00:33:08,922 --> 00:33:12,326
您可以通过为不同视图
设置可见性优先权进行控制


732
00:33:13,060 --> 00:33:14,895
一旦堆叠视图开始剪裁其中的视图


733
00:33:14,962 --> 00:33:18,131
有最低可见性优先权的视图
	将被完全丢弃


734
00:33:19,032 --> 00:33:21,001
在本例中
我们将设置由高到低的顺序


735
00:33:21,068 --> 00:33:23,170
以便随着堆叠视图
开始剪裁某一视图


736
00:33:23,237 --> 00:33:25,706
它只是暂时性的完全脱离


737
00:33:26,406 --> 00:33:29,343
因此在本例中
第6个不再看得见了


738
00:33:31,011 --> 00:33:32,646
如果堆叠视图再次增大


739
00:33:32,713 --> 00:33:35,582
它将重新附加这些项目
因为有了足够的尺寸容纳它们


740
00:33:36,383 --> 00:33:37,985
此外 当这种脱离或重新附加发生时


741
00:33:38,318 --> 00:33:40,621
您会获得回调
告诉您脱离或重新附加何时发生


742
00:33:40,687 --> 00:33:43,123
以便于您对您的UI的其他部分
做出可能的调整


743
00:33:43,190 --> 00:33:45,225
比如增加一个溢出菜单


744
00:33:46,960 --> 00:33:48,929
接下来我想快速地概述一下


745
00:33:48,996 --> 00:33:50,631
最新更新过的集合视图


746
00:33:50,731 --> 00:33:53,567
现在它与 UI 集合视图
有等同的特色


747
00:33:54,268 --> 00:33:55,802
包括项目的可重用性


748
00:33:55,869 --> 00:33:57,971
因此 对那些本部分支持的项目
的大型集合


749
00:33:58,038 --> 00:34:00,340
您可以有真正可扩展的呈现方式


750
00:34:01,241 --> 00:34:03,243
此外 有一些真正强大的布局支持


751
00:34:03,310 --> 00:34:06,580
所以不管您的集合视图的尺寸多大
它的行为都是极其良好的


752
00:34:06,647 --> 00:34:08,447
包括内置的网格布局


753
00:34:08,849 --> 00:34:11,851
与 iOS 匹配的流程布局


754
00:34:11,918 --> 00:34:13,554
以及创建您自己的
定制化布局的能力


755
00:34:13,820 --> 00:34:15,856
Troy 将在今天稍晚时
就此做一个很棒的讲座


756
00:34:15,922 --> 00:34:17,324
名为《集合视图中的新特性》


757
00:34:17,391 --> 00:34:18,824
我真心建议您看一下


758
00:34:20,594 --> 00:34:22,663
与此讲座相关联的还有示例代码


759
00:34:23,931 --> 00:34:25,199
它是一个图片浏览app


760
00:34:25,666 --> 00:34:29,136
展示Corbin和我谈到的
各种特性 API 以及行为


761
00:34:30,070 --> 00:34:32,239
例如 它展示各种全屏 API


762
00:34:32,306 --> 00:34:33,974
尤其是最新的平铺 API


763
00:34:34,308 --> 00:34:35,509
我们这个单独的小窗口


764
00:34:35,576 --> 00:34:38,011
通常被要求
尺寸符合宽高比


765
00:34:38,245 --> 00:34:39,379
而且可被全屏化


766
00:34:39,813 --> 00:34:41,415
然而 我们让它可被平铺


767
00:34:41,614 --> 00:34:43,684
且一旦处于平铺状态
便会有自定义布局


768
00:34:45,052 --> 00:34:46,987
它还采用了最新的
split view 控制器特性


769
00:34:47,054 --> 00:34:49,755
比如带有覆盖效果的
自动折叠侧边栏


770
00:34:50,791 --> 00:34:52,192
以及 NSStackView


771
00:34:52,359 --> 00:34:55,362
它使用零约束条件
创建了这个底部工具栏


772
00:34:55,696 --> 00:34:56,730
的的确确是很棒的


773
00:34:57,497 --> 00:34:59,066
它还使用脱离行为


774
00:34:59,366 --> 00:35:01,702
以便能够让菜单调整到更小


775
00:35:02,102 --> 00:35:03,504
并显示这个小巧的溢出菜单


776
00:35:03,570 --> 00:35:05,539
以便用户仍能使用
那些被隐藏的菜单项目


777
00:35:07,307 --> 00:35:10,077
它还使用经过更新的
NSCollectionView


778
00:35:10,244 --> 00:35:13,413
用于显示这个小图片网格
它的表现非常可靠


779
00:35:16,717 --> 00:35:19,987
那么 Corbin 带我们概览了
Full Screen 的各种特性


780
00:35:20,187 --> 00:35:22,656
比如如何在我们的应用中采用全屏


781
00:35:22,956 --> 00:35:24,625
以及使用标题栏辅助视图


782
00:35:24,892 --> 00:35:28,395
让那些在工具栏下方的标题栏
在全屏幕状态下有真正不错的表现


783
00:35:29,363 --> 00:35:31,865
此外 他还向我们展示了
一些全屏幕平铺 API


784
00:35:32,165 --> 00:35:33,333
以便让我们能够确保


785
00:35:33,567 --> 00:35:36,170
我们在特定情况下的窗口
是否在全屏状态下表现正常


786
00:35:37,538 --> 00:35:40,974
最后是一些确保我们的布局
真正具有灵活性的方法


787
00:35:41,041 --> 00:35:42,676
尤其是在这种狭窄环境下


788
00:35:43,343 --> 00:35:46,013
比如将新的标题栏
与Split View控制器


789
00:35:46,713 --> 00:35:48,115
自动布局和NSStackView配


790
00:35:48,182 --> 00:35:50,584
合使用以在您的UI的其他部分
构建灵活性


791
00:35:51,251 --> 00:35:54,621
而NSCollectionView
有真正很棒的对布局的支持


792
00:35:55,856 --> 00:35:58,058
若您有任何问题
您可以联系 Paul Marcos


793
00:35:58,125 --> 00:35:59,293
他乐于接收电子邮件


794
00:36:00,727 --> 00:36:03,230
此外我们还有一些相关的讲座环节
我早些时候也提到了


795
00:36:03,297 --> 00:36:05,832
现在它们已经都讲完了
但是您可以在视频上观看它们


796
00:36:06,567 --> 00:36:08,468
此外 我们今天晚些时候
还有一些实验室活动


797
00:36:08,535 --> 00:36:11,038
有的正在进行中
有的将在今天稍晚和明天进行


798
00:36:11,438 --> 00:36:12,773
如果您有任何问题
敬请提出


799
00:36:13,540 --> 00:36:15,742
祝您在WWDC上有美妙体验
敬请欢享盛会！


800
00:36:16,009 --> 00:36:16,844
回头见！

