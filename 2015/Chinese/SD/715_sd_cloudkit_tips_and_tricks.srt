1
00:00:20,254 --> 00:00:24,958
CloudKit技术讲座


2
00:00:30,030 --> 00:00:31,932
<br/> 
大家下午好 欢迎参加


3
00:00:31,999 --> 00:00:33,834
CloudKit技术讲座 


4
00:00:34,668 --> 00:00:36,570
我是尼哈 沙尔曼 


5
00:00:36,637 --> 00:00:38,172
是CloudKit团队的工程师 


6
00:00:39,072 --> 00:00:41,942
我知道 你们一些人可能
对我们的平台十分陌生 


7
00:00:42,242 --> 00:00:45,179
而且是首次遇到
CloudKit框架 


8
00:00:46,013 --> 00:00:48,715
而其他一些人可能已经开发
一些APP并且在应用商店中上架 


9
00:00:48,782 --> 00:00:51,051
在本讲座 我们将介绍
一些对所有人都适用的技术 


10
00:00:51,451 --> 00:00:52,286
现在让我们开始 


11
00:00:54,621 --> 00:00:55,822
什么是CloudKit？


12
00:00:56,390 --> 00:00:58,892
去年我们推出了CloudKit


13
00:00:58,959 --> 00:01:00,961
<br/>
这是一种全新的方法 


14
00:01:01,028 --> 00:01:03,997
让你能够与Apple的
iCloud数据库服务器对话 


15
00:01:05,032 --> 00:01:05,966
利用此功能


16
00:01:06,033 --> 00:01:08,635
我们为你
提供一系列的内置技术 


17
00:01:09,303 --> 00:01:10,504
例如大文件存储等 


18
00:01:12,272 --> 00:01:14,208
我们提供隐私保护标识符


19
00:01:14,274 --> 00:01:16,443
让你能够有效地管理


20
00:01:16,777 --> 00:01:19,012
任何拥有iCloud帐户
的用户 


21
00:01:21,215 --> 00:01:22,749
首先也是最重要的


22
00:01:22,816 --> 00:01:25,853
这是一个公开的开发者API 


23
00:01:25,919 --> 00:01:28,689
因为我们想希望你
利用这个平台的强大功能 


24
00:01:28,755 --> 00:01:31,692
为你的用户开发有用的APP 


25
00:01:33,527 --> 00:01:35,329
最后但并非不重要的事情是


26
00:01:35,395 --> 00:01:36,864
<br/>
Apple大力投资 


27
00:01:36,930 --> 00:01:37,764
开发这项技术 


28
00:01:38,131 --> 00:01:40,033
仅在去年
当我们首次发布此项技术时 


29
00:01:40,667 --> 00:01:41,502
我们就去推出


30
00:01:41,568 --> 00:01:42,636
一系列重要的客户端


31
00:01:42,703 --> 00:01:44,137
包括iCloud drive


32
00:01:44,204 --> 00:01:46,173
和iCloud
photo library


33
00:01:46,240 --> 00:01:48,041
今年我们增加了一些新客户端 


34
00:01:48,108 --> 00:01:50,711
例如 Notes APP
 News APP


35
00:01:51,311 --> 00:01:54,448
和WWDC APP 本周
你们很多人使用过这些APP


36
00:01:54,748 --> 00:01:56,283
而且你们的手机上还有这些APP 


37
00:01:58,185 --> 00:01:59,753
如果你不熟悉这些应用 


38
00:02:00,220 --> 00:02:01,588
我请你回顾一下


39
00:02:01,989 --> 00:02:03,423
去年的开发大会上的


40
00:02:03,490 --> 00:02:04,825
CloudKit讲座


41
00:02:04,892 --> 00:02:06,793
和Advanced
CloudKit讲座 


42
00:02:06,860 --> 00:02:09,263
这些讲座详细地
介绍了新API 


43
00:02:09,329 --> 00:02:11,164
我强烈建议你去看看 


44
00:02:12,466 --> 00:02:13,901
我们来先讲重要的事情 


45
00:02:13,967 --> 00:02:16,170
你们很多人一直在使用


46
00:02:16,236 --> 00:02:18,872
令人称道的Swift 2新功能 


47
00:02:19,273 --> 00:02:22,342
我很高兴宣布
对于iOS 9操作系统 


48
00:02:22,409 --> 00:02:25,445
在Swift中使用CloudKit
将会更加容易 


49
00:02:26,480 --> 00:02:28,582
让我们来通过一些例子


50
00:02:28,649 --> 00:02:29,583
来深入了解 


51
00:02:30,250 --> 00:02:34,288
直到现在 当你在CK记录中
设置和获取值时 你还必须


52
00:02:34,354 --> 00:02:37,324
使用陈旧的键值对象设置语法
使用对像语法设置键值


53
00:02:37,391 --> 00:02:40,327
这些工作将由
CloudKit API来完成 


54
00:02:40,394 --> 00:02:44,097
但是在iOS 9中  
在处理CK记录时 


55
00:02:44,164 --> 00:02:46,567
你可以使用更为熟悉和


56
00:02:46,767 --> 00:02:48,101
现代的字典订阅语法 


57
00:02:49,903 --> 00:02:52,739
除此之外 我们还利用
库标识符和轻量级泛型


58
00:02:52,906 --> 00:02:56,410
让你在Swift中编写的
CloudKit代码


59
00:02:56,610 --> 00:02:58,478
和Objective-C代码


60
00:02:58,679 --> 00:02:59,746
更不容易发生类型错误 


61
00:03:00,414 --> 00:03:05,118
以前你可能需要为记录设置
一组任意类型的对象


62
00:03:05,552 --> 00:03:09,056
来确保安全和正确的
CKRecords运算 


63
00:03:09,723 --> 00:03:13,994
现在利用iOS 9中的最新工具 


64
00:03:14,061 --> 00:03:16,663
当你做这些工作时 编译器
会发出提醒 让你及早发现错误 


65
00:03:16,964 --> 00:03:18,398
编写更可靠的代码 


66
00:03:21,001 --> 00:03:23,170
对此 请我简要回顾


67
00:03:23,604 --> 00:03:25,305
CloudKit存储架构 


68
00:03:27,241 --> 00:03:31,144
CloudKit的最顶层
称为CloudKit容器 


69
00:03:32,613 --> 00:03:35,749
它分为两个数据库 


70
00:03:36,283 --> 00:03:37,284
一个公用数据库


71
00:03:37,751 --> 00:03:40,587
它是你的所有用户共享的


72
00:03:41,288 --> 00:03:43,123
庞大APP数据 


73
00:03:44,858 --> 00:03:46,326
另一个私人数据库  


74
00:03:46,393 --> 00:03:48,228
仅供用户的iCloud帐户使用 


75
00:03:48,929 --> 00:03:50,430
这个数据库包含


76
00:03:50,497 --> 00:03:53,200
特定iCloud帐户
跨越所有用户设备


77
00:03:53,267 --> 00:03:54,368
所共享的数据 


78
00:03:55,769 --> 00:03:59,373
在每个数据库内 
我们还有一个分层离  


79
00:03:59,573 --> 00:04:01,041
用于存储记录 


80
00:04:01,508 --> 00:04:03,110
它们称为记录区 


81
00:04:05,112 --> 00:04:07,948
CloudKit使用这些数据库


82
00:04:08,015 --> 00:04:09,983
为你存储在其中的记录
提供更多的功能


83
00:04:10,884 --> 00:04:13,687
公用数据库有一个
称为默认区域的存储区域


84
00:04:13,754 --> 00:04:15,088
用于存储所有记录 


85
00:04:17,190 --> 00:04:20,226
私有数据库也有一个默认区域 


86
00:04:20,627 --> 00:04:23,163
利用这一特性  
你能够创建


87
00:04:23,230 --> 00:04:25,332
多个自定义区域 


88
00:04:25,732 --> 00:04:29,203
这些区域可以为你的记录
提供更多的功能 


89
00:04:31,438 --> 00:04:33,674
让我来介绍


90
00:04:33,740 --> 00:04:35,943
我们将在今天的讲座中
所要探讨的内容 


91
00:04:37,611 --> 00:04:39,713
你可能还记得 在去年
我们讨论了schema 


92
00:04:39,847 --> 00:04:42,816
我们介绍了一个APP的
示例schema 


93
00:04:42,883 --> 00:04:44,685
这个APP通过云端
将内容提供给各方 


94
00:04:45,519 --> 00:04:48,388
这里有一个简单的schema
其中有一个party记录类型


95
00:04:48,455 --> 00:04:50,924
和clown记录类型 
这两个类型的记录


96
00:04:51,758 --> 00:04:54,761
存储在公用数据库之中
让我们来运行这个示例APP


97
00:04:55,729 --> 00:04:57,798
并且为它开发更多的功能


98
00:04:58,298 --> 00:05:00,734
我们将这个示例APP
称为clown central 


99
00:05:00,801 --> 00:05:01,702
因为它是关于小丑的  


100
00:05:03,604 --> 00:05:05,239
我们将使用一个示例来介绍


101
00:05:05,305 --> 00:05:07,040
当你使用CloudKit
进行开发时 


102
00:05:07,207 --> 00:05:09,009
可以运用的经验和技巧 


103
00:05:10,344 --> 00:05:12,279
我们的APP有一个
简单的UI


104
00:05:12,346 --> 00:05:14,181
在这个UI中


105
00:05:14,248 --> 00:05:16,884
我们显示派对列表 
在这个讲座中 


106
00:05:16,950 --> 00:05:18,318
我们将会介绍一系列的功能 


107
00:05:20,120 --> 00:05:20,954
现在


108
00:05:21,021 --> 00:05:24,224
通过示例
我将会讨论四个主要方面的内容 


109
00:05:25,692 --> 00:05:27,594
第一个方面是错误处理 


110
00:05:28,762 --> 00:05:29,863
去年 我们曾经讲到过


111
00:05:29,930 --> 00:05:32,165
CloudKit APP


112
00:05:32,232 --> 00:05:33,667
是否处理错误


113
00:05:34,234 --> 00:05:36,770
不仅关系到APP的好坏


114
00:05:37,137 --> 00:05:38,906
甚至还决定APP是否


115
00:05:39,106 --> 00:05:40,440
正常运行或者完全崩溃 


116
00:05:41,041 --> 00:05:41,909
的确是这样的  


117
00:05:42,576 --> 00:05:45,546
当你使用API时 


118
00:05:45,612 --> 00:05:48,649
你会遇到一组特殊的错误代码 
我会讲解这些代码 


119
00:05:49,116 --> 00:05:50,684
并为你提供一些
一般性指导原则 


120
00:05:50,884 --> 00:05:51,818
告诉你如处理错误 


121
00:05:53,387 --> 00:05:54,221
对此


122
00:05:54,288 --> 00:05:56,356
我们将会介绍
一系列的技术 


123
00:05:56,423 --> 00:05:57,724
你需要记住这些技术


124
00:05:57,791 --> 00:05:59,359
当你维护本地缓存 


125
00:05:59,660 --> 00:06:00,727
进行CloudKit开发工作时 
可以使用这些技术 


126
00:06:02,029 --> 00:06:04,097
然后我们将会讨论
如何设置订阅 


127
00:06:04,164 --> 00:06:06,934
以不断地更新缓存 


128
00:06:07,634 --> 00:06:10,037
最后我将介绍一系列的


129
00:06:10,103 --> 00:06:12,739
通用性能技术你应该记住它们


130
00:06:12,806 --> 00:06:15,175
并用于你的APP开发 


131
00:06:16,944 --> 00:06:18,579
因此我们将会讲解许多内容 


132
00:06:18,645 --> 00:06:21,281
现在让我们讲解错误处理 


133
00:06:26,587 --> 00:06:29,623
我首先要讨论的事项
是关于帐户的 


134
00:06:30,824 --> 00:06:32,993
CloudKit并不需要


135
00:06:33,060 --> 00:06:35,128
你具有一个iCloud帐户 


136
00:06:35,462 --> 00:06:38,932
我们允许匿名只读
访问公用数据库 


137
00:06:40,033 --> 00:06:41,935
比如说 为了便于演示 


138
00:06:42,002 --> 00:06:44,805
clown central APP
将需要一个iCloud账户 


139
00:06:46,206 --> 00:06:47,708
我们将讨论一系列的功能 


140
00:06:47,774 --> 00:06:50,844
这些功能使用私有数据库 


141
00:06:50,911 --> 00:06:52,779
根据定义 将需要
一个通过身份验证的帐户 


142
00:06:54,515 --> 00:06:56,049
默认情况下 数据库写访问


143
00:06:56,116 --> 00:06:58,085
需要一个帐户 


144
00:07:00,554 --> 00:07:03,190
需要注意的是 
检查当前用户的


145
00:07:03,457 --> 00:07:05,959
帐户状态的方法是
使用CK容器内可用的


146
00:07:06,026 --> 00:07:09,229
完成处理API进行检查 


147
00:07:11,832 --> 00:07:15,035
在进行CloudKit开发时 
由于身份验证而造成的错误


148
00:07:15,102 --> 00:07:16,403
将会导致失败 


149
00:07:16,470 --> 00:07:20,107
并返回CKError
身份未验证错误代码 


150
00:07:21,475 --> 00:07:23,744
处理这种错误的一般性做法是


151
00:07:23,810 --> 00:07:25,045
重新检查帐户状态 


152
00:07:26,947 --> 00:07:29,249
例如 缺少iCloud帐户 


153
00:07:30,083 --> 00:07:31,518
当你检查账户状态时 


154
00:07:31,718 --> 00:07:34,488
你会收到“无帐户”
 CKAccount状态 


155
00:07:36,356 --> 00:07:37,491
在以前


156
00:07:37,558 --> 00:07:39,126
你没有办法知道


157
00:07:39,393 --> 00:07:41,895
因为帐户缺失而失败的请求


158
00:07:42,062 --> 00:07:43,297
是否会继续 


159
00:07:44,231 --> 00:07:45,532
正因为如此


160
00:07:45,599 --> 00:07:47,668
在iOS 9和
OS X El Capitan中 


161
00:07:47,935 --> 00:07:50,470
我们添加了CKAccount
变更通知 


162
00:07:51,138 --> 00:07:54,975
当用户帐户发生变更时 


163
00:07:55,042 --> 00:07:57,144
例如无登录或退出 


164
00:07:57,444 --> 00:07:59,213
或者iCloud 
drive功能开关


165
00:07:59,279 --> 00:08:00,581
被开启或关闭 
将会发送此通知 


166
00:08:02,850 --> 00:08:06,086
为此 我想介绍一些
最佳实践方法 


167
00:08:06,153 --> 00:08:08,322
以处理APP中的账户缺失错误 


168
00:08:10,290 --> 00:08:11,658
一种看上去不错的方法是


169
00:08:11,725 --> 00:08:13,126
<br/>
当遇到这种情况时 


170
00:08:13,193 --> 00:08:14,928
抛出一个警告


171
00:08:15,395 --> 00:08:17,264
告诉用户他们没有登录iCloud


172
00:08:17,331 --> 00:08:18,832
<br/>
因此不能继续 


173
00:08:19,800 --> 00:08:21,535
但是这对用户来说没有帮助作用 


174
00:08:21,602 --> 00:08:23,470
因为他们可能会忽略警告


175
00:08:24,004 --> 00:08:25,839
重新尝试操作 


176
00:08:25,906 --> 00:08:28,509
从而会继续看到警告 


177
00:08:29,576 --> 00:08:31,879
我们建议的方法是


178
00:08:32,679 --> 00:08:35,048
巧妙地设置你的UI 


179
00:08:35,115 --> 00:08:38,684
禁用需要帐户的功能 


180
00:08:39,620 --> 00:08:41,822
为此
你可以使用


181
00:08:41,889 --> 00:08:43,457
CKAccount变更通知 


182
00:08:43,590 --> 00:08:45,125
当你收到此通知时


183
00:08:45,192 --> 00:08:46,126
<br/>
应重新检查用户状态 


184
00:08:46,193 --> 00:08:47,561
查看帐户是否可用


185
00:08:47,628 --> 00:08:49,229
如果可用 则重新启用UI 


186
00:08:52,165 --> 00:08:53,600
帐户缺失仅仅是


187
00:08:53,667 --> 00:08:59,039
操作临时发生故障的
的原因之一 


188
00:09:01,041 --> 00:09:03,177
但是它可能在未来的
某个时间点发生 


189
00:09:04,511 --> 00:09:06,980
例如 在较差的
网络条件下 


190
00:09:07,114 --> 00:09:09,883
你可能遇到这种错误 
CKError网络故障 


191
00:09:11,318 --> 00:09:13,620
或者CloudKit服务器忙时 
也会发生这种错误 


192
00:09:13,687 --> 00:09:14,988
你可能会看到以下错误之一：


193
00:09:15,055 --> 00:09:16,323
CKError服务不可用


194
00:09:16,990 --> 00:09:18,225
或CKError区域忙 


195
00:09:19,326 --> 00:09:21,995
遇到这种错误时


196
00:09:22,629 --> 00:09:24,831
你应该在稍后重试操作 


197
00:09:26,099 --> 00:09:28,202
但是你可能会想 


198
00:09:28,435 --> 00:09:29,736
我应该在何时重试这些操作？


199
00:09:30,537 --> 00:09:32,906
你不需要猜想这个时间值 


200
00:09:34,842 --> 00:09:37,144
发生这些错误时 
在我们发送给你的用户信息字典中 


201
00:09:37,211 --> 00:09:40,314
在“CKError retry
 after key.”键值中


202
00:09:40,380 --> 00:09:41,949
<br/>
有一个专用的值 


203
00:09:42,983 --> 00:09:46,186
这个值就是
在重新尝试操作之前 


204
00:09:46,253 --> 00:09:48,522
需要等待的时间 单位为秒 


205
00:09:51,458 --> 00:09:53,460
现在让我们来看一个
类似的例子


206
00:09:54,061 --> 00:09:57,130
在这个例中 我们的APP
有一个bug 


207
00:09:57,197 --> 00:09:58,599
可能导致APP 


208
00:09:58,866 --> 00:10:02,336
在极短的时间内 
向服务器发送大量更新 


209
00:10:03,270 --> 00:10:06,373
如果这个APP始终这样做


210
00:10:06,440 --> 00:10:08,342
而且许多用户触发这个bug


211
00:10:08,642 --> 00:10:10,410
将会导致
iCloud服务器崩溃 


212
00:10:11,078 --> 00:10:12,412
为了避免这种问题 


213
00:10:12,713 --> 00:10:13,780
我们需要使用一个


214
00:10:13,847 --> 00:10:16,650
名为CKErrorRequest
RateLimited的


215
00:10:16,717 --> 00:10:17,684
专用错误代码 


216
00:10:19,019 --> 00:10:20,721
CloudKit利用这种方法


217
00:10:20,787 --> 00:10:22,222
避免APP bug造成


218
00:10:22,289 --> 00:10:24,157
iCloud服务器崩溃 


219
00:10:26,159 --> 00:10:29,263
如果请求数量达到限值 


220
00:10:29,329 --> 00:10:31,365
在一定的时间期限内


221
00:10:31,565 --> 00:10:33,467
将不发送请求给服务器


222
00:10:34,168 --> 00:10:35,936
那么这个时间期限是多少呢？


223
00:10:36,737 --> 00:10:39,339
系统通过“CKErrorretry
afterkey”


224
00:10:39,406 --> 00:10:40,307
来告知这个时间期限 


225
00:10:42,476 --> 00:10:44,111
因此 当你遇到这种错误时


226
00:10:44,711 --> 00:10:47,114
请在用户错误信息字典中
查找这个键值 


227
00:10:47,481 --> 00:10:50,050
请等待一定时间 
然后重试你的请求 


228
00:10:51,985 --> 00:10:54,154
现在我想介绍
你可能会遇到的


229
00:10:54,221 --> 00:10:55,989
另一种不同类别的错误 


230
00:10:56,857 --> 00:10:58,959
这类错误是由于
schema设计方式造成的 


231
00:10:59,026 --> 00:10:59,860
具体地说


232
00:10:59,927 --> 00:11:02,129
如果你的schema 
允许多个用户更新


233
00:11:04,231 --> 00:11:06,700
Cloud数据库中的同一条记录 
就可能发生这类错误 


234
00:11:07,734 --> 00:11:10,370
假设我们想要为APP
增加一项功能 


235
00:11:10,671 --> 00:11:12,005
从而允许用户


236
00:11:12,472 --> 00:11:13,974
将他们自己添加到派对之中 


237
00:11:16,009 --> 00:11:16,910
但是不幸的是


238
00:11:16,977 --> 00:11:18,879
在设计此APP的schema之前


239
00:11:18,946 --> 00:11:21,548
我们并没有参加去年的
关于高级CloudKit的讲座 


240
00:11:23,083 --> 00:11:24,618
这是我们设计的schema 


241
00:11:25,853 --> 00:11:27,621
对于派对记录本身


242
00:11:27,688 --> 00:11:28,755
我们决定存储


243
00:11:28,822 --> 00:11:31,425
一个引用数组 
它指向想要


244
00:11:31,491 --> 00:11:32,726
参加派对的人员记录 


245
00:11:36,563 --> 00:11:38,699
现在你可以看到 
每当我想要添加一个参加者


246
00:11:38,765 --> 00:11:40,701
到一个特定的派对时 


247
00:11:41,001 --> 00:11:43,570
我们都会修改同一个派对记录


248
00:11:45,105 --> 00:11:47,641
让我们通过一个例子来了解 
当两个不同的用户


249
00:11:47,975 --> 00:11:51,345
想要将他们添加到派对时 
将会发生什么 


250
00:11:53,280 --> 00:11:55,949
由于WWDC bash晚会
即将开始 


251
00:11:56,216 --> 00:11:58,018
因此让我们将这个记录


252
00:11:58,085 --> 00:11:59,253
保存到CloudKit 


253
00:12:00,621 --> 00:12:03,390
在我们了解
当两个用户下载此记录时


254
00:12:03,457 --> 00:12:05,192
将会发生什么之前


255
00:12:05,425 --> 00:12:06,260
我想介绍一下


256
00:12:06,326 --> 00:12:09,062
记录变更标记(record 
change tags)是什么  


257
00:12:10,097 --> 00:12:14,201
你可以认为它们是一个字符串


258
00:12:14,268 --> 00:12:15,736
<br/>
服务器使用它


259
00:12:16,170 --> 00:12:18,172
来标识特定的记录版本 


260
00:12:18,672 --> 00:12:21,642
保存在服务器上的记录版本


261
00:12:21,708 --> 00:12:24,745
通过变更标记A表示 


262
00:12:26,013 --> 00:12:29,383
它是CKRecords的只读属性 


263
00:12:29,516 --> 00:12:32,553
但是只有已经保存的记录
才会有这个标记 


264
00:12:34,054 --> 00:12:36,657
假设两个用户John
和Alice都下载


265
00:12:36,723 --> 00:12:38,959
这个特定的记录版本 


266
00:12:39,560 --> 00:12:42,262
你可以看到
他们接收相同的变更标记A 


267
00:12:43,664 --> 00:12:46,867
现在 John首先将他自己
作为参加者添加到派对 


268
00:12:47,601 --> 00:12:50,304
然后尝试将他的记录
添加到服务器 


269
00:12:51,438 --> 00:12:54,074
现在这条记录被保存  
我们将John的变更标记  


270
00:12:54,141 --> 00:12:57,010
也就是A 发送到服务器 


271
00:12:57,678 --> 00:12:59,746
服务器发现变更标记匹配 


272
00:13:00,614 --> 00:13:02,182
因此接受John的更改 


273
00:13:03,383 --> 00:13:06,520
由于服务器记录版本已发生变化 


274
00:13:06,787 --> 00:13:09,523
服务器将生成新的变更标记 
在本例中 此标记为B 


275
00:13:10,023 --> 00:13:12,693
并通过记录保存响应消息 
将它发回给John 


276
00:13:15,262 --> 00:13:17,865
现在Alice上线了 
她决定参加派对 


277
00:13:19,433 --> 00:13:22,135
她尝试相同的操作 
将她自己添加到数组中 


278
00:13:22,269 --> 00:13:23,904
并尝试保存她的记录版本 


279
00:13:24,805 --> 00:13:25,939
这时你会看到


280
00:13:26,006 --> 00:13:28,242
她发送旧的变更标记A


281
00:13:29,142 --> 00:13:30,477
服务器将会提醒 


282
00:13:30,577 --> 00:13:33,447
她正在尝试修改
已经不存在的


283
00:13:33,514 --> 00:13:34,681
服务器记录版本 


284
00:13:35,115 --> 00:13:36,750
她遇到了冲突 


285
00:13:38,318 --> 00:13:39,920
在她的设备上


286
00:13:39,987 --> 00:13:40,854
CloudKit


287
00:13:40,921 --> 00:13:44,124
通过“CKerror:server
 record changed” 


288
00:13:44,191 --> 00:13:47,060
专用代码向她告知这种冲突 


289
00:13:48,729 --> 00:13:51,532
其背后的机制并不神秘 


290
00:13:51,598 --> 00:13:53,200
我们不必想办法


291
00:13:53,267 --> 00:13:55,202
来解决这种冲突 


292
00:13:55,669 --> 00:13:57,070
你自己就可以解决 


293
00:13:57,571 --> 00:13:59,973
因此我们会为你提供


294
00:14:00,307 --> 00:14:01,775
尽可能多的有用信息 


295
00:14:01,842 --> 00:14:04,578
让你能够自己解决冲突 


296
00:14:05,879 --> 00:14:07,781
当更新请求被拒绝时  
我们为你提供的最早


297
00:14:07,848 --> 00:14:09,683
也是最重要的信息是


298
00:14:09,750 --> 00:14:13,353
服务器中的记录版本信息 


299
00:14:14,688 --> 00:14:16,089
在哪里可以找到这些信息呢？


300
00:14:16,156 --> 00:14:18,859
同样地 你可以
在用户错误字典中找到它 


301
00:14:19,126 --> 00:14:21,361
在本例中其值是
CKRecordchanged


302
00:14:21,428 --> 00:14:23,297
errorServer
RecordKey键值 


303
00:14:23,363 --> 00:14:24,965
在本例中 当我们将它


304
00:14:25,032 --> 00:14:27,234
用户错误信息字典中提取出来时 


305
00:14:27,434 --> 00:14:29,736
我们会发现
服务器中的记录


306
00:14:29,970 --> 00:14:33,340
已经记录John将会参加派对 
而且会发新的变更标记B 


307
00:14:35,342 --> 00:14:37,044
现在 除了服务器记录之外 


308
00:14:37,444 --> 00:14:40,147
我们还会为你返回
更多的信息 


309
00:14:42,349 --> 00:14:46,019
这些包括在Alice对记录
进行任何修改之前的


310
00:14:46,086 --> 00:14:49,423
原始记录键值 


311
00:14:50,824 --> 00:14:54,428
以及客户端记录键值 
此键值包含


312
00:14:54,494 --> 00:14:56,296
Alice尝试保存到服务器的记录 


313
00:14:59,733 --> 00:15:01,869
现在 我想强调的是  


314
00:15:01,935 --> 00:15:05,439
在大多数情况下
在解决冲突时


315
00:15:05,506 --> 00:15:07,441
最重要的事情 
也是你需要做的事情是 


316
00:15:07,908 --> 00:15:10,511
在发生错误之前 
及早保存你所做的修改 


317
00:15:10,577 --> 00:15:12,913
而不是等待错误响消息


318
00:15:13,480 --> 00:15:16,650
向你返回
服务器记录 


319
00:15:18,185 --> 00:15:20,320
在本例中 你获取服务器记录 


320
00:15:20,954 --> 00:15:23,624
我们将对想要保存的
这条记录进行相同的修改 


321
00:15:23,690 --> 00:15:26,760
也就是把Alice作为参加者


322
00:15:26,827 --> 00:15:29,329
添加到派对 包括她和John


323
00:15:29,696 --> 00:15:31,265
<br/>
并将这个记录版本


324
00:15:31,331 --> 00:15:32,299
保存到服务器 


325
00:15:34,401 --> 00:15:37,404
你会发现
服务器中的变更标记为B 


326
00:15:38,138 --> 00:15:40,641
当我们保存记录时 
这些变更标记将匹配 


327
00:15:40,707 --> 00:15:42,042
服务器将接受保存操作 


328
00:15:45,612 --> 00:15:47,214
在这里 我们应该知道


329
00:15:47,281 --> 00:15:50,217
如果我们为这项功能
设计更好的schema,


330
00:15:50,417 --> 00:15:52,419
我们可以避免这类错误 


331
00:15:53,620 --> 00:15:55,722
稍后我将会讨论schema 


332
00:15:58,425 --> 00:16:00,160
你会发现 在尝试修改相同记录时 


333
00:16:00,227 --> 00:16:03,463
每次不同的用户都要进行这种修改 


334
00:16:03,530 --> 00:16:05,632
这并不是最好的方法 


335
00:16:09,670 --> 00:16:11,271
让我们来了解一种新的schema 


336
00:16:11,538 --> 00:16:13,540
让我们来看
CloudKit操作 


337
00:16:14,975 --> 00:16:17,978
我想为APP添加一个新功能 


338
00:16:18,045 --> 00:16:20,681
以允许用户存储派对照片 


339
00:16:22,015 --> 00:16:24,985
这次 我们需要
在派对与照片之间


340
00:16:25,052 --> 00:16:26,186
建立一对多的关系


341
00:16:26,587 --> 00:16:28,055
照片将拥有
它们自己的记录类型 


342
00:16:28,856 --> 00:16:31,692
但是我们不想将它们
存储到照片记录 


343
00:16:31,992 --> 00:16:33,126
我们应该怎么做呢？


344
00:16:33,193 --> 00:16:37,564
我们可以通过反向引用
照片所属的派对


345
00:16:37,631 --> 00:16:39,666
来保存照片记录 


346
00:16:41,935 --> 00:16:42,870
你可以看到


347
00:16:42,936 --> 00:16:45,405
当我们保存照片记录时 


348
00:16:45,939 --> 00:16:49,042
不需要更改
照片所属的派对记录 


349
00:16:53,313 --> 00:16:55,349
让我们来了解
如何保存这些记录 


350
00:16:58,185 --> 00:16:59,820
在我们的APP中


351
00:16:59,887 --> 00:17:00,954
<br/>
我们使用便利性API


352
00:17:01,021 --> 00:17:03,023
利用完成处理操作保存记录 


353
00:17:03,090 --> 00:17:05,125
每次保存一个照片记录 


354
00:17:06,660 --> 00:17:07,594
但是


355
00:17:07,661 --> 00:17:10,731
用户可能一次存储多张照片 


356
00:17:10,797 --> 00:17:12,398
对于这种情况


357
00:17:12,465 --> 00:17:14,701
目前我们
使用便利性API


358
00:17:14,835 --> 00:17:17,304
通过不间断循环
来保存多条记录 


359
00:17:18,204 --> 00:17:21,141
让我们来看这些操作的


360
00:17:21,375 --> 00:17:22,542
背后机制 


361
00:17:24,912 --> 00:17:28,015
APP多次调用便利性API


362
00:17:28,080 --> 00:17:29,516
来保存多张照片  


363
00:17:30,450 --> 00:17:33,320
在系统中 
必须通过一组默认值  


364
00:17:33,487 --> 00:17:36,690
将它们封装在CK操作中


365
00:17:39,026 --> 00:17:43,030
当我们尝试将记录
保存到服务器时  


366
00:17:43,163 --> 00:17:45,165
这些操作中的每个操作
至少发出一次网络请求 


367
00:17:46,099 --> 00:17:48,502
我们不希望所有这些请求
导致服务器崩溃 


368
00:17:48,569 --> 00:17:52,072
但是我们造成了系统瓶颈 


369
00:17:52,139 --> 00:17:55,375
系统一次发送多个请求 


370
00:17:57,711 --> 00:17:59,079
以保存这些记录 


371
00:18:00,113 --> 00:18:02,516
现在 除了这个瓶颈之外 


372
00:18:02,583 --> 00:18:05,285
还需要考虑另外一件事情 


373
00:18:07,654 --> 00:18:11,558
这些操作中的每个操作
都请求一次保存一条记录 


374
00:18:11,625 --> 00:18:13,493
在本例中 


375
00:18:13,861 --> 00:18:15,996
将会产生大量的网络请求 


376
00:18:16,063 --> 00:18:18,232
从CloudKit APP开发人员
的角度来看 


377
00:18:19,233 --> 00:18:20,801
这显然不是一个好主意 


378
00:18:22,202 --> 00:18:24,905
我们希望通过一次网络请求


379
00:18:25,172 --> 00:18:28,275
批处理这些记录更新操作 
或者 至少应该


380
00:18:28,342 --> 00:18:29,743
使用最少的网络请求来处理它们 


381
00:18:30,010 --> 00:18:30,944
我们应该怎么做呢？


382
00:18:31,979 --> 00:18:36,383
我们使用与便利性API


383
00:18:36,450 --> 00:18:37,618
相对应的
CK操作 


384
00:18:38,886 --> 00:18:41,889
几乎每个一次处理一个项目的


385
00:18:41,955 --> 00:18:45,058
便利性API都有对应的CK操作 


386
00:18:45,192 --> 00:18:46,793
这些CK操作能够批处理记录更新 


387
00:18:47,427 --> 00:18:50,831
在本例中 我们想要使用
CKModifyRecords操作


388
00:18:51,198 --> 00:18:53,634
将多个记录作为一个数组
提供给记录保存资产


389
00:18:54,735 --> 00:18:57,237
以一次保存多个记录 


390
00:18:58,505 --> 00:19:01,008
让我们来看此操作的背后原理 


391
00:19:01,508 --> 00:19:04,144
现在我们可以将组合所有记录


392
00:19:04,211 --> 00:19:05,846
通过一次操作来保存它们 


393
00:19:08,448 --> 00:19:09,550
此操作进入系统队列 


394
00:19:09,616 --> 00:19:11,952
系统能够使用最少的请求数量 


395
00:19:12,019 --> 00:19:14,821
保存这些记录到服务器 


396
00:19:14,888 --> 00:19:17,858
我们就消除了瓶颈 


397
00:19:19,393 --> 00:19:24,164
同时 我们最大限度地


398
00:19:24,231 --> 00:19:25,165
减少了请求数量 


399
00:19:26,500 --> 00:19:30,370
我希望你们所有人
在你的APP中


400
00:19:30,437 --> 00:19:32,840
使用便利性API时 
使用这项技术 


401
00:19:33,640 --> 00:19:36,443
如果你考虑将它用于


402
00:19:36,510 --> 00:19:39,680
在多个位置或同一个类型的循环中 
处理同一种类型的请求 


403
00:19:40,514 --> 00:19:43,083
应考虑使用
CKOperation API


404
00:19:43,150 --> 00:19:44,852
以批处理这些请求 


405
00:19:45,719 --> 00:19:47,487
这将会减少请求数量 


406
00:19:47,554 --> 00:19:50,490
同时提高系统的效率


407
00:19:52,759 --> 00:19:55,195
好的 
现在我们来讨论批处理 


408
00:19:57,197 --> 00:19:58,765
这是我们需要考虑的


409
00:19:58,899 --> 00:19:59,833
另外一件事情 


410
00:20:02,970 --> 00:20:05,772
服务器限制
一次可以设置


411
00:20:05,839 --> 00:20:07,908
的批处理数量 


412
00:20:10,177 --> 00:20:12,012
这些限制包括


413
00:20:12,079 --> 00:20:14,181
每个请求中的项目数量


414
00:20:15,916 --> 00:20:18,318
和请求总数量 


415
00:20:18,519 --> 00:20:19,987
请求总数量是


416
00:20:20,053 --> 00:20:22,356
在隶属于该请求的记录中


417
00:20:22,422 --> 00:20:25,025
设置的键值数据之和 


418
00:20:26,360 --> 00:20:28,495
必须注意的一点是


419
00:20:28,562 --> 00:20:30,030
<br/>
通过CKAsset API


420
00:20:30,097 --> 00:20:32,466
作为批量存储的组成部分
存储的数据量


421
00:20:32,533 --> 00:20:35,636
并不会计入


422
00:20:35,702 --> 00:20:37,638
这个键值数据 


423
00:20:40,307 --> 00:20:43,510
但是 如果你的请求
想要绕过任何此类限制 


424
00:20:44,778 --> 00:20:45,879
你将会收到一个名为


425
00:20:45,946 --> 00:20:48,115
CKErrorLimit
Exceeded的专用错误代码 


426
00:20:49,316 --> 00:20:51,685
对于这种错误的处理方法 


427
00:20:51,752 --> 00:20:54,621
我们通常建议开发人员将
将项目对半拆拆分


428
00:20:54,688 --> 00:20:58,825
成为批处理 进行两次操作
而不是一次操作 


429
00:21:00,093 --> 00:21:02,129
如果再次遇到相同的错误 


430
00:21:02,196 --> 00:21:04,298
则应该进行同样的拆分 


431
00:21:06,366 --> 00:21:09,169
如果仅有批处理中的部分项目
发生错误 应该怎么办呢？


432
00:21:10,871 --> 00:21:15,008
由于批处理包括很多项目 


433
00:21:15,075 --> 00:21:18,445
但是只会返回一个错误 
但是我们仍然希望向你


434
00:21:18,512 --> 00:21:20,247
告知其中每一项错误 


435
00:21:20,981 --> 00:21:21,915
为此


436
00:21:21,982 --> 00:21:23,584
我们使用一个名为


437
00:21:24,651 --> 00:21:26,553
CKError partial 
failure的专用错误代码 


438
00:21:28,155 --> 00:21:30,324
这是一个顶层错误代码


439
00:21:30,657 --> 00:21:32,459
你并不希望直接处理它 


440
00:21:33,827 --> 00:21:34,661
但是与前面一样 


441
00:21:35,262 --> 00:21:37,030
在用户错误字典中 


442
00:21:37,097 --> 00:21:40,000
如果你按项目ID键值查找 
CKPartial错误键值 


443
00:21:40,701 --> 00:21:41,702
我们将会提供


444
00:21:41,768 --> 00:21:44,238
与你的批处理错误相应对应的


445
00:21:44,304 --> 00:21:45,706
项目ID字典 


446
00:21:47,274 --> 00:21:51,078
例如 在本例中 
有一个项目ID 


447
00:21:51,144 --> 00:21:52,846
发生CKRecord无效参数错误


448
00:21:53,213 --> 00:21:54,781
另外 批处理中的其他项目


449
00:21:54,848 --> 00:21:56,416
可能发生错误 
也可能没有错误 


450
00:21:56,750 --> 00:21:59,987
你需要打开这个字典 
在字典中进行查看 


451
00:22:00,053 --> 00:22:01,488
单独处理该错误 


452
00:22:03,757 --> 00:22:06,293
如果考虑自定义区域中的原子更新
(atomic update) 


453
00:22:06,360 --> 00:22:09,530
情况会略微发生变化 


454
00:22:11,665 --> 00:22:14,101
需要注意的是 自定义区域


455
00:22:14,168 --> 00:22:17,704
具有CKModify
记录操作功能 


456
00:22:17,771 --> 00:22:19,039
能够发送原子更新 


457
00:22:19,106 --> 00:22:22,276
在这种情况下 服务器将整个
批处理作为一个操作予以接受 


458
00:22:22,342 --> 00:22:24,444
或者拒绝整个批处理 


459
00:22:25,812 --> 00:22:28,448
如果批处理中的一个项目


460
00:22:28,515 --> 00:22:31,051
发生CKError无效参数错误
（与本例相同） 


461
00:22:31,118 --> 00:22:33,654
其余项目ID
将包含错误信息


462
00:22:34,021 --> 00:22:36,890
和CKRecords批处理
请求失败专用错误代码 


463
00:22:38,091 --> 00:22:39,793
在处理原子更新时 


464
00:22:39,860 --> 00:22:41,828
必须检索字典内容 


465
00:22:42,329 --> 00:22:43,764
处理未包含在


466
00:22:43,830 --> 00:22:45,599
批处理请求失败中的所有错误


467
00:22:47,734 --> 00:22:51,705
关于如何通过优化方式
将我们的照片记录存储到


468
00:22:51,772 --> 00:22:53,273
Cloud服务器 
我们就讲到这里 


469
00:22:53,674 --> 00:22:55,876
下面我们来讨论另外一半


470
00:22:55,943 --> 00:22:57,544
<br/>
即如何下载 


471
00:22:57,611 --> 00:23:00,113
我们使用
CloudKit查询来进行下载 


472
00:23:01,481 --> 00:23:03,150
现在 
利用我们设计的schema  


473
00:23:03,217 --> 00:23:06,053
下载特定派对的照片变得十分简单 


474
00:23:06,119 --> 00:23:08,889
在这种schema中 


475
00:23:08,956 --> 00:23:11,758
照片记录引用它们所属的派对 


476
00:23:12,759 --> 00:23:15,562
我们只需要创建一个CK查询 


477
00:23:15,863 --> 00:23:17,497
这个尝试匹配将这个引用


478
00:23:17,698 --> 00:23:19,132
与已知派对记录ID进行匹配 


479
00:23:22,035 --> 00:23:25,072
现在 如果我们发出查询 
以下载一个派对的照片 


480
00:23:25,772 --> 00:23:27,741
一些派对可能有大量的照片 


481
00:23:28,041 --> 00:23:29,877
我们是否需要全部下载它们呢？


482
00:23:31,111 --> 00:23:35,115
让我们来看如何
使用CKQuery操作


483
00:23:35,182 --> 00:23:37,017
发出特定派对照片


484
00:23:37,351 --> 00:23:38,952
优化下载查询 


485
00:23:42,589 --> 00:23:44,391
首先需要解决的问题是：


486
00:23:44,691 --> 00:23:47,661
我们并不知道有多少张照片
隶属于一个特定的派对 


487
00:23:47,928 --> 00:23:49,296
我们应该下载多少张照片呢？


488
00:23:50,163 --> 00:23:52,132
下载全部照片并没有意义 


489
00:23:53,267 --> 00:23:55,469
对于我们的UI来说 


490
00:23:55,536 --> 00:23:57,304
应该回答这个问题 


491
00:23:58,238 --> 00:24:00,274
如果你看一下
我们这里的示例UI 


492
00:24:00,541 --> 00:24:03,443
你可以看到 当我们调出
一个特定的派对时 


493
00:24:03,677 --> 00:24:06,380
我们看到20张照片 


494
00:24:07,648 --> 00:24:09,449
正确的做法是 


495
00:24:09,516 --> 00:24:11,718
当我们首次发出查询时 


496
00:24:12,052 --> 00:24:14,221
查询应仅返回20张照片给我们


497
00:24:15,189 --> 00:24:18,358
我们可以使用
CKQuery操作的结果限值属性


498
00:24:18,525 --> 00:24:19,726
来做到这一点 


499
00:24:21,295 --> 00:24:25,098
当你不知道总共会
返回多少个项目时  


500
00:24:26,300 --> 00:24:28,368
这个属性能够帮助你


501
00:24:28,435 --> 00:24:31,738
管理特定批处理中
的项目数量 


502
00:24:33,774 --> 00:24:35,676
因此 这个属性也可以用于


503
00:24:35,742 --> 00:24:37,544
CKFetch记录变更操作 


504
00:24:38,045 --> 00:24:39,980
此操作可能会返回大量的变更 


505
00:24:40,047 --> 00:24:42,516
而你并不知道自定义区域


506
00:24:43,851 --> 00:24:46,086
和CKFetch通知变更操作
会返回多少个变更 


507
00:24:46,153 --> 00:24:47,588
其原因与前面一样 


508
00:24:50,357 --> 00:24:52,526
好的 
现在我们只想下载20个记录 


509
00:24:52,993 --> 00:24:53,894
这样更简单一些 


510
00:24:54,494 --> 00:24:55,996
但是 我们可以做得更好吗吗？


511
00:24:56,763 --> 00:24:58,465
让我们来看我们的下载 


512
00:24:59,266 --> 00:25:02,069
我们再次来让UI
为我们回答这个问题


513
00:25:02,236 --> 00:25:04,605
当我们查看一个特定派对时 


514
00:25:04,671 --> 00:25:07,774
我们看到的是
特定派对的经过裁剪和


515
00:25:07,841 --> 00:25:09,810
缩小的缩略图


516
00:25:12,613 --> 00:25:14,882
但是我们存储在照片记录上


517
00:25:15,115 --> 00:25:17,985
而且默认情况下将会完全下载的


518
00:25:18,051 --> 00:25:22,256
可能是我们使用iOS设备


519
00:25:23,457 --> 00:25:25,459
高画质相机拍摄的


520
00:25:25,526 --> 00:25:26,593
照片的高分辨率版本 


521
00:25:27,794 --> 00:25:30,898
如果我们能够将该信息添加到


522
00:25:30,964 --> 00:25:33,667
我们的照片记录


523
00:25:34,635 --> 00:25:37,738
让我们能够调出部分记录 
将会很有帮助作用 


524
00:25:38,605 --> 00:25:40,107
但是 我们如何
调出部分记录呢吗？


525
00:25:41,008 --> 00:25:42,476
我们通过对CKQuery操作


526
00:25:42,543 --> 00:25:45,179
使用desiredKeys属性
来完成此任务 


527
00:25:46,313 --> 00:25:47,814
在本例中


528
00:25:47,881 --> 00:25:50,684
desiredKeys属性
接收一个键值属性数组 


529
00:25:50,751 --> 00:25:52,953
这些键值是符合查询条件的


530
00:25:53,020 --> 00:25:53,854
所有记录的键值 


531
00:25:55,122 --> 00:25:57,291
因此 如果我们将它设置为
thumbnail 


532
00:25:57,357 --> 00:26:00,327
你可以看到 当查询返回时 


533
00:26:00,394 --> 00:26:02,896
载入的数据量大幅减少了 


534
00:26:06,066 --> 00:26:08,936
这也可以用于
CKFetchRecords操作 


535
00:26:09,536 --> 00:26:13,440
在这种操作 你可能已经提前
知道你想要获取记录的ID 


536
00:26:14,007 --> 00:26:15,042
但是你的UI


537
00:26:15,108 --> 00:26:17,277
或者因其他原因 
你只想要


538
00:26:17,678 --> 00:26:19,246
下载部分记录 


539
00:26:21,882 --> 00:26:24,251
另外 也可以用于CKFetch
记录变更操作 


540
00:26:24,384 --> 00:26:27,387
默认情况下 此操作下载
任何已经变更的记录的


541
00:26:27,788 --> 00:26:29,356
全部记录内容 


542
00:26:31,925 --> 00:26:35,028
现在 如果我们只想显示
20张照片 当我们首次向用户


543
00:26:35,095 --> 00:26:38,165
显示这些照片时 


544
00:26:38,232 --> 00:26:39,800
照片应该以特定的顺序显示 


545
00:26:40,400 --> 00:26:43,203
假设我们想要按照


546
00:26:43,270 --> 00:26:45,439
照片在iCloud上的存储顺序


547
00:26:45,506 --> 00:26:48,075
显示这些照片 


548
00:26:50,711 --> 00:26:54,615
我们可以对CKQuery
设置sortDescriptor 


549
00:26:54,681 --> 00:26:56,984
并使用这些描述符
初始化CKQuery操作 


550
00:26:58,752 --> 00:27:01,822
你可以看到 在这里
我们将sortDescriptor


551
00:27:01,889 --> 00:27:04,958
设置为创建日期键值 
这是一个系统字段 


552
00:27:05,092 --> 00:27:07,961
保存在服务器上的所有
CKRecord都有这个字段 


553
00:27:09,930 --> 00:27:11,098
我们将它设置为降序 


554
00:27:14,735 --> 00:27:17,638
在这里 需要注意的是 
由于它是一个系统字段 


555
00:27:17,905 --> 00:27:21,108
因此你需要可以在服务器上
使用此字段进行排序 


556
00:27:21,642 --> 00:27:24,745
你可以通过iCloud 
Dashboard进行此设置 


557
00:27:25,612 --> 00:27:26,580
应该在保存记录之前


558
00:27:26,647 --> 00:27:29,416
进行此项设置 


559
00:27:29,917 --> 00:27:34,855
否则 在设置之前
保存的记录


560
00:27:34,922 --> 00:27:36,123
将不会有此项索引值 


561
00:27:38,292 --> 00:27:41,128
我们想要获取所有记录中的
小部分记录 


562
00:27:41,195 --> 00:27:43,897
你可能会想 


563
00:27:43,964 --> 00:27:45,532
如何向用户显示其余记录？


564
00:27:45,799 --> 00:27:48,435
假设用户开始向下滚动 


565
00:27:48,502 --> 00:27:49,770
想要查看下一批照片 


566
00:27:52,206 --> 00:27:55,209
在这种情况下 
我们如何实现分页显示？


567
00:27:55,676 --> 00:27:58,679
我们通过分析查询处理语句
返回的结果


568
00:27:58,745 --> 00:27:59,980
来处理这个问题 


569
00:28:01,315 --> 00:28:04,918
当查询完成时 


570
00:28:04,985 --> 00:28:06,954
我们不仅获得
查询返回的所有结果 


571
00:28:07,254 --> 00:28:09,056
还获得一个
CKQueryCursor 


572
00:28:10,591 --> 00:28:14,027
这是一个不透明的标记符 


573
00:28:14,094 --> 00:28:18,198
显示你在整个查询结果中
所处的位置 


574
00:28:18,932 --> 00:28:20,968
因此你应该存储


575
00:28:21,034 --> 00:28:23,437
首次查询操作返回给你的
QueryCursor


576
00:28:25,005 --> 00:28:26,907
当你想要


577
00:28:26,974 --> 00:28:28,509
获取下一批结果时 


578
00:28:28,942 --> 00:28:32,479
你可以始使用先前存储的
Cursor初始值 


579
00:28:32,546 --> 00:28:34,648
传递这个值 来初始化


580
00:28:34,948 --> 00:28:37,217
另一个CKQuery操作 


581
00:28:39,753 --> 00:28:43,323
当我们通过这种方式
优化CKQuery操作时 


582
00:28:43,390 --> 00:28:47,160
应确保对新查询操作
设置相同的必要键值 


583
00:28:47,227 --> 00:28:49,963
和结果返回数量限值 


584
00:28:50,964 --> 00:28:54,268
这将优化下一批照片
查询结果 


585
00:28:57,271 --> 00:28:59,706
关于下载记录就是这些 


586
00:29:01,074 --> 00:29:02,910
现在我想要切换主题 


587
00:29:02,976 --> 00:29:06,914
介绍一些在使用CloudKit时


588
00:29:07,014 --> 00:29:10,250
维护本地缓存方面的技术 


589
00:29:10,317 --> 00:29:12,719
让我们首先来讨论一项新功能 


590
00:29:15,189 --> 00:29:17,257
假设我们希望
用户能够为派对添加一些


591
00:29:17,324 --> 00:29:20,427
简短的个人评论 


592
00:29:22,462 --> 00:29:24,331
假设这些评论是个人化的 


593
00:29:24,932 --> 00:29:27,167
我们想要将它存储到
用户的私人数据库之中 


594
00:29:30,604 --> 00:29:33,540
我们不想要在用户每次查看
或修改这些评论时 


595
00:29:33,607 --> 00:29:35,709
获取这些评论 


596
00:29:36,443 --> 00:29:37,945
我们希望提供


597
00:29:38,011 --> 00:29:39,780
提供某种离线访问功能 


598
00:29:42,249 --> 00:29:45,953
你可以看到 在这种情况下 


599
00:29:46,386 --> 00:29:50,057
我们需要的是
在特定的设备用户上


600
00:29:50,123 --> 00:29:51,592
提供少量的数据 


601
00:29:52,926 --> 00:29:55,963
在这情况下使用CloudKit时 


602
00:29:56,630 --> 00:29:58,298
维护本地缓存是不错的做法  


603
00:30:00,434 --> 00:30:03,270
让我们先来看
如何从私人数据库


604
00:30:03,337 --> 00:30:04,404
下载内容 


605
00:30:05,572 --> 00:30:09,343
前面讲过 我们能够将记录
存储到私人数据库中的


606
00:30:09,409 --> 00:30:11,879
自定义区域
 此区域为我们提供一些附加功能


607
00:30:13,080 --> 00:30:14,848
让我们来进行这些操作 


608
00:30:15,382 --> 00:30:18,685
我们在私人数据库中
创建一个新区域 


609
00:30:19,920 --> 00:30:21,788
其名称为NotesZone 


610
00:30:22,089 --> 00:30:24,324
我们可以通过两种方法 
获取此区域中的数据 


611
00:30:26,126 --> 00:30:28,862
与前面一样 我们可以
使用CKQuery操作 


612
00:30:29,162 --> 00:30:31,131
并对它进行优化 
方法与前面一样 


613
00:30:32,533 --> 00:30:36,570
我们还可以通过
CKRecordsFetch操作


614
00:30:36,670 --> 00:30:41,175
使用delta下载 让我们仅获取


615
00:30:41,241 --> 00:30:42,543
区域中仅发生变更的记录 


616
00:30:43,076 --> 00:30:48,215
我们说过 此操作只适于


617
00:30:48,282 --> 00:30:50,050
具有获取变更功能的区域


618
00:30:50,551 --> 00:30:52,152
目前 私人数据库中的
所有自定义区域


619
00:30:52,219 --> 00:30:54,421
都具有此功能 


620
00:30:55,923 --> 00:30:57,191
如果你想要更详细地


621
00:30:57,257 --> 00:30:59,993
了解delta下载的工作原理 


622
00:31:00,060 --> 00:31:01,128
我建议你


623
00:31:01,195 --> 00:31:02,896
回顾去年的
高级CloudKit讲座 


624
00:31:03,230 --> 00:31:06,600
这个讲座详细地介绍
这种操作是如何工作的 


625
00:31:09,369 --> 00:31:10,737
假设我们想要使用这项功能 


626
00:31:11,238 --> 00:31:12,773
我们开始获取变更记录 


627
00:31:13,140 --> 00:31:16,677
我们将APP对象存储在


628
00:31:16,743 --> 00:31:18,478
一个本地数据库之中 
它可能是核心数据 


629
00:31:18,679 --> 00:31:20,247
或你选择的其它数据库 


630
00:31:21,815 --> 00:31:24,284
在这个位置
我们编码APP对象 


631
00:31:25,953 --> 00:31:28,222
这里有一个party对象 


632
00:31:28,422 --> 00:31:31,959
我们为它添加了
一个notes键值


633
00:31:32,092 --> 00:31:34,094
对应于用户为这个派对
添加的评论 


634
00:31:34,895 --> 00:31:39,199
我们将APP编码到
本地存储 


635
00:31:39,266 --> 00:31:42,169
当处理相应的CKRecords时 


636
00:31:42,669 --> 00:31:44,738
我们想要将记录
存储在Cloud之中 


637
00:31:46,907 --> 00:31:50,611
我们可能考虑
编码整个CKRecord 


638
00:31:51,879 --> 00:31:55,782
因此我们缓存这些记录
和我们的APP对象 


639
00:31:56,183 --> 00:31:57,651
让我们来看会发生什么 


640
00:31:58,051 --> 00:32:00,721
你可以看到 
CKRecord还具有为其设置的


641
00:32:00,787 --> 00:32:02,356
所有APP对象键值 


642
00:32:02,689 --> 00:32:04,358
当然 在我们编码时


643
00:32:04,424 --> 00:32:06,527
我们会复制所有的APP键值 


644
00:32:07,928 --> 00:32:09,897
当我们编码APP对象之后 


645
00:32:09,963 --> 00:32:11,565
以及当我们编码
CKRecord时 


646
00:32:12,266 --> 00:32:13,734
这就是我们想要的 


647
00:32:16,003 --> 00:32:18,138
你看到 CKRecord对象中的
橙色字段


648
00:32:18,205 --> 00:32:19,673
属于CKRecord 


649
00:32:19,973 --> 00:32:22,409
服务器通过这些字段


650
00:32:22,476 --> 00:32:26,780
来识别记录的特定版本 


651
00:32:27,014 --> 00:32:28,549
它们称为系统字段 


652
00:32:29,850 --> 00:32:32,119
在本例中 你真正的想要是的


653
00:32:32,186 --> 00:32:35,189
记录的系统字段的编码方法 


654
00:32:36,089 --> 00:32:39,126
你可以使用编码系统字段和


655
00:32:39,193 --> 00:32:41,328
编码器API对
CKRecord进行编码 


656
00:32:42,896 --> 00:32:45,465
你需要使用这些代码


657
00:32:45,532 --> 00:32:46,867
对这些系统字段进行编码 


658
00:32:47,134 --> 00:32:50,337
我们强烈建议你使用这种方法 


659
00:32:50,404 --> 00:32:52,773
如果遇到这样的情况 
你需要回顾以往的讲座 


660
00:32:55,008 --> 00:32:58,412
现在让我们来看当我们开始
编码系统字段时将会发生什么 


661
00:32:59,680 --> 00:33:02,583
我们想要高效地存储


662
00:33:02,649 --> 00:33:05,385
CKRecord的重要信息和
相应的party对象 


663
00:33:08,121 --> 00:33:11,091
现在 让我们来看 
尝试修改一个party对象时  


664
00:33:11,291 --> 00:33:13,160
将会发生什么 


665
00:33:13,560 --> 00:33:16,196
我们已经使用前面所述的方法
存储这个对象的系统字段 


666
00:33:18,432 --> 00:33:22,669
为此 我们使用CKRecord的
编码器初始化函数 


667
00:33:27,140 --> 00:33:28,575
你可以看到 当我们调用它时 


668
00:33:29,443 --> 00:33:34,648
我们获得先前存储的
所有系统字段 


669
00:33:34,715 --> 00:33:37,317
为了简洁起见 我仅显示
记录ID和我们已经看到的


670
00:33:37,651 --> 00:33:38,585
变更标记 


671
00:33:40,420 --> 00:33:44,324
对于这个CKRecord 
你完全可以设置


672
00:33:44,391 --> 00:33:48,762
此记录发生变更的键值 


673
00:33:49,162 --> 00:33:50,831
比如说 我们想要变更派对名称 


674
00:33:51,698 --> 00:33:54,935
将派对名称更改为
WWDC bash 


675
00:33:55,169 --> 00:33:57,171
我们为这个键值设置为新的值 


676
00:33:57,538 --> 00:33:59,006
并在服务器上保存新记录 


677
00:34:01,875 --> 00:34:05,612
必须指出的是 
当存储记录的变更值时  


678
00:34:05,679 --> 00:34:07,848
你不必设置记录的


679
00:34:08,047 --> 00:34:10,117
所有键值 


680
00:34:12,553 --> 00:34:15,155
我们正式地维护和存储


681
00:34:15,222 --> 00:34:19,525
本地缓存 让我们来看
如何从自定义区域


682
00:34:19,592 --> 00:34:22,862
获取变更值 
以使缓存保持为最新 


683
00:34:24,197 --> 00:34:27,100
与前面一样 我们使用


684
00:34:27,167 --> 00:34:29,469
CKFetchRecord
Changes操作


685
00:34:29,536 --> 00:34:31,205
来完成这个任务 


686
00:34:31,271 --> 00:34:33,206
此操作提供区域中
所有已经发生变更的记录 


687
00:34:33,774 --> 00:34:36,944
真正的问题是 
应该在何时使用此操作？


688
00:34:37,578 --> 00:34:40,514
因为 单独使用此操作
并不会告诉我们 


689
00:34:40,647 --> 00:34:42,482
存储区域在何时已经发生变更 


690
00:34:43,016 --> 00:34:44,384
为此 我们需要


691
00:34:44,451 --> 00:34:47,387
通过CKSubscription 
API来使用通知 


692
00:34:49,690 --> 00:34:52,525
更具体地说 
由于区域中的变更


693
00:34:52,592 --> 00:34:56,429
并不是你想通知给用户的变更 


694
00:34:56,864 --> 00:34:59,566
因此在这里我们应该
使用静默通知 


695
00:35:01,735 --> 00:35:06,406
在下一节中 我将介绍


696
00:35:06,473 --> 00:35:09,343
始何启用并运行订阅 


697
00:35:09,409 --> 00:35:11,645
尤其是当你想要
使用静默订阅时 


698
00:35:12,446 --> 00:35:14,448
让我们简要回顾


699
00:35:15,148 --> 00:35:16,350
什么是订阅?


700
00:35:17,484 --> 00:35:19,286
订阅内容是根据


701
00:35:19,353 --> 00:35:21,555
用户存储在服务器上的
定期内容查询请求而提供的


702
00:35:23,490 --> 00:35:26,026
你或你的APP通过这种方法


703
00:35:26,159 --> 00:35:29,463
接收相关内容变更远程通知 


704
00:35:30,497 --> 00:35:33,200
有两种类型的订阅 
它们的不同之处在于


705
00:35:33,267 --> 00:35:36,570
你如何定义哪些变更
是你需要关注的


706
00:35:38,639 --> 00:35:41,275
第一种是查询订阅


707
00:35:41,708 --> 00:35:43,210
允许你存储
一个预设条件 


708
00:35:44,011 --> 00:35:46,413
如果变更符合预设条件时 


709
00:35:46,613 --> 00:35:47,681
就是你所需要的变更 


710
00:35:48,982 --> 00:35:51,285
第二种是区域订阅 
在这种方法中 


711
00:35:51,351 --> 00:35:53,253
区域中的每次记录修改


712
00:35:53,320 --> 00:35:55,622
都被计为一个相关变更 


713
00:35:58,358 --> 00:36:01,428
因此 很明显 在本例中 
我们需要静默通知 


714
00:36:02,529 --> 00:36:05,699
当我们的区域发生变更时 
将会发送此通知 


715
00:36:07,501 --> 00:36:10,737
但是 我们首先需要了解
当你处理各种CloudKit订阅时


716
00:36:11,071 --> 00:36:13,340
所需要的常规设置 


717
00:36:14,675 --> 00:36:16,977
对这个设置 我想强调的是 


718
00:36:17,144 --> 00:36:22,149
如果远程通知
并非来自于CloudKit. 


719
00:36:22,216 --> 00:36:24,084
你仍然需要


720
00:36:24,251 --> 00:36:26,386
设置远程通知 


721
00:36:27,554 --> 00:36:28,722
让我来阐明其含义 


722
00:36:29,256 --> 00:36:31,892
首先 你仍然需要
在开发者门户中 


723
00:36:31,959 --> 00:36:34,595
为这个APP ID 
开启APS功能 


724
00:36:35,262 --> 00:36:38,165
当你开启CloudKit功能时 


725
00:36:38,232 --> 00:36:39,566
将会自动为你开启此功能 


726
00:36:41,368 --> 00:36:44,771
第二 在测试你的APP
而且预计会收到远程通知时  


727
00:36:44,838 --> 00:36:47,641
你需要在你的APP中
将APS环境键值


728
00:36:47,708 --> 00:36:49,276
设置到P列表之中
以用于开发工作 


729
00:36:51,778 --> 00:36:52,880
第三 你仍然需要


730
00:36:52,946 --> 00:36:55,782
通过UI应用API
进行注册 


731
00:36:56,650 --> 00:36:58,886
如果你计划在你的App中
显示用户通知


732
00:36:58,952 --> 00:37:02,890
至少 你需要调用
远程通知注册  


733
00:37:03,023 --> 00:37:05,692
并且提醒用户 


734
00:37:05,759 --> 00:37:08,328
注册用户通知设置


735
00:37:11,198 --> 00:37:14,134
由于我们需要静默通知 


736
00:37:14,501 --> 00:37:16,103
而且会通过
CloudKit服务器


737
00:37:16,170 --> 00:37:19,273
向我们发送通知 
我们应该如何告诉服务器 


738
00:37:19,973 --> 00:37:21,642
此通知应该是静默通知呢？


739
00:37:22,743 --> 00:37:26,346
我们通过与CK订阅相对应的


740
00:37:26,413 --> 00:37:28,815
CKNotification信息
来完成这个任务 


741
00:37:28,882 --> 00:37:30,150
我们将它作为入口点


742
00:37:30,417 --> 00:37:32,819
告诉CloudKit服务器
应该发送哪种类型的


743
00:37:32,886 --> 00:37:36,156
推送内容和以哪种优先级
进行发送 


744
00:37:36,523 --> 00:37:37,724
让我们来说说优先级 


745
00:37:39,960 --> 00:37:44,431
如前所述 我们配置
CKNotification信息 


746
00:37:44,531 --> 00:37:45,933
以告诉CloudKit服务器


747
00:37:46,166 --> 00:37:48,635
这是一个静默通知 


748
00:37:48,702 --> 00:37:49,837
它需要以低优先级发送 


749
00:37:51,772 --> 00:37:53,574
如果你为
CKNotification


750
00:37:53,640 --> 00:37:55,108
信息设置这些键值 


751
00:37:55,175 --> 00:37:57,411
服务器将为你发送
高优先级推送内容 


752
00:37:57,811 --> 00:38:02,149
无论它是提醒正文 
徽标或声音名称 


753
00:38:03,584 --> 00:38:06,320
我们将它们称为订阅
使用的UI键值 


754
00:38:06,420 --> 00:38:07,754
如果你发送其中任何一项 


755
00:38:08,188 --> 00:38:10,657
服务器将发送
高优先级推送内容 


756
00:38:10,724 --> 00:38:12,159
这意味着 需要立即发送 


757
00:38:14,027 --> 00:38:17,664
所有其他推送内容
将会以中优先级发送 


758
00:38:17,731 --> 00:38:19,032
并计入静默通知数量 


759
00:38:21,435 --> 00:38:23,904
让我们来看你需要


760
00:38:23,971 --> 00:38:26,206
什么样的静默通知设置 


761
00:38:29,309 --> 00:38:30,711
首先 你需要为你的APP


762
00:38:30,777 --> 00:38:33,614
开启远程通知后台模式 


763
00:38:34,281 --> 00:38:36,884
你可以通过
Xcode中的功能窗格来启用它 


764
00:38:37,951 --> 00:38:39,653
你应该记得选中该选项 


765
00:38:42,055 --> 00:38:43,690
第二 你应该确保


766
00:38:43,757 --> 00:38:45,692
你实现的APP


767
00:38:45,759 --> 00:38:47,361
接收远程通知 


768
00:38:47,694 --> 00:38:49,596
获取应用委派的API


769
00:38:49,663 --> 00:38:51,031
完成处理通知


770
00:38:52,699 --> 00:38:55,636
将会在后台调用其他版本 


771
00:38:55,702 --> 00:38:58,405
在计划使用静默通知时 


772
00:38:58,472 --> 00:38:59,973
请确保已经实现这个版本 


773
00:39:03,210 --> 00:39:06,313
第三 我们需要再一次
告诉CloudKit服务器 


774
00:39:06,380 --> 00:39:08,248
通知是静默推送通知 


775
00:39:08,715 --> 00:39:11,118
我们如何配置CK
Notification信息呢？


776
00:39:12,953 --> 00:39:14,388
首先也是最重要的 


777
00:39:14,454 --> 00:39:15,289
你应该将


778
00:39:15,355 --> 00:39:17,224
shouldSendContent
Availablent属性


779
00:39:17,291 --> 00:39:18,458
设置为true.


780
00:39:18,792 --> 00:39:21,094
这个属性告诉
CloudKit服务器 


781
00:39:21,161 --> 00:39:22,629
在你的推送内容中 
应该包含


782
00:39:22,696 --> 00:39:23,564
可用内容键值 


783
00:39:26,066 --> 00:39:29,703
其次 你应该为C
Notification信息


784
00:39:29,770 --> 00:39:32,806
设置我们前面所述的UI键值 


785
00:39:33,507 --> 00:39:35,309
目前并不支持
同时设置这些属性和


786
00:39:35,375 --> 00:39:38,278
shouldSendContent
Available属性 


787
00:39:38,345 --> 00:39:40,714
这将会导致服务器错误 


788
00:39:44,318 --> 00:39:46,553
现在 让我们探讨
静默推送内容送达 


789
00:39:46,620 --> 00:39:49,189
我们已经配置
与推送相关的所有设置 


790
00:39:49,556 --> 00:39:51,959
我们将于何时获得推送内容呢？


791
00:39:52,292 --> 00:39:55,529
由于这些通知的目的
并不是为了提醒用户 


792
00:39:55,596 --> 00:39:58,765
因此系统将会在适当的时机


793
00:39:58,832 --> 00:40:00,334e
发送这些通知 


794
00:39:58,832 --> 00:40:00,334
发送这些通知 


795
00:40:00,834 --> 00:40:03,737
在决定何时发送这些通知时  


796
00:40:03,804 --> 00:40:04,905
系统将会考虑各种因素 


797
00:40:07,875 --> 00:40:10,544
通常来说 推送是尽力而为的 


798
00:40:11,645 --> 00:40:14,348
也就是说 推送可能会被合并


799
00:40:14,648 --> 00:40:17,284
甚至被丢弃 
具体视设备状况而定 


800
00:40:17,951 --> 00:40:21,355
例如 如果在需要接收紧急通知时  


801
00:40:21,421 --> 00:40:24,658
设备处于飞行模式 
当设备退出飞行模式时 


802
00:40:24,725 --> 00:40:27,494
Apple推送通知服务器
仅会向设备发送


803
00:40:27,561 --> 00:40:29,796
确实需要接收的
最后一条推送通知 


804
00:40:31,832 --> 00:40:34,067
现在 我们有办法
来解决这个问题 


805
00:40:34,134 --> 00:40:36,470
因为我们可以
使用CloudKit通知 


806
00:40:37,471 --> 00:40:38,772
具体来说


807
00:40:39,273 --> 00:40:42,576
CloudKit服务器
存储需要发送到你的设备的


808
00:40:42,643 --> 00:40:44,645
所有通知 


809
00:40:44,745 --> 00:40:46,847
我们将它称为通知集合 


810
00:40:48,382 --> 00:40:50,851
因此当你接收静默通知时 


811
00:40:51,084 --> 00:40:53,720
应该确保从这个通知集合中


812
00:40:53,787 --> 00:40:55,222
获取变更通知 


813
00:40:55,322 --> 00:40:56,523
你可以通过CK


814
00:40:56,590 --> 00:40:59,493
FetchNotification
Changes操作来完成 


815
00:41:01,528 --> 00:41:04,565
因此 当我们获取静默通知时 
我们检查


816
00:41:04,665 --> 00:41:06,400
是否有任何丢失的通知 


817
00:41:07,134 --> 00:41:09,036
而且我们知道
我们的区域已经发生变更 


818
00:41:09,102 --> 00:41:11,572
这也是我们获得通知的原因 


819
00:41:12,339 --> 00:41:13,574
在这种情况下 我们使用


820
00:41:13,640 --> 00:41:15,876
CKFetchRecord
Changes操作


821
00:41:15,943 --> 00:41:17,578
来查看我们的区域内
发生了哪些变更 


822
00:41:20,314 --> 00:41:22,382
和前面讨论的一样 


823
00:41:22,449 --> 00:41:24,918
我们并不知道区域内
发生了多少变更 


824
00:41:25,919 --> 00:41:28,055
因此这可能一个
长时间运行的操作 


825
00:41:28,388 --> 00:41:31,191
如果操作需要较长的时间来完成 


826
00:41:31,692 --> 00:41:32,759
我建议你考虑使用


827
00:41:32,826 --> 00:41:35,429
针对UI应用的后台任务API 


828
00:41:37,264 --> 00:41:39,399
这将允许你分配更多的时间


829
00:41:39,466 --> 00:41:41,735
给你的操作 直到操作完成 


830
00:41:44,137 --> 00:41:46,340
现在 在我们开始讨论通知之前 
我需要告诉你们 


831
00:41:46,940 --> 00:41:50,544
在iOS 8中 我们引入了
一个全新的通知类别 


832
00:41:50,811 --> 00:41:53,413
称为交互式通知 


833
00:41:53,647 --> 00:41:57,684
它允许用户在信息条 


834
00:41:57,784 --> 00:41:59,620
提醒界面或通知中心
处理推送通知 


835
00:42:01,455 --> 00:42:03,724
利用CloudKit 你可以
将大量的请求


836
00:42:03,790 --> 00:42:06,193
配置为交互式通知 


837
00:42:06,727 --> 00:42:09,229
我很高兴地告诉你们 
在iOS 9中你只需要很少的设置 


838
00:42:09,296 --> 00:42:10,964
就可以完成此操作 


839
00:42:11,431 --> 00:42:14,001
同样地如果CK
Notification信息


840
00:42:14,067 --> 00:42:15,302
设置新的类型属性 


841
00:42:15,369 --> 00:42:17,237
当注册用户通知设置时  


842
00:42:18,672 --> 00:42:21,441
这个属性将对应于


843
00:42:21,942 --> 00:42:23,343
你使用UIMutable


844
00:42:23,410 --> 00:42:26,580
Notification
Categories注册的标识符


845
00:42:27,481 --> 00:42:28,949
只需要进行这些设置 


846
00:42:29,016 --> 00:42:31,685
就可以通过
CloudKit运行交互式通知 


847
00:42:39,193 --> 00:42:40,027
<br/> 
谢谢 


848
00:42:40,594 --> 00:42:43,463
结合这些功能 我想介绍一些


849
00:42:43,530 --> 00:42:46,099
你应该掌握的一些常用性能技术 


850
00:42:46,200 --> 00:42:49,102
在使用CloudKit
开发APP时 


851
00:42:49,303 --> 00:42:50,571
你应该使用这些技术 


852
00:42:52,339 --> 00:42:55,209
CloudKit是高度异步API 


853
00:42:56,977 --> 00:43:00,380
大多操作在网络上进行 
你经常会遇到


854
00:43:00,447 --> 00:43:03,750
许多具有依赖关系的任务 


855
00:43:04,318 --> 00:43:07,221
而且你需要保持
特定的任务完成顺序 


856
00:43:09,756 --> 00:43:15,062
当针对这些任务实施任务管理时 


857
00:43:15,362 --> 00:43:18,732
需要实现一些目标 


858
00:43:18,799 --> 00:43:20,400
你们需要记住一些重要的目标 


859
00:43:22,069 --> 00:43:23,971
首先 很明显 


860
00:43:24,271 --> 00:43:27,474
无论你使用什么样的技术 
你都需要


861
00:43:27,541 --> 00:43:29,643
为每个CloudKit任务


862
00:43:29,710 --> 00:43:31,712
实施良好的错误处理方法 


863
00:43:33,447 --> 00:43:35,916
其次 由于这些操作
是异步操作 


864
00:43:35,983 --> 00:43:38,485
你应该确保
在任何情况下 


865
00:43:38,552 --> 00:43:39,853
避免阻止主线程


866
00:43:40,287 --> 00:43:41,822
和降低它们的UI性能 


867
00:43:44,358 --> 00:43:47,528
最后但非不重要的是 
作为开发人员 


868
00:43:47,928 --> 00:43:51,164
你应该确保你的任务管理方案
能够保持良好的代码可维护性


869
00:43:51,231 --> 00:43:54,301
当你为APP添加新功能时 
代码应该便于分析 


870
00:43:54,368 --> 00:43:56,970
调试和扩展 


871
00:43:59,006 --> 00:44:01,308
让我们来看一些方法 


872
00:44:01,675 --> 00:44:03,110
并且了解一些技巧和缺点 


873
00:44:05,913 --> 00:44:09,249
第一点是不要嵌套
便利性API调用 


874
00:44:11,051 --> 00:44:14,154
让我们来看一个简单的例子 


875
00:44:14,288 --> 00:44:17,090
在前面所述的schema中 
如果我们想要修改


876
00:44:17,191 --> 00:44:20,294
一个派对参加者记录 
请不要在实际中编程中 


877
00:44:20,360 --> 00:44:21,461
使用这个schema 


878
00:44:21,795 --> 00:44:24,264
但是 当你使用便利性API时 


879
00:44:24,331 --> 00:44:27,034
如果你想要修改派对参加者记录 
你就必须这样做 


880
00:44:27,401 --> 00:44:29,837
你首先需要使用ID获取记录 


881
00:44:29,903 --> 00:44:31,038
然后尝试获取


882
00:44:31,104 --> 00:44:33,173
参加者想要参加的派对的记录 


883
00:44:33,841 --> 00:44:36,844
然后从参加者数组中


884
00:44:36,910 --> 00:44:41,448
找到参加者记录ID 
然后对参加者记录进行修改 


885
00:44:41,515 --> 00:44:44,251
然后尝试保存记录 


886
00:44:45,285 --> 00:44:48,155
当需要修改一条具有很多
依存关系的字段的记录时 


887
00:44:48,555 --> 00:44:50,090
你必须执行这些操作 


888
00:44:50,290 --> 00:44:52,359
你会看到一大堆


889
00:44:54,895 --> 00:44:58,565
杂乱无章的代码 


890
00:44:58,632 --> 00:45:02,236
你不知道在哪里处理哪些错误 


891
00:45:02,669 --> 00:45:05,105
以及如何最合理地
重试这些操作 


892
00:45:06,106 --> 00:45:07,708
除此之外 还需要


893
00:45:07,774 --> 00:45:10,177
考虑另外一件事情 


894
00:45:11,378 --> 00:45:14,014
假设用户的某些APP操作


895
00:45:14,081 --> 00:45:16,283
导致我们需要进行这些操作 


896
00:45:17,351 --> 00:45:20,387
如果一个用户后续操作


897
00:45:20,454 --> 00:45:22,923
而导致不再需要这些任务 


898
00:45:23,223 --> 00:45:25,626
由于这些任务已经进入队列 


899
00:45:25,692 --> 00:45:26,693
你将无法取消这些任务 


900
00:45:27,661 --> 00:45:30,163
如果它们的运行时间很长 
当它们运行时 


901
00:45:30,230 --> 00:45:32,666
你将无法进行其它操作 
你必须等待它们完成 


902
00:45:34,468 --> 00:45:36,570
当你管理相关依赖的任务时 
尤其是在你需要


903
00:45:36,670 --> 00:45:39,540
对批量记录进行相同的修改时 


904
00:45:40,374 --> 00:45:43,510
我们建议你不要使用这种方法  


905
00:45:45,679 --> 00:45:47,881
另一种方法是
消除API的异步性质 


906
00:45:47,948 --> 00:45:50,717
这可以使用信号灯


907
00:45:50,784 --> 00:45:52,786
并且等待信号灯来实现 


908
00:45:54,521 --> 00:45:57,224
在一些情况下 
这也会变得十分复杂 


909
00:45:57,925 --> 00:46:00,527
你不应该尝试这样做 


910
00:46:00,827 --> 00:46:04,998
如果你这样做 你应该知道 


911
00:46:05,766 --> 00:46:08,769
尤其是在你的长时间
等待操作完成时 


912
00:46:08,836 --> 00:46:10,838
你很容易遇到


913
00:46:10,904 --> 00:46:12,606
循环式的依赖关系 


914
00:46:12,673 --> 00:46:14,174
而导致APP陷入死循环 


915
00:46:15,609 --> 00:46:19,213
或者 如果你想对主线程
使用这种方法 


916
00:46:19,847 --> 00:46:23,116
在网络上等待被处理的操作


917
00:46:23,183 --> 00:46:25,352
将会导致UI停止响应  


918
00:46:25,419 --> 00:46:26,820
从而严重影响用户体验 


919
00:46:28,956 --> 00:46:30,057
因此我们不建议这样做 


920
00:46:33,927 --> 00:46:36,396
我们建议你查看


921
00:46:36,463 --> 00:46:40,334
NSOperation 提供的
依赖关系管理API 


922
00:46:41,902 --> 00:46:43,570
就是这个API 


923
00:46:44,071 --> 00:46:46,840
NSOperation
让你能够轻松添加


924
00:46:46,907 --> 00:46:49,343
和消除其他NSOperations
之间的依赖关系 


925
00:46:50,544 --> 00:46:52,246
让我们来看如何使用


926
00:46:52,312 --> 00:46:53,547
CKOperations
实现这一点 


927
00:46:53,614 --> 00:46:56,450
CKOperations是
NSOperations的子类 


928
00:46:58,185 --> 00:47:01,154
如果有两个互相依赖的
获取记录操作 


929
00:47:01,722 --> 00:47:05,125
而且第二个操作应该
在第一个操作完成之后开始 


930
00:47:05,192 --> 00:47:09,062
你只需设置这两个操作 


931
00:47:09,596 --> 00:47:13,267
将第一个获取操作设置为
第二操作的先决条件 


932
00:47:13,333 --> 00:47:14,935
然后将这两个操作送入队列 


933
00:47:15,936 --> 00:47:19,806
这将保证
在第一个获取操作完成之前 


934
00:47:20,140 --> 00:47:21,542
第二个获取操作不会启动 


935
00:47:22,543 --> 00:47:25,512
你会看到 
这提供一个符合逻辑的方法 


936
00:47:25,579 --> 00:47:27,915
让你能够发现特定操作的错误 


937
00:47:28,248 --> 00:47:30,384
并且能够方便地


938
00:47:30,450 --> 00:47:32,252
管理它们的依赖关系 


939
00:47:34,721 --> 00:47:37,357
现在 当我们从性能的角度


940
00:47:37,424 --> 00:47:39,459
考虑NSOperations时 


941
00:47:40,928 --> 00:47:43,997
我希望你们思考


942
00:47:44,064 --> 00:47:45,365
另外一个不同之处 


943
00:47:47,134 --> 00:47:49,336
并非所有NSOperations
都是同等的 


944
00:47:49,903 --> 00:47:52,606
有些NSOperations 
可能是因为用户在APP中的


945
00:47:52,673 --> 00:47:54,241
显式操作而产生的 


946
00:47:54,308 --> 00:47:56,543
其他一些
NSOperations示操作


947
00:47:56,743 --> 00:47:58,312
则可能是一些
低优先级的后台任务 


948
00:47:59,379 --> 00:48:02,182
为了向系统告知


949
00:48:02,249 --> 00:48:04,351
这些NSOperations
的相对重要性 


950
00:48:04,518 --> 00:48:07,154
在iOS 8中 
我们为NSOperations.


951
00:48:07,221 --> 00:48:09,656
引入了服务质量属性  


952
00:48:11,325 --> 00:48:14,862
你可以用这个属性
指定NSOperation封装的


953
00:48:14,928 --> 00:48:17,598
作业的性质和重要性 


954
00:48:19,032 --> 00:48:21,201
可以将这个属性


955
00:48:21,268 --> 00:48:24,605
设置为不同的服务质量级别 
我建议你们


956
00:48:24,671 --> 00:48:26,874
查看相关文档 
来了解各个服务质量等级


957
00:48:26,940 --> 00:48:28,675
以及它们的重要性 


958
00:48:29,476 --> 00:48:32,012
在这里 需要记住的一点是 


959
00:48:32,079 --> 00:48:35,148
这个服务质量值
直接影响NSOperation的


960
00:48:35,215 --> 00:48:38,952
资源分配优先级 


961
00:48:39,353 --> 00:48:43,156
例如CPU时间、
磁盘资源和网络资源 


962
00:48:45,092 --> 00:48:47,794
现在结合去年推出的CloudKit


963
00:48:47,861 --> 00:48:50,163
<br/>
 我们想要为你提供类似的方法  


964
00:48:50,230 --> 00:48:53,267
让你能够将低优先级
CKOperations


965
00:48:53,467 --> 00:48:55,202
优化成为自主性网络行为 


966
00:48:56,570 --> 00:48:57,538
我的意思是


967
00:48:57,604 --> 00:49:01,341
优化非用户发起的任务 


968
00:49:01,775 --> 00:49:04,344
预取用户内容 
就像我们在前面


969
00:49:04,411 --> 00:49:07,247
使用CKRecords
获取记录变更操作


970
00:49:07,314 --> 00:49:09,383
来响应静默通知所作的那样 


971
00:49:10,317 --> 00:49:13,153
你需要将这些任务
优化成为自主性行为 


972
00:49:13,220 --> 00:49:16,356
使系统在合适的时机


973
00:49:16,924 --> 00:49:18,625
执行这些网络请求 


974
00:49:19,760 --> 00:49:22,362
在决定何时执行这些请求时 


975
00:49:22,596 --> 00:49:25,432
系统会考虑很多因素 


976
00:49:26,133 --> 00:49:27,534
例如蜂窝网络连通性等 


977
00:49:27,935 --> 00:49:31,872
系统可能会等待网络
连通性改善之后 


978
00:49:31,939 --> 00:49:34,775
再发送这些请求


979
00:49:35,375 --> 00:49:36,777
另外还会考虑电量等 


980
00:49:37,277 --> 00:49:38,812
如果用户设备电量过低 


981
00:49:39,046 --> 00:49:41,882
或者设备未在充电 
系统将会等待


982
00:49:41,949 --> 00:49:45,252
电量增加之后 
再发送这些请求 


983
00:49:46,153 --> 00:49:47,154
我们通过使用


984
00:49:47,221 --> 00:49:48,522
CKOperations的


985
00:49:48,589 --> 00:49:51,491
userBackground
Session属性来实现这一点 


986
00:49:53,126 --> 00:49:55,529
在iOS 9中


987
00:49:55,596 --> 00:49:57,364
我们可以


988
00:49:57,564 --> 00:50:00,868
极大地简化和统一这些功能


989
00:50:00,934 --> 00:50:02,536
这两个概念


990
00:50:02,603 --> 00:50:06,340
我们通过服务质量来
推测你的网络行为 


991
00:50:06,940 --> 00:50:09,877
同时应用特定服务等级参数


992
00:50:09,943 --> 00:50:12,646
向系统发送的所有其他设置 


993
00:50:13,647 --> 00:50:15,048
这就是我们使用的方法 


994
00:50:16,283 --> 00:50:18,519
我们不建议用户
使用后台会话属性 


995
00:50:19,119 --> 00:50:22,155
而建议你为所有
CKOperation操作


996
00:50:22,322 --> 00:50:24,091
设置服务级别 


997
00:50:25,792 --> 00:50:27,761
现在 对于网络行为  


998
00:50:28,061 --> 00:50:29,997
可以设置将服务级别设置为


999
00:50:30,063 --> 00:50:32,165
UserInteractive


1000
00:50:32,232 --> 00:50:33,634
或UserInitiated 


1001
00:50:33,700 --> 00:50:35,736
来优化这些自主性行为


1002
00:50:38,705 --> 00:50:41,074
对于自主性行为 


1003
00:50:41,141 --> 00:50:43,777
你可以设置utility值 


1004
00:50:44,811 --> 00:50:45,879
在这种情况下 


1005
00:50:45,946 --> 00:50:49,449
系统将推测 
是否根据发送请求的APP


1006
00:50:49,516 --> 00:50:53,954
在前台或在后台运行
来优化自主性行为 


1007
00:50:54,755 --> 00:50:57,391
从而始终会产生
自主性网络行为 


1008
00:50:59,259 --> 00:51:01,862
请记住中 
如果你在iOS 9


1009
00:51:01,929 --> 00:51:05,432
和OS X El Capitan
或后续版本中开发APP 


1010
00:51:06,466 --> 00:51:08,669
默认情况下 
所有新CKOperations


1011
00:51:08,735 --> 00:51:10,971
将具有后台服务质量级别 


1012
00:51:11,839 --> 00:51:15,175
你应该确保
审查所有CKOperations,


1013
00:51:16,176 --> 00:51:17,477
查看它们所代表的


1014
00:51:17,544 --> 00:51:18,745
作业的重要性 


1015
00:51:19,079 --> 00:51:20,480
应该保持良好的系统性能 


1016
00:51:20,714 --> 00:51:22,983
为这些操作合适的QS值 


1017
00:51:24,818 --> 00:51:26,820
NSOperation是
功能强大的API 


1018
00:51:26,887 --> 00:51:28,789
你可以使用它实现很多功能  


1019
00:51:29,556 --> 00:51:32,759
如果你想了解更多信息 
我强烈建议你们


1020
00:51:32,826 --> 00:51:36,163
参加明天上午在Presidio举行
的高级NSOperation讲座 


1021
00:51:37,831 --> 00:51:38,866
作为总结


1022
00:51:40,701 --> 00:51:42,002
我想重新强调


1023
00:51:42,069 --> 00:51:45,005
CloudKit代码中的
错误处理方法很重要 


1024
00:51:45,339 --> 00:51:47,574
它与功能一样重要 


1025
00:51:48,108 --> 00:51:50,043
我希望你们反复检查你的代码 


1026
00:51:50,110 --> 00:51:52,379
查看你的所有操作 


1027
00:51:52,446 --> 00:51:54,581
弄清楚你遇到哪些类型的错误 


1028
00:51:54,648 --> 00:51:56,483
以及你是否遵守了
今在我们所讲述的


1029
00:51:56,550 --> 00:51:58,719
关于错误处理的
一般性指导原则 


1030
00:52:00,521 --> 00:52:03,023
第二 应该批处理你的请求 


1031
00:52:03,290 --> 00:52:07,394
当你发现你的APP
使用便利性API,


1032
00:52:07,461 --> 00:52:09,663
一次处理一个项目


1033
00:52:10,163 --> 00:52:11,798
而且在多个位置
进行这样的处理时 


1034
00:52:11,865 --> 00:52:15,135
你应该考虑使用该API的
CKOperation版本 


1035
00:52:15,502 --> 00:52:16,703
并且批处理这些请求 


1036
00:52:17,237 --> 00:52:19,173
你不仅会全面提升


1037
00:52:19,540 --> 00:52:22,509
系统的操作执行效率 


1038
00:52:22,910 --> 00:52:25,512
而且会减少网络请求数量 


1039
00:52:28,048 --> 00:52:29,416
应考虑优化schema 


1040
00:52:29,616 --> 00:52:31,285
我们看到两种情况


1041
00:52:31,351 --> 00:52:33,654
需要我们优化schema...


1042
00:52:35,556 --> 00:52:38,325
让我们能够获得优化的好处 


1043
00:52:38,492 --> 00:52:41,295
例如 当我们为照片记录


1044
00:52:41,361 --> 00:52:42,896
添加缩略键值时


1045
00:52:43,096 --> 00:52:45,465
<br/>
我们可以仅下载需要的数据


1046
00:52:45,532 --> 00:52:48,168
从而能够优化下载性能 


1047
00:52:48,902 --> 00:52:51,972
在另一种情况下 
当我们避免


1048
00:52:52,039 --> 00:52:54,474
某些派对照片被修改时


1049
00:52:54,541 --> 00:52:56,977
<br/>
当我们为派对存储照片时 


1050
00:52:57,044 --> 00:52:58,478
可以避免发生
整个类别的错误 


1051
00:52:59,112 --> 00:53:01,281
因此 在设计功能时  


1052
00:53:02,349 --> 00:53:03,684
请认真思考你的schema 


1053
00:53:05,252 --> 00:53:06,687
最后并非不重要的是


1054
00:53:06,753 --> 00:53:08,522
应该配置你的
CKOperations 


1055
00:53:08,589 --> 00:53:11,124
它们是功能非常强大的API 


1056
00:53:11,191 --> 00:53:14,061
它们提供大量的优化特性
让你能够优化


1057
00:53:14,228 --> 00:53:16,864
发送至CloudKit服务器的


1058
00:53:16,930 --> 00:53:17,931
网络请求 


1059
00:53:20,234 --> 00:53:22,736
要想获取更多信息 
请访问我们的文档地址是


1060
00:53:22,803 --> 00:53:25,706
developer.Apple.com/CloudKit.


1061
00:53:26,240 --> 00:53:28,775
关于其他所有问题和解答 


1062
00:53:28,842 --> 00:53:31,879
可以咨询技术支持部门 
论坛和CK支持网站 


1063
00:53:32,279 --> 00:53:33,113
对于一般性咨询


1064
00:53:33,180 --> 00:53:35,582
请发送邮件至
CloudKit@Apple.com 


1065
00:53:36,850 --> 00:53:38,919
这周我们举行了
一些很不错的讲座 


1066
00:53:38,986 --> 00:53:41,221
我希望你们回去后
观看这些讲座视频 


1067
00:53:41,522 --> 00:53:44,091
了解Web服务新功能


1068
00:53:44,558 --> 00:53:46,159
和CloudKit其他新功能 


1069
00:53:46,960 --> 00:53:48,061
明天上午9点 


1070
00:53:48,128 --> 00:53:50,163
我们还会在
Frameworks lab D


1071
00:53:50,230 --> 00:53:51,498
举行另外一场讲座 


1072
00:53:52,299 --> 00:53:54,301
请准备好你们的问题 
我们将乐意为你解答 


1073
00:53:54,768 --> 00:53:55,602dle
谢谢 

