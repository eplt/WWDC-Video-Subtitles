1
00:00:19,553 --> 00:00:23,156
介绍watchOS 2的
WatchKit


2
00:00:23,223 --> 00:00:24,525
乔希·谢弗: 好的 上午好


3
00:00:25,025 --> 00:00:27,694
感谢大家今天来到这里学习


4
00:00:27,761 --> 00:00:30,097
有关watchkit和
watchOS 2的新知识


5
00:00:30,464 --> 00:00:32,698
今天上午要讲的东西有很多


6
00:00:33,433 --> 00:00:36,503
当然
最重要的部分是WatchKit


7
00:00:36,770 --> 00:00:38,238
以及WatchKit相关最新信息


8
00:00:38,805 --> 00:00:43,277
WatchKit
作为watchOS系统平台的一部分


9
00:00:43,677 --> 00:00:45,579
存在一系列其他框架


10
00:00:45,879 --> 00:00:47,414
其中很多是各位已经熟悉的


11
00:00:47,481 --> 00:00:48,882
用于开发iOS应用的框架


12
00:00:49,349 --> 00:00:52,085
此外还有一些用于专属watchOS


13
00:00:52,486 --> 00:00:55,322
用于提供特性的新内容
都属于Apple Watch所独有


14
00:00:55,589 --> 00:00:57,724
今天我们将讨论这些新信息


15
00:00:57,791 --> 00:01:02,663
以及一些各位已经熟悉的
涉及watchOS专属的新内容


16
00:01:06,166 --> 00:01:07,734
也就是watchOS 2


17
00:01:09,102 --> 00:01:11,271
首先让我们简单谈谈系统结构


18
00:01:12,840 --> 00:01:16,510
各位已经熟悉用于WatchOS 1
的Watch系统应用


19
00:01:17,144 --> 00:01:17,978
其运行方式是


20
00:01:18,278 --> 00:01:21,582
需要在iPhone和Apple
Watch上同时有用户界面


21
00:01:22,049 --> 00:01:24,418
你推出了一款iPhone app


22
00:01:24,918 --> 00:01:26,420
这款iPhone app中有


23
00:01:26,720 --> 00:01:29,756
适合Apple Watch
作为Watch app的一部分


24
00:01:31,558 --> 00:01:33,861
用户界面
分镜故事板


25
00:01:34,161 --> 00:01:36,430
在Apple Watch中存在
并安装在这里


26
00:01:36,830 --> 00:01:38,332
但app拓展在手机上运行


27
00:01:38,966 --> 00:01:41,101
watchOS 2的一大进展就是


28
00:01:41,301 --> 00:01:45,272
app拓展并运行
在Apple Watch


29
00:01:47,841 --> 00:01:50,544
这给各位的用户带来了一些便利


30
00:01:51,011 --> 00:01:56,083
首先 当然是用户界面
和运行的后台代码处于同一设备


31
00:01:56,383 --> 00:01:58,986
可使交互等待时间更短


32
00:01:59,286 --> 00:02:01,822
从而使应用反应速度更灵敏


33
00:02:03,123 --> 00:02:05,692
显然 这一改善带来了很好的效果


34
00:02:06,093 --> 00:02:08,362
比如在手机不在身边时
仍然可以运行应用


35
00:02:09,530 --> 00:02:11,665
为了确保这一效果高效运行


36
00:02:11,999 --> 00:02:16,937
各位应该现在花时间了解清楚
如何将应用程序逻辑移动到程序拓展中


37
00:02:18,071 --> 00:02:19,273
如果在watchOS 1中


38
00:02:19,373 --> 00:02:24,378
你耗费大量时间用于打开父应用程序
在iPhone app中运行代码


39
00:02:24,778 --> 00:02:27,981
你想要重构该逻辑并移动到拓展中


40
00:02:29,483 --> 00:02:31,251
app拓展获得的代码越多


41
00:02:31,652 --> 00:02:35,556
在iPhone不在身边的情况下
就可以提供越多的单机功能


42
00:02:36,623 --> 00:02:38,959
当然 有关单机功能
另一个重要的部分是


43
00:02:39,326 --> 00:02:43,163
Apple Watch可以通过
Wi-Fi访问网络


44
00:02:43,730 --> 00:02:47,301
以便你的app可以从HTTP服务器
获得数据


45
00:02:47,434 --> 00:02:49,436
即使在iPhone不在身边时
也能访问网络


46
00:02:49,670 --> 00:02:52,906
如果你习惯在iOSapp中
使用NSURL Session


47
00:02:53,307 --> 00:02:54,975
那么你已经知道如何操作了


48
00:02:55,275 --> 00:02:56,410
稍后我们会讨论这个问题


49
00:02:57,144 --> 00:02:58,712
但首先我们来谈谈


50
00:02:59,012 --> 00:03:00,514
WatchKit框架下的新特性


51
00:03:00,981 --> 00:03:04,751
除了将代码运行移动到Apple
Watch这一巨大进展


52
00:03:05,052 --> 00:03:07,387
我们也为WatchKit
加入了一系列新的性能


53
00:03:07,855 --> 00:03:10,591
以便各位在watchOS 2
开发更酷的应用程序


54
00:03:11,658 --> 00:03:13,160
为了给大家一些有关新性能的概述


55
00:03:13,427 --> 00:03:15,629
这里的列表举出了我们即将谈到的性能


56
00:03:15,929 --> 00:03:18,498
我们拥有数码表冠 设计和动画


57
00:03:18,732 --> 00:03:21,301
因此现在我们来介绍这些优秀的性能


58
00:03:21,668 --> 00:03:23,504
首先我们来看数码表冠


59
00:03:24,071 --> 00:03:27,641
这是属于Apple Watch的
独特交互机制


60
00:03:28,408 --> 00:03:31,311
一系列新的简单的控制


61
00:03:31,645 --> 00:03:35,048
方便您将数码表冠
应用于工作界面选取器


62
00:03:36,250 --> 00:03:42,422
选择器控件是通过
数码表冠滚动单元列表


63
00:03:42,756 --> 00:03:43,590
并选择其中一项


64
00:03:44,191 --> 00:03:45,993
数码表冠有三种类型


65
00:03:46,560 --> 00:03:47,528
现在详细介绍每一类


66
00:03:47,628 --> 00:03:50,230
我们现在看到的是第一类列表类型


67
00:03:50,864 --> 00:03:53,934
如果你了解表盘上的配置合并


68
00:03:54,268 --> 00:03:55,469
那你已经了解其基本运行了


69
00:03:55,936 --> 00:03:56,803
这是一个项目列表


70
00:03:57,638 --> 00:04:00,374
可以在周围列出可选的焦点框


71
00:04:00,908 --> 00:04:04,912
并在顶端给出有关已选项目
更多的细节信息介绍


72
00:04:05,145 --> 00:04:08,582
以防列出的项目本身
代表的含义并不明确


73
00:04:10,083 --> 00:04:12,986
用户可以选择显示或隐藏更多细节信息
针对任意一项用户交互单元


74
00:04:13,387 --> 00:04:16,023
如果屏幕中同时列出多个选择器


75
00:04:16,190 --> 00:04:18,257
用户可能需要显示焦点框


76
00:04:18,458 --> 00:04:22,129
以便清晰告知用户
一旦按下表冠将要进行何种操作


77
00:04:23,330 --> 00:04:27,868
第二种模式是堆叠式


78
00:04:28,936 --> 00:04:32,539
堆叠式提供一系列图像


79
00:04:32,673 --> 00:04:34,608
使用户可以滚动并选取其中之一


80
00:04:34,942 --> 00:04:39,112
这一模式可以进行自动转换
其他项目自动淡出


81
00:04:39,646 --> 00:04:43,784
如果你想给用户提供一系列选择
并生动地呈现出来


82
00:04:44,017 --> 00:04:46,854
你可以选择这一模式
它的视觉效果很好


83
00:04:47,788 --> 00:04:49,923
第三种模式是图像序列


84
00:04:50,891 --> 00:04:54,661
图像序列模式提供一个可以滚动的列表


85
00:04:54,928 --> 00:04:56,730
其中是相互没有过渡效果的图像


86
00:04:57,197 --> 00:05:00,868
如果经过一个程序到另一个的转换后看
起来十分自然


87
00:05:01,168 --> 00:05:05,506
那么你可以选择这个十分适合此类情况
更适合使用这种图像的模式


88
00:05:07,140 --> 00:05:09,076
我们可以看到右上角这里


89
00:05:09,443 --> 00:05:11,044
这里设有一个滚动指示


90
00:05:11,678 --> 00:05:15,782
这是一个三种模式都适用的
可选用户交互元素


91
00:05:16,717 --> 00:05:19,820
这个滚动指示器使用的情况是


92
00:05:19,953 --> 00:05:23,724
用户不能准确看到列表内容
或列表内容数量的情况


93
00:05:24,291 --> 00:05:26,760
例如 用户在应用中选择一天中的时刻


94
00:05:27,594 --> 00:05:28,896
选择一天中的一个小时


95
00:05:29,463 --> 00:05:31,598
这时可能不需要滚动指示


96
00:05:31,865 --> 00:05:36,170
因为用户明确知道一天有多少小时
并且在列表中有明显显示


97
00:05:36,970 --> 00:05:41,208
加入选择的内容是其他多少不能像选择
表情符号那样清楚显示的


98
00:05:41,508 --> 00:05:42,709
那么适合选择滚动指示


99
00:05:42,776 --> 00:05:45,979
以便用户了解所面临的选项
以及一共有多少个选择


100
00:05:48,182 --> 00:05:49,983
除了这三种模式


101
00:05:50,217 --> 00:05:53,287
选择器控件事实上还有另一个性能


102
00:05:53,487 --> 00:05:56,857
在运行中可以带来更多的灵活性
实现更便捷的用户交互


103
00:05:57,324 --> 00:05:59,293
也就是协调化图像


104
00:05:59,860 --> 00:06:01,528
这一特性的最大优点在于


105
00:06:01,595 --> 00:06:05,132
可以用于创建动态的图像
在其他交互元素中


106
00:06:05,199 --> 00:06:08,535
例如群组背景 或其他交互图像


107
00:06:08,836 --> 00:06:12,072
你可以将它们设置为
与选择性控件相协调


108
00:06:12,639 --> 00:06:17,911
当用户进行整理时
我们会调整动态图像的框架的偏移量


109
00:06:18,078 --> 00:06:20,881
从而与列表项目中相关的偏移量相对应


110
00:06:21,348 --> 00:06:23,984
从而方便您建立用户交互
看起来就像这样


111
00:06:24,685 --> 00:06:29,323
当用户浏览 进行选择时
有一个协调话图像填充环形


112
00:06:30,157 --> 00:06:32,025
不同模式的相互结合使用


113
00:06:32,092 --> 00:06:36,129
并通过数码表冠操控
可以方便你开发一个有趣 独特的模式


114
00:06:37,698 --> 00:06:40,100
接下来让我们谈谈动画技术和设计


115
00:06:40,968 --> 00:06:41,869
正如各位所知


116
00:06:41,935 --> 00:06:44,037
应该在storyboards上
在watchOS上建立用户交互


117
00:06:44,104 --> 00:06:45,506
并且基于Xcode


118
00:06:47,541 --> 00:06:50,978
Xcode中你有各种选择可用于设置


119
00:06:51,044 --> 00:06:53,080
storyboard中
不同的交互元素


120
00:06:53,814 --> 00:06:57,451
现在watchOS 1中推出了很多
此类选择可以以编程的方式进行改变


121
00:06:57,551 --> 00:06:59,853
但是有一些选择
只能在storyboard中运行


122
00:07:00,320 --> 00:07:02,723
在watchOS
2中我们不断推出新性能 进行提高


123
00:07:02,823 --> 00:07:04,558
从而为这些项目提供设置


124
00:07:04,625 --> 00:07:08,362
改变这些项目之前在设计过程中
只能在Xcode中设置的状态


125
00:07:09,096 --> 00:07:11,732
这一性能可以极大改善
程序运行时的效果


126
00:07:11,798 --> 00:07:13,300
改变之前只能静态呈现的状态


127
00:07:14,334 --> 00:07:19,206
此外我们还添加了新的动画API界面


128
00:07:19,473 --> 00:07:24,344
其持续时间可以通过一个讯息块
并可以将你设置的改动加入到交互元素


129
00:07:24,811 --> 00:07:27,080
在该模块中
做的任何改动都会随之被动态化


130
00:07:27,381 --> 00:07:30,751
如果您熟悉用户界面套件动态API
那么对这一特性就十分熟悉


131
00:07:31,451 --> 00:07:36,757
这一特性有助于用动画开发
一系列很酷 运行流畅的交互


132
00:07:37,457 --> 00:07:39,159
另外要介绍许多WatchKit方面


133
00:07:39,226 --> 00:07:42,763
比如有关设计的整个过程和动画技术


134
00:07:43,030 --> 00:07:44,331
所以您可以对此进行了解


135
00:07:45,065 --> 00:07:46,767
有一些不能显示的很清楚的部分


136
00:07:46,834 --> 00:07:49,336
和使用这些API时一些很酷的手法


137
00:07:49,703 --> 00:07:51,038
可以带来很好的效果


138
00:07:51,338 --> 00:07:53,907
因此如果你进行更多了解
会发现它们也是很出色的部分


139
00:07:55,342 --> 00:07:57,010
下面 让我们介绍Taptic引擎


140
00:07:57,611 --> 00:08:00,647
这是Apple Watch
又一项独特的性能


141
00:08:00,848 --> 00:08:05,752
使信息传达到用户
而不用用户真的在屏幕中读取出来


142
00:08:06,053 --> 00:08:06,920
这个功能真的很棒


143
00:08:07,154 --> 00:08:08,989
Taptic引擎的
一个很棒的特点就是


144
00:08:09,056 --> 00:08:13,794
可以通过用户触觉掌握用户感受和声音


145
00:08:14,094 --> 00:08:17,030
以及在app环境下的意义


146
00:08:17,631 --> 00:08:23,637
我们推出一个简洁的API
方便您在工作交互设备上使用触觉技术


147
00:08:23,837 --> 00:08:25,973
有不同的模式可供选择


148
00:08:26,473 --> 00:08:29,343
我所提到的每一个模式


149
00:08:29,409 --> 00:08:31,945
都有预期使用环境
您的用户会了解这一模式


150
00:08:32,145 --> 00:08:35,883
因为这一性能的目的就是传递信息
而不用真的读取屏幕


151
00:08:36,316 --> 00:08:38,485
你会需要确保不断使用这一功能


152
00:08:38,784 --> 00:08:42,089
这些模式的命名就是为了帮助你
了解他们所使用的情况


153
00:08:42,489 --> 00:08:46,026
我们在说明文件中准备了相关文件


154
00:08:46,226 --> 00:08:49,429
深度介绍每一个模式在设计Apple
Watch中有的预期使用环境


155
00:08:49,863 --> 00:08:52,499
所以如果你想在开发应用中
使用触觉技术并持续使用


156
00:08:52,833 --> 00:08:54,401
请继续了解此功能


157
00:08:54,468 --> 00:08:58,205
最终达到用户可以直接了解程序运行
而不用读取屏幕


158
00:09:01,074 --> 00:09:05,479
此外还有一些其他硬件
我们想要在WatchKit中应用


159
00:09:05,979 --> 00:09:07,481
第一 是麦克风


160
00:09:08,382 --> 00:09:10,284
我们在watchOS 2中
采用新的API


161
00:09:10,551 --> 00:09:12,286
从而方便您采用录音表


162
00:09:12,753 --> 00:09:18,325
录制记录音频
在用户进行处理之前回放


163
00:09:18,692 --> 00:09:21,528
最后通过按下右上角的按键
对音频进行最终处理


164
00:09:23,197 --> 00:09:28,569
因此右上角的按键
可以根据您的应用来命名


165
00:09:28,936 --> 00:09:31,839
在此环境下我将它命名为“发送”
因为我预设它会发送一条消息


166
00:09:32,206 --> 00:09:35,275
但你也可以将它命名为“保存”
如果你开发的是语音备忘录一类应用


167
00:09:36,710 --> 00:09:40,514
它操作十分简单
先录制成文件 用户点击确认键时


168
00:09:40,747 --> 00:09:41,949
你会收到一个文件 以便处理


169
00:09:42,216 --> 00:09:45,185
任何的方式对于你的应用都是合适的


170
00:09:46,520 --> 00:09:50,023
当然 除了麦克风
我们也想要开发扬声器的功能


171
00:09:50,724 --> 00:09:55,128
我们通过为您的应用提供
回放视频音频内容


172
00:09:55,863 --> 00:09:58,632
有三种API
用不同的方式实现这一操作


173
00:09:59,299 --> 00:10:03,270
第一种是新的交互对象
叫做工作交互影片


174
00:10:03,971 --> 00:10:06,807
这一元素提供标准的外观


175
00:10:07,207 --> 00:10:11,044
方便视频文件播放以及重放


176
00:10:11,712 --> 00:10:13,514
在屏幕上这个案例中我准备了两个视频


177
00:10:13,847 --> 00:10:15,048
假设现有一个海报形象


178
00:10:15,415 --> 00:10:17,451
全球资源定位器可以定位你的内容


179
00:10:17,784 --> 00:10:19,186
WatchKit操作为你重放


180
00:10:19,653 --> 00:10:23,190
如果你已经将内容输入到手表中
这个全球资源定位器可以是本地文件


181
00:10:23,390 --> 00:10:26,627
如果不是本地文件
则使用远程HTTP URL


182
00:10:27,094 --> 00:10:28,862
如果提供一个远程资源


183
00:10:29,129 --> 00:10:33,967
WatchKit可以下载 显示进程
并在下载完成后立即播放


184
00:10:34,468 --> 00:10:36,904
如果是本地文件
可以很快进行重放


185
00:10:38,272 --> 00:10:39,907
当用户点击播放键


186
00:10:40,140 --> 00:10:45,746
则可以看到优质的全屏播放的视频
以及全屏视频回放


187
00:10:46,079 --> 00:10:50,951
回放控制将在简要浏览全部内容后
立即淡出


188
00:10:53,787 --> 00:10:57,558
此外 如果你想要用其他方式回放
而不采用标准界面


189
00:10:57,758 --> 00:11:01,962
也有一个API可
直接从其他界面呈现控制器


190
00:11:04,598 --> 00:11:07,234
这些API可以播放视频音频内容


191
00:11:07,568 --> 00:11:10,037
且十分适用于回放小型文件


192
00:11:10,404 --> 00:11:12,773
Apple Watch
被设计为简短的互动


193
00:11:13,140 --> 00:11:17,077
7所以在这里播放的
最好是不太长的东西


194
00:11:17,277 --> 00:11:19,379
你也许不想以这种方式


195
00:11:19,713 --> 00:11:21,815
在Apple Watch上
播放两个小时的电影


196
00:11:21,915 --> 00:11:26,854
有时你想播放的音频类型
内容很长


197
00:11:27,287 --> 00:11:30,023
如果你正在编写类似播客的app


198
00:11:30,257 --> 00:11:32,192
你也许想要下载一些播客


199
00:11:32,392 --> 00:11:35,195
然后运行一下
在你的蓝牙耳机上听一听


200
00:11:35,696 --> 00:11:40,100
我们有另外一个API
对于播放这类较长形式的音频确实不错


201
00:11:40,834 --> 00:11:44,371
如果你熟悉AV基础的API
你就知道如何使用这些


202
00:11:44,438 --> 00:11:45,606
因为它们非常相似


203
00:11:46,473 --> 00:11:51,111
你也许从iOS了解到这与以AV为基
础的API之间唯一的不同是


204
00:11:51,278 --> 00:11:58,185
为了使应用程序获得真正的高性能
和更大的电池使用


205
00:11:58,585 --> 00:12:03,123
它不要求你的应用程序
为了播放那个音频而持续在后台运转


206
00:12:03,524 --> 00:12:05,926
该文件可以被切换到系统来播放


207
00:12:05,993 --> 00:12:08,228
即使你的应用程序被悬置没有运行


208
00:12:08,829 --> 00:12:11,565
如果用户在外奔跑时查看表盘


209
00:12:12,866 --> 00:12:14,668
它们可以提供正在播放的信息


210
00:12:14,868 --> 00:12:17,604
并且控制来自你应用程序的音频播放


211
00:12:17,738 --> 00:12:19,173
即使你的应用程序没有在运行


212
00:12:22,409 --> 00:12:27,447
我想在这里快速地谈一下
还有几个其他与硬件无关的API


213
00:12:28,182 --> 00:12:29,750
第一个是提醒


214
00:12:30,284 --> 00:12:34,221
我再重复一次Apple Watch
是为简短的互动而设计的


215
00:12:34,655 --> 00:12:38,525
因此你也许真的要小心
不要过度使用这种API


216
00:12:38,592 --> 00:12:43,530
因为它确实将额外的步骤引入了
你的应用程序中的一些工作流程中


217
00:12:44,097 --> 00:12:48,135
有时候你只需要在获得回答前
问用户一个问题即可


218
00:12:48,468 --> 00:12:50,470
对于那些情况
我们有提醒API


219
00:12:50,537 --> 00:12:53,607
向你提供这种类UI
的统一外观


220
00:12:54,441 --> 00:12:55,909
你提供一个标题 一个描写


221
00:12:56,243 --> 00:12:59,513
块中应该采取的按钮列表和动作


222
00:13:00,180 --> 00:13:01,081
它们只是被显示出来


223
00:13:01,148 --> 00:13:03,417
当用户点击它们中的一个时
你就会获得回调


224
00:13:03,750 --> 00:13:07,454
在这种情况下
我包含了一个破坏按钮


225
00:13:07,521 --> 00:13:09,990
明确说明当我点击这里的删除
破坏的事情就会发生


226
00:13:13,193 --> 00:13:15,896
我们有个非常不错的
开放系统URL API


227
00:13:16,096 --> 00:13:17,798
它允许做许多新的事情


228
00:13:18,198 --> 00:13:20,601
开放系统URL可以采用另外的URL


229
00:13:20,767 --> 00:13:26,940
并发送给用户一个小型应用程序
使其发送信息给app中已有的接受者


230
00:13:28,275 --> 00:13:30,777
更酷的是你可以传递来自
始于Apple Watch的


231
00:13:30,978 --> 00:13:34,882
电话呼叫应用程序
tel URL


232
00:13:35,649 --> 00:13:36,483
当那个发生的时候


233
00:13:36,550 --> 00:13:38,852
通话中的UI就会出现在你的app中


234
00:13:39,186 --> 00:13:41,688
用户可以打电话
他们只要一挂机


235
00:13:41,922 --> 00:13:45,225
他们立刻就能回到他们开始打电话时
离开的app界面


236
00:13:48,962 --> 00:13:51,798
我们还对票据进行集成-票据工具箱


237
00:13:52,432 --> 00:13:56,103
实际上
票据工具箱是手表操作系统的一部分


238
00:13:56,803 --> 00:14:01,141
这样你就能够访问
在iPhone上可能具有的票据


239
00:14:01,275 --> 00:14:03,677
票据库与iPhone
Apple Watch是同步的


240
00:14:03,744 --> 00:14:04,678
这样你能同时获得


241
00:14:05,345 --> 00:14:07,681
更不错的是
WatchiKit有个API


242
00:14:07,748 --> 00:14:09,750
允许你添加票据到票据库中


243
00:14:10,117 --> 00:14:13,720
你以这样的方式将PK票据
交给WatchKit API


244
00:14:14,188 --> 00:14:17,691
用户能够滚动它
来查看那个票据中有什么


245
00:14:17,925 --> 00:14:20,928
一直到最后有个添加按钮
将它添加到库中


246
00:14:21,695 --> 00:14:22,529
当他们点击那个时


247
00:14:22,596 --> 00:14:23,997
它就会被添加到
Apple Watch库中


248
00:14:24,064 --> 00:14:27,935
但是也在iPhone
及其它通过云端服务同步的设备中


249
00:14:28,802 --> 00:14:32,773
因此从输入一直到后来票据的使用


250
00:14:32,840 --> 00:14:35,676
所有的端到端的票据情况
都在Apple Watch上


251
00:14:38,846 --> 00:14:42,082
这就是WatchKit的新性能
那里还有许多新奇的东西


252
00:14:42,783 --> 00:14:47,154
正如我所说过的WatchKit只是
整个的手表操作系统STK的一部分


253
00:14:47,621 --> 00:14:49,056
还有其他的框架


254
00:14:49,156 --> 00:14:54,161
一些是新的
一些是已有的并添加了新功能


255
00:14:54,962 --> 00:14:57,231
我现在就要谈谈其他的几个


256
00:14:57,464 --> 00:15:00,067
先说两个对WatchOS
很特别的特性


257
00:15:00,934 --> 00:15:02,970
第一个是Clock Kit


258
00:15:05,339 --> 00:15:08,742
Clock Kit是不需要构建信息


259
00:15:08,809 --> 00:15:12,579
直接在表盘上显示的框架


260
00:15:12,846 --> 00:15:16,116
它可以迅速地将你的数据
放在用户的面前


261
00:15:19,052 --> 00:15:20,821
信息有几种模式


262
00:15:21,121 --> 00:15:22,789
但Clock Kit支持所有的模式


263
00:15:22,990 --> 00:15:26,393
让我们来仔细查看表盘
来看看它是什么样子的


264
00:15:27,194 --> 00:15:29,496
这里是我们的实用表盘


265
00:15:29,563 --> 00:15:32,432
现在表盘上能看到
有三种不同的信息特性


266
00:15:32,833 --> 00:15:37,871
你可以看到有不同的尺寸
和形状的信息特性


267
00:15:38,172 --> 00:15:44,411
为了显示信息 Clock Kit
以恰当的方式格式化数据


268
00:15:45,078 --> 00:15:47,214
例如 如果我们看彩色的表盘


269
00:15:47,481 --> 00:15:49,650
这个有着更宽尺寸的信息特性


270
00:15:49,716 --> 00:15:53,620
且更高些可显示两行的文本或图像


271
00:15:54,588 --> 00:15:56,657
最后 在数字模块表盘上


272
00:15:56,723 --> 00:16:00,160
我们将最大的信息放在正中央
其他的放在边缘上


273
00:16:00,527 --> 00:16:03,163
Clock Kit提供了
一些非常好的API


274
00:16:03,297 --> 00:16:07,768
让你以多种不同模板来格式化你的数据
并满足不同的外观需求


275
00:16:08,101 --> 00:16:14,708
使它能针对不同大小的信息进行调节
来显示合适的数据数量


276
00:16:16,743 --> 00:16:18,745
现在有关信息的另一个重要特性是


277
00:16:18,979 --> 00:16:20,714
它们正好在你的表盘上


278
00:16:21,081 --> 00:16:23,884
这就意味着每次用户举起手腕看表


279
00:16:24,051 --> 00:16:26,687
他们想要立即看到最新的数据


280
00:16:27,421 --> 00:16:32,459
如果每次都要用户举起手腕询问代码
来提供要显示的当前数值


281
00:16:32,793 --> 00:16:33,861
我们就已经失败了


282
00:16:34,361 --> 00:16:38,699
在用户举起他们的手腕之前
信息需要立即在那儿


283
00:16:39,166 --> 00:16:40,400
为了实现这个目标


284
00:16:40,667 --> 00:16:44,471
你以时间轴的形式向ClockKit
提供应用程序数据


285
00:16:45,272 --> 00:16:48,242
在这种情况下
我以这里的信息和时间轴的形式


286
00:16:48,642 --> 00:16:50,577
向WWDC提供应用程序数据


287
00:16:51,178 --> 00:16:52,713
如果是上午10:00


288
00:16:53,113 --> 00:16:54,314
它将显示的早晨的主题


289
00:16:54,581 --> 00:16:57,217
表明当前正在召开会议


290
00:16:58,685 --> 00:17:01,922
随着一天的流逝
现在到2:00


291
00:17:02,155 --> 00:17:03,290
因为它已经有了数据


292
00:17:03,423 --> 00:17:06,492
所以ClockKit选择
那个时间点合适的事情


293
00:17:06,760 --> 00:17:08,595
它会移动到国情咨询平台


294
00:17:09,162 --> 00:17:11,598
移动到4:00
苹果设计奖励


295
00:17:12,398 --> 00:17:15,435
这种格式的了不起的地方是


296
00:17:15,502 --> 00:17:20,674
你整天都可获得自动的行为
不需要代码一直在运行


297
00:17:21,074 --> 00:17:25,311
但是你可以参与时空之旅
而不需要你费任何事


298
00:17:25,811 --> 00:17:30,217
如果用户将数字表冠向后移动
想看看这一天的早些时候都发生了什么


299
00:17:30,651 --> 00:17:34,988
Clock Kit就会转换到显示
那一时刻的合适的数据段


300
00:17:35,789 --> 00:17:42,229
这很容易为信息添加支持
也很有效地将数据放在用户面前


301
00:17:43,830 --> 00:17:44,965
这就是Clock Kit


302
00:17:45,032 --> 00:17:49,403
有一个全程的讲座
将会对此详细地进行说明及相关API


303
00:17:49,636 --> 00:17:52,739
和不同的模板
甚至你起始要做的一切东西


304
00:17:53,040 --> 00:17:55,409
离开时请领取
一本名叫用Clock Kit的书


305
00:17:57,811 --> 00:17:59,613
下来我想说的是连网


306
00:18:01,114 --> 00:18:03,483
在Apple Watch和
IPhone上


307
00:18:03,550 --> 00:18:07,087
有代码运行连网是很重要的内容


308
00:18:09,089 --> 00:18:12,125
有两种连网也许你想要在app中使用


309
00:18:12,459 --> 00:18:16,363
第一个
你也许要有较宽的因特网


310
00:18:17,764 --> 00:18:23,904
当你处于独立模式或手表和手机在相同
的地方使用NSURL对话API时


311
00:18:23,971 --> 00:18:26,340
你可以使用这种连网方式


312
00:18:27,608 --> 00:18:32,613
它会根据用户使用手机的方式


313
00:18:33,013 --> 00:18:37,384
包括手机检测并连接Wi-Fi的方式
以最佳的方式连接到网络


314
00:18:40,287 --> 00:18:42,556
有个全程的讲座都
将讨论NSURL连网


315
00:18:42,823 --> 00:18:45,292
NSURL连网将会单独讲解


316
00:18:46,426 --> 00:18:51,598
点击因特网上的任何服务器
都可以下载数据


317
00:18:51,865 --> 00:18:55,035
如果你曾使用过iOS
它们是相同的API


318
00:18:55,536 --> 00:18:58,672
且还具有相同的特性设置
包括后台下载


319
00:19:00,807 --> 00:19:06,079
有时你想在Apple Watch和
iPhone上运行代码


320
00:19:06,313 --> 00:19:08,649
你想让它们分享数据并且彼此对话


321
00:19:09,583 --> 00:19:13,654
我们为WatchOS和iOS提供了
崭新的框架


322
00:19:13,720 --> 00:19:14,888
叫做手表连通性


323
00:19:15,189 --> 00:19:16,623
它允许你来做那样的事情


324
00:19:16,823 --> 00:19:20,360
你的iPhone可以连通正在
iPhone上运行的代码


325
00:19:20,527 --> 00:19:23,330
同时你的手表可以连通正在
手表上运行的代码


326
00:19:26,400 --> 00:19:32,105
比如当你想要从因特网上下载数据


327
00:19:33,040 --> 00:19:37,044
构建一个天气应用程序
去下载当前的天气信息


328
00:19:37,744 --> 00:19:39,746
我们可以说
你的用户拿起他们的iPhone


329
00:19:39,980 --> 00:19:40,981
并且启动了该应用程序


330
00:19:41,148 --> 00:19:45,118
你来到因特网获取最新的天气
并将它显示在他们的iPhone上


331
00:19:45,786 --> 00:19:47,354
如果你没有做其它的任何事


332
00:19:47,521 --> 00:19:49,790
你构建手表应用程序
来做相同的事情


333
00:19:50,157 --> 00:19:52,192
下次他们看到手表上的应用程序


334
00:19:52,359 --> 00:19:55,429
来到网络上下载最新的数据
并将它显示在那儿


335
00:19:56,430 --> 00:19:59,233
但是那不是我们能做的最好的做法
我们肯定可以做得更好


336
00:19:59,433 --> 00:20:03,370
因为我们有刚从iPhone获得的数
据 它现在在用户的口袋中


337
00:20:04,238 --> 00:20:10,611
如果我们能充分利用已经下载的数据
并在我们设备中的多次使用


338
00:20:10,677 --> 00:20:12,145
那就太好了


339
00:20:13,113 --> 00:20:15,148
为达到这个目的
可以做类似这样的事情


340
00:20:15,649 --> 00:20:17,484
用户将数据下载
在他们的iPhone上


341
00:20:17,551 --> 00:20:20,921
你将它转移并保存在手表上


342
00:20:21,088 --> 00:20:24,224
因此如果用户看到手表上的应用程序


343
00:20:24,458 --> 00:20:28,495
数据已经在那儿且不需要再次下载


344
00:20:29,196 --> 00:20:32,533
当然 你仍然可以下载最近的更新版本


345
00:20:32,666 --> 00:20:36,403
如果你知道天气数据是
每小时更新一次


346
00:20:36,603 --> 00:20:39,039
你可能已经获得了最新的数据
那就不需要这样做了


347
00:20:39,406 --> 00:20:43,744
你现在就有更新的东西
可以立即显示


348
00:20:44,978 --> 00:20:47,714
手表连通性就提供了这个功能


349
00:20:48,282 --> 00:20:51,185
有两个提供后台下载的API


350
00:20:51,385 --> 00:20:52,853
第一个叫做应用程序语境


351
00:20:53,086 --> 00:20:58,091
你将它做的一切都
移交到一个数据字典中


352
00:20:58,358 --> 00:21:02,196
你希望每当再次运行在另一侧的应用程
序时 都可以获得该数据


353
00:21:02,596 --> 00:21:04,998
它总是获得最新的数据版本


354
00:21:05,199 --> 00:21:07,234
所以你只是设置为无论如何都是当前的


355
00:21:07,434 --> 00:21:10,304
下次你的应用程序运行的时候
就可以在那里得到


356
00:21:11,071 --> 00:21:16,777
在幕后 手表连通性在能量
和性能最佳的时机传输数据


357
00:21:18,212 --> 00:21:22,282
还有个文件传输API
如果你有较大的数据


358
00:21:22,549 --> 00:21:26,720
你可以将更多的数据从的iPhone
传输到你的手表 反之亦然


359
00:21:27,154 --> 00:21:31,358
同样的 它会在后台
能量和性能的最佳时机完成


360
00:21:32,860 --> 00:21:37,130
还有时你还需要在两侧
互动消息传递


361
00:21:37,764 --> 00:21:41,401
如果你的手表应用程序将要在
你的iPhone上启动一些操作


362
00:21:41,635 --> 00:21:43,170
你也许想要发送一个消息过去


363
00:21:43,670 --> 00:21:46,540
在这个例子中
我在手表上有个去按钮


364
00:21:46,874 --> 00:21:49,443
当我点击它的时候
我想给iPhone发送一个消息


365
00:21:50,577 --> 00:21:55,315
下来要发生的就是
若应用程序已在iPhone后台运行


366
00:21:55,549 --> 00:21:56,717
消息就会被转发


367
00:21:56,783 --> 00:22:01,555
这样你就可以做类似开始一个会话
或在iPhone上进行一些活动


368
00:22:02,623 --> 00:22:05,859
现在我提到这些API在两侧都存在
它们是双向的


369
00:22:06,193 --> 00:22:08,128
应用程序语境可以到达两个方向


370
00:22:08,562 --> 00:22:11,498
文件传输API
可以在两个方向传输文件


371
00:22:11,999 --> 00:22:14,368
一个不同之处是在发送消息API


372
00:22:14,801 --> 00:22:16,837
当从手表到iPhone发送消息时


373
00:22:16,904 --> 00:22:20,340
可以唤醒iPhone后台的应用程序
进行一些活动


374
00:22:20,841 --> 00:22:23,577
但是当从iPhone到手表的时候


375
00:22:23,744 --> 00:22:25,512
它就不会唤醒后台的手表


376
00:22:25,579 --> 00:22:29,650
你的app在手表上运行的目的
就是为了接受来自iPhone的消息


377
00:22:31,952 --> 00:22:34,755
在这些API中还有很多细节需要注意


378
00:22:34,821 --> 00:22:38,025
还有一个完整的讲座讲的是这些东西
这个讲座的名字是介绍手表的连接性


379
00:22:38,091 --> 00:22:39,393
所以你需要看一下


380
00:22:39,593 --> 00:22:45,199
并学习一下如何将后端从只能在一个
设备上运行


381
00:22:45,766 --> 00:22:48,902
变成同时在iPhone
和Apple Watch运行


382
00:22:51,805 --> 00:22:54,474
所以这些就是那三个新的构架


383
00:22:54,808 --> 00:22:57,344
对于WatchOS来讲
是全新并且独有的


384
00:22:57,878 --> 00:23:00,480
现存的IOS上有很多框架


385
00:23:00,714 --> 00:23:02,783
你已经熟悉了在你的app中使用它们


386
00:23:03,150 --> 00:23:07,921
我们在Apple Watch上添加
了一些新功能或者说加强了独有的功能


387
00:23:08,555 --> 00:23:10,457
我现在想要概述一下这些功能


388
00:23:11,091 --> 00:23:13,026
第一个是Core Motion


389
00:23:13,760 --> 00:23:20,133
正如你所知 Core Motion
可以让你访问IOS设备的运动传感器


390
00:23:20,634 --> 00:23:22,369
WatchOS中同样存在


391
00:23:22,436 --> 00:23:24,171
可以让你能够访问加速度计


392
00:23:24,972 --> 00:23:26,907
和在IOS上一样
在WatchOS上


393
00:23:26,974 --> 00:23:30,611
Core Motion
给你程序运行的实时数据


394
00:23:31,411 --> 00:23:35,315
但对于Apple Watch来讲
这是新的而且很赞的是


395
00:23:35,649 --> 00:23:42,189
它可以在程序中记录运动数据
即使它不是以一个较低的刷新速率运行


396
00:23:42,456 --> 00:23:46,627
然后将加速度计的数据批量发送给你
在下次你的应用程序运行的时候


397
00:23:47,561 --> 00:23:50,531
这在你的APP没有运行的时候


398
00:23:50,831 --> 00:23:52,466
是一种很酷地检测运动数据的方法


399
00:23:53,467 --> 00:23:56,403
关于这有一个完整的讲座
叫做Core Motion的新功能


400
00:23:56,603 --> 00:23:57,871
所以你一定要去看一下


401
00:23:59,173 --> 00:24:02,009
另外Core Location
是WatchOS的一部分


402
00:24:02,376 --> 00:24:06,180
这是寻找用户新位置的很棒的方法


403
00:24:06,613 --> 00:24:10,317
现在iOS 9和watchOS
2有个新的API


404
00:24:10,584 --> 00:24:15,355
就可以非常简单地实现一些很赞的事情


405
00:24:17,157 --> 00:24:20,194
现在另一件需要注意的是


406
00:24:20,527 --> 00:24:23,630
WatchOS上
CoreLocation的位置信息


407
00:24:23,697 --> 00:24:26,633
可以授权在iPhone上
运行的IOS APP


408
00:24:26,800 --> 00:24:29,336
和Apple Watch上的
WatchOS APP之间共享


409
00:24:29,937 --> 00:24:32,472
众所周知 当你使用
Core Location的时候


410
00:24:32,539 --> 00:24:37,144
在app进行定位之前
要请求用户进行位置授权


411
00:24:37,578 --> 00:24:39,246
在Apple Watch上也是这样


412
00:24:39,880 --> 00:24:44,418
当用户允许了iPhone
或者Watch上的授权


413
00:24:44,484 --> 00:24:46,453
它会同时提供给
IPhone和Watch


414
00:24:46,753 --> 00:24:48,455
所以他们不需要对这个问题回答两次


415
00:24:48,789 --> 00:24:51,758
有一个办法可以管理
用户的这种授权


416
00:24:54,127 --> 00:24:55,796
有一完整的讲座介绍了
Core Location


417
00:24:55,863 --> 00:24:57,331
叫做Core Location
的新功能


418
00:24:57,397 --> 00:24:58,765
很多东西都能在那里找到


419
00:25:00,567 --> 00:25:01,869
接下来是HealthKit


420
00:25:02,336 --> 00:25:04,705
HealthKit也是
WatchOS的一部分


421
00:25:04,771 --> 00:25:08,509
和你在IOS中使用的
是相同的API设置和相同的构架


422
00:25:09,376 --> 00:25:12,246
在WatchOS上使用
HealthKit的最大优点是


423
00:25:12,579 --> 00:25:16,817
有非常多的健康数据被记录在了手表上


424
00:25:17,084 --> 00:25:20,854
你现在可以访问更多最新的实时数据


425
00:25:20,921 --> 00:25:22,422
因为这都在手表其本身上


426
00:25:22,823 --> 00:25:25,526
你现在可以在产生那些数据的设备上
进行查看


427
00:25:26,760 --> 00:25:30,430
例如你可以看到实时的心率信息


428
00:25:30,697 --> 00:25:32,699
当它正在记录并存储
在HealthKit中


429
00:25:33,534 --> 00:25:35,702
HealthKit和WatchOS
的另一件很棒的事情是


430
00:25:35,769 --> 00:25:39,706
它为API提供了
提醒你开始锻炼的功能


431
00:25:40,507 --> 00:25:43,877
这些锻炼会话能够做很多这一类的事情


432
00:25:44,178 --> 00:25:48,348
Watch本身的锻炼app也能做


433
00:25:48,448 --> 00:25:53,453
例如如果你开始跑步
你想要记录用户的高频率心率数据


434
00:25:53,620 --> 00:25:55,822
可以使用HealthKit API
打开那个会话


435
00:25:55,889 --> 00:26:00,627
选择记录高频率的心率数据信息


436
00:26:01,895 --> 00:26:05,599
使用这个API中健身应用的
另一个很棒的事情是


437
00:26:06,133 --> 00:26:12,639
每当用户举起手腕使用的时候
它允许程序继续回前台


438
00:26:13,106 --> 00:26:17,411
如果你在写一个骑行APP
用户开始一个骑行会话


439
00:26:17,911 --> 00:26:19,213
每次他们举起手腕的时候


440
00:26:19,279 --> 00:26:21,582
在会话中他们能够通过app
查看最新的实时的数据


441
00:26:21,782 --> 00:26:26,753
并看到自己在运动的时候表现的怎么样


442
00:26:28,322 --> 00:26:32,426
现在当用户放下手腕
屏幕关闭的时候 应用程序被暂停


443
00:26:33,060 --> 00:26:36,864
但是HealthKit将
默默地为你记录所有的数据


444
00:26:37,097 --> 00:26:39,633
所以当用户举起手腕
能够再次运行起来


445
00:26:39,833 --> 00:26:43,770
app被暂停时的数据得到了更新


446
00:26:45,239 --> 00:26:51,678
这提供了一种很棒的方法
实现所有数据的统一


447
00:26:51,912 --> 00:26:54,381
并为用户提供优秀的用户体验


448
00:26:56,583 --> 00:26:59,386
也有一个完整的讲座
叫做HealthKit的新功能


449
00:26:59,753 --> 00:27:02,623
如果你正在写一个锻炼类型的app


450
00:27:03,090 --> 00:27:05,492
或者任何可能使用
Health Kit数据优点的程序


451
00:27:06,927 --> 00:27:09,496
我也想花一点时间讲一下
关于安全构架的问题


452
00:27:09,563 --> 00:27:12,499
这也许不是最令人兴奋的消磨时间方法


453
00:27:13,033 --> 00:27:14,801
但是请相信我
这里有非常重要的东西


454
00:27:15,969 --> 00:27:19,273
如果你使用过IOS的安全构架


455
00:27:19,706 --> 00:27:23,043
你就会知道它允许你
访问Keychain


456
00:27:24,278 --> 00:27:26,780
Apple Watch上的
Keychain非常有意思


457
00:27:26,914 --> 00:27:29,183
Apple Watch独一无二的是


458
00:27:29,349 --> 00:27:32,553
当它在用户的手腕上的时候
它会保持开启


459
00:27:33,220 --> 00:27:35,122
一旦当用户摘掉手表


460
00:27:35,756 --> 00:27:37,324
这个设备就会马上锁定


461
00:27:38,392 --> 00:27:39,760
你可以利用这一点


462
00:27:40,027 --> 00:27:44,932
在Keychain中存储
你的凭据和安全数据


463
00:27:46,466 --> 00:27:47,301
这样可以保证


464
00:27:47,367 --> 00:27:51,638
当手表在用户的手腕上的时候
你能够访问数据


465
00:27:52,172 --> 00:27:56,643
一旦手表被取下来
数据将不能够被访问因为手表被锁定了


466
00:28:00,214 --> 00:28:01,048
谢谢


467
00:28:03,984 --> 00:28:05,185
他感到非常兴奋


468
00:28:08,322 --> 00:28:09,790
好吧
这就是安全部分


469
00:28:11,258 --> 00:28:12,259
接下来是MapKit


470
00:28:13,861 --> 00:28:18,599
有一个MapKit API子集可以
作为WatchOS STK的一部分


471
00:28:18,832 --> 00:28:21,168
特别是MK Map API


472
00:28:21,802 --> 00:28:22,769
它很酷的方面是


473
00:28:22,836 --> 00:28:27,241
你可以从你的应用程序中
发送一个定位到地图APP


474
00:28:27,474 --> 00:28:30,010
可以让用户在完整的地图应用中查看


475
00:28:30,611 --> 00:28:35,916
他们不仅能够查看
还能够开始导航并在APP中寻找路线


476
00:28:36,483 --> 00:28:40,521
如果你有一个位置
并且想使用户能够找到直接到那里


477
00:28:40,854 --> 00:28:42,389
你可以在Apple Watch
和iPhone上


478
00:28:42,456 --> 00:28:45,292
使用MapKit API开始导航


479
00:28:45,459 --> 00:28:48,262
向用户发送导航信息


480
00:28:50,163 --> 00:28:51,765
同样有一个关于MapKit的讲座


481
00:28:51,832 --> 00:28:54,268
叫做MapKit的新功能
你可以了解到所有信息


482
00:28:55,936 --> 00:28:57,938
最后两个我想要讲的构架是


483
00:28:58,005 --> 00:29:01,642
都是关于访问
Apple Watch上数据的


484
00:29:02,042 --> 00:29:04,077
在Apple
Watch上的用户数据类型


485
00:29:04,478 --> 00:29:07,047
我们已经进行了同步处理


486
00:29:08,615 --> 00:29:10,350
第一个是联系构架


487
00:29:11,385 --> 00:29:15,289
在IOS 9和WatchOS 2中
联系是一个全新的构架


488
00:29:15,722 --> 00:29:19,927
可以让你访问
Apple Watch中的通讯簿


489
00:29:19,993 --> 00:29:23,397
因为在我们的应用程序中使用了
所以它已经同步了


490
00:29:23,597 --> 00:29:27,134
你不需要传输就可以访问本地数据


491
00:29:28,035 --> 00:29:29,803
有一个讲座讲了这个全新的构架


492
00:29:30,137 --> 00:29:33,040
叫做iOS和OS 10的联系架构


493
00:29:33,340 --> 00:29:36,243
如果你准备使用联系信息的话
就应该查看一下


494
00:29:36,844 --> 00:29:38,579
就像Core Location一样


495
00:29:38,846 --> 00:29:41,682
访问IOS APP
和WatchOS APP的


496
00:29:41,748 --> 00:29:44,785
共享通讯簿数据需要用户的授权


497
00:29:45,452 --> 00:29:49,423
当用户授权你访问通讯簿


498
00:29:49,656 --> 00:29:51,091
你在任何一边都有访问的授权


499
00:29:51,391 --> 00:29:56,964
在Apple Watch和
iPhone上都有个管理授权信息


500
00:29:59,099 --> 00:30:00,868
最后一个是EventKit


501
00:30:01,168 --> 00:30:03,704
EventKit是用作
访问用户日历的


502
00:30:04,638 --> 00:30:08,675
这和我们讲过的联系构架上
有很多相同点


503
00:30:09,076 --> 00:30:10,944
一旦你得到访问它的授权


504
00:30:11,311 --> 00:30:14,114
对于iPhone APP
和Watch APP来讲是相同的


505
00:30:16,817 --> 00:30:20,487
所以在WatchOS 2中
有非常多的东西


506
00:30:21,688 --> 00:30:23,156
三个全新的构架


507
00:30:23,891 --> 00:30:28,896
三个全新的构架
WatchKit 手表连接


508
00:30:34,568 --> 00:30:35,869
还有Clock Kit
谢谢


509
00:30:42,709 --> 00:30:45,279
WatchOS独有的三个全新的构架


510
00:30:45,979 --> 00:30:51,051
在所有的其他构架中
有很多新功能是WatchOS特有的


511
00:30:51,351 --> 00:30:54,688
有一些是在你的App之间共享的


512
00:30:55,689 --> 00:31:02,129
当你在一个平台上学习并将其运用到其
他平台上的app时有大量的工作要做


513
00:31:02,396 --> 00:31:05,499
其他的框架能够利用
Watch独有的功能


514
00:31:06,466 --> 00:31:10,070
这一周有非常多的讲座
可以在其他地方学到更多东西


515
00:31:10,704 --> 00:31:12,840
在文档中有一个过渡指南


516
00:31:12,906 --> 00:31:14,541
WatchKit过渡指南


517
00:31:14,808 --> 00:31:18,545
将帮你学习支持
WatchOS1的WatchKit


518
00:31:18,745 --> 00:31:23,350
升级后支持在WatchOS 2上
运行作为手表本身的本地程序运行


519
00:31:24,484 --> 00:31:27,454
有非常多的实例代码和开发者论坛


520
00:31:27,521 --> 00:31:31,658
技术支撑是最好的解决所有问题的去处


521
00:31:32,025 --> 00:31:33,560
这就是WatchKit的新东西


522
00:31:33,627 --> 00:31:35,162
感谢您今早的到来


523
00:31:35,395 --> 00:31:39,166
我非常期待你们
使用这些东西能做出来什么

