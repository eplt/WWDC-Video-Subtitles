1
00:00:32,466 --> 00:00:33,567
伍迪·李德斯东：
大家好


2
00:00:34,301 --> 00:00:38,305
今天早些时候我对斯特凡说
我希望有人能来


3
00:00:38,906 --> 00:00:40,841
太不可思议你把这里都包了


4
00:00:40,908 --> 00:00:41,975
感谢你能出来


5
00:00:42,042 --> 00:00:44,011
我是伍迪
很高兴给大家讲讲


6
00:00:44,077 --> 00:00:46,413
用Swift改进现有的App


7
00:00:47,748 --> 00:00:48,715
大家能不能举一下手


8
00:00:48,782 --> 00:00:51,585
多少人实际上
在用Swift 进行编码？


9
00:00:53,520 --> 00:00:54,354
好的<c.blue> </c>很好


10
00:00:54,488 --> 00:00:55,756
那你们大家就 都来对了


11
00:00:56,423 --> 00:00:57,724
无论你是否用了都是如此


12
00:00:57,791 --> 00:00:59,860
希望在讲座后你可以用Swift


13
00:01:00,327 --> 00:01:02,229
打理现有的
Objective-C项目


14
00:01:03,630 --> 00:01:08,368
要知道 去年我也
我也在这屋里 坐在后面的角落 


15
00:01:08,635 --> 00:01:11,305
是个听众的身份还带着笔记本


16
00:01:11,371 --> 00:01:14,007
想试着实践一下


17
00:01:14,074 --> 00:01:16,677
我在之前讲座学到的新技术


18
00:01:17,044 --> 00:01:19,546
同时还在回复着工作邮件 
虽然我之前说过不会回复的


19
00:01:20,080 --> 00:01:23,183
同时把一半的心思放在发言人身上


20
00:01:23,250 --> 00:01:25,319
我相信在座的大部分现在也是这样


21
00:01:25,919 --> 00:01:30,757
然后 角色换位 我从台下听众


22
00:01:30,824 --> 00:01:31,859
走到了台前


23
00:01:31,925 --> 00:01:33,894
我从加拿大新斯科舍省哈利法克斯 


24
00:01:33,961 --> 00:01:37,397
来到了加利福尼亚


25
00:01:37,831 --> 00:01:41,235
如今来这里帮助大家学习使用


26
00:01:41,301 --> 00:01:43,570
Swift和Objective-C
的部分技术


27
00:01:46,773 --> 00:01:47,774
我就不必上前去翻动了


28
00:01:47,908 --> 00:01:49,209
这里有遥控


29
00:01:53,380 --> 00:01:56,617
我想来做的是


30
00:01:56,850 --> 00:02:01,088
介绍部分技术内容让大家可以
把Swift加到现有项目


31
00:02:01,154 --> 00:02:02,289
让项目变得更好


32
00:02:02,523 --> 00:02:04,825
本次讲座我就会用来


33
00:02:04,892 --> 00:02:06,426
介绍这样的内容


34
00:02:06,894 --> 00:02:10,264
我去过Infinite
Loop园区到了停车场


35
00:02:10,330 --> 00:02:12,999
来到下面一层的地下迷宫


36
00:02:13,333 --> 00:02:16,136
经过守卫工业设计入口的三头犬


37
00:02:16,203 --> 00:02:18,005
在尽头 是我们


38
00:02:18,071 --> 00:02:19,473
保存软件的保险库


39
00:02:19,540 --> 00:02:21,308
我打开软件保险库


40
00:02:21,375 --> 00:02:25,078
取出app<c.blue> </c>The 
Elements 这可能在两三年内


41
00:02:25,145 --> 00:02:26,547
都没在WWDC见到了


42
00:02:26,713 --> 00:02:28,849
现在我就将向
大家介绍它是怎么回事


43
00:02:30,784 --> 00:02:32,486
好的 这就是 
The Elements


44
00:02:32,686 --> 00:02:34,488
有谁还记得以前见过?


45
00:02:34,588 --> 00:02:36,423
啊? 有人见过 有人没有


46
00:02:36,623 --> 00:02:37,658
有人当真喜欢它


47
00:02:37,758 --> 00:02:38,592
我就是


48
00:02:40,127 --> 00:02:43,230
这是个标准的
基于UIKit的表视图app


49
00:02:43,830 --> 00:02:45,465
我们有一束单元格 针对


50
00:02:45,699 --> 00:02:47,768
针对原子表中的每个元素


51
00:02:47,935 --> 00:02:49,303
我们还有这个小的详细视图


52
00:02:49,369 --> 00:02:50,704
其中会有更多的信息


53
00:02:50,771 --> 00:02:52,439
如果点击一个单元格


54
00:02:53,106 --> 00:02:58,278
我们有这个导航控制器
推动演示显示部分相关细节


55
00:02:59,680 --> 00:03:00,747e
非常棒


56
00:02:59,680 --> 00:03:00,747
非常棒


57
00:03:08,755 --> 00:03:09,590
<c.blue> </c>我相信可能


58
00:03:09,656 --> 00:03:11,992
很多人都会这么做


59
00:03:12,059 --> 00:03:13,827
在不同的应用中移动


60
00:03:13,927 --> 00:03:15,462
并且回来再来看有一阵子


61
00:03:15,529 --> 00:03:17,431
没用的app 或是有一阵子
没编程的app 


62
00:03:17,497 --> 00:03:19,466
然后有人让你增添新的功能


63
00:03:19,533 --> 00:03:21,568
或是支持
新的操作系统 新的SDK


64
00:03:22,069 --> 00:03:23,737
这就是我们马上要做的事情


65
00:03:23,804 --> 00:03:27,007
我们会对Objective-C
app准备用Swift来实现现代化


66
00:03:28,876 --> 00:03:31,979
意思是说：如果有现有应用


67
00:03:32,546 --> 00:03:34,014
你必须要为它编写新代码


68
00:03:34,147 --> 00:03:36,517
而现有的应用是
Objective-C app


69
00:03:36,850 --> 00:03:40,988
考虑利用Swift功能
使用Swift来编写新代码


70
00:03:41,388 --> 00:03:42,556
与此同时


71
00:03:43,423 --> 00:03:46,560
把原始的Objective-C代码
留在Objective-C


72
00:03:46,793 --> 00:03:47,661
这也很好的


73
00:03:48,495 --> 00:03:52,633
在本讲座中 我们先从


74
00:03:52,866 --> 00:03:55,502
对应用的翻新讲起为用户界面


75
00:03:55,569 --> 00:03:57,304
带来更为现代的外观


76
00:03:57,538 --> 00:03:59,373
我们马上要做的是使用Swift


77
00:03:59,606 --> 00:04:02,643
之后 我们还要来看看代码


78
00:04:02,709 --> 00:04:06,146
Swift的结构及其函数
比如映射


79
00:04:06,213 --> 00:04:08,582
找到为应用增添新功能的办法


80
00:04:12,186 --> 00:04:15,789
这个应用有大小tile框架


81
00:04:15,923 --> 00:04:17,558
小tile框架是表视图


82
00:04:17,658 --> 00:04:18,992
大tile框架是详细视图


83
00:04:19,625 --> 00:04:22,095
这些tile框架包括背景


84
00:04:22,229 --> 00:04:24,798
外加在背景上渲染的文本


85
00:04:25,566 --> 00:04:27,301
因为这个app是个老版本app


86
00:04:27,768 --> 00:04:30,504
背景最初是用
Photoshop做的渲染


87
00:04:30,637 --> 00:04:32,573
然后嵌入到应用之中


88
00:04:33,207 --> 00:04:35,342
因为背景中的不同颜色取决于


89
00:04:35,475 --> 00:04:40,080
原子状态固体 液体 合成气体


90
00:04:40,614 --> 00:04:43,650
是仅为最初的iPhone做的渲染


91
00:04:43,717 --> 00:04:45,552
其中并不包括Retina艺术设计


92
00:04:45,652 --> 00:04:47,754
也就是说当我们拿到这个老版本app


93
00:04:47,821 --> 00:04:49,523
在新版本硬件上运行时
我们必须做扩展


94
00:04:50,224 --> 00:04:54,828
当我们扩展这个老版本艺术设计时


95
00:04:55,162 --> 00:04:57,364
我们最后是得到的是圆角失真效果 
就是锯齿


96
00:04:57,497 --> 00:05:00,033
因为没有足够的像素数据


97
00:05:00,133 --> 00:05:01,568
来光滑地表现这些角


98
00:05:01,835 --> 00:05:04,605
所以我们在
本次讲座中就会解决这个问题


99
00:05:06,440 --> 00:05:09,343
还有一个问题就是 当你看自己的


100
00:05:10,077 --> 00:05:11,645
中学纪念册时


101
00:05:12,045 --> 00:05:14,314
也许是80年代或90年代


102
00:05:14,381 --> 00:05:16,016
对吗？


103
00:05:16,083 --> 00:05:17,351
你看到了自己的照片


104
00:05:17,584 --> 00:05:19,820
你在这里穿着马甲


105
00:05:19,887 --> 00:05:22,656
还绣着小猫手里拿着键盘


106
00:05:22,723 --> 00:05:24,057
因为当时这样很酷


107
00:05:24,191 --> 00:05:25,826
背景还是激光效果


108
00:05:25,893 --> 00:05:26,894
因为这当初也很酷


109
00:05:26,960 --> 00:05:27,828
现在你再来看着它


110
00:05:27,895 --> 00:05:30,230
心里会想着
当时我脑子里在想什么呢？


111
00:05:34,968 --> 00:05:36,670
有时 我们看着以前的app心里会想


112
00:05:37,004 --> 00:05:38,438
当时我们脑子里是想什么呢？


113
00:05:38,505 --> 00:05:40,541
还有闪亮 光泽 反射效果


114
00:05:41,275 --> 00:05:43,277
我们这就来调整


115
00:05:43,510 --> 00:05:45,345
时尚潮流改变了
风格不一样了


116
00:05:45,412 --> 00:05:46,613
有一种办法是从


117
00:05:46,747 --> 00:05:50,918
背景上把光泽效果删除下去


118
00:05:52,653 --> 00:05:55,088
我们得到了非常时尚的
渲染矩形轮廓


119
00:05:55,622 --> 00:05:57,991
看似在小tile框架上效果不错


120
00:05:58,058 --> 00:05:59,893
就像是在app的大tile框架一样


121
00:05:59,960 --> 00:06:02,162
现在我们可以在
Photoshop渲染新 背景


122
00:06:02,262 --> 00:06:03,530
并把它们嵌入应用中


123
00:06:03,830 --> 00:06:05,365
不过要清楚这个应用我们


124
00:06:06,233 --> 00:06:07,467
不会经常使用


125
00:06:07,534 --> 00:06:10,938
要知道  我们再讲到


126
00:06:11,305 --> 00:06:14,775
可能到了WWDC2020
Elements 我希望确保


127
00:06:14,875 --> 00:06:17,177
当时它看上去还不错
不是简单的过去的硬件


128
00:06:17,244 --> 00:06:19,646
和现在的硬件 而是
潜在的未来硬件


129
00:06:19,947 --> 00:06:24,051
那我继续选择
放入一些自定义绘图代码


130
00:06:24,117 --> 00:06:26,787
绘制圆角矩形背景因为它是个圆角矩形


131
00:06:26,954 --> 00:06:29,523
我准备在Swift中实现 但是


132
00:06:29,590 --> 00:06:31,325
我会从 Objective-C调用


133
00:06:33,760 --> 00:06:36,296
为实现这一点 我用到的是
Mix和Match技术


134
00:06:36,964 --> 00:06:39,032
我们在去年和今年有许多讲座


135
00:06:39,132 --> 00:06:42,236
都是介绍Swift
和Objective-C的互操作性


136
00:06:42,536 --> 00:06:44,938
对其中的机制都有很好的介绍


137
00:06:45,239 --> 00:06:47,341
现在我想来为大家进行综述


138
00:06:47,407 --> 00:06:49,076
来看技术怎样发挥作用


139
00:06:49,209 --> 00:06:51,712
然后深入介绍一个
演示 大家可以直观地了解


140
00:06:54,147 --> 00:06:56,750
一般而言 当我们考虑到
Objective-C中的类时


141
00:06:56,817 --> 00:06:59,019
会有个头文件和一个执行文件


142
00:06:59,086 --> 00:07:01,522
两部分共同构成类定义


143
00:07:02,122 --> 00:07:03,824
但是可能我们会有部分


144
00:07:04,157 --> 00:07:06,193
分类中执行的方法


145
00:07:06,393 --> 00:07:07,694
这相当好


146
00:07:07,961 --> 00:07:10,597
然后我们的类定义是基类


147
00:07:10,998 --> 00:07:12,499
加上分类


148
00:07:12,599 --> 00:07:13,534
并不是说


149
00:07:13,600 --> 00:07:14,902
不可以有多个分类


150
00:07:15,169 --> 00:07:17,137
实际上 我们可以
用UI表视图做些什么


151
00:07:17,204 --> 00:07:19,206
如果来看
Objective-C中的头文件


152
00:07:19,273 --> 00:07:22,009
会看到在UI表视图有很多分类


153
00:07:23,010 --> 00:07:27,047
同样 也不是说这些分类之一


154
00:07:27,114 --> 00:07:28,549
不可以在Swift中执行


155
00:07:29,049 --> 00:07:31,785
其中 术语会改变可是概念还是一样


156
00:07:31,885 --> 00:07:35,322
我们只是称其为Objective-
C的Swift扩展


157
00:07:35,455 --> 00:07:36,456
在本例中是基类


158
00:07:36,723 --> 00:07:37,691
并不是说


159
00:07:37,758 --> 00:07:41,595
不可以用多个
Objective-C分类


160
00:07:41,662 --> 00:07:46,900
与多个Swift扩展
相混合 其中所有的内容构成类


161
00:07:48,302 --> 00:07:50,904
我们在Objective-C中
编写部分函数


162
00:07:51,305 --> 00:07:53,540
这会让你在Swift中
编写更新的函数


163
00:07:54,541 --> 00:07:58,045
为了让互操作性技术可以实现我们用到


164
00:07:58,212 --> 00:08:00,347
一组桥接头文件不是一组桥接头文件


165
00:08:00,414 --> 00:08:02,149
我们是用桥接头文件和一个生成头文件


166
00:08:03,650 --> 00:08:06,787
现在桥接头文件在Xcode中编成


167
00:08:06,854 --> 00:08:10,390
首次向现有Objective-C
项目中引入Swift


168
00:08:10,924 --> 00:08:12,326
然后进行维护


169
00:08:12,392 --> 00:08:14,294
基本上要进入其中
加上部分输入语句


170
00:08:14,361 --> 00:08:18,298
这样就可以针对性
从Objective-C 


171
00:08:18,532 --> 00:08:20,133
面向Swift
使用选择数据类型


172
00:08:21,201 --> 00:08:24,137
然后在倒数上
Swift编译器编成生成的头文件


173
00:08:24,204 --> 00:08:27,541
可以将之输入到
Objective-C执行文件


174
00:08:27,741 --> 00:08:30,177
来面对Swift 
在本例中是针对


175
00:08:30,344 --> 00:08:33,046
Objective-C的扩展
和其他数据类型


176
00:08:33,447 --> 00:08:34,881
现在我们有了两个头文件


177
00:08:34,948 --> 00:08:36,350
你会在演示中看到它们


178
00:08:38,085 --> 00:08:39,453
马上就好


179
00:08:50,197 --> 00:08:51,431
好的<c.blue> </c>在项目中


180
00:08:51,598 --> 00:08:53,834
这个类名为原子元素tile视图


181
00:08:54,868 --> 00:08:56,837
这就是实际在绘制背景的


182
00:08:57,504 --> 00:08:58,639
其中有个方法


183
00:08:58,972 --> 00:09:00,541
这其实不仅是绘制背景


184
00:09:00,607 --> 00:09:02,576
它为大小tile框架绘制了背景


185
00:09:02,643 --> 00:09:03,911
和背景上的所有的文本


186
00:09:04,545 --> 00:09:07,047
我准备介绍新的绘图代码


187
00:09:07,114 --> 00:09:09,283
但我将用Swift来实现因此
我会继续制作新的Swift文件


188
00:09:09,349 --> 00:09:11,151
这是Xcode
中的command-N


189
00:09:11,418 --> 00:09:15,956
我们会选择Swift文件来创建


190
00:09:16,223 --> 00:09:18,292
因为是这是首次将Swift加入


191
00:09:18,392 --> 00:09:19,826
这个项目我可以选择


192
00:09:19,927 --> 00:09:21,061
现在就生成接桥头文件


193
00:09:21,361 --> 00:09:24,064
我想创建一个按下Return


194
00:09:27,334 --> 00:09:30,804
现在我有两个文件
其中包括Objective-C的


195
00:09:31,405 --> 00:09:32,706
基类 外加Swift文件


196
00:09:33,006 --> 00:09:34,808
我还有接桥头文件


197
00:09:35,209 --> 00:09:37,144
还可以把这个再加宽一些 就这样


198
00:09:39,046 --> 00:09:41,548
你可能注意到
Swift文件的文件名


199
00:09:41,815 --> 00:09:44,284
和Objective-C中
的完全一样


200
00:09:44,384 --> 00:09:46,320
并不是有这样的要求
而是为了方便起见


201
00:09:46,587 --> 00:09:48,555
因为这表示在Xcode 


202
00:09:48,622 --> 00:09:51,458
可以用快捷方式 control
command-up arrow


203
00:09:51,525 --> 00:09:55,162
并循环Swift和
Objective-C头文件并执行


204
00:09:55,562 --> 00:09:57,631
在这三个之间快速往复即可


205
00:09:59,733 --> 00:10:02,102
现在我选定在桥接头文件


206
00:10:02,402 --> 00:10:04,505
把在Objective-C中
声明的数据类型


207
00:10:04,571 --> 00:10:07,007
暴露Swift通过输入头文件来实现


208
00:10:07,641 --> 00:10:11,745
因为我想将原子元素tile视图
扩展到Swift


209
00:10:11,812 --> 00:10:15,115
或使用Swift 
将之输入给接桥头文件


210
00:10:16,683 --> 00:10:20,654
此刻我只需要的是我已经强调过的
原子元素tile视图


211
00:10:20,721 --> 00:10:22,856
但是在演讲的稍后部分
我还需要其他几个


212
00:10:22,923 --> 00:10:24,658
我先来继续现在把它们全都输入


213
00:10:26,527 --> 00:10:28,228
我们在来看Swift文件


214
00:10:29,029 --> 00:10:33,200
我会编写原子元素tile视图的扩展


215
00:10:40,941 --> 00:10:44,178
现在类原子元素
tile视图 调用这个新函数


216
00:10:44,478 --> 00:10:45,646
叫绘制原始背景


217
00:10:45,879 --> 00:10:49,183
大家可以看到 我还用到了
新的Xcode 7标记


218
00:10:49,316 --> 00:10:51,351
给出文档注释文档注释


219
00:10:51,485 --> 00:10:53,687
在本例中 是绘制原子
元素背景tile框架


220
00:10:54,488 --> 00:10:55,956
我来继续 把实际


221
00:10:56,089 --> 00:10:57,257
进行绘制的代码加进去


222
00:11:02,763 --> 00:11:04,064
这就是Swift的部分


223
00:11:04,131 --> 00:11:06,967
但现在我想从Objective-C
中调用Swift函数


224
00:11:07,401 --> 00:11:09,903
这样反而是装载预渲染图像


225
00:11:09,970 --> 00:11:12,973
我会用这种方法来绘制


226
00:11:14,107 --> 00:11:16,376
然后切换到原子元素tile视图m


227
00:11:16,877 --> 00:11:19,847
需要确保
它可以看到我加入Swift中的


228
00:11:20,180 --> 00:11:22,583
代码 因此我继续并输入生成的头文件


229
00:11:24,251 --> 00:11:26,286
生成的头文件和
产品使用完全相同的名称


230
00:11:26,486 --> 00:11:31,959
因此元素
再加上连字符 Swift.h


231
00:11:34,528 --> 00:11:37,364
现在 在这种方法中我通常会装载


232
00:11:37,464 --> 00:11:39,633
预渲染背景
我会加注释


233
00:11:41,568 --> 00:11:45,506
并反而调用“self draw”
大家可以看到


234
00:11:45,572 --> 00:11:47,241
Swift的方法作为原生方法


235
00:11:47,307 --> 00:11:49,743
和这里的所有内容一起显示


236
00:11:49,810 --> 00:11:51,778
你甚至可以看到注释显示为
draw  


237
00:11:51,845 --> 00:11:55,082
an atomicelements
background tile


238
00:11:55,148 --> 00:11:57,818
我来传递交出这个元素


239
00:12:03,490 --> 00:12:05,025
把它传递交给外包矩形


240
00:12:05,092 --> 00:12:06,693
它会绘制圆角矩形


241
00:12:09,563 --> 00:12:10,631
运行app


242
00:12:15,002 --> 00:12:18,639
就这样运用Swift代码
和Objective-C


243
00:12:18,705 --> 00:12:20,541
获得部分圆角矩形 谢谢


244
00:12:26,613 --> 00:12:28,515
这就是在观众里
安排自己的朋友的好处


245
00:12:38,192 --> 00:12:40,561
大部分内容 都是和我的预期相符


246
00:12:40,627 --> 00:12:41,495
是圆角矩形


247
00:12:41,662 --> 00:12:43,564
但是圆角矩形本身 它们并不


248
00:12:43,630 --> 00:12:44,831
和我想要的方式相符


249
00:12:45,098 --> 00:12:48,535
实际上 如果放大 大家可以看到


250
00:12:48,602 --> 00:12:50,904
里边是圆角但外边不是圆角


251
00:12:51,138 --> 00:12:52,306
这不是我的本意


252
00:12:52,472 --> 00:12:54,775
我是希望是纯圆角纯粹的圆角


253
00:12:54,842 --> 00:12:55,976
在里边和外边都是


254
00:12:56,777 --> 00:12:59,980
我们来仔细看看为什么会是这样


255
00:13:00,047 --> 00:13:03,083
我们来看Swift结构


256
00:13:03,951 --> 00:13:05,619
Swift会怎么让它


257
00:13:05,752 --> 00:13:07,154
更简单并与结构配合更自然


258
00:13:07,354 --> 00:13:11,091
例如在Core Graphics
框架中我们有许多 


259
00:13:11,625 --> 00:13:12,726
基本结构


260
00:13:12,793 --> 00:13:16,163
我们有CGrects
CGpoints CGsize等等


261
00:13:17,764 --> 00:13:22,302
绘制的时候我有外包矩形是个
CGrect我绘制了贝兹曲线路径


262
00:13:22,669 --> 00:13:24,171
现在贝兹曲线路径是屏幕上的


263
00:13:24,238 --> 00:13:27,474
灰色边框绘制贝兹曲线路径


264
00:13:29,710 --> 00:13:31,879
接下来 把它被放在外包矩形内部


265
00:13:31,945 --> 00:13:33,313
你就会看到这里是外包矩形


266
00:13:34,181 --> 00:13:36,583
贝兹曲线路径
你看到的不是这样本身并非是你所见


267
00:13:36,650 --> 00:13:38,986
直到对之应用线条才会进行渲染


268
00:13:39,052 --> 00:13:41,321
比如画线大家会看到


269
00:13:41,388 --> 00:13:42,990
对贝兹曲线路径的渲染效果


270
00:13:43,790 --> 00:13:46,026
我们来绘制贝兹曲线路径


271
00:13:47,027 --> 00:13:48,195
在加上画线


272
00:13:48,595 --> 00:13:51,765
例如 画线为
10个单位宽 10点宽


273
00:13:52,399 --> 00:13:53,901
但是会超过外包矩形的


274
00:13:53,967 --> 00:13:54,835
边界


275
00:13:56,970 --> 00:13:58,272
这会导致剪切


276
00:13:58,772 --> 00:14:00,908
圆角矩形实际上是在外边


277
00:14:00,974 --> 00:14:03,877
但是在外包矩形上
发生的剪切防止它到达那里


278
00:14:05,078 --> 00:14:08,048
我知道 在座的朋友
有人会觉得


279
00:14:08,115 --> 00:14:09,716
如果剪切存在问题 那就关闭剪切


280
00:14:10,184 --> 00:14:11,451
问题就解决了


281
00:14:11,518 --> 00:14:12,452
就可以继续了


282
00:14:14,188 --> 00:14:16,490
当然可以 我觉得


283
00:14:16,557 --> 00:14:20,260
在Xcode中
Swift问题可以这么解决


284
00:14:20,727 --> 00:14:23,463
只要重新安排
Swift的感叹号位置


285
00:14:23,530 --> 00:14:25,232
直至开始编译为止


286
00:14:27,134 --> 00:14:30,070
可以这么做 只是我不会
称之为最佳实践


287
00:14:30,871 --> 00:14:33,507
当出现剪切问题时


288
00:14:35,275 --> 00:14:36,710
这是性能表现的问题


289
00:14:36,777 --> 00:14:38,912
通过所调用的每个API


290
00:14:39,046 --> 00:14:42,916
通过发起的每个任务
通过进行的每个动作


291
00:14:42,983 --> 00:14:44,585
通过你的每一次呼吸


292
00:14:44,885 --> 00:14:47,921
你需要考虑对
功能和性能的影响


293
00:14:48,288 --> 00:14:52,359
不断计算两个矩形的
交叉部分并对之进行剪切


294
00:14:52,426 --> 00:14:53,393
这不是很有效的方法


295
00:14:53,861 --> 00:14:57,564
在一开始就把矩形设置为
正确大小则更为有效


296
00:14:59,266 --> 00:15:00,200
我们就要这么做


297
00:15:00,400 --> 00:15:02,202
准备嵌入贝兹曲线路径


298
00:15:02,402 --> 00:15:03,670
这样就不会自行剪切


299
00:15:04,238 --> 00:15:07,307
为此 我们会用到一些方法


300
00:15:07,741 --> 00:15:11,345
我是说CGrect上的方法


301
00:15:11,411 --> 00:15:13,313
当它在Swift中使用的时候


302
00:15:14,214 --> 00:15:16,183
考虑一下这些原始类型怎样正常使用


303
00:15:16,316 --> 00:15:18,685
我们有CGrects
CGpoint等等


304
00:15:19,119 --> 00:15:21,388
我说过它们可能会在这里


305
00:15:21,855 --> 00:15:25,859
那么单独来看
你获得了可适用的整套全局通用函数


306
00:15:25,926 --> 00:15:29,263
例如CGrectZero
CGrectMake


307
00:15:29,329 --> 00:15:32,132
或GetWidth
或是部分实际函数


308
00:15:32,199 --> 00:15:33,634
例如获得联合或交点


309
00:15:34,001 --> 00:15:35,869
这是二者之间的认知区分


310
00:15:35,936 --> 00:15:37,771
我们了解是这个类型 然后我们需要


311
00:15:37,871 --> 00:15:40,374
了解是这些方法 不好意思


312
00:15:40,440 --> 00:15:41,875
是作用的函数


313
00:15:43,076 --> 00:15:45,612
我们用Swift
工作时我们实际上改变的是


314
00:15:45,679 --> 00:15:49,650
CGrect和CGpoint
及CGsize进入Swift的方法


315
00:15:50,517 --> 00:15:52,920
我们基本会用封装用所有这些


316
00:15:53,453 --> 00:15:56,356
这些全局 正式来讲是
作用于框架的全局函数


317
00:15:56,423 --> 00:15:59,193
并在结构中搭建它以便使之完成代码


318
00:16:00,561 --> 00:16:05,299
更为简单
还可以更出色预测到API是什么


319
00:16:06,166 --> 00:16:09,770
因为你可以处理点结构


320
00:16:09,837 --> 00:16:13,140
然后为所有方法和属性
获得它所具备的代码完成


321
00:16:14,074 --> 00:16:16,109
然是如果我们把名称就保留成这样


322
00:16:16,476 --> 00:16:17,878
这还不是原生的感觉


323
00:16:18,445 --> 00:16:21,415
名称实际上都做了重新映射 


324
00:16:22,115 --> 00:16:25,953
让人觉得
这是数据类型的 第一类型方法


325
00:16:26,420 --> 00:16:30,858
这样做的好处在于
处理Swift中的结构的方法


326
00:16:31,325 --> 00:16:35,195
调用函数或调用方法


327
00:16:35,262 --> 00:16:38,732
或访问其属性这与类的处理方法


328
00:16:39,199 --> 00:16:42,336
与枚举的处理方法完全相同


329
00:16:43,103 --> 00:16:45,339
都是相同的一致风格


330
00:16:45,672 --> 00:16:48,275
我们还要在所有不同数据类型中


331
00:16:48,408 --> 00:16:49,776
使用同样的初始化器


332
00:16:49,943 --> 00:16:51,912
我们有着更好的代码完成


333
00:16:51,979 --> 00:16:56,850
总之
在Swift中运用这些类型更为自然


334
00:16:56,917 --> 00:17:02,055
因为
它们作为第一类型数据类型和方法配合


335
00:17:03,557 --> 00:17:06,126
好的我们还要做一件事情


336
00:17:06,193 --> 00:17:08,929
在下面的演示中我不了解大家会怎样但
是当我用图形代码时


337
00:17:08,996 --> 00:17:10,998
特别是部分Core
Graphics代码时 


338
00:17:11,164 --> 00:17:16,637
我使用的一个方法是渲染代码


339
00:17:16,703 --> 00:17:19,106
然后会运行接着来构建并复制到


340
00:17:19,173 --> 00:17:21,407
模拟器然后我导航到


341
00:17:21,474 --> 00:17:23,644
模拟器中代码真正被激活被使用的位置


342
00:17:23,844 --> 00:17:25,746
我还会进行检测 如果不喜欢


343
00:17:25,811 --> 00:17:27,748
就会返回调整代码并运行全部内容


344
00:17:27,814 --> 00:17:29,917
这是个循环


345
00:17:29,983 --> 00:17:32,152
来回走一遍会非常耗时


346
00:17:32,252 --> 00:17:34,488
来看如果把直线宽度


347
00:17:34,555 --> 00:17:37,357
从3改到4 或是关闭光栅化 或是


348
00:17:37,424 --> 00:17:39,626
进行某种设置更改试着让它运转会怎样


349
00:17:41,995 --> 00:17:43,330
还有更好的方法


350
00:17:43,897 --> 00:17:45,432
不需要这么来回反复


351
00:17:45,832 --> 00:17:48,302
也不必经常注释出


352
00:17:48,368 --> 00:17:50,337
部分代码只为尝试效果如何


353
00:17:50,404 --> 00:17:51,505
如果真想试验 可以


354
00:17:51,572 --> 00:17:54,842
拿一些代码试试看看效果怎样


355
00:17:55,042 --> 00:17:56,543
体育场就是为这个准备的


356
00:17:56,877 --> 00:17:58,745
通过体育场循环修改成


357
00:17:58,812 --> 00:17:59,713
这个样子


358
00:18:00,214 --> 00:18:03,283
只要调整代码你就会立刻看到改变
如果不喜欢可以立 刻修改


359
00:18:03,684 --> 00:18:06,186
这些都不会复制到模拟器中 导航并


360
00:18:06,553 --> 00:18:09,323
现在通过体育场 
解决圆角来看看是什么样子


361
00:18:09,590 --> 00:18:11,258
矩形的问题并使用CGrect


362
00:18:11,525 --> 00:18:15,295
的部分方法
从中得到更好的CGrect


363
00:18:15,395 --> 00:18:16,697
我来给大家看看


364
00:18:23,670 --> 00:18:26,406
绘图代码在原子元素tile视图


365
00:18:26,473 --> 00:18:27,574
<c.blue>.</c>点Swift就在这里 


366
00:18:27,708 --> 00:18:29,209
这是我在之前演示中


367
00:18:29,276 --> 00:18:30,577
复制的函数


368
00:18:30,911 --> 00:18:32,346
我就是想要处理这个


369
00:18:32,412 --> 00:18:33,514
所以把它复制到体育场


370
00:18:33,847 --> 00:18:37,518
复制好了点击command-N
生成新的iOS体育场


371
00:18:46,860 --> 00:18:47,928
粘贴进去


372
00:18:48,395 --> 00:18:49,730
现在就有了绘图函数


373
00:18:51,698 --> 00:18:53,500
开发人员并非身处孤岛


374
00:18:53,700 --> 00:18:56,036
没有任何绘图函数是完全隔绝


375
00:18:56,336 --> 00:18:58,639
绘图函数需要在有上下文来绘制


376
00:18:58,872 --> 00:19:00,674
也就是绘图上下文或是图形上下文


377
00:19:00,941 --> 00:19:03,210
获得图形上下文的最便捷方式


378
00:19:03,277 --> 00:19:04,578
是在UIView生成子类


379
00:19:04,645 --> 00:19:06,046
这就是我准备做的


380
00:19:06,113 --> 00:19:09,516
我先来声明UIView的子类 这里


381
00:19:11,919 --> 00:19:16,023
它所做的就是调用绘图函数


382
00:19:17,224 --> 00:19:19,393
然后我会实例化这个类


383
00:19:23,096 --> 00:19:26,533
然后我会采用绘图函数


384
00:19:26,700 --> 00:19:28,869
绘制的图像
并直接加入这里的故事板


385
00:19:30,971 --> 00:19:32,472
放大些 这样都能看清


386
00:19:34,341 --> 00:19:35,742
接着可以进行尝试


387
00:19:35,809 --> 00:19:37,044
你可以指出自己该做什么


388
00:19:37,110 --> 00:19:38,812
让它按照自己的意图来进行绘制


389
00:19:39,012 --> 00:19:41,114
例如 我想看看是否看似


390
00:19:41,181 --> 00:19:42,683
它只有120点


391
00:19:43,884 --> 00:19:44,785
这就是结果


392
00:19:46,286 --> 00:19:49,690
也许我想看看如果直线宽度
不是6而是60圆角半径


393
00:19:50,457 --> 00:19:55,596
为356会怎样


394
00:19:55,662 --> 00:19:56,663
就是这样


395
00:19:57,531 --> 00:19:59,032
大家可以一直做尝试


396
00:19:59,099 --> 00:20:00,734
一旦代码运行方式符合要求


397
00:20:00,968 --> 00:20:01,969
就可以复制并


398
00:20:02,035 --> 00:20:03,470
粘贴到它来自的实际文件中


399
00:20:04,571 --> 00:20:08,509
在本例中我希望获得直线宽度比例


400
00:20:08,609 --> 00:20:10,611
那么如果是表视图中的小tile视图


401
00:20:11,011 --> 00:20:13,113
就会是细边如果是大些的视图


402
00:20:13,180 --> 00:20:14,548
相应的就是宽一些的边


403
00:20:14,715 --> 00:20:18,819
因此我会
让它关联到背景矩形的宽度上


404
00:20:19,520 --> 00:20:24,091
那么背景矩形宽度在本例中会除以36


405
00:20:25,292 --> 00:20:27,094
对圆角半径 我也会做同样处理


406
00:20:27,861 --> 00:20:30,864
Background
rectangle.width除以


407
00:20:31,198 --> 00:20:32,766
小一点的值 比如16


408
00:20:34,668 --> 00:20:37,037
现在来看我希望它看的内容


409
00:20:37,104 --> 00:20:38,272
但我仍然还有剪切的问题


410
00:20:38,338 --> 00:20:40,874
我还是不能看到画线或者是


411
00:20:40,941 --> 00:20:42,876
圆角矩形的全部内容


412
00:20:43,610 --> 00:20:45,913
为此 在背景矩形


413
00:20:46,780 --> 00:20:50,684
我会通过嵌入使用矩形方法


414
00:20:50,884 --> 00:20:52,953
并且嵌入到直线宽度的一半


415
00:20:54,321 --> 00:20:57,057
这里的直线宽度除以2 


416
00:20:57,491 --> 00:21:00,594
然后 同样直线宽度除以2


417
00:21:03,597 --> 00:21:05,866
我有个完美的圆角矩形


418
00:21:05,933 --> 00:21:07,734
和我最初设想完全相同


419
00:21:08,101 --> 00:21:13,640
我把这个代码从这里复制到扩展


420
00:21:13,907 --> 00:21:15,409
代替这个文档 不对


421
00:21:15,475 --> 00:21:16,376
代替这里的方法


422
00:21:17,477 --> 00:21:19,346
用command-R再次运行app


423
00:21:22,516 --> 00:21:25,352
正如我所愿圆角矩形


424
00:21:25,886 --> 00:21:26,854
好的 很好


425
00:21:34,461 --> 00:21:37,998
这很有WWDC的感觉如果你想鼓掌
那就随时可以鼓掌


426
00:21:38,532 --> 00:21:40,434
没有人会阻止这一点


427
00:21:41,602 --> 00:21:42,603
没问题
好的 谢谢大家


428
00:21:45,072 --> 00:21:46,373
app看似没问题


429
00:21:46,440 --> 00:21:47,541
我也实现了圆角矩形


430
00:21:47,608 --> 00:21:48,742
非常好 就是我想要的


431
00:21:48,976 --> 00:21:49,943
接下来 我想做的是


432
00:21:50,010 --> 00:21:52,679
让这个app看上去像是当前的app


433
00:21:54,047 --> 00:21:58,619
我不了解大家会怎样但是在参加WWD
C大会之后你是否曾跑到客户那里


434
00:21:58,685 --> 00:22:01,054
说 现在iOS的新版本出来了 


435
00:22:01,121 --> 00:22:02,723
比如说iOS 9出来了


436
00:22:02,789 --> 00:22:05,259
我觉得 应该不再支持iOS 8


437
00:22:05,626 --> 00:22:09,496
我们应该只支持新的操作系统


438
00:22:11,899 --> 00:22:13,100
很好<c.blue> </c>你们这么干过吗？


439
00:22:15,636 --> 00:22:16,937
好 那你再去找下一个客户好了


440
00:22:17,971 --> 00:22:22,376
因为大家都希望你支持这些旧版本


441
00:22:22,676 --> 00:22:27,181
iOS 7 8现在可能9
对大部分人而言会在秋天能用上


442
00:22:27,614 --> 00:22:32,319
为实现这一点 我们在Swift
2.0推出了新的可用性功能


443
00:22:32,386 --> 00:22:34,321
只要是用Swift 2.0编写代码


444
00:22:34,388 --> 00:22:38,292
我们有很好的办法来看所用的SDK


445
00:22:38,358 --> 00:22:40,994
无论你是否真会用这种功能与否


446
00:22:42,529 --> 00:22:44,097
去年在WWDC


447
00:22:44,264 --> 00:22:48,035
我们推出了一些新的
视图控制器显示API


448
00:22:48,735 --> 00:22:50,671
可以在iPhone上弹出显示


449
00:22:51,138 --> 00:22:54,341
我想用元素app
做的是当我在支持它的任何设备上


450
00:22:54,408 --> 00:22:58,111
例如在iOS 8或者更新


451
00:22:58,412 --> 00:22:59,980
版本的设备上我想用弹出显示


452
00:23:00,280 --> 00:23:01,748
但是当我在iOS 7上


453
00:23:01,815 --> 00:23:05,452
我想继续使用导航推送显示样式


454
00:23:06,353 --> 00:23:08,222
好 怎么做呢？


455
00:23:09,556 --> 00:23:14,561
这是检测是否支持API的经典办法


456
00:23:14,895 --> 00:23:17,798
无论是什么类型我们都要
检测它是否对选择器有反应


457
00:23:17,865 --> 00:23:19,800
如果有反应我们就用这款选择器


458
00:23:19,900 --> 00:23:21,568
如果没有我们就做其他的事情


459
00:23:23,837 --> 00:23:27,174
在Swift 到Swift 2.0
我们都是这么做的


460
00:23:27,741 --> 00:23:32,980
我们有这个井号标签指定想要的SDK


461
00:23:33,046 --> 00:23:35,482
在本例中是iOS 8.3如果是这样


462
00:23:35,782 --> 00:23:38,819
我们会用到弹出框
如果不是我们用其他方法


463
00:23:39,419 --> 00:23:42,155
这种样式的好处在于你并没有等待


464
00:23:42,222 --> 00:23:44,358
运行时间来看是否实际工作正常


465
00:23:44,424 --> 00:23:46,593
在编译时间编译器会告知你 


466
00:23:47,060 --> 00:23:49,229
没问题 这可行或不可行 


467
00:23:49,296 --> 00:23:50,497
根据你的部署目标而定


468
00:23:50,597 --> 00:23:52,432
如果我在iOS 7部署


469
00:23:52,999 --> 00:23:54,735
它会告知无法进行弹出


470
00:23:55,135 --> 00:23:57,171
但是因为我进行了妥善保护 


471
00:23:57,538 --> 00:23:59,573
提供了另外的路径就可以编译


472
00:24:02,576 --> 00:24:06,180
在本例中 如果我没有进行保护
如果我没有说这里是检测


473
00:24:07,047 --> 00:24:10,951
我想要做编译 准备部署到iOS 7


474
00:24:12,252 --> 00:24:15,022
它就会说 弹出显示
控制器不可用


475
00:24:15,189 --> 00:24:16,423
只能在8或者更新版本才行


476
00:24:17,157 --> 00:24:18,425
然后会给我一些修复


477
00:24:18,492 --> 00:24:19,927
但是我不会用更多的幻灯片


478
00:24:19,993 --> 00:24:21,094
而是直接给大家看代码


479
00:24:22,095 --> 00:24:22,930
好<c.blue> </c>首先


480
00:24:22,996 --> 00:24:24,731
在第二个视图控制器显示的代码


481
00:24:24,798 --> 00:24:27,668
保存在elements
viewcontroller.m.


482
00:24:28,435 --> 00:24:33,674
表视图附件的执行
但是点击了索引路径的行


483
00:24:34,875 --> 00:24:36,443
因为我想使用可用性检测


484
00:24:36,510 --> 00:24:39,012
我只能在Swift上执行


485
00:24:39,079 --> 00:24:40,747
执行而不是Objective-C
我现在就来添加注释


486
00:24:41,915 --> 00:24:43,884
然后我会生成一个类扩展


487
00:24:43,951 --> 00:24:46,854
更像20分钟左右前的
那个最初演示的样子


488
00:24:47,221 --> 00:24:52,759
这样我可以扩展元素视图控制器 
并在Swift中执行部分功能


489
00:24:53,660 --> 00:24:56,163
我点击command-N 
生成新文件 是Swift文件


490
00:24:57,965 --> 00:25:00,267
是元素视图控制器.Swift


491
00:25:01,134 --> 00:25:03,637
然后我会在上面编写扩展


492
00:25:05,606 --> 00:25:08,575
扩展 元素视图控制器


493
00:25:09,977 --> 00:25:15,215
其中 我会用 等效的Swift函数


494
00:25:15,382 --> 00:25:16,984
因此这基本上是我在Swift中


495
00:25:17,084 --> 00:25:18,085
已有的相同代码


496
00:25:18,185 --> 00:25:19,620
这里并没有新鲜内容


497
00:25:19,686 --> 00:25:21,522
就是在Swift上执行的相同内容


498
00:25:21,588 --> 00:25:23,423
但是这可以让我进行可用性检测


499
00:25:25,325 --> 00:25:29,830
这个特殊应用是针对 iOS 7.1


500
00:25:30,731 --> 00:25:35,369
我想在其中用这个新的弹出显示
控制器技术 


501
00:25:37,271 --> 00:25:38,805
那么就在这一行做注释


502
00:25:40,140 --> 00:25:43,110
并加入代码试着直接调用弹出显示


503
00:25:47,714 --> 00:25:48,815
我有些错误


504
00:25:49,082 --> 00:25:51,018
一个错误是抱怨我没有


505
00:25:51,084 --> 00:25:54,488
真正满足弹出框所需的委托协议


506
00:25:55,189 --> 00:25:59,226
在旁边可以用Swift扩展


507
00:25:59,293 --> 00:26:02,696
并用它来为额外的协议添加一致性


508
00:26:02,763 --> 00:26:06,867
所以我将添加UI弹出显示控制器委托


509
00:26:08,368 --> 00:26:11,271
这就会消除这个错误但我仍然还有问题


510
00:26:11,939 --> 00:26:15,809
就是要用iOS
7.1中不存在的API


511
00:26:16,276 --> 00:26:17,644
而我却偏偏需要这样


512
00:26:17,945 --> 00:26:19,179
嗯 是在演示中需要如此


513
00:26:19,847 --> 00:26:21,982
我有两种解决办法


514
00:26:23,917 --> 00:26:25,886
现在就给大家简单介绍一下


515
00:26:28,155 --> 00:26:30,624
如果我是在运 
在本例中是iOS 8.3


516
00:26:31,058 --> 00:26:32,426
继续 并作为弹出显示


517
00:26:32,593 --> 00:26:34,261
否则 就用导航控制器


518
00:26:35,963 --> 00:26:40,000
现在 如果我运行它 并点击 


519
00:26:42,102 --> 00:26:43,170
我们来看这里


520
00:26:45,038 --> 00:26:46,039
我们得到一个弹出框


521
00:26:46,907 --> 00:26:49,910
已经15年了 
我们仍在WWDC上见到Carbon


522
00:26:52,813 --> 00:26:53,647
好


523
00:27:04,758 --> 00:27:06,460
若要了解可用性检测的更多详情


524
00:27:06,827 --> 00:27:09,096
可去看周四的讲座《Swift实践》


525
00:27:09,363 --> 00:27:10,731
其中会有大篇幅的相关介绍


526
00:27:14,067 --> 00:27:15,903
接下来 之前的演示是关于


527
00:27:15,969 --> 00:27:18,939
应用外观的改进和现代化处理


528
00:27:19,006 --> 00:27:21,575
要知道 我们改变绘图来取消光泽


529
00:27:21,642 --> 00:27:23,210
我们现在还有弹出框等等 不胜枚举


530
00:27:23,644 --> 00:27:25,412
但是让我们实际增添部分功能


531
00:27:25,546 --> 00:27:28,515
我们要执行智能搜索


532
00:27:28,882 --> 00:27:30,184
为此 我们会来看看


533
00:27:30,250 --> 00:27:31,652
Swift的过滤方法


534
00:27:31,718 --> 00:27:34,821
在所有的集合中都有包括集合和数组


535
00:27:35,756 --> 00:27:39,393
过滤可以用于驱动智能搜索函数
其中只有满足搜索


536
00:27:39,459 --> 00:27:42,930
字符串的原子元素会在表视图中显示


537
00:27:44,665 --> 00:27:48,335
标准设置是这个样子
我们有TableView


538
00:27:48,402 --> 00:27:51,605
TableView
加上视图控制器作为数据源


539
00:27:52,072 --> 00:27:53,941
视图控制器有内容数组


540
00:27:56,243 --> 00:27:59,413
我在搜索域输入一些东西时


541
00:27:59,847 --> 00:28:01,682
就会有个委托方式在视图控制器上叫做


542
00:28:01,748 --> 00:28:04,218
searchbar:
textDidChange.


543
00:28:06,153 --> 00:28:07,888
我找出传递的字符串


544
00:28:07,955 --> 00:28:09,022
那只是一个参数


545
00:28:09,089 --> 00:28:10,657
我过滤内容数组


546
00:28:10,924 --> 00:28:13,927
并告知TableView用过滤后的


547
00:28:15,562 --> 00:28:17,231
内容数组进行更新


548
00:28:17,297 --> 00:28:19,766
Searchbar:
textDidChange


549
00:28:19,833 --> 00:28:21,401
基本是这样


550
00:28:22,269 --> 00:28:24,037
实际上 就是这个样子


551
00:28:24,104 --> 00:28:25,472
因为这就是我用的代码


552
00:28:25,906 --> 00:28:27,040
现在我要大家注意


553
00:28:27,574 --> 00:28:29,910
标亮的部分是个闭包


554
00:28:30,477 --> 00:28:32,713
我正在运行过滤器 在过滤器中


555
00:28:33,013 --> 00:28:35,382
会应用数组中的每一项


556
00:28:35,816 --> 00:28:38,585
数组中的项我有占位控件


557
00:28:38,986 --> 00:28:41,622
是$0我得到了它的名称
接着询问它是否有前缀


558
00:28:41,688 --> 00:28:42,789
无论搜索字符串是什么


559
00:28:45,792 --> 00:28:48,729
都会这样运行 顶部是最初的数组


560
00:28:49,129 --> 00:28:51,198
我有一个封闭的过滤器


561
00:28:51,832 --> 00:28:52,933
会循环


562
00:28:52,999 --> 00:28:54,601
每次都会传递元素


563
00:28:54,668 --> 00:28:57,538
如果名称前有字母在本例中是N


564
00:28:57,871 --> 00:28:59,773
它被传递给返回过滤数组


565
00:29:01,008 --> 00:29:02,376
如果没有字母 那就不是


566
00:29:02,943 --> 00:29:04,011
我给大家看看代码


567
00:29:04,411 --> 00:29:06,280
但是为加快速度我已经运行过


568
00:29:06,947 --> 00:29:08,248
把搜索条放在上面


569
00:29:08,982 --> 00:29:09,950
但我还没搭建好


570
00:29:10,017 --> 00:29:11,418
那么如果我试着在里面做点什么


571
00:29:12,386 --> 00:29:14,621
都不会奏效 因为我没有加入委托方式


572
00:29:16,623 --> 00:29:18,625
委托方式是这个


573
00:29:23,030 --> 00:29:24,665
也就是说 如果搜索文本为空 
就在这里


574
00:29:24,731 --> 00:29:27,234
显示所有原子元素


575
00:29:28,235 --> 00:29:30,537
如果不是空我想做个过滤器


576
00:29:30,604 --> 00:29:32,005
这部分需要完成


577
00:29:32,072 --> 00:29:32,940
我们现在就动手


578
00:29:38,278 --> 00:29:39,746
我准备一个过滤器


579
00:29:40,013 --> 00:29:41,648
如果这是大家第一次见到闭包


580
00:29:42,015 --> 00:29:43,684
不错 欢迎闭包


581
00:29:43,884 --> 00:29:44,952
我来给大家多讲几句


582
00:29:45,018 --> 00:29:46,787
如果不是的话就当是复习了


583
00:29:47,354 --> 00:29:50,023
当Xcode显示这种蓝色符号化背景


584
00:29:50,090 --> 00:29:52,226
还都是单项可以双击


585
00:29:52,292 --> 00:29:54,528
会展开需要填入空白部分


586
00:29:54,795 --> 00:29:57,531
我会用这个闭包双击 会展开


587
00:29:59,499 --> 00:30:03,637
我知道
有原子元素数组数据类型叫原子元素


588
00:30:04,137 --> 00:30:07,341
如果传递的参数是一个原子元素


589
00:30:07,975 --> 00:30:10,077
我会明确在闭包中


590
00:30:10,611 --> 00:30:13,213
所传递的参数是原子元素


591
00:30:13,280 --> 00:30:17,551
我会给它一个本地名称
这样原子元素有了自己的本地名称


592
00:30:17,618 --> 00:30:20,053
而数据类型是原子元素


593
00:30:21,255 --> 00:30:23,824
在闭包中 我需要检查是否要将它


594
00:30:23,891 --> 00:30:26,760
包括在过滤结果中


595
00:30:27,127 --> 00:30:29,763
因为我承诺给出Boolean返回值


596
00:30:30,964 --> 00:30:35,736
我来看返回值是否是原子元素


597
00:30:38,438 --> 00:30:43,110
名称
有前缀 再看搜索条传递的搜索文本


598
00:30:48,148 --> 00:30:50,150
像这样 现在 当我运行的时候


599
00:30:55,489 --> 00:30:59,092
我们会搜索所有以字母N开始的内容


600
00:30:59,493 --> 00:31:02,029
就这样 
我们用Swift过滤器过滤了


601
00:31:03,330 --> 00:31:04,831
但是有两方面内容需要给大家展示


602
00:31:04,898 --> 00:31:07,701
其一 有两种方法可以来看闭包 


603
00:31:07,768 --> 00:31:09,436
这里是个扩展句法


604
00:31:11,872 --> 00:31:13,373
这里还有精简句法


605
00:31:13,607 --> 00:31:15,108
我来给大家看看精简句法


606
00:31:16,476 --> 00:31:19,146
Swift有非常强大的类型推断系统


607
00:31:19,213 --> 00:31:21,648
我们可根据上下文和所使用的数据类型


608
00:31:21,715 --> 00:31:23,050
推断出很多内容


609
00:31:23,617 --> 00:31:26,653
例如 如果在闭包有个单独行


610
00:31:26,720 --> 00:31:29,289
假设它将返回一个值 


611
00:31:29,356 --> 00:31:30,557
那我不必放入返回值


612
00:31:30,858 --> 00:31:35,262
实际上 如果前缀
返回了Boolean类型


613
00:31:35,329 --> 00:31:37,564
Swift可推断这个闭包的返回类型


614
00:31:37,631 --> 00:31:40,167
就是Boolean 所以我不需要


615
00:31:40,534 --> 00:31:42,970
把它放在这里也就是说我也不必


616
00:31:43,036 --> 00:31:45,305
把它放在那里因为原子元素


617
00:31:45,806 --> 00:31:49,643
我就不必明确 原子元素需要传递
就可以不要这部分


618
00:31:50,177 --> 00:31:53,247
因为我没有任何参数 我不必区分代码


619
00:31:53,313 --> 00:31:54,681
和参数 那么我不需要关键词 


620
00:31:55,549 --> 00:31:58,085
也就是说 可以不要这部分


621
00:31:59,219 --> 00:32:02,456
节省空间 
最后我得到的是这样的东西


622
00:32:05,225 --> 00:32:07,528
因为最后的


623
00:32:07,594 --> 00:32:11,231
过滤方法参数是闭包本身


624
00:32:12,199 --> 00:32:14,902
我们可以把它变成结尾闭包
并且可以删掉括号


625
00:32:15,669 --> 00:32:17,871
我们得到的是这个样子


626
00:32:18,472 --> 00:32:19,706
现在唯一的问题是


627
00:32:19,773 --> 00:32:22,109
没有符号声明调用了原子元素


628
00:32:22,609 --> 00:32:23,577
因为我删掉了


629
00:32:24,278 --> 00:32:28,315
但是我可以每次传递给过滤闭包一个项


630
00:32:28,382 --> 00:32:32,152
而且可以这样参考那个参数


631
00:32:32,853 --> 00:32:35,255
这是完全一样的代码
如果大家怀念Perl代码


632
00:32:35,722 --> 00:32:37,191
这里就是


633
00:32:44,498 --> 00:32:46,066
现在可以检测一下


634
00:32:46,133 --> 00:32:48,302
我们放入字母N 不错


635
00:32:48,902 --> 00:32:51,538
现在有了这些元素不过
它们不是在正确的方向分类


636
00:32:51,805 --> 00:32:52,840
实际上 它们就没有分类


637
00:32:53,140 --> 00:32:55,375
我们快速继续加入分类


638
00:32:55,809 --> 00:32:58,345
我会把它加在现有闭包的结尾


639
00:32:58,412 --> 00:33:01,682
.sort在本例中


640
00:33:01,748 --> 00:33:05,118
我双击这个蓝色的符号 让它展开


641
00:33:05,185 --> 00:33:07,154
还有很多方式可以比较字符串 


642
00:33:07,287 --> 00:33:10,490
比如大小写和区分比较本地化比较等等


643
00:33:10,824 --> 00:33:13,794
但是因为我知道某种程度上 我得到


644
00:33:14,261 --> 00:33:17,497
一个原子元素 
接着又得到一个原子元素


645
00:33:17,564 --> 00:33:21,902
我只需要明确哪个在前 哪个在后


646
00:33:22,202 --> 00:33:24,404
或是否一个在另一个之前 我可以自己


647
00:33:24,538 --> 00:33:28,041
编写闭包首先识别
我会有两个原子元素传递过来 


648
00:33:28,709 --> 00:33:31,812
拿到第一个来查看名称


649
00:33:31,879 --> 00:33:32,913
然后是第二个


650
00:33:32,980 --> 00:33:33,947
也要查看名称


651
00:33:36,416 --> 00:33:38,452
其本身不会做比较


652
00:33:39,019 --> 00:33:41,288
但是在Swift中我们过载了


653
00:33:41,355 --> 00:33:44,057
许多标准运算符例如大于和小于


654
00:33:44,124 --> 00:33:47,261
那么它们会在你可能不希望它们处理的
类型上发挥作用 比如字符串


655
00:33:50,097 --> 00:33:51,498
这是字符串比较


656
00:33:52,999 --> 00:33:54,201
我再次运行


657
00:33:57,437 --> 00:34:01,408
搜索字母N 现在分类妥当了


658
00:34:01,475 --> 00:34:03,644
过滤和分类都在一行


659
00:34:04,011 --> 00:34:04,978
我再检查一遍


660
00:34:05,045 --> 00:34:06,380
我们搜索S 


661
00:34:06,713 --> 00:34:08,047
我有一些非常重要的元素


662
00:34:08,681 --> 00:34:10,016
比如Swiftonium 


663
00:34:11,318 --> 00:34:12,386
非常重要


664
00:34:13,587 --> 00:34:16,489
好的<c.blue> </c>我们回来


665
00:34:17,623 --> 00:34:20,561
在这部分我们通过


666
00:34:20,627 --> 00:34:23,362
Swift的过滤方法执行过滤表视图


667
00:34:25,599 --> 00:34:30,036
然后用分类进行分类
看到过载操作符是小于或是大于


668
00:34:31,271 --> 00:34:33,907
下面的功能
也是我想加入app中的最后一个功能


669
00:34:34,107 --> 00:34:37,476
是可以选择多个行 再做累计以便得到


670
00:34:37,811 --> 00:34:40,112
所选元素的原子量


671
00:34:40,347 --> 00:34:41,348
是这样的


672
00:34:41,715 --> 00:34:44,117
我们先从表视图开始


673
00:34:44,818 --> 00:34:47,286
顶部的导航条说选择二或更多项


674
00:34:48,222 --> 00:34:52,626
你选择二或更多项
接着顶部的导航条确定其原子量总数


675
00:34:54,795 --> 00:34:57,097
为实现这一点我从内容数组开始


676
00:34:57,164 --> 00:34:58,899
这就是我有的全部原子元素


677
00:34:58,966 --> 00:35:00,767
那些是在表视图中显示的全部


678
00:35:01,001 --> 00:35:05,405
但是我只想要 选中的原子元素


679
00:35:06,273 --> 00:35:08,942
为此 我不能前往表视图


680
00:35:09,009 --> 00:35:12,646
让询问视图所选项的数组


681
00:35:12,946 --> 00:35:16,750
我只能通过所选项的索引路径来找


682
00:35:19,052 --> 00:35:22,189
表视图会给我所选项的索引路径数组


683
00:35:22,389 --> 00:35:24,458
我可以询问索引路径 还获得这一行


684
00:35:24,525 --> 00:35:27,261
我可以将这与支持数组内容相关联


685
00:35:27,661 --> 00:35:30,597
从这里 生成所选元素


686
00:35:31,265 --> 00:35:32,366
基本上 就是这个


687
00:35:32,999 --> 00:35:34,067
我们生成新数组


688
00:35:34,334 --> 00:35:36,003
循环索引路径


689
00:35:36,236 --> 00:35:37,571
返回内容


690
00:35:37,771 --> 00:35:42,910
为当前的索引路径的行
找出对应的原子元素


691
00:35:43,443 --> 00:35:45,746
如果你们习惯于这样编码


692
00:35:46,713 --> 00:35:48,549
在Swift中也可以同样


693
00:35:49,316 --> 00:35:50,150
这是映射函数


694
00:35:51,051 --> 00:35:53,287
重要的内容 还是用橙色表示


695
00:35:53,587 --> 00:35:55,155
周围所有的额外基础架构


696
00:35:55,222 --> 00:35:56,490
都已经删除


697
00:35:58,859 --> 00:36:02,729
接下来 一旦我有所有所选项的数组


698
00:36:03,697 --> 00:36:05,666
我就想加上原子量


699
00:36:06,166 --> 00:36:09,770
为此 我会传统地使用一个外循环


700
00:36:09,837 --> 00:36:12,039
那里 我把其变量设置为零


701
00:36:12,105 --> 00:36:16,043
接着重复所选对象并加上 


702
00:36:16,109 --> 00:36:18,645
在本例中是D原子量


703
00:36:18,812 --> 00:36:21,148
如果习惯用for-in循环做这类事


704
00:36:21,381 --> 00:36:22,916
可以在Swift中也同样如此


705
00:36:23,150 --> 00:36:26,153
通过化简函数 我们将初始值设为零


706
00:36:26,220 --> 00:36:29,356
接下来
我们加上采用初始值的闭包也就是零值


707
00:36:29,756 --> 00:36:32,960
再把它附在传递来的下一项后面做累加


708
00:36:33,994 --> 00:36:36,563
我给大家看看代码 不过我会把所做的


709
00:36:37,030 --> 00:36:37,965
全部内容用一行代码


710
00:36:38,165 --> 00:36:39,800
进行综述像这样


711
00:36:40,834 --> 00:36:42,503
有个图形设计师看过演示后


712
00:36:42,569 --> 00:36:44,538
曾经问过我
能不能把这些放在一行中？


713
00:36:45,539 --> 00:36:46,907
不 不可以


714
00:36:46,974 --> 00:36:47,975
我觉得 你们看不到


715
00:36:48,442 --> 00:36:53,013
我们转到演示电脑上


716
00:37:02,823 --> 00:37:05,425
现在就是所有内容的函数


717
00:37:05,626 --> 00:37:08,862
首先要确保选中的是两个以上的项


718
00:37:09,196 --> 00:37:11,532
这样大家可以看到


719
00:37:11,632 --> 00:37:15,836
只要选中的项大于或
等于2就要继续执行这个代码


720
00:37:17,171 --> 00:37:20,507
然后我会用映射
这样可以获得通过表视图


721
00:37:20,574 --> 00:37:21,875
而不是索引路径所选定的对象


722
00:37:22,743 --> 00:37:25,078
接着用化简函数进行累加


723
00:37:25,846 --> 00:37:28,682
最后
通过数字格式器传递固定在标题部分


724
00:37:29,149 --> 00:37:31,618
如果想在一行内看到同样内容
就是这样


725
00:37:34,288 --> 00:37:35,622
在我运行程序时


726
00:37:39,726 --> 00:37:41,261
就会做累加并把结果放在顶部


727
00:37:42,062 --> 00:37:47,034
这样显示映射和化简会使与支持表视图
的项一起配合会更容易些


728
00:37:56,176 --> 00:37:59,446
好 总之 


729
00:38:00,314 --> 00:38:03,450
我希望大家发现使用Swift
会有很多好处


730
00:38:03,517 --> 00:38:06,053
甚至可以和现有的
Objective-C项目配合使用


731
00:38:06,119 --> 00:38:08,922
这并不难 而且还有诸多好处


732
00:38:09,489 --> 00:38:11,225
大家不必把任何现有代码都扔掉


733
00:38:11,291 --> 00:38:15,996
而且会习惯使用这些现代的强大技术
例如化简和映射


734
00:38:16,063 --> 00:38:17,631
和这些功能强大的结构等等 


735
00:38:18,532 --> 00:38:20,267
若想了解更多详情可以来实验室找我们


736
00:38:20,334 --> 00:38:22,669
查看文档资料访问开发人员论坛


737
00:38:23,003 --> 00:38:24,238
给斯特凡发邮件


738
00:38:24,304 --> 00:38:25,205
他喜欢收邮件


739
00:38:25,272 --> 00:38:27,274
你可以告诉他大会开的非常好
就行了


740
00:38:27,741 --> 00:38:29,810
这么说 我会非常感谢你
希望大家喜欢这次大会

