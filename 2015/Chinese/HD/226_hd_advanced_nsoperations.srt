1
00:00:20,087 --> 00:00:24,424
高级 NSOperations
开发WWDC app


2
00:00:32,933 --> 00:00:34,902
早上好
我叫菲利普·豪斯勒


3
00:00:35,002 --> 00:00:37,704
我在框架组
从事Foundation相关工作


4
00:00:38,338 --> 00:00:41,008
今天我们要讲的是
NSOperation


5
00:00:41,208 --> 00:00:42,843
和NSOperation队列


6
00:00:43,477 --> 00:00:46,680
这是两种极其强大的类


7
00:00:46,947 --> 00:00:48,949
可将你的应用


8
00:00:49,283 --> 00:00:54,621
从直线性运行任务


9
00:00:54,688 --> 00:00:57,958
转变成为以目标为导向


10
00:00:58,225 --> 00:01:02,329
和功能异步概念的
混合模式


11
00:01:03,063 --> 00:01:07,267
现在 我很肯定
大家都已经看过这个应用


12
00:01:09,636 --> 00:01:11,338
WWDC应用广泛使用


13
00:01:11,405 --> 00:01:14,641
NSOperation
和NSOperation队列


14
00:01:15,809 --> 00:01:17,544
使我们能够


15
00:01:21,048 --> 00:01:26,220
一直通过从互联网下载内容
与数据库甚至是


16
00:01:26,386 --> 00:01:29,957
出现提醒或展示视频的
概念同步


17
00:01:30,023 --> 00:01:33,360
来完成各种不同的任务


18
00:01:33,961 --> 00:01:35,896
大卫·德龙将带我们深入了解


19
00:01:36,330 --> 00:01:39,299
NSOperation
和NSOperation队列


20
00:01:39,499 --> 00:01:43,971
以及如何使用它们
执行实现WWDC应用


21
00:01:44,171 --> 00:01:45,572
大卫


22
00:01:54,181 --> 00:01:55,015e
菲利普


23
00:02:01,722 --> 00:02:05,959
我叫大卫·德龙
我是Apple的框架专员


24
00:02:06,159 --> 00:02:07,995
同时
我也是WWDC应用的首席工程师


25
00:02:08,061 --> 00:02:11,131
大家对WWDC应用应该都很了解了吧


26
00:02:13,267 --> 00:02:15,202
今天 我们会讲到WWDC应用


27
00:02:15,269 --> 00:02:16,770
和NSOperation


28
00:02:16,904 --> 00:02:19,473
三个主要方面


29
00:02:20,140 --> 00:02:23,310
首先 我们回顾一下
NSOperation的主要概念


30
00:02:23,510 --> 00:02:26,580
如何理解它的API


31
00:02:26,647 --> 00:02:28,382
以及充分利用
它的强大的状态机的优势


32
00:02:29,283 --> 00:02:32,619
然后 我们将看看除了基础知识外


33
00:02:32,686 --> 00:02:35,889
WWDC应用还面临的挑战


34
00:02:36,290 --> 00:02:37,491
以及我们如何解决这些挑战


35
00:02:38,192 --> 00:02:41,128
最后 我们会讲讲


36
00:02:41,428 --> 00:02:42,863
部分已经提供给你们的样品代码


37
00:02:46,366 --> 00:02:48,969
首先 我们来看看一些核心概念


38
00:02:53,106 --> 00:02:55,175
不管任何时候
一旦你用了NSOperation


39
00:02:55,242 --> 00:02:58,011
你也总是会用到
NSOperation队列


40
00:02:58,879 --> 00:03:01,448
关于NSOperation队列


41
00:03:01,748 --> 00:03:04,351
可以说其实就是一个高级调度队列


42
00:03:04,985 --> 00:03:07,554
相信通过使用多线程优化技术


43
00:03:07,654 --> 00:03:09,423
你们对调度队列都很熟悉了


44
00:03:10,390 --> 00:03:13,460
现在 我们还提供基于
NSOperation队列的包装器


45
00:03:13,660 --> 00:03:15,529
然我们可以获得一些功能


46
00:03:17,064 --> 00:03:18,131
比如说


47
00:03:20,667 --> 00:03:24,471
NSOperation队列
可以很容易取消


48
00:03:24,538 --> 00:03:27,808
还未执行的操作


49
00:03:28,675 --> 00:03:31,578
虽然你可以通过调度块来取消


50
00:03:31,945 --> 00:03:33,380
这是很机智的做法


51
00:03:33,680 --> 00:03:36,216
但是NSOperation队列
可以让操作更简单


52
00:03:39,052 --> 00:03:39,887
另一个


53
00:03:39,953 --> 00:03:42,089
你可从NSOperation
队列获得的是


54
00:03:42,155 --> 00:03:44,424
一个属性 叫做最大并行操作计数


55
00:03:45,058 --> 00:03:47,427
为更好的理解它


56
00:03:47,494 --> 00:03:48,729
我们先来看一个小动画


57
00:03:52,165 --> 00:03:54,635
若将NSOperation队列的


58
00:03:54,701 --> 00:03:57,037
最大并行操作计数设为1


59
00:03:58,038 --> 00:03:58,972
基本上


60
00:03:59,039 --> 00:04:00,908
就可以将NSOperation队列


61
00:04:00,974 --> 00:04:02,509
做成一个串行操作队列


62
00:04:04,278 --> 00:04:07,548
在队列中加载多个操作


63
00:04:09,349 --> 00:04:12,219
最大并行操作计数为1时


64
00:04:12,753 --> 00:04:15,522
队列将一个一个完成操作


65
00:04:15,822 --> 00:04:17,156
并按照顺序执行


66
00:04:17,791 --> 00:04:20,459
在前一个操作未完成前


67
00:04:20,594 --> 00:04:22,362
下个操作是无法开始的


68
00:04:23,564 --> 00:04:24,731
这是一个串行队列


69
00:04:27,835 --> 00:04:30,137
可是 通过默认


70
00:04:30,204 --> 00:04:32,439
这个属性的数值是默认数值


71
00:04:32,940 --> 00:04:35,776
意思是说和系统允许的一样多


72
00:04:36,443 --> 00:04:41,815
也就是说操作队列
可以同时执行多重操作


73
00:04:41,882 --> 00:04:45,085
正如系统资源所允许的那样


74
00:04:46,520 --> 00:04:48,088
在这个案例中


75
00:04:48,155 --> 00:04:51,592
操作队列可能一次执行
两个操作


76
00:04:53,627 --> 00:04:56,230
可以改变像这个操作队列的
行为的能力


77
00:04:56,296 --> 00:04:58,198
可以说是非常强大的


78
00:04:58,498 --> 00:05:00,868
在操作队列创建时


79
00:05:00,968 --> 00:05:02,102
我们并不需要做决定


80
00:05:07,841 --> 00:05:09,843
这就是NSOperation队列


81
00:05:10,477 --> 00:05:12,379
现在来看NSOperation


82
00:05:14,281 --> 00:05:17,551
既然队列是调度队列之外的
高级包装器


83
00:05:17,951 --> 00:05:19,920
我们也可以将NSOperation


84
00:05:19,987 --> 00:05:22,689
理解成是调度块之外的
高级包装器


85
00:05:24,424 --> 00:05:25,626
现在 一般来说


86
00:05:25,692 --> 00:05:28,662
NSOperation运行时间


87
00:05:28,729 --> 00:05:30,931
比块的运行时间
稍微多了些


88
00:05:31,798 --> 00:05:34,801
块的执行通常只需几纳秒


89
00:05:34,868 --> 00:05:37,371
甚至是毫秒


90
00:05:38,372 --> 00:05:42,309
换句话说NSOperation
花费更长的时间


91
00:05:42,376 --> 00:05:45,145
从数毫秒甚至到数分钟


92
00:05:45,245 --> 00:05:46,680
随后我们会讲到这点


93
00:05:49,183 --> 00:05:51,885
NSOperation
另一个很棒的地方是


94
00:05:51,985 --> 00:05:55,522
因为它是一个类
可以被划分成子类


95
00:05:55,722 --> 00:05:59,159
你也可以自定义它的执行逻辑


96
00:06:00,360 --> 00:06:02,496
为将NSOperation
划分为子类


97
00:06:03,030 --> 00:06:04,798
我们来看下它的生命周期


98
00:06:06,099 --> 00:06:08,068
当你创建NSOperation时


99
00:06:09,636 --> 00:06:11,338
它总是从一个被称为


100
00:06:12,739 --> 00:06:14,107
待定状态的状态中
开始


101
00:06:14,274 --> 00:06:16,510
所以 当它被初始化


102
00:06:16,844 --> 00:06:19,980
并被放到操作队列时
这就是操作


103
00:06:21,515 --> 00:06:22,649
现在 在某一时刻


104
00:06:23,183 --> 00:06:24,518
操作已准备好可以开始执行


105
00:06:24,751 --> 00:06:26,253
它进入就绪状态


106
00:06:26,320 --> 00:06:29,723
准备就绪后


107
00:06:30,457 --> 00:06:32,626
操作队列将完成队列排列


108
00:06:32,693 --> 00:06:34,261
并开始执行


109
00:06:34,895 --> 00:06:38,632
正如我所说的
这执行可能用掉数毫秒


110
00:06:38,699 --> 00:06:40,467
或数分钟 甚至更长时间


111
00:06:44,738 --> 00:06:46,340
执行结束后


112
00:06:47,774 --> 00:06:51,311
操作进入完成状态
它的完成状态


113
00:06:52,679 --> 00:06:53,614
非常的简单


114
00:06:55,649 --> 00:06:57,584
操作可以做的另一件事是


115
00:06:57,651 --> 00:06:58,952
可以在任何时候


116
00:06:59,620 --> 00:07:01,555
进入取消状态


117
00:07:02,923 --> 00:07:04,625
我们来看看取消


118
00:07:08,762 --> 00:07:11,431
NSOperation中的
取消被定义为


119
00:07:11,498 --> 00:07:14,434
一种简单的布尔属性被取消


120
00:07:15,235 --> 00:07:17,638
理解这个属性的关键点是


121
00:07:18,138 --> 00:07:20,140
它只改变


122
00:07:20,207 --> 00:07:21,542
属性的状态


123
00:07:21,909 --> 00:07:24,211
当你取消操作时
所出现的只是


124
00:07:24,278 --> 00:07:26,413
布尔数值快速翻动


125
00:07:28,182 --> 00:07:30,651
当你在划分
NSOperation子类时


126
00:07:30,717 --> 00:07:32,819
取消NSOperation
意味着什么


127
00:07:32,886 --> 00:07:35,622
取决于你的意图是什么


128
00:07:36,323 --> 00:07:37,191
比如说


129
00:07:37,858 --> 00:07:40,527
你的操作正在执行网络任务


130
00:07:40,594 --> 00:07:42,863
取消操作意味着


131
00:07:42,930 --> 00:07:46,500
取消网络通信


132
00:07:47,534 --> 00:07:49,036
又或许


133
00:07:49,102 --> 00:07:51,638
你的操作在执行一些数据处理


134
00:07:51,939 --> 00:07:54,241
取消操作


135
00:07:54,308 --> 00:07:56,710
可能就是放弃处理


136
00:07:57,411 --> 00:07:59,479
所以当你划分
NSOperation子类时


137
00:07:59,646 --> 00:08:02,015
务必观察数值变化


138
00:08:02,082 --> 00:08:05,085
并在需要作出反应时
做出正确的反应


139
00:08:07,621 --> 00:08:08,755
关于取消 你还需要知道


140
00:08:08,822 --> 00:08:11,825
它对竞态条件很敏感


141
00:08:13,260 --> 00:08:14,294
这是什么意思呢


142
00:08:14,628 --> 00:08:17,731
试想一下
有个在后台执行的操作


143
00:08:18,465 --> 00:08:20,601
或许在你的UI中


144
00:08:20,667 --> 00:08:22,069
有个取消按钮


145
00:08:22,135 --> 00:08:23,570
可以取消这个操作


146
00:08:25,172 --> 00:08:27,040
若用户轻敲取消按钮


147
00:08:27,307 --> 00:08:29,643
它需要一点时间


148
00:08:29,710 --> 00:08:33,113
将取消信息从主队列


149
00:08:33,746 --> 00:08:35,282
传递到后台的操作中


150
00:08:36,450 --> 00:08:39,285
若在那段传递时间里


151
00:08:39,352 --> 00:08:41,989
你的操作完成执行


152
00:08:42,655 --> 00:08:45,225
那么你的操作将无法被取消


153
00:08:45,492 --> 00:08:48,362
因为一个操作


154
00:08:48,662 --> 00:08:49,997
无法从完成状态回到取消状态


155
00:08:51,131 --> 00:08:54,468
所以知道这点很重要


156
00:08:54,535 --> 00:08:57,471
你试图取消操作


157
00:08:57,771 --> 00:08:59,439
但事实上 有些情况无法取消


158
00:09:00,941 --> 00:09:04,044
然而 如果你不需要取消操作


159
00:09:04,378 --> 00:09:05,946
那就很简单了


160
00:09:06,446 --> 00:09:08,715
你所需做的 只是调用取消方法


161
00:09:11,185 --> 00:09:12,686
这就是取消


162
00:09:14,354 --> 00:09:16,490
现在来看看另一个有趣的状态


163
00:09:17,257 --> 00:09:18,425
叫做就绪


164
00:09:20,894 --> 00:09:24,831
NSOperation的准备
就绪就像取消一样


165
00:09:25,199 --> 00:09:28,368
被定义成一种简单的布尔属性
即准备就绪


166
00:09:29,803 --> 00:09:31,438
这个属性的意思是


167
00:09:31,839 --> 00:09:34,508
操作已准备好可以执行了


168
00:09:35,375 --> 00:09:36,877
我们来看看


169
00:09:36,944 --> 00:09:40,280
它如何与操作队列中的
操作相互作用


170
00:09:41,648 --> 00:09:44,551
再一次
我们有了串行操作队列


171
00:09:45,953 --> 00:09:48,055
载入多个操作


172
00:09:48,121 --> 00:09:51,024
所有操作都处在
最初的蓝色待定状态


173
00:09:52,226 --> 00:09:54,127
尽管 比如 在这个案例中


174
00:09:54,328 --> 00:09:58,632
第四个操作也在队列里


175
00:09:58,699 --> 00:10:02,936
但是进入就绪状态的
第一个操作


176
00:10:03,070 --> 00:10:06,340
才是即将被执行的第一个操作


177
00:10:06,940 --> 00:10:09,943
所以一旦操作准备就绪
它就开始执行


178
00:10:11,411 --> 00:10:14,281
随后 当其他操作准备就绪


179
00:10:14,848 --> 00:10:17,518
它们将推进队列 并被执行


180
00:10:19,052 --> 00:10:21,088
在这个案例中
因为这是一个串行队列


181
00:10:21,154 --> 00:10:25,559
一次只能执行一个


182
00:10:25,692 --> 00:10:28,262
若两个操作同时准备就绪


183
00:10:28,829 --> 00:10:31,131
拥有较高优先权的操作
获得较早执行顺序


184
00:10:31,532 --> 00:10:33,333
随后才是优先权较低的那个


185
00:10:33,934 --> 00:10:37,137
当其他操作也准备就绪了


186
00:10:37,404 --> 00:10:39,973
它们也将赢得队列
并被执行


187
00:10:42,042 --> 00:10:43,343
以上简要介绍了准备就绪


188
00:10:46,180 --> 00:10:47,548
那我们可以用它来做什么呢


189
00:10:49,383 --> 00:10:51,919
我们可以用它来创建相关性


190
00:10:53,086 --> 00:10:57,090
相关性是用来表达


191
00:10:57,491 --> 00:10:59,626
操作的严格排序的一种方法


192
00:10:59,693 --> 00:11:03,163
我们要先执行这个
然后执行那个


193
00:11:07,968 --> 00:11:10,170
相关性灵活的地方在于


194
00:11:10,604 --> 00:11:12,105
它提供了


195
00:11:12,172 --> 00:11:16,577
准备就绪操作的基础定义


196
00:11:18,612 --> 00:11:19,847
通过默认设置


197
00:11:20,414 --> 00:11:22,583
当操作的相关性完成执行时


198
00:11:22,649 --> 00:11:25,452
操作也准备就绪


199
00:11:25,519 --> 00:11:27,521
该行为是自动的


200
00:11:30,090 --> 00:11:33,060
相关性另一个灵活的地方在于


201
00:11:33,827 --> 00:11:36,563
它们不受操作队列的限制


202
00:11:36,797 --> 00:11:37,631
这是什么意思呢


203
00:11:38,365 --> 00:11:41,535
若你的应用中有两个操作队列


204
00:11:43,103 --> 00:11:45,372
第一个队列中的操作


205
00:11:45,439 --> 00:11:49,009
可以取决于
第二个队列中的操作


206
00:11:49,443 --> 00:11:50,811
随后我们会说说


207
00:11:50,878 --> 00:11:54,114
它如何让
一些真正强大的模态成为可能


208
00:11:55,315 --> 00:11:57,851
现在 在你的操作中创建相关性


209
00:11:58,285 --> 00:11:59,887
很简单


210
00:12:00,654 --> 00:12:04,224
我所需做的是
使用增加相关性方法


211
00:12:04,658 --> 00:12:05,626
在这个案例中


212
00:12:06,026 --> 00:12:11,999
操作B将取决于
操作A的成功执行


213
00:12:12,499 --> 00:12:17,571
操作B将等到操作A执行
完毕后才开始执行


214
00:12:18,639 --> 00:12:19,907
这是确定的


215
00:12:22,242 --> 00:12:26,713
关于相关性 我们会碰到一些问题


216
00:12:27,314 --> 00:12:29,149
比如操作停顿


217
00:12:30,350 --> 00:12:32,219
如果我们有操作A


218
00:12:32,719 --> 00:12:37,257
和取决于操作A执行的操作B


219
00:12:37,991 --> 00:12:38,926
这没有问题


220
00:12:39,826 --> 00:12:45,832
然而 要是我无意中
让A也取决于B


221
00:12:46,767 --> 00:12:49,736
那么这两个操作将无法执行


222
00:12:50,037 --> 00:12:52,739
因为它们彼此
都在等待对方完成


223
00:12:52,806 --> 00:12:56,410
既然都在等 
那也就是没有开始了


224
00:12:57,277 --> 00:12:58,946
所以 当你在你的应用中


225
00:12:59,012 --> 00:13:01,682
创建相关性时 不要这么做


226
00:13:05,319 --> 00:13:08,922
现在WWDC应用到处都在用相关性


227
00:13:09,723 --> 00:13:13,293
一个很简单的例子
当你在你的app上


228
00:13:13,360 --> 00:13:16,396
点击增加到收藏夹按钮时
会发生什么


229
00:13:16,563 --> 00:13:18,599
这个很可能你们都做过


230
00:13:20,634 --> 00:13:21,768
当你点击按钮


231
00:13:22,336 --> 00:13:24,304
我们先首先创建一个操作


232
00:13:24,371 --> 00:13:25,572
叫做登录操作


233
00:13:25,672 --> 00:13:30,077
这个操作可确保你


234
00:13:30,143 --> 00:13:33,547
使用开发者的名字和密码
登录到app上


235
00:13:34,081 --> 00:13:39,319
接下来
我们将创建另一个操作


236
00:13:39,953 --> 00:13:41,355
叫做用户信息操作


237
00:13:42,089 --> 00:13:45,158
这个操作确保
你的用户名和密码


238
00:13:45,225 --> 00:13:48,929
比如说 就是开发者的用户名和密码


239
00:13:48,996 --> 00:13:53,033
而不是iTunes用户名和密码


240
00:13:53,834 --> 00:13:57,037
这样你的Apple ID
就是开发者AppleID了


241
00:13:59,406 --> 00:14:02,176
现在 WWDC应用的收藏夹


242
00:14:02,242 --> 00:14:03,477
保存在CloudKit中


243
00:14:03,777 --> 00:14:06,246
我就需要另一个操作


244
00:14:06,480 --> 00:14:09,016
确保我们可以获得
你的iCloud账号


245
00:14:09,950 --> 00:14:11,451
这是后台进行的


246
00:14:11,752 --> 00:14:14,054
因为我并未请求允许


247
00:14:14,121 --> 00:14:16,123
查看你在app上的
第一个和最后一个名字


248
00:14:17,291 --> 00:14:19,326
我们需要确保你有一个
iCloud账号


249
00:14:20,093 --> 00:14:21,028
最后


250
00:14:21,828 --> 00:14:24,531
我们创建保存收藏夹操作


251
00:14:24,731 --> 00:14:25,799
这取决于


252
00:14:25,866 --> 00:14:28,936
成功完成
关于你是一名开发者的验证


253
00:14:29,336 --> 00:14:30,971
和成功完成


254
00:14:31,038 --> 00:14:33,006
你拥有iCloud账号的验证


255
00:14:35,409 --> 00:14:36,510
这只是一个简单的例子


256
00:14:37,010 --> 00:14:38,745
我们来看看复杂点的事例


257
00:14:41,548 --> 00:14:44,084
当WWDC应用启动


258
00:14:44,151 --> 00:14:45,953
我们需要一堆的设置


259
00:14:47,020 --> 00:14:50,691
首先我们需要下载
一个小的配置文件


260
00:14:51,225 --> 00:14:52,860
这个文件将提供一些信息


261
00:14:52,926 --> 00:14:53,827
比如


262
00:14:53,894 --> 00:14:56,563
应用的最新支持版本是什么


263
00:14:56,830 --> 00:14:58,866
有什么特性 等等


264
00:15:00,901 --> 00:15:02,903
所以 文件下载后


265
00:15:02,970 --> 00:15:04,638
我们需要检查版本


266
00:15:04,705 --> 00:15:07,341
确保所运行的版本
就是WWDC应用最新版本


267
00:15:08,742 --> 00:15:11,178
app版本检查完毕后


268
00:15:11,645 --> 00:15:14,248
就可以开始下载
一些有用的信息


269
00:15:14,681 --> 00:15:17,184
比如新闻标签里的新闻


270
00:15:17,618 --> 00:15:21,154
发布会时间表


271
00:15:21,221 --> 00:15:22,956
时间表下载后


272
00:15:23,490 --> 00:15:26,093
就可以开始导入
存放在iCloud中的收藏夹了


273
00:15:26,159 --> 00:15:28,729
以及导入提交的反馈信息


274
00:15:28,896 --> 00:15:31,398
在App中可以看到 另外


275
00:15:31,465 --> 00:15:33,400
我们还可以下载视频文件


276
00:15:34,935 --> 00:15:37,971
所有这些均需要
时间表事先准备就绪


277
00:15:39,106 --> 00:15:40,174
最后


278
00:15:41,308 --> 00:15:44,311
我们可以保存
NSManaged对象环境


279
00:15:45,112 --> 00:15:46,847
在这里 我们保存了所有的信息


280
00:15:47,814 --> 00:15:49,783
我们来看看


281
00:15:50,050 --> 00:15:51,919
相关性和操作生命周期


282
00:15:52,653 --> 00:15:55,155
如何影响这些操作的执行


283
00:15:55,522 --> 00:15:56,990
我们要将它们


284
00:15:57,057 --> 00:15:58,992
全部移到设定为待定操作状态


285
00:16:00,027 --> 00:16:01,328
现在


286
00:16:01,395 --> 00:16:04,298
下载app设置的第一个操作
没有相关性


287
00:16:04,565 --> 00:16:06,867
因此它立刻准备就绪 可以执行


288
00:16:07,568 --> 00:16:11,205
我们的操作队列即将完成


289
00:16:11,405 --> 00:16:13,774
开始执行 随后它将完成执行


290
00:16:14,708 --> 00:16:15,742
现在 当它完成时


291
00:16:16,910 --> 00:16:20,414
版本检查操作


292
00:16:20,480 --> 00:16:21,582
也立马准备就绪


293
00:16:22,049 --> 00:16:24,685
推进队列 然后开始执行


294
00:16:27,054 --> 00:16:28,589
当它完成时


295
00:16:28,655 --> 00:16:32,626
第三个操作也同时准备就绪
可以开始执行


296
00:16:34,294 --> 00:16:36,463
它们即将开始执行


297
00:16:37,865 --> 00:16:39,433
当他们完成执行时


298
00:16:40,133 --> 00:16:42,669
越来越多的操作
也准备好可以执行了


299
00:16:43,103 --> 00:16:45,472
它们将推进队列 并开始执行


300
00:16:46,740 --> 00:16:48,842
需要明白和注意的
一件重要事情是


301
00:16:48,909 --> 00:16:51,245
在所有其他操作
全部执行完毕之前


302
00:16:51,612 --> 00:16:53,447
保存环境的操作是


303
00:16:53,580 --> 00:16:58,018
没办法准备就绪 等待执行的


304
00:16:58,719 --> 00:17:02,089
通过使用相关性
可以确保


305
00:17:02,155 --> 00:17:06,292
操作按照正确的顺序进行
不会出现失控的情况


306
00:17:06,926 --> 00:17:08,328
所以现在 这个准备就绪


307
00:17:08,729 --> 00:17:11,198
可以执行 完成了


308
00:17:11,397 --> 00:17:13,099
这样App的启动就可以持续进行


309
00:17:14,233 --> 00:17:16,002
以上就是关于相关性的内容


310
00:17:19,540 --> 00:17:22,742
总的来说NSOperation
是一种极好的方法


311
00:17:22,809 --> 00:17:24,845
可以用来提取代码中的逻辑


312
00:17:26,180 --> 00:17:28,615
通过在操作中放入逻辑


313
00:17:29,216 --> 00:17:33,287
简化逻辑变化


314
00:17:33,353 --> 00:17:36,056
因为我们处理的是单独的工作


315
00:17:36,123 --> 00:17:38,125
很多就像我们处理块一样


316
00:17:39,293 --> 00:17:40,661
作为例子


317
00:17:41,495 --> 00:17:43,530
今年的WWDC应用中


318
00:17:43,597 --> 00:17:47,601
收藏夹和反馈的保存位置


319
00:17:47,668 --> 00:17:50,804
从后端移到CloudKit


320
00:17:51,939 --> 00:17:53,707
此刻 请大家想想


321
00:17:54,041 --> 00:17:58,145
将你的应用从自定义
从你正在使用的任何服务上


322
00:17:58,245 --> 00:18:01,348
转移到CloudKit上
需要做些什么


323
00:18:02,249 --> 00:18:05,219
获得网络通信的
代码的所有地方


324
00:18:05,285 --> 00:18:08,288
服务器供应商复杂事情的
所有相关性


325
00:18:08,355 --> 00:18:12,059
如果你突然对这些变得很恐慌


326
00:18:13,227 --> 00:18:15,462
这就是
应该使用操作了


327
00:18:16,763 --> 00:18:18,265
在WWDC应用中


328
00:18:18,332 --> 00:18:21,602
我们所有的网络通信都在操作之后进行


329
00:18:22,002 --> 00:18:24,238
这意味着后台将从


330
00:18:24,304 --> 00:18:27,374
使用自定义服务
变为使用CloudKit


331
00:18:28,008 --> 00:18:31,411
我们要做的就是
重新编写这四个小的类别


332
00:18:31,612 --> 00:18:33,247
这只需要花费我们不到一天的时间


333
00:18:33,313 --> 00:18:35,849
然后还需要另外几天
来测试我们的改动


334
00:18:36,149 --> 00:18:38,785
这个过程简单但是琐碎


335
00:18:41,388 --> 00:18:43,657
现在 这所有的一切 也许会令你疑惑


336
00:18:43,724 --> 00:18:45,359
那多线程优化技术呢


337
00:18:47,628 --> 00:18:50,330
多线程优化技术绝对会占有一席之地


338
00:18:50,664 --> 00:18:52,566
事实上
当你下载一组示例代码做准备时


339
00:18:52,633 --> 00:18:55,736
仔细查看 你会发现


340
00:18:55,802 --> 00:18:59,106
我们在示例代码中
使用了多线程优化技术


341
00:19:00,274 --> 00:19:02,976
当无法完全使用
NSOperation时


342
00:19:03,544 --> 00:19:05,379
比如 任何时候 当你需要


343
00:19:05,445 --> 00:19:09,650
从一个队列到另一个队列调用一个方法


344
00:19:10,217 --> 00:19:12,152
你都不需要将其打包进一个操作中去


345
00:19:12,719 --> 00:19:15,589
你需要更快更简便的方法


346
00:19:16,089 --> 00:19:18,058
如果你使用信号量


347
00:19:18,292 --> 00:19:19,459
或调度组来做实现


348
00:19:19,526 --> 00:19:22,963
这些都很适合使用多线程优化技术


349
00:19:25,299 --> 00:19:27,467
所以 那些就是基础技术


350
00:19:28,735 --> 00:19:29,803
现在看看更高级的技术


351
00:19:32,139 --> 00:19:35,175
现在 我们意识到其中一件事
在WWDC应用中


352
00:19:35,242 --> 00:19:40,147
我们实现了UI交互


353
00:19:40,581 --> 00:19:43,851
但仍需其参与在操作链中


354
00:19:44,351 --> 00:19:45,919
比如 身份验证


355
00:19:45,986 --> 00:19:48,055
我们之前谈论了保存收藏夹


356
00:19:48,689 --> 00:19:50,023
我们需要确保你已经登录了


357
00:19:50,190 --> 00:19:51,325
但如果你没有呢


358
00:19:52,960 --> 00:19:57,564
那么我们意识到
我们可以设置UI元素


359
00:19:57,631 --> 00:20:00,901
UI功能存在于我们的操作之中


360
00:20:01,368 --> 00:20:04,071
比如 在WWDC应用中


361
00:20:04,171 --> 00:20:06,440
向上滑动的身份验证对话框


362
00:20:06,507 --> 00:20:08,642
其实是NSOperation


363
00:20:11,211 --> 00:20:14,481
无论何时 当你通过WWDC观看视频


364
00:20:14,848 --> 00:20:19,553
我们都将其压缩为“观看视频”操作


365
00:20:20,020 --> 00:20:22,723
所以 我们所要做的就是


366
00:20:22,890 --> 00:20:25,192
用适宜的视频资源创立一个操作


367
00:20:25,259 --> 00:20:26,793
并将其放置在我们的操作队列之中


368
00:20:27,060 --> 00:20:29,329
而后一切就都将井然有序了


369
00:20:32,032 --> 00:20:36,904
更甚者当你看见WWDC应用的报警


370
00:20:37,237 --> 00:20:40,140
这也我们将UI放置到


371
00:20:40,207 --> 00:20:43,911
NSOperation内部
的一个良好应用


372
00:20:45,379 --> 00:20:48,649
当我们处理不同模态UI时


373
00:20:48,715 --> 00:20:51,418
我们发现了潜在原则


374
00:20:51,485 --> 00:20:56,023
所以 当一个UI逐步
接管了整个应用的资源


375
00:20:56,156 --> 00:20:59,393
这时候可以进行打包


376
00:20:59,560 --> 00:21:02,329
一起打包进
NSOperation之中


377
00:21:04,231 --> 00:21:05,532
重申一下


378
00:21:05,599 --> 00:21:07,634
当你第一次使用WWDC应用时


379
00:21:08,001 --> 00:21:09,203
你会看见一个对话框


380
00:21:09,670 --> 00:21:12,472
询问我们是否能够收集一些


381
00:21:12,539 --> 00:21:13,774
你使用应用时的简单数据


382
00:21:14,842 --> 00:21:16,410
对话框出现时


383
00:21:17,211 --> 00:21:18,645
这个UI警报管理者


384
00:21:19,012 --> 00:21:21,915
事实上开始在
NSOperation内部运行


385
00:21:24,685 --> 00:21:25,752
或者是登陆页面


386
00:21:25,919 --> 00:21:27,988
如果你尝试添加一些东西到收藏夹


387
00:21:28,055 --> 00:21:29,790
或对某个板块留言反馈


388
00:21:30,691 --> 00:21:32,759
这都是NSOperation


389
00:21:36,997 --> 00:21:38,665
接下来我们会遇见的是


390
00:21:39,066 --> 00:21:42,169
有时我们想执行简单的区块逻辑操作


391
00:21:42,236 --> 00:21:46,273
但我们还想参与


392
00:21:46,340 --> 00:21:50,310
内部的机械操作


393
00:21:50,878 --> 00:21:52,980
所以我们转向区块操作


394
00:21:53,046 --> 00:21:54,281
NS区块操作


395
00:21:54,348 --> 00:21:56,350
以及我们创建的其他自定义操作


396
00:21:58,585 --> 00:22:01,355
这就是一个
NSOperation在执行区块


397
00:22:01,688 --> 00:22:03,090
也许你会问


398
00:22:03,156 --> 00:22:07,094
那么 如果NSOperation
是区块的一个抽象概念


399
00:22:07,728 --> 00:22:09,396
为什么我又会回过头来


400
00:22:09,463 --> 00:22:11,765
在NSOperation
内部使用区块呢


401
00:22:13,066 --> 00:22:14,368
那是因为通过


402
00:22:14,434 --> 00:22:16,470
在NSOperation内部
设置区块


403
00:22:16,737 --> 00:22:20,073
你可以获得


404
00:22:21,141 --> 00:22:23,010
许多NSOperation的好功能


405
00:22:23,076 --> 00:22:25,445
比如相关性


406
00:22:27,247 --> 00:22:29,183
让我们看看我们能用它来做些什么


407
00:22:29,650 --> 00:22:34,755
看看在WWDC应用中
当你点击反馈按钮时会发生什么


408
00:22:38,659 --> 00:22:40,327
好的 离开反馈按钮


409
00:22:42,362 --> 00:22:43,931
想执行一个segue


410
00:22:44,164 --> 00:22:46,567
想呈现一个视图管理器


411
00:22:46,633 --> 00:22:52,472
好让你给出五颗星表示非常满意
四颗星表示满意


412
00:22:54,341 --> 00:22:55,843
我们会执行这个segue


413
00:22:56,176 --> 00:22:58,946
所以我们将这个
segue设置在区块里面


414
00:22:59,246 --> 00:23:00,747
然后将这个区块


415
00:23:01,081 --> 00:23:03,383
放置进区块操作


416
00:23:04,785 --> 00:23:08,922
现在我们允许你离开反馈
如果你已经注册完这个应用


417
00:23:09,389 --> 00:23:13,760
所以我们需要验证
用你的开发者账号已经登录


418
00:23:13,827 --> 00:23:15,796
就像我们添加收藏夹时做的那样


419
00:23:17,431 --> 00:23:20,634
为了验证你拥有一个开发者账号


420
00:23:20,801 --> 00:23:22,636
我们需要确定你已经成功登录


421
00:23:24,671 --> 00:23:30,043
所以通过执行区块
操作内部的segue


422
00:23:30,577 --> 00:23:32,145
我们能保证


423
00:23:32,913 --> 00:23:35,916
在你登录之后


424
00:23:36,717 --> 00:23:38,552
不会再呈现登录页面


425
00:23:40,454 --> 00:23:42,256
这是非常强大的功能


426
00:23:42,623 --> 00:23:45,058
我们在描述一个非常复杂的行为


427
00:23:45,125 --> 00:23:47,861
一系列的事情


428
00:23:48,061 --> 00:23:50,531
都是依靠使用操作和相关性


429
00:23:53,066 --> 00:23:55,502
在我们编写WWDC应用过程中


430
00:23:55,569 --> 00:23:58,438
我们注意到在某些情况


431
00:23:58,505 --> 00:24:00,841
我们在重复大量的同样操作


432
00:24:00,941 --> 00:24:03,477
比如 我们已经看到


433
00:24:03,544 --> 00:24:07,414
注册和用户信息操作过几次了


434
00:24:09,650 --> 00:24:12,052
那么我们就想如果能


435
00:24:12,119 --> 00:24:14,521
创造一种自动操作方法


436
00:24:14,588 --> 00:24:15,722
不是很好吗


437
00:24:16,857 --> 00:24:19,193
所以我们提出一种方法


438
00:24:19,259 --> 00:24:21,762
形成其相关的操作


439
00:24:22,596 --> 00:24:24,665
换言之 我们想表达


440
00:24:24,731 --> 00:24:28,001
就是我们不想执行那些总是


441
00:24:28,202 --> 00:24:31,572
需要执行的事


442
00:24:32,873 --> 00:24:34,741
所以 让我们在此看看


443
00:24:34,975 --> 00:24:36,643
收藏夹和Cloudkit


444
00:24:37,845 --> 00:24:39,413
或下载一个通行证


445
00:24:40,013 --> 00:24:41,682
亦或看看


446
00:24:41,748 --> 00:24:44,551
WWDC应用中需要登录的情况


447
00:24:47,788 --> 00:24:50,424
所以 当你点击“添加收藏夹”按钮时


448
00:24:50,824 --> 00:24:55,162
我们做的就是常见一个单一操作


449
00:24:55,562 --> 00:24:56,697
来添加收藏夹


450
00:24:57,064 --> 00:25:00,234
这将打包某些信息


451
00:25:01,001 --> 00:25:02,302
如这个会议的标志


452
00:25:02,369 --> 00:25:05,305
以及你是否想添加到收藏夹或进行移除


453
00:25:05,372 --> 00:25:07,074
一个布尔标识符


454
00:25:08,976 --> 00:25:11,578
现在 这个“收藏”操作


455
00:25:11,645 --> 00:25:14,081
需要获得允许才能执行


456
00:25:14,615 --> 00:25:17,885
所以它自动的形成了两个相关性


457
00:25:18,986 --> 00:25:21,421
一个用来确认你是开发者


458
00:25:21,488 --> 00:25:23,624
另一个保证我们获得iCloud账号


459
00:25:26,093 --> 00:25:29,663
现在 这个操作保证了


460
00:25:29,730 --> 00:25:33,166
你作为开发者能确保登录账号


461
00:25:33,600 --> 00:25:36,770
所以形成了相关性


462
00:25:37,638 --> 00:25:39,039
从而确保你登录成功


463
00:25:39,806 --> 00:25:42,409
这样我们能够


464
00:25:43,243 --> 00:25:45,212
简单保存应用密码


465
00:25:45,279 --> 00:25:47,748
我们只需要创立一个单一操作


466
00:25:48,515 --> 00:25:51,318
然后它会自动形成相关性


467
00:25:51,785 --> 00:25:55,822
可能稍后 如果我们想要移除代码


468
00:25:56,590 --> 00:25:58,625
那么需要登录才能添加收藏夹


469
00:25:58,959 --> 00:26:01,128
我们只需移除一小段


470
00:26:01,461 --> 00:26:04,498
执行收藏操作的代码


471
00:26:04,565 --> 00:26:07,234
那么该相关性就被移除了


472
00:26:07,301 --> 00:26:10,671
这样就移除了整个应用中的相关性


473
00:26:11,305 --> 00:26:13,373
我们并不需要检查


474
00:26:13,440 --> 00:26:15,209
每一个“添加收藏”位置


475
00:26:15,509 --> 00:26:16,677
并改写它们的代码


476
00:26:23,050 --> 00:26:25,319
现在 我们还想要确认


477
00:26:26,153 --> 00:26:28,655
其他条件也得到满足


478
00:26:30,224 --> 00:26:33,760
我们需要能够将准备状态进行扩展


479
00:26:34,161 --> 00:26:37,364
在允许执行操作的情况下


480
00:26:37,664 --> 00:26:39,366
进行扩展


481
00:26:40,267 --> 00:26:42,603
我们可以举出一些示例


482
00:26:43,737 --> 00:26:47,541
比如我们只想在确实连接到网络的情况
下才执行操作


483
00:26:47,741 --> 00:26:50,010
比如 如果你尝试


484
00:26:50,077 --> 00:26:52,479
在手机处于飞行模式
的情况下添加收藏夹


485
00:26:52,546 --> 00:26:55,449
当然 我们不会
使用执行CloudKit操作


486
00:26:58,418 --> 00:27:01,855
我们还想要确保


487
00:27:01,989 --> 00:27:04,625
在抵达某个位置后执行一个操作


488
00:27:05,492 --> 00:27:07,728
那么 我们需要有能够
表达该意图的方式


489
00:27:11,465 --> 00:27:14,134
又或者 我们只想
在实际登录到app后


490
00:27:14,201 --> 00:27:17,070
才执行特定的操作


491
00:27:18,972 --> 00:27:20,607
因此 通过扩展这个概念


492
00:27:20,674 --> 00:27:23,243
让操作已经准备就绪


493
00:27:24,044 --> 00:27:26,480
我们可以更有效地执行操作


494
00:27:27,981 --> 00:27:31,818
因此希望大家不会遇到这样的错误


495
00:27:32,386 --> 00:27:34,955
如果遇到了 说明操作出错了


496
00:27:35,189 --> 00:27:38,625
因为操作还未准备就绪执行


497
00:27:39,660 --> 00:27:41,862
这种情况下


498
00:27:41,929 --> 00:27:42,996
由于无法连接到网络


499
00:27:44,798 --> 00:27:47,334
因此 扩展该准备状态


500
00:27:47,401 --> 00:27:48,802
非常有用


501
00:27:53,240 --> 00:27:56,677
另外 我们还有一些操作


502
00:27:56,743 --> 00:27:59,346
我们可以同时执行


503
00:28:00,280 --> 00:28:02,950
因此 我们想如果需要不断


504
00:28:03,016 --> 00:28:05,986
创建相同的操作序列的话
那就很麻烦了


505
00:28:06,053 --> 00:28:08,455
是否可以开发一个操作


506
00:28:08,789 --> 00:28:10,324
然后在其之下


507
00:28:10,390 --> 00:28:12,926
创建相同的操作序列？


508
00:28:13,861 --> 00:28:15,562
一个普通例子是


509
00:28:15,629 --> 00:28:18,332
下载文件然后


510
00:28:18,398 --> 00:28:21,502
另存到本地空间


511
00:28:22,836 --> 00:28:24,505
我知道大家


512
00:28:24,571 --> 00:28:25,973
对这个非常熟悉了


513
00:28:26,406 --> 00:28:29,343
那么 让我们看看
我们可以如何合并操作


514
00:28:30,010 --> 00:28:31,011
从而简化流程


515
00:28:31,745 --> 00:28:34,615
假设我们有一个一般类的数据操作


516
00:28:34,681 --> 00:28:36,316
然后它和其他东西


517
00:28:36,383 --> 00:28:38,185
互相关联


518
00:28:38,952 --> 00:28:41,188
现在我们想植入一个想法


519
00:28:41,855 --> 00:28:44,391
好的 我们想要它做两件事


520
00:28:44,458 --> 00:28:48,262
首先要包括另一个
NSOperation


521
00:28:48,762 --> 00:28:51,899
然后这个操作要执行下载任务


522
00:28:52,666 --> 00:28:55,002
这是个简单独立的工作


523
00:28:56,670 --> 00:28:59,306
然后它会创建第二个操作


524
00:29:00,040 --> 00:29:04,211
用于下载另存


525
00:29:04,478 --> 00:29:05,612
然后和下载操作相互关联


526
00:29:05,679 --> 00:29:08,482
这样另存操作总会在下载之后执行


527
00:29:09,483 --> 00:29:12,786
现在 通过将这两个操作打包


528
00:29:12,853 --> 00:29:14,788
成一个更大的操作


529
00:29:15,389 --> 00:29:17,691
我们可以轻松修改


530
00:29:18,158 --> 00:29:20,894
我们数据的来源


531
00:29:21,328 --> 00:29:22,663
数据的格式


532
00:29:22,930 --> 00:29:24,631
甚至是处理错误的方式


533
00:29:25,465 --> 00:29:27,668
而我们只需在一个地方


534
00:29:28,135 --> 00:29:30,671
修改即可


535
00:29:30,737 --> 00:29:33,941
在输入操作中修改
因为这里是app唯一可识别的位置


536
00:29:36,643 --> 00:29:39,546
现在 你没有一定要提前清楚


537
00:29:39,813 --> 00:29:43,317
你需要执行的操作是什么


538
00:29:44,751 --> 00:29:46,553
在WWDC应用中


539
00:29:46,620 --> 00:29:49,089
在编译时间 我们无法知道


540
00:29:49,489 --> 00:29:52,693
保存到CloudKit上的收藏夹
有多少内容


541
00:29:53,126 --> 00:29:54,228
这样我们需要一种方式


542
00:29:54,294 --> 00:29:57,431
让我们可以进行动态操作编辑


543
00:30:00,300 --> 00:30:04,671
因此 我们开发了封装器
称之为抓取收藏夹操作


544
00:30:05,539 --> 00:30:08,475
而且由于我们正在
包装器下使用CloudKit


545
00:30:08,709 --> 00:30:11,812
我们需要执行CK请求操作


546
00:30:12,646 --> 00:30:15,516
因为CloudKit是基于
NSOperation开发的


547
00:30:16,750 --> 00:30:18,819
这样 我们先要执行第一个请求操作


548
00:30:18,886 --> 00:30:21,688
也许WWDC上有你收藏的一个会议


549
00:30:22,155 --> 00:30:24,725
因此该操作会指向那里


550
00:30:24,892 --> 00:30:27,394
并获取更多的收藏内容


551
00:30:27,995 --> 00:30:31,231
因此 我们现在要继续执行请求操作


552
00:30:31,565 --> 00:30:33,367
直到我们接收到反馈


553
00:30:33,433 --> 00:30:35,702
说明我们已经全部获得了


554
00:30:36,904 --> 00:30:40,307
因此 通过使用组合模式


555
00:30:40,607 --> 00:30:44,478
我们仍可以通过一个“抓取收藏夹”


556
00:30:44,545 --> 00:30:48,248
操作来表达我们的操作链


557
00:30:48,782 --> 00:30:50,250
但是在其之下


558
00:30:50,717 --> 00:30:55,222
实际上是按次序执行多个操作


559
00:30:57,791 --> 00:30:59,993
现在 在代码中的情况看起来是这样的


560
00:31:01,128 --> 00:31:03,497
我们的操作有一种执行方法


561
00:31:03,564 --> 00:31:05,766
而且这是所有操作的起点


562
00:31:06,800 --> 00:31:07,935
因此第一次


563
00:31:08,535 --> 00:31:12,005
抓取收藏夹
操作开始执行后


564
00:31:12,272 --> 00:31:14,107
这里会进行初始请求


565
00:31:14,575 --> 00:31:18,512
我们要为你查找收藏的会议记录


566
00:31:19,780 --> 00:31:21,748
这样我们会发出请求操作


567
00:31:22,316 --> 00:31:24,885
然后提交给这个方法
称之为执行请求操作


568
00:31:26,453 --> 00:31:28,422
这是执行请求操作


569
00:31:30,023 --> 00:31:32,593
请求操作完成后


570
00:31:32,793 --> 00:31:34,161
我们需要先检查


571
00:31:34,228 --> 00:31:36,163
看看是否有错误


572
00:31:36,396 --> 00:31:38,599
如果有 我们要中止流程先处理错误


573
00:31:40,701 --> 00:31:44,137
如果没有错误 但是存在指针


574
00:31:44,638 --> 00:31:46,440
这是CloudKit
通过指针告诉我们


575
00:31:46,607 --> 00:31:48,976
还有其他有待抓取


576
00:31:49,543 --> 00:31:52,980
那么 我们要使用该指针在序列后


577
00:31:53,046 --> 00:31:55,015
创建下一个CK请求操作


578
00:31:55,816 --> 00:32:00,487
然后进行半递归式调用执行请求操作


579
00:32:00,888 --> 00:32:04,558
这是我们执行多个请求操作的方法


580
00:32:06,493 --> 00:32:09,863
另外 如果没有指针或者错误出现


581
00:32:10,097 --> 00:32:13,133
那么是CloudKit
指示我们已经抓取完毕


582
00:32:13,400 --> 00:32:15,736
这样我们可以开始导入


583
00:32:16,970 --> 00:32:18,372
已经下载好的记录了


584
00:32:26,113 --> 00:32:28,649
在开发过程中


585
00:32:28,715 --> 00:32:32,986
有几次我们遇到视图故障


586
00:32:33,720 --> 00:32:35,789
我们认为是视图故障


587
00:32:36,557 --> 00:32:39,326
现在 也许大家都有
在使用app过程中


588
00:32:39,760 --> 00:32:41,128
警告跳出的经历


589
00:32:41,895 --> 00:32:44,064
在你准备点击关闭的时候


590
00:32:44,131 --> 00:32:45,432
另一个警告又跳出来


591
00:32:46,133 --> 00:32:48,402
这时你想 哦 好吧
这是发生了什么呢？


592
00:32:48,802 --> 00:32:50,537
也许又在你要点击关闭的时候


593
00:32:50,737 --> 00:32:52,472
又有一个跳出来


594
00:32:52,539 --> 00:32:55,342
因此画面总是反反复复


595
00:32:55,409 --> 00:32:57,144
你甚至不确定现在看到的是第一个警告


596
00:32:57,211 --> 00:32:59,046
还是第几个警告


597
00:33:00,314 --> 00:33:03,951
我们是如此想要避免
这种令人厌烦的情况


598
00:33:06,186 --> 00:33:07,955
另一个我们想要的是


599
00:33:08,021 --> 00:33:09,923
我们想要确保


600
00:33:10,791 --> 00:33:15,762
你只会一次观看一个视频


601
00:33:15,829 --> 00:33:18,866
这个问题WWDC应用现在还无法明白


602
00:33:18,932 --> 00:33:20,367
如何正确处理


603
00:33:20,434 --> 00:33:23,170
因此我们想要确保无论你做什么


604
00:33:23,670 --> 00:33:25,305
我们都不会允许你这么做


605
00:33:27,908 --> 00:33:29,877
另一个我们想确认的是


606
00:33:29,943 --> 00:33:32,446
我们不会一次试图


607
00:33:32,513 --> 00:33:35,883
加载多个基本数据库


608
00:33:37,384 --> 00:33:41,655
因此 我们想出一个方法
用于描述互斥性


609
00:33:41,955 --> 00:33:47,661
这种方法是在一个时候
只执行一种特定的操作


610
00:33:49,730 --> 00:33:52,599
现在 也许你在想 哇
这个想法真复杂


611
00:33:52,666 --> 00:33:54,501
具体我们如何办到呢


612
00:33:55,802 --> 00:33:57,437
实际上很简单


613
00:33:58,272 --> 00:34:00,040
现在我们回到那个警告的例子


614
00:34:01,508 --> 00:34:04,578
假设我们创建一个操作用于显示警告


615
00:34:04,811 --> 00:34:06,079
并警告用户


616
00:34:06,146 --> 00:34:08,549
然后我们将其放到操作序列中


617
00:34:08,715 --> 00:34:11,251
也许需要等待一下
让其他操作先完成


618
00:34:11,451 --> 00:34:14,721
也许操作已经完成了一半
我们不确定


619
00:34:15,755 --> 00:34:17,090
但之后发生了些事


620
00:34:17,591 --> 00:34:20,793
而且我们决定再创建另一个警告操作


621
00:34:21,594 --> 00:34:23,096
好的 我们要做的就是


622
00:34:23,330 --> 00:34:25,966
让第二个警告操作


623
00:34:26,033 --> 00:34:28,168
与第一个相关联


624
00:34:29,101 --> 00:34:33,841
这正是跨队列相关性
强大之所在


625
00:34:34,708 --> 00:34:36,909
因为不论警告操作


626
00:34:37,010 --> 00:34:40,947
在哪个队列中执行


627
00:34:41,447 --> 00:34:44,885
只要第二个操作与第一个相关


628
00:34:45,418 --> 00:34:52,092
那么第二个操作
只有在第一个操作结束后才可以执行


629
00:34:52,926 --> 00:34:56,362
而且 由于某些奇怪原因


630
00:34:56,429 --> 00:34:58,866
我们决定创建更多的警告操作


631
00:34:59,066 --> 00:35:02,102
更多的警告操作 只要我们设定


632
00:35:02,169 --> 00:35:05,973
下个操作与之前的相关即可


633
00:35:06,039 --> 00:35:10,310
就像一张时间关联表一样


634
00:35:10,811 --> 00:35:14,014
我们可以确保操作


635
00:35:14,081 --> 00:35:15,382
将彼此产生互斥性


636
00:35:16,817 --> 00:35:19,019
真是功能强大啊


637
00:35:20,020 --> 00:35:21,522
通过使用相关性


638
00:35:22,022 --> 00:35:26,260
我们可以确保应用的行为正确


639
00:35:26,527 --> 00:35:29,329
我们可以确保用户


640
00:35:29,396 --> 00:35:30,631
不会同时收到多个警告


641
00:35:30,764 --> 00:35:34,067
我们可以确保用户


642
00:35:34,134 --> 00:35:35,536
不会一次试图观看多个视频


643
00:35:35,836 --> 00:35:40,307
我们可以确保用户


644
00:35:40,374 --> 00:35:42,643
不会同时加载两份数据


645
00:35:45,812 --> 00:35:47,948
因此 以上是我们遇到的一些挑战


646
00:35:48,015 --> 00:35:51,485
并尝试在编写WWDC
用的时候解决


647
00:35:52,052 --> 00:35:53,086
还有更多


648
00:35:54,288 --> 00:35:56,456
但我们认为这些真的很酷


649
00:35:56,857 --> 00:35:58,592
而且我们会想到更为简单的方法


650
00:35:58,659 --> 00:36:00,160
去解决我们遇到的问题


651
00:36:02,129 --> 00:36:04,731
那么 我们现在谈谈样本代码


652
00:36:07,134 --> 00:36:10,237
在WWDC网站上的样本代码部分


653
00:36:10,304 --> 00:36:12,406
你可以找到一段样本代码


654
00:36:12,472 --> 00:36:14,107
叫做高级 NSOperations


655
00:36:14,708 --> 00:36:16,610
这是一个简单的app


656
00:36:16,677 --> 00:36:18,078
用于显示最近的地震


657
00:36:19,012 --> 00:36:20,447
但是这个app是


658
00:36:20,514 --> 00:36:22,716
完全基于NSOperations的


659
00:36:23,417 --> 00:36:25,018
而且该app的操作


660
00:36:25,085 --> 00:36:26,954
是我们之前


661
00:36:27,020 --> 00:36:30,524
从WWDC的app中提取出来


662
00:36:31,158 --> 00:36:32,392
然后放进去的


663
00:36:32,759 --> 00:36:34,561
这个app中的这些代码


664
00:36:34,628 --> 00:36:36,296
实际上已经有好几年的历史了


665
00:36:36,530 --> 00:36:37,497
非常稳定


666
00:36:40,367 --> 00:36:45,205
现在 初级类别就是样本代码


667
00:36:45,639 --> 00:36:49,209
这是NSOperations
的基础子类别


668
00:36:50,110 --> 00:36:52,312
在样本代码中


669
00:36:52,379 --> 00:36:54,381
我们在才操作中加入了两个关键特性


670
00:36:55,682 --> 00:36:56,517
首先


671
00:36:58,085 --> 00:37:00,120
是条件


672
00:37:00,187 --> 00:37:01,421
之后我们会谈谈这点


673
00:37:02,456 --> 00:37:06,159
第二个概念我们称之为“观测器”


674
00:37:07,261 --> 00:37:08,829
现在在样本代码中


675
00:37:08,896 --> 00:37:11,632
我们已经有许多不同种类的操作代码


676
00:37:11,965 --> 00:37:14,635
我们有群操作


677
00:37:14,768 --> 00:37:18,272
方便进行更多的内部操作


678
00:37:19,006 --> 00:37:22,476
另外 在样本代码中
我们还有操作子类别


679
00:37:22,976 --> 00:37:26,013
允许你获取
NSURLSession任务


680
00:37:26,413 --> 00:37:29,082
并在NSOperation
中进行处理


681
00:37:29,349 --> 00:37:33,554
这样你可以让不同任务之间进行关联


682
00:37:33,620 --> 00:37:37,391
或者进行条件设定 或者设置观测器


683
00:37:38,225 --> 00:37:40,994
这里有一个示范操作
用于请求你当前的位置


684
00:37:41,328 --> 00:37:43,096
有时候这非常有用


685
00:37:43,163 --> 00:37:45,399
我们要做的就是稍微等待一下


686
00:37:45,899 --> 00:37:47,234
这里甚至还有一种操作


687
00:37:47,301 --> 00:37:48,836
可以向用户显示


688
00:37:49,002 --> 00:37:50,771
带按钮和块处理程序的警告


689
00:37:52,072 --> 00:37:54,074
因此 NSOperation
的样本代码中


690
00:37:54,141 --> 00:37:56,844
有非常多的子类


691
00:37:58,812 --> 00:38:02,249
现在 操作有了条件的概念


692
00:38:02,583 --> 00:38:05,152
一个条件指的是一个协议


693
00:38:05,219 --> 00:38:07,454
我们定义的协议


694
00:38:07,521 --> 00:38:09,990
这样 对于操作而言


695
00:38:10,691 --> 00:38:13,360
可以表示它是如何生成相关性的


696
00:38:14,928 --> 00:38:17,998
如何定义互斥性
以及如何扩展预备状态概念


697
00:38:19,833 --> 00:38:21,702
这样 我们在样本代码中


698
00:38:21,969 --> 00:38:24,104
提供了一些条件


699
00:38:24,304 --> 00:38:27,241
其中之一是互斥性通用条件


700
00:38:27,841 --> 00:38:29,610
这种条件表示一个操作


701
00:38:29,877 --> 00:38:33,580
与相同类属的其他操作


702
00:38:33,647 --> 00:38:36,116
是互相排斥的


703
00:38:37,284 --> 00:38:40,554
这里我们还有可达性条件


704
00:38:40,621 --> 00:38:42,422
这样通过一行代码


705
00:38:42,589 --> 00:38:44,491
你可以方便地通过操作表达


706
00:38:44,791 --> 00:38:47,361
只有在网速很好的情况下才执行


707
00:38:48,161 --> 00:38:51,498
另外 我们还有非常多的许可类条件


708
00:38:52,199 --> 00:38:53,133
比如


709
00:38:53,200 --> 00:38:56,637
只有在使用特定的Cloudkit
container的情况下


710
00:38:56,703 --> 00:38:57,638
才执行操作


711
00:38:58,071 --> 00:39:00,507
或者当我们使用日历


712
00:39:00,574 --> 00:39:02,843
或者使用照片库
或者使用通讯录


713
00:39:02,910 --> 00:39:05,646
或者其他你设定条件的情况下才执行操
作


714
00:39:07,481 --> 00:39:08,448
这就是条件操作


715
00:39:10,317 --> 00:39:12,920
最后是操作观测器


716
00:39:15,088 --> 00:39:19,426
操作观测器也是一种协议


717
00:39:19,493 --> 00:39:22,829
通过这种方法


718
00:39:22,963 --> 00:39:27,067
在操作过程中


719
00:39:27,134 --> 00:39:28,769
操作会注意重要事件的值


720
00:39:29,102 --> 00:39:31,438
比如开始执行 终止执行


721
00:39:31,738 --> 00:39:34,942
以及如果该操作决定


722
00:39:35,309 --> 00:39:38,645
生成稍后被执行的另一个操作


723
00:39:38,712 --> 00:39:43,150
从而生成一个警告操作


724
00:39:44,885 --> 00:39:48,188
另外我们有许多观测器示例


725
00:39:48,889 --> 00:39:49,756
比如超时


726
00:39:50,724 --> 00:39:53,527
通过在操作中简单加入超时观测器


727
00:39:54,394 --> 00:39:56,964
这样观测器会进行观测确保


728
00:39:57,030 --> 00:39:58,365
操作在你设定的时间范围内


729
00:39:58,432 --> 00:40:00,734
执行完毕


730
00:40:01,134 --> 00:40:02,236
并且 如果超时


731
00:40:02,302 --> 00:40:04,104
那么观测器将自动取消操作


732
00:40:05,739 --> 00:40:08,976
我认为一项利器的是背景观测器


733
00:40:09,409 --> 00:40:12,613
当你将背景观测器
设定到一个操作中后


734
00:40:12,679 --> 00:40:16,583
观测器会观测UI应用的状态


735
00:40:17,117 --> 00:40:18,652
如果应用进入背景


736
00:40:19,353 --> 00:40:21,889
那么观测器将


737
00:40:21,955 --> 00:40:24,625
自动启动背景任务


738
00:40:25,158 --> 00:40:26,827
然后在操作完成后


739
00:40:27,261 --> 00:40:29,029
自动终止任务


740
00:40:29,696 --> 00:40:31,932
这样 如果你正处理某些重要操作


741
00:40:31,999 --> 00:40:34,434
比如也许你正上传数据到服务器


742
00:40:34,501 --> 00:40:36,436
而你不想被终端或者暂停


743
00:40:37,471 --> 00:40:39,206
一个方法是你可以


744
00:40:39,273 --> 00:40:42,142
添加背景观测器到操作中


745
00:40:42,609 --> 00:40:46,079
这样可以确保你在背景
有足够多的时间


746
00:40:46,146 --> 00:40:48,348
这样你可以完成该上传操作


747
00:40:49,917 --> 00:40:52,019
另一种方法很酷


748
00:40:52,085 --> 00:40:54,154
是网络活动指示器观测器


749
00:40:54,888 --> 00:40:57,658
你可以将这个观测器添加到操作中


750
00:40:57,724 --> 00:40:59,126
当其启动后


751
00:40:59,193 --> 00:41:01,795
观测器将在状态栏中


752
00:41:02,596 --> 00:41:07,167
对互动指示器进行数值递增操作


753
00:41:07,234 --> 00:41:08,836
然后当操作停止后


754
00:41:09,203 --> 00:41:10,971
进行数值递减操作


755
00:41:11,305 --> 00:41:15,943
这样你可以同时进行多个网络操作


756
00:41:16,510 --> 00:41:19,413
并且添加其中一个网络指示器


757
00:41:19,479 --> 00:41:21,181
或者观测器后


758
00:41:21,248 --> 00:41:23,317
观测器会自动


759
00:41:23,383 --> 00:41:25,953
显示和隐藏网络活动指示器


760
00:41:26,019 --> 00:41:28,155
从此 管理这种复杂的事情


761
00:41:30,457 --> 00:41:32,793
都可以完全交给操作了


762
00:41:33,126 --> 00:41:35,095
而所有这一切都可以自动进行
实在是酷


763
00:41:35,696 --> 00:41:37,231
另外在样本代码中


764
00:41:37,564 --> 00:41:39,933
我们还提供了其他的观测器


765
00:41:40,000 --> 00:41:43,670
比如能够添加任意代码块
到这三个事件中


766
00:41:43,971 --> 00:41:45,806
然后让其自动重新执行


767
00:41:47,241 --> 00:41:48,909
以上就是样本代码的情况


768
00:41:49,610 --> 00:41:52,713
乍看之下 代码很像一个简单的应用


769
00:41:52,779 --> 00:41:55,849
但是仔细一看 里面很精妙


770
00:41:55,916 --> 00:41:58,385
我真的推荐大家下载看看


771
00:42:00,187 --> 00:42:01,321
那么 总之


772
00:42:02,656 --> 00:42:06,059
使用操作可以对应用
进行逻辑抽象处理


773
00:42:06,593 --> 00:42:11,632
通过在操作中加入你的逻辑
而且之后很容易进行修改


774
00:42:11,832 --> 00:42:15,335
比如我们如何将WWDC应用
跳转到使用CloudKit


775
00:42:15,602 --> 00:42:17,704
这只是一个简单的改变


776
00:42:19,106 --> 00:42:23,777
使用相关性可以表达
应用之间的关系


777
00:42:24,077 --> 00:42:28,382
这样可以很容易
确保特定行为之间的关系


778
00:42:28,515 --> 00:42:30,717
比如A行为之后必须是B行为


779
00:42:34,087 --> 00:42:34,922
另外


780
00:42:35,822 --> 00:42:38,926
操作让你可以描述复杂的行为


781
00:42:39,393 --> 00:42:43,130
比如互斥性或者整合


782
00:42:43,497 --> 00:42:46,200
这对于操作来说很简单


783
00:42:48,569 --> 00:42:52,539
而且NSOperation能够允许
你花费非常少的心思


784
00:42:52,806 --> 00:42:54,875
就能执行非常强大的功能


785
00:42:56,276 --> 00:42:58,245
因此 我们未大家提供了相关的会议


786
00:42:58,645 --> 00:43:00,414
接下来的会议是


787
00:43:01,215 --> 00:43:04,318
“建立响应以及GCD的高效应用”


788
00:43:04,551 --> 00:43:06,653
我们期待大家也参与GCD


789
00:43:06,720 --> 00:43:10,123
这是一项非常好的实用技术


790
00:43:10,190 --> 00:43:12,893
因此 我鼓励大家出席会议
或者观看视频


791
00:43:13,260 --> 00:43:16,096
看看如何在你的应用中使用GCD


792
00:43:16,763 --> 00:43:18,031
另外 如果你想要了解更多


793
00:43:18,098 --> 00:43:21,368
关于我们的框架是如何
使用NSOperation的


794
00:43:21,435 --> 00:43:24,872
你可以查看今年的CloudKit
提示和技巧大会


795
00:43:25,205 --> 00:43:27,941
或者去年的
“高级CloudKit”大会


796
00:43:31,178 --> 00:43:34,381
另外 我们在WWDC网站上
提供了样本代码供大家使用


797
00:43:34,448 --> 00:43:35,782
建议大家去看看


798
00:43:36,450 --> 00:43:40,621
我还想鼓励大家阅读开发者库中的
“线程编辑指导”部分


799
00:43:40,854 --> 00:43:43,290
这里有很多有用的信息


800
00:43:43,524 --> 00:43:45,893
方便大家使用NSOperation


801
00:43:46,360 --> 00:43:49,263
如果你需要任何技术支持


802
00:43:49,396 --> 00:43:51,632
我们建议大家可以在开发者论坛上发帖


803
00:43:51,832 --> 00:43:53,467
请教
或者联系开发者技术支持部


804
00:43:54,902 --> 00:43:57,237
非常谢谢
希望大家继续享受接下来的部分

