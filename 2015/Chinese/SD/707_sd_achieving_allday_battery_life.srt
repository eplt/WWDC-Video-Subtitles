1
00:00:19,319 --> 00:00:24,558
全天电池续航的会议


2
00:00:24,725 --> 00:00:25,626
早上好


3
00:00:30,297 --> 00:00:33,500
感谢您来观看关于
实现全天电池续航的会议


4
00:00:34,101 --> 00:00:36,737
很兴奋能够和您讨论这个领域


5
00:00:37,204 --> 00:00:39,139
我是来自于Core OS
的 強·安德魯斯


6
00:00:39,206 --> 00:00:41,408
同时我的同事
桑仁·斯碧丝也将加入我们


7
00:00:42,910 --> 00:00:46,413
我希望你们所有人
昨天晚上都把手机充满电了


8
00:00:46,480 --> 00:00:48,248
而且在这个早晨不要看它


9
00:00:49,316 --> 00:00:51,218
我们希望你能在当天晚些时候再去看


10
00:00:52,085 --> 00:00:55,189
事实上 我们想让你看到
它比你已经看到它的时间要晚


11
00:00:56,190 --> 00:00:57,357
我们将会讨论


12
00:00:57,891 --> 00:01:01,128
在iOS的环境下如何去实现
全天电池续航的一些具体内容


13
00:01:03,263 --> 00:01:06,166
我们将会谈到
用户对于全天电池续航的期待


14
00:01:07,434 --> 00:01:14,074
计算做出改进后的大致功耗


15
00:01:14,975 --> 00:01:19,112
你在帮助我们实现
全天电池续航中的任务


16
00:01:19,780 --> 00:01:22,249
之后 桑仁 也将会更深入的


17
00:01:22,316 --> 00:01:26,019
指导你们怎样改进程序
从而实现这些目的


18
00:01:27,855 --> 00:01:30,057
先让我们了解一下
究竟什么是电池全天续航


19
00:01:31,925 --> 00:01:36,096
用户在一天中不是一直使用他们的手机
8或者10个小时


20
00:01:36,997 --> 00:01:39,600
他们实际上只是在某个密集的时间
才会使用它


21
00:01:39,666 --> 00:01:42,603
可能是他们在早上上班的时候


22
00:01:43,103 --> 00:01:45,906
然后手机就会被闲置


23
00:01:46,373 --> 00:01:47,975
那么它就可以做一些后台工作


24
00:01:48,041 --> 00:01:51,578
比如维护工作和网络通信
或下载邮件等


25
00:01:53,013 --> 00:01:56,049
这种模式将会持续一整天
伴随着工作负载的激增


26
00:01:56,950 --> 00:01:58,552
随后出现了一段空闲阶段


27
00:02:00,020 --> 00:02:04,124
为了实现全天续航
需要保持一个较低的功耗


28
00:02:06,293 --> 00:02:10,531
因此在一天中平均的功耗都很低


29
00:02:12,900 --> 00:02:17,804
而那就是我们在关注操作系统的过程中
一直去努力追求的目标


30
00:02:20,407 --> 00:02:24,912
因此让我们看一下
计算功耗的基本原理


31
00:02:25,879 --> 00:02:29,082
首先功耗有两个要素 功率和时间


32
00:02:29,883 --> 00:02:32,219
而时间因素经常被忽略


33
00:02:33,820 --> 00:02:39,293
你可以做些耗费很多功率的密集操作


34
00:02:39,893 --> 00:02:41,762
但你需要知道它工作多长时间


35
00:02:43,430 --> 00:02:47,167
如果在待机的状态下
它并不会消耗过多的功率


36
00:02:48,101 --> 00:02:50,704
但是你可以在很长的一段时间内
保持在待机状态


37
00:02:51,638 --> 00:02:55,475
对于我们的设备来说
播放音频是另一项低功率的应用


38
00:02:55,742 --> 00:02:58,045
因此可以提供很长的播放时间


39
00:02:59,112 --> 00:03:02,583
但是当你进一步加强工作负载时


40
00:03:03,116 --> 00:03:07,521
消耗的功率也会随之增加
所以我们才希望你能减少使用设备时间


41
00:03:09,356 --> 00:03:14,161
如果工作负载像空闲状态那样
实现全天续航将会变得非常简单


42
00:03:15,729 --> 00:03:18,265
只要在平均功耗很低的情况下


43
00:03:18,332 --> 00:03:23,337
意味着也可以产生
比较高的功率脉冲


44
00:03:25,138 --> 00:03:27,808
现在我们的设备正在增加动态范围


45
00:03:29,042 --> 00:03:32,279
我们正在开始接近MacBook领域


46
00:03:32,346 --> 00:03:34,815
在这里你可以从系统中获取可观的性能


47
00:03:34,882 --> 00:03:36,416
所以你需要非常小心的去使用它


48
00:03:37,618 --> 00:03:38,685
其它要记住的事情就是


49
00:03:38,752 --> 00:03:40,754
随着我们不断的增加动态范围


50
00:03:41,255 --> 00:03:45,425
每一代的硬件效率也变得更好


51
00:03:45,926 --> 00:03:50,764
因此我们将会给你更好的能力
去实现这些低功耗的操作


52
00:03:51,431 --> 00:03:54,801
但是你也可以为了
实现密集操作或者超爽的用户体验


53
00:03:55,269 --> 00:03:58,238
去使用更高的峰值性能


54
00:04:00,107 --> 00:04:03,310
因此让我们从一个应用程序
生命循环周期的角度去审视它


55
00:04:05,345 --> 00:04:08,982
这幅图中的区域
表示被应用程序所使用的功耗


56
00:04:10,450 --> 00:04:13,253
你启动应用程序时
有些需要进行的工作


57
00:04:14,688 --> 00:04:18,358
比如去初始化应用程序
可能在开始的时候有一些动画


58
00:04:19,091 --> 00:04:23,697
当你的用户与应用程序进行交互时
可以会有一些活动的爆发


59
00:04:24,965 --> 00:04:27,835
你需要记住的是
那样可能需要一些固定的消耗


60
00:04:28,335 --> 00:04:32,840
而且那些功耗正是
被系统和功耗所正使用的


61
00:04:33,340 --> 00:04:35,776
而那时用户的工作负载是最重要的


62
00:04:37,377 --> 00:04:40,214
当用户结束使用应用程序之后


63
00:04:40,380 --> 00:04:44,218
你希望在应用程序
进入后台时可以进行一些操作


64
00:04:44,718 --> 00:04:46,954
然而最终应用程序被暂停了


65
00:04:48,288 --> 00:04:52,759
在这儿我们可以看到
有着固定和动态损耗的时间因素


66
00:04:54,628 --> 00:04:59,099
现在我们也只需要
从一个系统的角度来考虑


67
00:05:00,300 --> 00:05:03,337
那么就让我们看看
系统在待机状态中的情况


68
00:05:05,706 --> 00:05:08,275
在这里绝大部分的组件
都处于睡眠状态的形式下


69
00:05:09,543 --> 00:05:14,214
屏幕是关闭的
内存也处于一种低功耗的


70
00:05:14,982 --> 00:05:17,117
刷新模式下


71
00:05:17,918 --> 00:05:23,056
只有一些无线电在开着
仅允许接收传入的流量或者唤醒系统


72
00:05:24,157 --> 00:05:25,859
这种模式的功耗非常低


73
00:05:27,794 --> 00:05:32,332
然后我们讨论一下用户闲置的情况
在这儿有更多系统的组件被唤醒


74
00:05:34,034 --> 00:05:39,640
你也可看到显示屏处于开启运行状态
这带来了一些伴随着的的软系统


75
00:05:41,508 --> 00:05:45,279
其他的组件
例如CPU 和GPU等


76
00:05:45,946 --> 00:05:49,583
绝大多数是不活跃的并且闲置时间短


77
00:05:49,950 --> 00:05:51,652
因此这个周期也很低


78
00:05:52,586 --> 00:05:56,890
如果我们把它做成动画
并且展示功耗可能会是什么样子的话


79
00:05:57,090 --> 00:06:01,195
那么在一天当中
用户的电池消耗将会得到很好的减缓


80
00:06:01,595 --> 00:06:05,832
希望在进入夜晚
你准备睡觉时为手机充电


81
00:06:08,302 --> 00:06:13,207
然而假如你想运行
大功耗的程序比如3D游戏


82
00:06:13,774 --> 00:06:16,310
这将会使用系统的绝大部分


83
00:06:17,077 --> 00:06:19,746
你已经让所有的组件都处于运行状态


84
00:06:19,813 --> 00:06:26,486
为了让GPU复杂的渲染跑起来
你可能正在使用大量的CPU


85
00:06:27,020 --> 00:06:31,992
播放游戏音频会导致音频系统启动


86
00:06:32,926 --> 00:06:39,900
因此预期的使用功率稍高
电池持续的时间相应的也会比较短


87
00:06:45,572 --> 00:06:51,311
对于这三个组件
我们有一个非常简单的策略去优化功耗


88
00:06:52,346 --> 00:06:53,780
你想做更少的工作


89
00:06:55,582 --> 00:07:00,187
就需要考虑一下工作
是否需要现在去做或者随后再做


90
00:07:02,689 --> 00:07:06,593
最终进行那项工作的时候
需要设法尽可能高效率地完成


91
00:07:09,329 --> 00:07:12,900
桑仁 将会在下次讨论的部分
涉及到更多的细节问题


92
00:07:15,302 --> 00:07:17,137
那么让我们讨论一下
在iOS 9下的情况


93
00:07:18,438 --> 00:07:21,475
我们的已经有了一流的电池续航能力


94
00:07:22,342 --> 00:07:24,011
然而我们确实认为我们能够做的更好


95
00:07:24,912 --> 00:07:26,847
除此之外我们的顾客
也希望我们做的更好


96
00:07:27,314 --> 00:07:28,415
你也希望我们做的更好


97
00:07:29,550 --> 00:07:32,853
我们开始通过优化
操作系统和集成的应用程序


98
00:07:33,654 --> 00:07:35,789
从而在现存的硬件中促进电池续航


99
00:07:37,024 --> 00:07:41,395
去增加电池的额外一个小时的寿命


100
00:07:42,963 --> 00:07:45,999
现在我们的做法
对于你们中的一些人可能很熟悉


101
00:07:46,066 --> 00:07:48,936
因为我们在OS X Mavericks中
曾有过相似的努力


102
00:07:50,137 --> 00:07:53,373
我们取消了应用程序
框架和驱动程序的轮询


103
00:07:53,440 --> 00:07:54,508
我们优化了内核


104
00:07:56,276 --> 00:08:00,180
同时把我们的服务质量
应用到我们的线程中


105
00:08:00,948 --> 00:08:03,016
采用了更多的NS操作


106
00:08:03,750 --> 00:08:06,153
以及用更加正确的服务质量
去安排输入输出


107
00:08:08,021 --> 00:08:13,093
我们结合定时器去减少CPU


108
00:08:13,594 --> 00:08:16,029
以及像午睡app这样速率限制的
应用程序的唤醒次数


109
00:08:17,364 --> 00:08:21,502
从系统的角度来看
重新执行我们的CPU电源管理单元


110
00:08:22,002 --> 00:08:24,538
功耗将会得到显著的降低


111
00:08:25,439 --> 00:08:29,710
然后我们添加了个非常受欢迎的特性


112
00:08:29,977 --> 00:08:34,181
即为电池目录添加“重大能源”标示


113
00:08:34,414 --> 00:08:38,217
从而使得你能够看到哪个应用程序
正在从电池中消耗比较大的能量


114
00:08:40,687 --> 00:08:43,657
因此现在回到iOS中
看一下我们怎样应用这些措施的


115
00:08:44,191 --> 00:08:45,726
我们之所以专注于iPhone


116
00:08:46,360 --> 00:08:50,931
是因为我们得到很多人的反馈说
希望提高iphone的电池续航能力


117
00:08:52,199 --> 00:08:56,236
然而从某种程度上来说这些提高措施
已经应用到我们所有的iOS设备中


118
00:08:58,172 --> 00:09:01,208
现在让我们通过这三个组件的策略


119
00:09:02,643 --> 00:09:03,510
以减少工作量


120
00:09:05,646 --> 00:09:11,285
我们希望进一步优化闲置负载
以及特别关注睡眠定时器


121
00:09:11,919 --> 00:09:15,923
在用户完成交互之后
系统的绝大部分时间都用在睡眠上


122
00:09:16,323 --> 00:09:20,394
现在是基于用户在设备上的
操作基础上去优化


123
00:09:21,094 --> 00:09:25,465
他们与推送的交互究竟是否进行


124
00:09:27,267 --> 00:09:29,503
我们减少CPU在空闲时刻
被唤醒的次数


125
00:09:29,837 --> 00:09:33,240
我们已经给它添加了
关于屏幕检测的一个很酷的特性


126
00:09:34,007 --> 00:09:37,878
因此当手机屏幕面向桌面时


127
00:09:39,847 --> 00:09:41,215
收到一条通知


128
00:09:42,082 --> 00:09:44,451
屏幕不会为处理那个通知而去亮起来


129
00:09:44,651 --> 00:09:48,088
我们让系统尽可能少的做准备工作


130
00:09:48,155 --> 00:09:51,525
这样 只有当用户接电话的时候
通知才被提供给他们


131
00:09:54,027 --> 00:09:55,596
现在开始后续的一些工作


132
00:09:58,031 --> 00:10:00,300
我们做了很多努力去将工作推迟到


133
00:10:00,667 --> 00:10:02,669
设备被充电时


134
00:10:03,504 --> 00:10:09,276
进行用户不需要的后台和维持工作
是没有意义的


135
00:10:09,676 --> 00:10:12,946
他们可能是一个日常的活动
所以当给手机充电时可以完成一些操作


136
00:10:13,013 --> 00:10:16,650
因为我们知道用户只会
在一天的某些时候给手机充电


137
00:10:18,151 --> 00:10:21,722
因为人们需要对Wi-Fi付费


138
00:10:21,855 --> 00:10:24,458
所以连接Wi-Fi时
我们同样也可以推迟网络


139
00:10:25,626 --> 00:10:28,362
然后我们甚至更多的
持续利用应用程序接口


140
00:10:28,695 --> 00:10:31,765
使得当接收器开启时


141
00:10:31,832 --> 00:10:36,537
即使接收器在做一些后台工作
我们也可以完成一些相应的工作


142
00:10:38,839 --> 00:10:42,743
现在对于那项工作来说一切都很好
但我们想能更有效率的去完成那项工作


143
00:10:44,011 --> 00:10:45,179
因此让我们做一些改变


144
00:10:45,612 --> 00:10:47,714
我们优化我们的iOS和网络堆栈


145
00:10:48,182 --> 00:10:52,786
去让4G网络
特别是4G接收器工作的更好


146
00:10:53,887 --> 00:10:55,689
我们再一次优化我们的电源管理单元


147
00:10:55,989 --> 00:10:59,493
去减少维持系统
在低功耗状态而产生的消耗


148
00:11:00,661 --> 00:11:03,330
我们已经降低了日志记录机制的消耗


149
00:11:03,830 --> 00:11:07,201
以至于它们不能和系统进行交互


150
00:11:07,901 --> 00:11:12,706
当然我们继续优化
我们的numerics库


151
00:11:13,173 --> 00:11:15,309
使他们更好去优化每一个硬件


152
00:11:16,043 --> 00:11:18,846
我认为明天可能会有
关于那个话题的会议


153
00:11:22,082 --> 00:11:26,119
所以我们谈论一下用户反馈
及怎样添加进Mavericks中


154
00:11:26,620 --> 00:11:32,626
我们已经设置好了电池
使其能够显示你的应用程序的使用方法


155
00:11:33,760 --> 00:11:38,632
或允许给你提供
一些周围环境因素的信息


156
00:11:38,699 --> 00:11:42,202
以及给想提高电池续航的用户一些建议


157
00:11:43,237 --> 00:11:44,838
在这儿已经进入到更进一步的阶段


158
00:11:45,205 --> 00:11:49,877
添加每一个应用屏幕或后台时间...


159
00:11:51,111 --> 00:11:52,312
到这个设置面板上


160
00:11:53,080 --> 00:11:55,082
所以你在角落里可以看到一个控制


161
00:11:55,349 --> 00:11:56,850
让我们回过头继续向前走


162
00:11:57,417 --> 00:11:59,953
你可以看到一个小的控制
可以让您切换模式


163
00:12:04,992 --> 00:12:07,060
然后我们已经添加了低功耗的模式


164
00:12:09,196 --> 00:12:13,500
而用户的偏好也将会影响电池的寿命


165
00:12:14,568 --> 00:12:17,571
它将限制CPU以及后台操作


166
00:12:17,638 --> 00:12:19,840
导致以前我们引入的
后台应用程序刷新机制


167
00:12:19,907 --> 00:12:21,808
在这个模式下失效了


168
00:12:23,377 --> 00:12:26,747
我们关掉自由裁量和后台工作


169
00:12:27,114 --> 00:12:31,485
所以如果你想在后台完成预定的下载
在用户退出前这些行为是不被允许的


170
00:12:32,853 --> 00:12:34,488
邮件获取也被禁用了


171
00:12:35,122 --> 00:12:38,358
是因为如果收发太多的邮件
将会让系统产生一个较大的功耗


172
00:12:41,161 --> 00:12:43,130
我们已经讨论了
关于操作系统的内容


173
00:12:43,530 --> 00:12:47,034
现在让我们谈论一些将会帮助你
提高电池续航能力的事情


174
00:12:49,069 --> 00:12:53,340
我们已经使用了一个相当周到的方式


175
00:12:54,875 --> 00:12:57,211
把OS X上能量计移植到iOS中


176
00:12:57,277 --> 00:13:02,282
从而能量计对iOS产生最显著的影响


177
00:13:02,349 --> 00:13:08,388
系统除了其它的仪器
我们又添加了定位仪


178
00:13:09,489 --> 00:13:13,193
除了改善OS X的能源指南


179
00:13:13,894 --> 00:13:17,564
我们还在网站上写了个
全新的iOS能源指南


180
00:13:20,200 --> 00:13:22,236
现在你能用这个指南做些什么事情呢？


181
00:13:23,770 --> 00:13:27,107
我们希望你能够优化应用程序的功耗


182
00:13:27,908 --> 00:13:29,643
给你一个简单的例子吧


183
00:13:32,012 --> 00:13:33,547
比如你正在全屏播放一个视频


184
00:13:33,881 --> 00:13:37,084
现在让我们做一个优化
很可能像家里的电视那样


185
00:13:37,351 --> 00:13:38,986
减少backlight
调整伽玛补偿


186
00:13:39,286 --> 00:13:42,856
从而给出同样视觉图像


187
00:13:43,857 --> 00:13:44,691
现在


188
00:13:46,260 --> 00:13:48,362
这些措施将会使得功耗少量减少


189
00:13:48,662 --> 00:13:52,699
但是因为时间的因素
节省的功耗是相当可观的


190
00:13:53,467 --> 00:13:56,003
因此你在观看全屏视频的时候


191
00:13:56,136 --> 00:13:58,972
我们也可以得到额外的续航时间
只是在这个机制非常简单


192
00:13:59,673 --> 00:14:05,345
一旦你想在屏幕上放置任何用户界面
这个机制就会失效


193
00:14:06,013 --> 00:14:12,352
我们也可以看到全透明用户界面层的
全屏应用程序会完全禁用这个机制


194
00:14:12,419 --> 00:14:14,021
这对于用户没有任何好处


195
00:14:18,892 --> 00:14:22,029
在讨论过OS X后
现在让我们说说iOS


196
00:14:23,096 --> 00:14:25,232
在早些时候我们推出了
的MacBook


197
00:14:25,532 --> 00:14:27,568
因为那是我们
第一个fanless系统


198
00:14:27,868 --> 00:14:30,137
所以它会有点散热的约束


199
00:14:30,637 --> 00:14:34,575
而MacBook被设计为
可以很好的应对突发性的工作负载


200
00:14:35,209 --> 00:14:39,279
我们也已经对操作系统进行优化
让它能与那些机器一起工作


201
00:14:40,180 --> 00:14:45,219
你也应当用适当的线程服务质量去
去标记所有的工作


202
00:14:46,553 --> 00:14:50,190
使用我们已经预装在OS X上
可用的仪表和仪器


203
00:14:50,557 --> 00:14:52,826
可以确保你
利用NSOperation和GCD


204
00:14:53,727 --> 00:14:55,629
来对你的工作进行优先级的考虑


205
00:14:56,129 --> 00:14:59,566
如果现在有用户启动的操作
确保它被尽可能的标记


206
00:14:59,633 --> 00:15:02,002
但是如果它后台工作的话
仍像那样去标记它


207
00:15:02,669 --> 00:15:08,108
而操作系统在为这些任务
提供更强性能的同时


208
00:15:08,442 --> 00:15:13,113
还会管理
该设备的电源和散热


209
00:15:17,818 --> 00:15:21,321
最后总结一下
我们知道了功耗是功率乘以时间


210
00:15:21,722 --> 00:15:25,092
当你为提高电池续航的能力
在思考怎样优化应用程序的时候


211
00:15:25,759 --> 00:15:27,895
一定要记住时间的因素是非常重要的


212
00:15:29,062 --> 00:15:30,964
硬件的动态范围正在变得更大


213
00:15:31,231 --> 00:15:36,470
因此当你正在操作的时候
必须认真的考虑怎样有效率的完成


214
00:15:36,737 --> 00:15:40,340
进行这些工作时认真考虑
是否这些工作全部需要完成


215
00:15:41,675 --> 00:15:44,912
为了实现全天电池续航


216
00:15:45,579 --> 00:15:48,715
你需要让平均功耗尽可能的低


217
00:15:49,983 --> 00:15:53,287
现在我将会把这个任务交给我的同事
桑仁 去更详细的讨论


218
00:16:01,862 --> 00:16:03,030
早上好
谢谢


219
00:16:03,397 --> 00:16:05,732
真的很高兴看到
你们在这儿学习能量效率的知识


220
00:16:06,099 --> 00:16:11,438
也很希望自己能够帮助你们理解
代码在电池续航中心是怎样工作的


221
00:16:14,074 --> 00:16:16,410
我们将讨论两大类事情


222
00:16:17,811 --> 00:16:21,582
但是首先我们要从一些
強 已经讨论过的原则开始


223
00:16:21,648 --> 00:16:22,883
我们将把这个原则和用户


224
00:16:22,950 --> 00:16:26,920
及用户为何是在你的应用程序上
获取正确的时间关键因素相互联系起来


225
00:16:27,654 --> 00:16:29,356
我们也准备讨论一下能量究竟去了哪里


226
00:16:29,423 --> 00:16:33,126
特别是CPU以及GPU对OS X
和iOS来说都是非常重要的


227
00:16:35,062 --> 00:16:38,298
通过这一部分的讨论
我将会详细的向你们解释


228
00:16:39,066 --> 00:16:44,371
怎样实现较低的平均功耗
从而最终实现全天的电池续航


229
00:16:45,038 --> 00:16:46,807
此外我们也特别的讨论一下iOS


230
00:16:46,874 --> 00:16:50,143
在我们的iOS设备上
你可以利用的许多硬件组件


231
00:16:50,210 --> 00:16:53,413
为了让电池能够全天续航


232
00:16:53,480 --> 00:16:57,451
需要同时注意功率和时间


233
00:16:57,751 --> 00:17:02,589
最后我们谈一下
怎样把这些理论融入在你的开发过程中


234
00:17:02,689 --> 00:17:06,226
以便每天你都能思考
一点关于功耗的东西


235
00:17:09,563 --> 00:17:12,398
在更进一步讨论之前
我们并不能看到太好的一面


236
00:17:12,766 --> 00:17:15,435
但是如果你家的某个地方有个LED灯
请举起你的手


237
00:17:16,670 --> 00:17:19,039
好的 你们应该知道什么是LED灯
很好


238
00:17:19,373 --> 00:17:21,775
你们家里可能还会留着一些白炽灯
我家确实还留着一些


239
00:17:21,842 --> 00:17:23,644
最近我把冰箱中的白炽灯换掉了


240
00:17:23,710 --> 00:17:25,679
而如果在冰箱中放LED灯泡
则很有意思


241
00:17:29,183 --> 00:17:31,585
请不在家时仍然让灯
一直开的人举起你的手


242
00:17:33,353 --> 00:17:34,922
好的 有一个人是那样做的


243
00:17:34,988 --> 00:17:37,758
他是我的办公室同事
我准备给他一个艰难的时刻


244
00:17:38,392 --> 00:17:40,894
他在办公室时并不是让灯一直开的人


245
00:17:42,863 --> 00:17:47,000
关键是当我们换了LED灯的时候
功率可以明显的降下来


246
00:17:47,601 --> 00:17:50,070
而且我们也不会让它们整天运行
不用的时候也会把它关掉


247
00:17:50,137 --> 00:17:51,271
这样的话时间也降下来了


248
00:17:52,339 --> 00:17:54,174
在你的屋子里可能有很多的设备


249
00:17:54,408 --> 00:17:57,578
网络 DVR甚至计算机和服务器


250
00:17:58,212 --> 00:17:59,646
而这些设备都将会整天运行


251
00:17:59,713 --> 00:18:02,249
因为它们并不像灯泡那样点着
或许你并不会关注它们


252
00:18:02,349 --> 00:18:05,552
而我准备帮助你们
在软件的角度去思考这些问题


253
00:18:05,686 --> 00:18:10,057
因为最终是软件来控制硬件上
所有灯的开关


254
00:18:10,290 --> 00:18:13,026
所以为了实现电池的全天续航
我们必须让灯的开关


255
00:18:13,093 --> 00:18:14,795
在绝大部分的时间中都处于关闭的状态


256
00:18:15,062 --> 00:18:17,097
那么让我们谈论一下具体的措施


257
00:18:17,831 --> 00:18:20,734
因为最终我们的目的
就是完成用户驱动的工作


258
00:18:21,134 --> 00:18:23,837
所以我们也希望用户
能从电池的能量中获益


259
00:18:23,904 --> 00:18:24,738
他们已经实现了


260
00:18:25,472 --> 00:18:29,176
软件在很多时候都是很相似的


261
00:18:29,309 --> 00:18:30,878
我现在有一些事情去处理
我能去做吗？


262
00:18:30,944 --> 00:18:32,880
哦 是的 可以
让我们再一次完成它


263
00:18:33,580 --> 00:18:34,548
不 不 不


264
00:18:35,249 --> 00:18:37,651
我们必须消除
任何类型的轮询或者计时器


265
00:18:37,918 --> 00:18:41,355
计算机操作的比人类更加的快


266
00:18:41,655 --> 00:18:43,290
确切的说在键击之间


267
00:18:43,590 --> 00:18:45,692
即使你是一个超快的打字
一分钟可以打一百个字


268
00:18:45,759 --> 00:18:48,262
在微秒时间尺度的键击之间


269
00:18:48,662 --> 00:18:52,866
我们仍然可以闲置部分系统
处理器将会在按键间隙处于休眠状态


270
00:18:53,267 --> 00:18:55,636
而当用户利用键盘 鼠标
和计算机进行交互的间隙


271
00:18:56,403 --> 00:18:59,540
对计算机来说仍有很多的运行时间


272
00:18:59,606 --> 00:19:03,510
所以你希望你的软件不要
按照计算机运行的速度运行


273
00:19:04,011 --> 00:19:06,380
除非它直接为用户工作


274
00:19:08,015 --> 00:19:10,050
你回应用户
那样很棒


275
00:19:10,284 --> 00:19:13,320
使用我们超强的硬件
然后回到空闲状态


276
00:19:13,921 --> 00:19:15,455
变得完全平坦
最后归零


277
00:19:17,958 --> 00:19:19,560
強 已经讨论过延时工作了


278
00:19:19,793 --> 00:19:22,196
很多时候你可以无限期的延时工作


279
00:19:22,262 --> 00:19:23,163
我现在需要延时吗？


280
00:19:23,230 --> 00:19:25,532
并不需要
稍后或许会用到


281
00:19:26,600 --> 00:19:28,235
但总的来说结果就是我们不需要延时


282
00:19:28,535 --> 00:19:29,636
如果现在有少量的任务


283
00:19:30,137 --> 00:19:32,072
而现在用户不需要它


284
00:19:32,139 --> 00:19:35,642
那么最好将其推迟
可以说


285
00:19:36,210 --> 00:19:40,013
“嗨 系统 请完成这个
如果有计时器的话”


286
00:19:40,080 --> 00:19:41,548
在下个小时的任何时刻


287
00:19:41,615 --> 00:19:44,651
希望你能给出十分钟
或者其它有余量的时间


288
00:19:45,786 --> 00:19:47,554
如果没有计时器的话
那么只能完成上传和下载了


289
00:19:47,621 --> 00:19:49,690
因为系统在随后可能会安排其他


290
00:19:50,123 --> 00:19:51,658
可能发生的工作


291
00:19:52,059 --> 00:19:53,794
你也可以把所有的任务集中在一起


292
00:19:54,695 --> 00:19:58,465
因为批处理是获得效率的重要途径


293
00:19:58,665 --> 00:20:01,001
你想打开那个硬件
但是把它打开需要一些功耗


294
00:20:01,068 --> 00:20:04,738
而你希望在它被关闭之前去使用它


295
00:20:04,805 --> 00:20:07,708
需要在硬件开启状态下
尽可能多的完成工作


296
00:20:08,208 --> 00:20:13,947
我们能再一次降低功耗
节省时间是很重要的因素


297
00:20:14,715 --> 00:20:18,519
这是我特别指出的有趣的关键信息


298
00:20:18,585 --> 00:20:22,122
我们有所有的可用能源
但是你不能在电池上整天的运行


299
00:20:22,322 --> 00:20:24,858
否则设备会变得很热
而且电池也不能持续运行


300
00:20:25,425 --> 00:20:31,031
我们真正想让你考虑的是
占用整个系统10%的负载


301
00:20:31,131 --> 00:20:34,101
这些负载不仅是软件
还包括你所做的其它操作


302
00:20:34,535 --> 00:20:38,038
那么你怎样才能利用你可以实现的措施


303
00:20:38,305 --> 00:20:42,009
把负载降到1/10或1/100呢


304
00:20:42,376 --> 00:20:44,978
这是当你在屏幕上的情况
当你后台的时候 我们需要的更少


305
00:20:46,180 --> 00:20:47,614
这里我要说一个比较坏的消息


306
00:20:48,081 --> 00:20:50,918
我也对我们所有的硬件
做过一些这方面的研究


307
00:20:50,984 --> 00:20:52,819
人们表现出就像...
哦不对


308
00:20:52,886 --> 00:20:55,689
这也不是谈话的要点
关键在于让你去思考这个问题


309
00:20:56,623 --> 00:21:00,761
大概百分之十到百分之五的负载之间
是仅在打开显示器时产生的


310
00:21:01,828 --> 00:21:03,297
现在显示器打开之后的状态良好


311
00:21:03,363 --> 00:21:07,201
因为用户正在从系统中得到更多的好处
所以这有很大的希望不仅仅是一个通知


312
00:21:09,503 --> 00:21:11,038
然后有百分之十的目标


313
00:21:11,672 --> 00:21:13,307
这就是平均水平


314
00:21:13,373 --> 00:21:14,942
这听起来就像只实现了5%


315
00:21:15,275 --> 00:21:17,244
在长周期下的确如此


316
00:21:17,578 --> 00:21:20,013
但在短时间内争取100%


317
00:21:20,180 --> 00:21:22,883
将你完成的工作优先呈现出来


318
00:21:22,983 --> 00:21:25,452
我们将会安排它


319
00:21:26,353 --> 00:21:29,523
这部分就是这样 你必须让它
处于百分之5到百分之10之间


320
00:21:30,824 --> 00:21:34,094
现在让我们讨论一下CPU和GPU


321
00:21:34,161 --> 00:21:38,198
在OS X中CPU和GPU
会消耗大部分的能量


322
00:21:39,199 --> 00:21:40,133
它们也是最具活力的


323
00:21:40,200 --> 00:21:46,640
我们有非常强大的多核CPU
和大规模并行GPU完成各样任务


324
00:21:47,241 --> 00:21:49,209
然而如果你把设备插入电源的话


325
00:21:49,776 --> 00:21:52,212
CPU和GPU一般来说
确实会消耗电池很多能量


326
00:21:52,779 --> 00:21:55,182
在这儿你已经可以看到
我们已经完成了大部分工作


327
00:21:55,249 --> 00:21:58,018
我们已经让CPU开始运行了
同时也让GPU运行一会儿


328
00:21:58,218 --> 00:22:00,921
而事实上这并不会持续一整天


329
00:22:01,121 --> 00:22:05,225
但如果这个对于
你工作方式非常重要的模式


330
00:22:05,626 --> 00:22:08,262
如果这个模式持续的话
将会使得我们不能实现全天续航


331
00:22:08,328 --> 00:22:10,197
因为平均功耗太高了


332
00:22:14,034 --> 00:22:16,236
那么我们仅唤醒CPU又会怎么样呢？


333
00:22:16,503 --> 00:22:18,172
是否有工作要做？
是否有工作要做？


334
00:22:18,238 --> 00:22:19,640
是否有邮件？
用户是否点击过？


335
00:22:19,706 --> 00:22:20,741
有没有什么事情发生？


336
00:22:21,542 --> 00:22:22,376
嗨 服务器


337
00:22:23,210 --> 00:22:24,044
不要那样做


338
00:22:24,111 --> 00:22:25,679
当唤醒CPU或者GPU时


339
00:22:26,513 --> 00:22:29,483
我们需要大量的能量去让他们加速


340
00:22:32,419 --> 00:22:33,353
有工作要做么？


341
00:22:35,722 --> 00:22:36,557
没有收到任何工作


342
00:22:38,458 --> 00:22:41,495
所有你能看到的这些三角形
即使是iOS的三角形


343
00:22:41,562 --> 00:22:44,731
也在5%到10%的范围中
占据了很重要的一部分


344
00:22:46,300 --> 00:22:47,901
不要尝试不必要的唤醒


345
00:22:48,502 --> 00:22:50,237
在OS X上如果你整天唤醒CPU


346
00:22:50,304 --> 00:22:52,139
那么事实上你的电池
根本不能实现全天续航


347
00:22:52,206 --> 00:22:54,641
即使你不运行
甚至只是做一些检查工作


348
00:22:55,108 --> 00:22:55,943
不要那样做


349
00:22:56,009 --> 00:22:59,546
GPU是一个时间尺度略有不同的怪物


350
00:23:00,848 --> 00:23:03,116
它工作的频率比
你需要唤醒GPU的频率更高


351
00:23:03,183 --> 00:23:05,953
甚至对于一些漂亮的图形


352
00:23:06,019 --> 00:23:09,389
在下一帧之前需要15ms


353
00:23:09,456 --> 00:23:12,860
然而在1ms之内
GPU已经可以完成大量的工作了


354
00:23:15,562 --> 00:23:16,797
现在让我们讨论一下性能


355
00:23:17,564 --> 00:23:19,666
你来到这里的目的是关注能源性能


356
00:23:20,100 --> 00:23:22,336
而且你做事的时间效率也更高
完成任务的时间更快


357
00:23:22,402 --> 00:23:26,139
这些对用户是有好处的
对能源的效率也是一个关键因素


358
00:23:26,306 --> 00:23:27,207
现在让我解释其原因


359
00:23:29,142 --> 00:23:31,144
这里是一个工作负载
而是一个固定的工作负载


360
00:23:31,211 --> 00:23:32,779
它的状态也不能持续下去


361
00:23:32,846 --> 00:23:34,548
我只需要完成这个工作


362
00:23:35,949 --> 00:23:37,050
但是它的工作负载很大


363
00:23:37,451 --> 00:23:38,952
因此我可能需要优化我的代码


364
00:23:39,019 --> 00:23:41,622
可以访问代码的内部循环


365
00:23:41,688 --> 00:23:44,791
做更少的内存访问和传统的性能工作


366
00:23:45,592 --> 00:23:47,227
这样就会使得执行更加的有效率


367
00:23:47,895 --> 00:23:48,962
但功率增加了


368
00:23:49,496 --> 00:23:52,065
然而时间却又变短了


369
00:23:52,399 --> 00:23:54,034
从而功耗可以大幅的降低


370
00:23:54,468 --> 00:23:56,570
前面的工作做的非常好
但是我们能做的更好


371
00:23:56,670 --> 00:24:00,174
可以将工作并行化
并使用多核


372
00:24:00,607 --> 00:24:03,610
最后我们可以更疯狂一点
让GPU跑起来


373
00:24:04,344 --> 00:24:07,881
现在的好消息就是
通常你并不需要写优化代码


374
00:24:07,948 --> 00:24:09,750
但是你却需要找到这个优化代码


375
00:24:09,816 --> 00:24:12,152
你需要找到这些优化的数字库


376
00:24:12,653 --> 00:24:15,722
在后面我们有一个
关于会议和能源文件的链接


377
00:24:16,356 --> 00:24:20,694
你必须找到正确的数据结构
然后审视一下你的应用程序


378
00:24:21,028 --> 00:24:25,499
最后谈一下为什么我一直在搅动
及在规则的旧时间中我又能够优化什么


379
00:24:27,968 --> 00:24:29,403
这幅图片中的东西是很重要的


380
00:24:30,304 --> 00:24:33,607
那是直接执行的低功耗解决方案


381
00:24:33,674 --> 00:24:35,475
在这个方案中系统就像开始工作一样


382
00:24:35,542 --> 00:24:37,344
而你只需要一等等待存储和加载


383
00:24:37,411 --> 00:24:38,846
你已经让一个核心运行了


384
00:24:39,279 --> 00:24:41,148
如果我们让多核都运行的话


385
00:24:41,281 --> 00:24:44,084
那我们才是真正的在使用该系统
但如果只有单核情况会怎么样呢？


386
00:24:44,318 --> 00:24:48,155
因为时间的因素只会导致
虽然功率很低但是功耗却很大


387
00:24:50,424 --> 00:24:53,594
现在让我们研究一下为什么会这样


388
00:24:53,961 --> 00:24:57,898
在运行系统的其他部分的时候


389
00:24:57,965 --> 00:24:59,933
无论CPU GPU
或是系统的其它部分


390
00:25:00,868 --> 00:25:03,003
固定功耗都会慢慢增加


391
00:25:03,403 --> 00:25:06,106
你越快把这些固定消耗关掉
效果自然就越好


392
00:25:06,807 --> 00:25:09,943
我自己也为GPU增加以下额外的功耗


393
00:25:10,010 --> 00:25:12,913
因为事实上在使用GPU的过程中
会产生更多的功耗


394
00:25:12,980 --> 00:25:15,782
观察绿色的部分我们看出


395
00:25:16,383 --> 00:25:19,453
当我们节省时间之后
是否使用了更少的能量


396
00:25:21,655 --> 00:25:24,725
关键课程
高速也是能源效率


397
00:25:25,759 --> 00:25:27,394
我们在看这些在线下是否满足的时候


398
00:25:27,728 --> 00:25:29,830
请谨记按照重要性排列


399
00:25:31,031 --> 00:25:32,833
这是最直接的一个措施


400
00:25:33,233 --> 00:25:36,937
因为任何一个熟悉高中几何的
都很清楚那并不满足


401
00:25:37,638 --> 00:25:39,072
我们会把它拉到平均水平


402
00:25:39,139 --> 00:25:40,507
在这里不再是功率乘以时间


403
00:25:40,574 --> 00:25:41,408
这只是平均水平


404
00:25:42,109 --> 00:25:42,943
将不再适合


405
00:25:43,477 --> 00:25:44,545
至于其他的


406
00:25:44,878 --> 00:25:47,414
注意
效率有所提高


407
00:25:48,315 --> 00:25:49,316
但是依然不够


408
00:25:50,150 --> 00:25:53,520
可以看到除了CPU/GPU
平行线几乎都在线下


409
00:25:53,720 --> 00:25:56,490
因为时间很短
所以确实满足条件


410
00:25:56,557 --> 00:25:59,126
同时虽然功率很高
但时间很短


411
00:25:59,193 --> 00:26:00,794
这些就是你在设计程序
要遵从的方法


412
00:26:00,861 --> 00:26:03,864
但是不要重复的使用这些措施


413
00:26:04,431 --> 00:26:06,166
在你做这些之前请稍等一下你的用户


414
00:26:09,436 --> 00:26:10,671
现在让我们调整一下


415
00:26:10,971 --> 00:26:13,640
这些是应用在OS X和iOS的
所有CPU和GPU


416
00:26:13,774 --> 00:26:16,643
而它们对OS X尤其重要


417
00:26:16,743 --> 00:26:18,812
此外我们在衡量能量
对OS X的影响时


418
00:26:18,879 --> 00:26:20,614
除了系统可以处理的CPU指令


419
00:26:20,814 --> 00:26:23,283
还可以通过人们可以唤醒系统的次数


420
00:26:24,051 --> 00:26:28,021
现在让我们切换到iOS


421
00:26:28,555 --> 00:26:31,625
我们知道iOS设备
不仅有CPU和GPU性能非常强悍


422
00:26:32,159 --> 00:26:37,197
而且iOS的网络定位
和后台运行的能力也很强大


423
00:26:43,036 --> 00:26:47,975
其中网络的功率很大
大量的硬件网络


424
00:26:48,642 --> 00:26:52,012
此外还涉及到很重要的时间组件
也需要详细考虑


425
00:26:53,013 --> 00:26:56,049
定位是一个很好的功能
用起来很棒


426
00:26:56,383 --> 00:26:57,718
但是它主要的设计目的


427
00:26:58,118 --> 00:26:59,586
比如我正在观察地图上的一个点


428
00:26:59,653 --> 00:27:01,722
此时我准备穿过舞台
而小点也相应的跟着移动


429
00:27:01,788 --> 00:27:05,192
我很喜欢这个功能让人印象非常深刻
可以告诉我自己正在穿过舞台


430
00:27:07,261 --> 00:27:10,130
不幸的是这个应用程序的接口
很容易被留下继续运行


431
00:27:10,531 --> 00:27:11,765
甚至当我不在看地图的时候


432
00:27:12,299 --> 00:27:16,270
因此我需要除了改进应用程序的接口


433
00:27:16,670 --> 00:27:20,407
我们也需要你在自己需要的最短
时间之内去使用定位


434
00:27:21,074 --> 00:27:23,677
最终任何时刻都在后台运行


435
00:27:24,378 --> 00:27:27,414
那就会使得设备


436
00:27:29,249 --> 00:27:32,286
增加了保持唤醒的时间


437
00:27:32,486 --> 00:27:34,888
每次我按屏幕上的home键
离开你的应用程序的时候


438
00:27:35,189 --> 00:27:37,658
你都在后台运行
可能时间很短也许时间会很长


439
00:27:38,692 --> 00:27:40,827
我们希望尽可能的消除这种情况


440
00:27:40,894 --> 00:27:43,597
因为我们希望设备
能保持在良好的待机状态


441
00:27:44,031 --> 00:27:47,201
从而使得设备的随机存储器和接收器
可以保持在一个低功耗的模式下


442
00:27:48,769 --> 00:27:50,470
让我们讨论一下网络


443
00:27:51,939 --> 00:27:54,041
幻灯片橘色的部分状态不好


444
00:27:54,575 --> 00:27:55,642
因为它代表的是消耗


445
00:27:56,577 --> 00:28:01,014
思考一下
当你想向网络上特别是蜂窝设备


446
00:28:01,081 --> 00:28:03,817
发送一些数据的时候会发生什么


447
00:28:04,651 --> 00:28:08,522
系统可能会说“我现在必须发送数据
因为应用程序告诉我的”


448
00:28:09,489 --> 00:28:12,893
不要把它标记为后台任务
它不可延迟 必须立即完成


449
00:28:13,894 --> 00:28:17,865
我们之间没有连接起来
只是通过入站连接与蜂窝系统联系


450
00:28:18,131 --> 00:28:19,366
但是我们没有出站


451
00:28:20,300 --> 00:28:21,201
所以举起来


452
00:28:21,735 --> 00:28:24,404
找到一个基站
已经找到基站


453
00:28:24,471 --> 00:28:26,106
但是总体情况并不太好
尝试另一个


454
00:28:26,540 --> 00:28:28,442
这个基站非常好


455
00:28:28,809 --> 00:28:29,910
我们连上了


456
00:28:29,977 --> 00:28:32,279
好的 我发送一些数据
好的 数据发送了


457
00:28:34,681 --> 00:28:36,517
没有数据发送了 但是仍然连接着


458
00:28:36,750 --> 00:28:38,519
连接时的代价很高
当我把设备打开时


459
00:28:39,152 --> 00:28:40,988
按照蜂窝网络的工作方式


460
00:28:41,054 --> 00:28:43,724
我必须让它运行一到两秒


461
00:28:44,424 --> 00:28:47,828
它可能只需要几毫秒时间去发送数据


462
00:28:47,995 --> 00:28:50,697
但它可能需要停留长达10秒
去连接到网络


463
00:28:51,031 --> 00:28:52,699
显然不是高功率模式


464
00:28:52,766 --> 00:28:56,170
但是功率仍远高于输入连接的闲置等待


465
00:28:56,870 --> 00:28:59,540
因此消耗是一个重要的能源影响


466
00:29:00,207 --> 00:29:02,876
正在运行的网络工作量大小并不重要


467
00:29:03,210 --> 00:29:06,647
在某些情况下如果接收机关闭的话
必须重启后运行


468
00:29:07,047 --> 00:29:11,385
耗费的时间比你实际上
需要发送数据的时间长一千倍


469
00:29:12,486 --> 00:29:16,056
而且没有任何方法能降低功率至预期值


470
00:29:16,223 --> 00:29:19,359
收音机不能一直开启
去实现全天续航的目标


471
00:29:20,694 --> 00:29:22,129
这对聊天应用程序是一个坏消息


472
00:29:22,863 --> 00:29:27,034
好消息是人们并不会在他们的手机上
点击聊天应用程序长达10个小时


473
00:29:27,100 --> 00:29:27,935
他们不会这样的


474
00:29:28,168 --> 00:29:30,037
因此只要你能够明白


475
00:29:30,103 --> 00:29:33,941
如果没有实时聊天让网络继续下去


476
00:29:35,175 --> 00:29:36,810
那么你就可以让电池实现全天续航


477
00:29:38,378 --> 00:29:40,347
我们如何解决这个问题
我们怎样让它更好


478
00:29:40,714 --> 00:29:42,683
因为它们不是一天可以解决的事情
难度很高


479
00:29:44,151 --> 00:29:48,021
我们必须通过合并把它们组合在一起
通过批处理的方式去解决它


480
00:29:48,622 --> 00:29:50,824
所以在这个特殊的例子里


481
00:29:50,891 --> 00:29:53,360
我们将会把未来的工作
纳入到旧的工作中


482
00:29:53,427 --> 00:29:55,963
如今将来的工作更加的重要


483
00:29:56,029 --> 00:29:58,665
所以你应当推迟以前的工作
那样可能更容易去完成目标


484
00:29:58,765 --> 00:30:01,568
但是如果你想了解那两项工作
究竟哪一个更重要


485
00:30:01,969 --> 00:30:05,205
对于你的应用程序来说目标就是
现在你可以实现哪一个


486
00:30:05,272 --> 00:30:07,107
现在我们将这些很棒的工具展示给你


487
00:30:07,274 --> 00:30:12,579
基本上在Xcode上的这些图形
图形表示的新工具都将装在你的软件上


488
00:30:12,846 --> 00:30:13,680
它非常好


489
00:30:14,414 --> 00:30:17,885
你可以看一下再谈谈为什么我要去做
这些没有必要 也许没有必要的事情


490
00:30:18,785 --> 00:30:21,388
为什么我的网络模式没有一点效率


491
00:30:21,555 --> 00:30:23,490
为什么它时分散的？
我怎样才能通力合作？


492
00:30:23,891 --> 00:30:27,828
然后我们才能真正达到这个目标
平均低功耗


493
00:30:28,195 --> 00:30:29,363
那就意味着全天的续航


494
00:30:30,130 --> 00:30:32,132
因此对网络进行总结


495
00:30:32,566 --> 00:30:35,035
如果你想在网络上做更少的工作


496
00:30:35,769 --> 00:30:37,971
就必须正确的设计你的系统


497
00:30:39,239 --> 00:30:42,809
即使你有一分钟的网络
这只增加了几秒钟的消耗


498
00:30:43,177 --> 00:30:47,981
此外 除非用户请求你现在访问网络


499
00:30:48,615 --> 00:30:52,419
否则直到确实重要的事情
请不要访问网络


500
00:30:53,253 --> 00:30:56,857
就设计来说 对于卸载系统


501
00:30:56,924 --> 00:30:59,026
以及让系统决定什么时候


502
00:30:59,092 --> 00:31:03,463
在接下来的十分钟内
下一个小时 下一个二十四小时


503
00:31:04,264 --> 00:31:07,201
怎样变化来说你所能做的就是对允许
我们对任务进行批量处理


504
00:31:07,267 --> 00:31:08,869
使得你卸载网络


505
00:31:08,936 --> 00:31:12,673
当工作完成的时候
我们将会给你打电话叫醒你


506
00:31:15,442 --> 00:31:17,778
很多时候 你可以在工作的时候等待


507
00:31:18,612 --> 00:31:21,748
背景更新 NSURLSession
都有这个特性


508
00:31:22,015 --> 00:31:23,417
只要等着 推迟它


509
00:31:24,051 --> 00:31:25,452
去排队吧 这很好


510
00:31:26,086 --> 00:31:27,788
但不要强迫它马上发生


511
00:31:29,356 --> 00:31:33,393
这些通知很棒


512
00:31:33,927 --> 00:31:36,496
但是它们有时候也会脱离控制


513
00:31:36,563 --> 00:31:37,865
比如在服务器端


514
00:31:37,931 --> 00:31:41,535
记得我曾提到过我们总是和
进站连接服务器相连接么


515
00:31:41,602 --> 00:31:42,603
強 也提到过


516
00:31:44,071 --> 00:31:45,172
入站连接很便宜


517
00:31:45,239 --> 00:31:46,673
它们基本上都是可靠的


518
00:31:46,974 --> 00:31:51,278
所以继续发送一些信息而不是轮询


519
00:31:51,578 --> 00:31:55,148
最好把一些信息发送出去
而且把这些通知标记为PushKit


520
00:31:55,582 --> 00:31:58,552
有了一个适当的优先级
这样我们就可以批量处理了


521
00:31:58,619 --> 00:32:02,022
而当我得到一个即时消息的时候
迅速地完成是最重要的


522
00:32:02,089 --> 00:32:05,692
也可能是把
带有新内容的通知下载到你的


523
00:32:05,759 --> 00:32:07,394
新应用程序或者其他类似的东西上


524
00:32:08,962 --> 00:32:10,664
现在让我们讨论一下定位


525
00:32:12,799 --> 00:32:17,171
定位也有两个要素
好消息是定位的功率相对较低


526
00:32:17,638 --> 00:32:19,640
如果你让定位一直运行


527
00:32:19,706 --> 00:32:22,109
那么只会有很少的空间去做其他的事情


528
00:32:22,176 --> 00:32:24,311
因此不要让精确定位一直运行


529
00:32:24,778 --> 00:32:26,580
事实上 最好不要一直运行定位


530
00:32:26,647 --> 00:32:33,520
除非用户确实希望在生活中
一直运行定位程序


531
00:32:33,587 --> 00:32:36,023
他们会看你的电池目录


532
00:32:36,089 --> 00:32:38,325
从而知道 后台定位会占用...


533
00:32:39,526 --> 00:32:40,594
25%的电池


534
00:32:40,794 --> 00:32:41,628
那样并不好


535
00:32:41,828 --> 00:32:43,363
除非你的应用程序就是那样


536
00:32:43,664 --> 00:32:44,631
那很好


537
00:32:46,900 --> 00:32:48,936
如此精确的定位是很昂贵的


538
00:32:49,002 --> 00:32:50,971
我们必须打开更多的硬件
与卫星对话


539
00:32:51,038 --> 00:32:52,773
联系所有的卫星


540
00:32:52,840 --> 00:32:53,740
完成


541
00:32:56,410 --> 00:32:58,712
不精确的定位便宜很多
我们只能说


542
00:32:58,779 --> 00:33:01,215
我已连接哪个Wi-Fi网络
我附近的基站是什么


543
00:33:01,748 --> 00:33:02,716
然后我们才能真正


544
00:33:02,783 --> 00:33:06,353
你看到的绿色正是系统运行的地方
显示正在运行


545
00:33:06,420 --> 00:33:08,822
虽然我们的系统大部分是关闭的


546
00:33:09,156 --> 00:33:11,458
但是仍然在跟踪你的位置
甚至精确定位


547
00:33:11,525 --> 00:33:12,359
它不是免费的


548
00:33:12,426 --> 00:33:14,695
不会一直运行
这些是漏洞


549
00:33:14,761 --> 00:33:16,797
从而使得我可以确定你在家里


550
00:33:17,197 --> 00:33:18,765
特别是加利福利亚居民


551
00:33:20,834 --> 00:33:22,102
定位只不过是滴、滴、滴


552
00:33:22,603 --> 00:33:24,805
因此我们可以优化它


553
00:33:25,906 --> 00:33:26,740
尽量少用它


554
00:33:26,874 --> 00:33:28,976
你知道 如果你准备去申请更新定位


555
00:33:29,176 --> 00:33:30,143
请不要马上申请


556
00:33:30,210 --> 00:33:32,679
那有一些应用程序
当我启动时我想知道我的位置


557
00:33:32,746 --> 00:33:34,681
我想知道公交车什么时候来


558
00:33:35,682 --> 00:33:36,517
那很好


559
00:33:36,583 --> 00:33:39,219
我周围的食物网络应用程序 很棒


560
00:33:39,453 --> 00:33:40,821
启动 获取位置


561
00:33:41,154 --> 00:33:44,591
否则等待用户去搜索
或者无论你需要什么


562
00:33:45,125 --> 00:33:48,996
然后尽快为用户完成设置
你已经得到了你想要的精确定位


563
00:33:49,263 --> 00:33:50,097
然后去申请停止


564
00:33:51,331 --> 00:33:54,801
对iOS 9来说 我们已经引入了
新的应用程序接口来完成这些任务


565
00:33:54,868 --> 00:33:56,170
这被称为请求定位


566
00:33:56,937 --> 00:33:58,338
它通过启动和停止


567
00:33:58,405 --> 00:34:00,474
确保你得到适当的精度


568
00:34:00,741 --> 00:34:04,745
你也不必管理开始和停止
这种情况只对iOS 9种适用


569
00:34:04,811 --> 00:34:07,181
对老版的操作系统仍然要按照
以前的方法去操作


570
00:34:07,481 --> 00:34:09,616
在幻灯片的结尾有关于定位讨论的链接


571
00:34:10,684 --> 00:34:15,121
我们改变了系统中后台定位的行为方式


572
00:34:15,188 --> 00:34:17,958
因此你的应用程序可以请求
使用后台定位


573
00:34:18,192 --> 00:34:21,628
但在请求被允许之前
可能会和用户有更多的交互


574
00:34:22,029 --> 00:34:25,232
如果不想再后台使用的话
你必须对你的应用程序谨慎一点


575
00:34:25,866 --> 00:34:28,835
保持允许后台定位更新的属性


576
00:34:29,136 --> 00:34:32,940
除非当你在后台中积极的完成它
否则就把它设置为假


577
00:34:33,739 --> 00:34:36,310
当你打开硬件定位的时候
要能够意识到


578
00:34:36,376 --> 00:34:38,779
就像打开电灯开关一样
你实际上在给它供电


579
00:34:38,846 --> 00:34:40,848
切换状态也是非常容易的


580
00:34:42,416 --> 00:34:44,985
当你实际使用它的时候
想把功耗降下来


581
00:34:45,052 --> 00:34:46,920
当我们讨论到时间的时说到要节省时间


582
00:34:47,353 --> 00:34:48,388
当涉及把功率降下来


583
00:34:48,922 --> 00:34:50,657
我提到过我们实际上可以卸载


584
00:34:50,724 --> 00:34:53,025
所以让我们说一下我们正在做的
我喜欢自行车


585
00:34:53,260 --> 00:34:56,996
我可以跟踪我的自行车
你知道 非常准确


586
00:34:57,297 --> 00:34:59,466
但那是硬件而不是软件


587
00:34:59,533 --> 00:35:04,538
所以推迟那些更新
所以每15分钟就会打电话给你


588
00:35:04,605 --> 00:35:07,207
嘿 看 这里是所有的跟踪信息


589
00:35:07,508 --> 00:35:10,477
但是大多数系统和你的软件都在休眠


590
00:35:10,544 --> 00:35:12,646
只有定位芯片在运行


591
00:35:14,414 --> 00:35:16,783
最后 我们第三个因素
对调试软件来说


592
00:35:16,850 --> 00:35:19,653
这确实是我们希望你做的三件事


593
00:35:20,454 --> 00:35:23,056
你知道 减少网络 减少定位


594
00:35:23,490 --> 00:35:24,892
和后台运行


595
00:35:27,127 --> 00:35:31,598
这些只是用户通常看不到的功耗
当他们推出这个应用程序的时候


596
00:35:31,665 --> 00:35:33,634
用户可能会喜欢
这个实时更新的应用程序


597
00:35:33,700 --> 00:35:35,936
但是尝试使用后台应用程序刷新


598
00:35:36,003 --> 00:35:37,838
尽量呈现优质
大量的leeways


599
00:35:38,472 --> 00:35:40,707
如果你发送通知随后被忽略


600
00:35:41,141 --> 00:35:44,011
会点亮屏幕
它正在发射网络 这只是


601
00:35:44,711 --> 00:35:47,581
不仅是这个消耗


602
00:35:47,648 --> 00:35:49,850
如果你一直运行的话
将会很快的消耗你的电池


603
00:35:49,917 --> 00:35:51,952
但是这是一个...


604
00:35:53,153 --> 00:35:55,556
这基本上只是去掉了


605
00:35:56,256 --> 00:35:58,292
适用于其它事物的能量


606
00:35:58,358 --> 00:36:00,694
它正在减少基本上
如果我降低了障碍


607
00:36:00,761 --> 00:36:04,298
那么就是说你已经实现了...
9%以下而不是10%


608
00:36:04,765 --> 00:36:05,866
我们需要避免...


609
00:36:06,333 --> 00:36:07,968
而这20%更糟


610
00:36:08,502 --> 00:36:11,138
因为平均下来你只有5%


611
00:36:11,939 --> 00:36:14,241
只要确定你不在后台运行
怎样去实现这一目的呢


612
00:36:15,209 --> 00:36:17,377
调用后台任务时


613
00:36:17,444 --> 00:36:19,713
我们将让设备保持几分钟的唤醒状态


614
00:36:20,647 --> 00:36:23,417
这样你可以尽快的
终止后台任务


615
00:36:23,851 --> 00:36:27,688
除了能量指南之外
还有一个很好的应用程序指南


616
00:36:27,754 --> 00:36:29,857
那还有一个应用程序生命周期指南


617
00:36:29,923 --> 00:36:34,361
这个消息会通知你
你将进入后台


618
00:36:35,462 --> 00:36:38,398
你的用户界面状态保存在那儿


619
00:36:38,465 --> 00:36:40,234
和用户界面对话 保持当前状态


620
00:36:40,601 --> 00:36:42,870
如果你有需要保存的重要数据


621
00:36:44,371 --> 00:36:46,974
去开一个后台操作


622
00:36:48,308 --> 00:36:50,978
但是确定
所有的代码申请终止后台任务


623
00:36:51,044 --> 00:36:52,613
不要泄露后台任务


624
00:36:53,814 --> 00:36:55,449
如果你有网络


625
00:36:55,516 --> 00:36:58,719
也许像保存到磁盘那样
这也可能会发生


626
00:36:59,119 --> 00:37:00,387
网络活动...


627
00:37:00,654 --> 00:37:04,925
这是把网络从操作系统中卸载的好机会


628
00:37:04,992 --> 00:37:06,627
嗨 我有这个网络 它需要发生


629
00:37:06,693 --> 00:37:09,363
但它不是时间的关键
只要在一定的时间范围内


630
00:37:09,963 --> 00:37:11,265
有机会就一定需要完成它


631
00:37:11,598 --> 00:37:14,468
给系统一个机会去优化


632
00:37:15,669 --> 00:37:17,504
这也是很好的一个设计时间


633
00:37:17,905 --> 00:37:21,441
在这方面可以让你
在设计应用程序的时候更灵活


634
00:37:23,110 --> 00:37:24,211
这是我理想的应用程序


635
00:37:24,411 --> 00:37:25,712
強 展示了一个很好的幻灯片


636
00:37:25,846 --> 00:37:28,248
典型的应用程序
在你启动它的时候会有很多工作


637
00:37:28,916 --> 00:37:31,818
我理想的应用程序
是在你退出的时候几乎没有任何工作


638
00:37:31,952 --> 00:37:33,253
它不做任何工作


639
00:37:33,754 --> 00:37:35,255
直到用户实际交互


640
00:37:35,556 --> 00:37:36,857
这很疯狂！


641
00:37:37,558 --> 00:37:39,793
很多工作 需要我们完成
这是所有的工作


642
00:37:39,860 --> 00:37:41,228
请优先考虑


643
00:37:41,728 --> 00:37:44,131
然后 在它完成之后再返回


644
00:37:44,498 --> 00:37:45,599
它是好的而且是空闲的


645
00:37:45,766 --> 00:37:49,670
那样你就可以推翻泛美金字塔


646
00:37:50,070 --> 00:37:51,872
这达到了预期要求


647
00:37:54,741 --> 00:37:56,376
那么你的应用程序是怎样运行的呢


648
00:37:56,510 --> 00:37:58,645
我们真的很希望你们回家的
时候运行一下这个工具


649
00:37:58,712 --> 00:38:01,081
完整的运行一遍来检查你的应用程序


650
00:38:01,148 --> 00:38:03,717
之后这些工具将会告诉
你对应用程序的操作是什么


651
00:38:04,184 --> 00:38:07,020
确定应用程序正在做的事情
对功耗产生的影响


652
00:38:07,354 --> 00:38:09,990
就相当于用户被交付的利益


653
00:38:10,490 --> 00:38:14,561
除了OS X 对于iOS来说Xcode
现在也有了一个能量计


654
00:38:14,995 --> 00:38:17,064
它突出我刚才讨论到的事情


655
00:38:17,130 --> 00:38:19,666
比如有中央处理器
网络 定位以及后台


656
00:38:20,300 --> 00:38:23,036
把所有的网络融合然后
控制所有的定位


657
00:38:23,403 --> 00:38:25,339
最后再取消后台任务


658
00:38:25,939 --> 00:38:27,941
那么就来到我们下一个话题
了解一下它


659
00:38:28,675 --> 00:38:31,512
首先当你设计你的下一个特征


660
00:38:31,812 --> 00:38:34,848
设计你的下一个应用程序的时候
请思考一下这些消耗


661
00:38:35,148 --> 00:38:38,719
比如原处理器功率
CPU和GPU的模式


662
00:38:38,785 --> 00:38:40,387
我是正在醒来或是准备去休息


663
00:38:40,454 --> 00:38:42,589
我能对它做出更多的约束么


664
00:38:43,390 --> 00:38:45,325
任何像那样的闪烁


665
00:38:45,526 --> 00:38:48,595
你们中的一些人可能还记得
早些时候网页上闪烁的标签


666
00:38:48,829 --> 00:38:51,265
没有闪烁 特别是在高频下


667
00:38:52,499 --> 00:38:55,636
比用户交互更快的任何东西
都是高频率的


668
00:38:56,770 --> 00:38:58,705
尝试着给自己设定一个期望值


669
00:38:58,772 --> 00:39:01,175
因为如果你准备写一个聊天应用程序


670
00:39:01,408 --> 00:39:03,343
全天下来
你自己本身可能都变成流媒体了


671
00:39:03,410 --> 00:39:05,812
你应当把程序安装
在一个新的硬件设备上


672
00:39:06,480 --> 00:39:09,149
这样的话用户就很有可能在你的
应用程序中实现全天续航


673
00:39:09,216 --> 00:39:11,852
他们必须买一个单独的手机
事实上是三部手机


674
00:39:11,919 --> 00:39:13,387
以确保可以整天运行


675
00:39:15,689 --> 00:39:17,391
但很遗憾 那个应用程序卖的并不好


676
00:39:19,493 --> 00:39:21,662
在你的商业模式中这种计划


677
00:39:21,728 --> 00:39:23,931
是否与这个应用程序的电池续航能力
表现的一样呢


678
00:39:24,364 --> 00:39:28,769
我正在使用很多的定位以及很多的网络
我在后台去完成这些任务


679
00:39:29,102 --> 00:39:30,270
主要是因为它们很昂贵


680
00:39:31,772 --> 00:39:34,074
看一下执行效果
可以通过查阅能源指南


681
00:39:34,141 --> 00:39:36,844
确保你可以给应用程序接口
传递最佳参数


682
00:39:37,244 --> 00:39:39,079
看一下你自己的代码
再看一下我们的代码


683
00:39:39,146 --> 00:39:41,582
如果我们的代码在做一些奇怪的事情
比如提交一个错误


684
00:39:41,648 --> 00:39:43,984
最后看一下你可能使用的第三方代码


685
00:39:44,751 --> 00:39:48,455
你有一个广告框架 广告本身很好
因为它可以支持我们的平台


686
00:39:49,990 --> 00:39:53,360
但是 如果他们像其它广告那样
做很多的下载


687
00:39:53,427 --> 00:39:55,629
下载显示 下载显示 下载显示


688
00:39:56,063 --> 00:39:58,398
在很长一段时间之间
我们必须保持网络开启


689
00:39:58,799 --> 00:40:00,701
那样并不好
必须要注意到这一点


690
00:40:01,335 --> 00:40:02,302
在最后 进行测试


691
00:40:02,369 --> 00:40:04,071
可以通过定期运行这些工具


692
00:40:04,137 --> 00:40:07,808
去确保你的应用程序
可以按照你期望的方式去运行


693
00:40:09,743 --> 00:40:13,614
如果你已经把这些事情都完成了
我怀疑你没有 但也许你有


694
00:40:13,680 --> 00:40:14,982
在这项任务中 最重要的工作


695
00:40:15,682 --> 00:40:19,119
就是继续进行
检查你的后台更新间隔


696
00:40:19,186 --> 00:40:22,689
你能够减少或者给你的系统
更大的自由度么


697
00:40:23,657 --> 00:40:25,592
你能够更加谨慎的使用声明么


698
00:40:25,659 --> 00:40:29,263
特别是当你开发VoIP应用程序的时候
我们给应用程序的接口做了一些改变


699
00:40:29,396 --> 00:40:31,231
请记住 这些传入连接是很便宜的


700
00:40:31,532 --> 00:40:34,034
但并不是免费的
他们会让你回电话


701
00:40:34,101 --> 00:40:35,602
但不要退出


702
00:40:36,603 --> 00:40:38,172
不要弄混显示屏的亮度


703
00:40:38,839 --> 00:40:41,041
绘画可能是下一个过度的前奏...


704
00:40:41,375 --> 00:40:44,077
我讨论到闪烁的知识
那仍有很多绘画的事情你可以去完成


705
00:40:44,144 --> 00:40:46,680
去年谈论到这个话题
在末尾的链接中


706
00:40:46,947 --> 00:40:48,715
可以知道相关的主题图是正确的


707
00:40:49,016 --> 00:40:49,983
也获得了一些工具


708
00:40:50,250 --> 00:40:51,084
最后...


709
00:40:51,919 --> 00:40:54,755
对于OS X和iOS来说
我们现在已经有一些能量指南


710
00:40:54,821 --> 00:40:57,591
我只是提出把所有的这些信息
都记录下来


711
00:40:57,658 --> 00:40:59,693
我将会继续
在developer.Apple.com中


712
00:40:59,760 --> 00:41:01,328dle
更新这些信息


713
00:40:59,760 --> 00:41:01,328
更新这些信息


714
00:41:01,929 --> 00:41:04,131
所以总结我们所讲过的内容


715
00:41:05,032 --> 00:41:06,233
就是功耗是功率


716
00:41:07,034 --> 00:41:09,236
乘以时间
如果你想减少功耗


717
00:41:09,570 --> 00:41:13,607
那么相对于你运行的时间来说
功率是很重要的


718
00:41:14,208 --> 00:41:16,143
我们希望你能够降低功率


719
00:41:16,210 --> 00:41:19,313
当然我们的工具本身就是低功率的
我们的工具在低功率方面表现的不错


720
00:41:19,379 --> 00:41:20,681
你也将会在下一次讨论中涉及到它


721
00:41:20,747 --> 00:41:23,350
这些可以支持用户实现
电池提供全天续航


722
00:41:24,418 --> 00:41:26,119
做更少的工作


723
00:41:26,587 --> 00:41:28,622
或者延迟工作
以及提高完成工作的效率


724
00:41:29,756 --> 00:41:31,291
这里是我谈论到的链接


725
00:41:31,792 --> 00:41:36,330
文档、视频、指南 以及去年的谈话


726
00:41:37,865 --> 00:41:39,766
我们有我们的标准论坛


727
00:41:39,833 --> 00:41:42,769
你可以和其他人交流
你能够联系我或者DTS的人


728
00:41:43,170 --> 00:41:44,171
他们有我的手机号码


729
00:41:44,371 --> 00:41:48,008
你不必要我的手机号码 他们有
和他们谈一下 他们可能会帮助你


730
00:41:48,075 --> 00:41:50,978
如果他们不能的话 他们可以联系我
或者我的一个出色的队友


731
00:41:51,879 --> 00:41:54,248
保羅 也在这里
他的电子邮箱附在这张幻灯片中


732
00:41:56,850 --> 00:41:57,851
参加相关会议


733
00:41:58,952 --> 00:42:00,687
或下一届会议的人请留下来


734
00:42:00,921 --> 00:42:03,190
我们有一些网络的参数性能


735
00:42:03,724 --> 00:42:05,893
可以看一下 他们将会帮助你


736
00:42:05,959 --> 00:42:08,362
去思考怎样优化
我刚才所谈论到的所有事情


737
00:42:08,762 --> 00:42:11,632
请继续为了节能优化你的应用程序

