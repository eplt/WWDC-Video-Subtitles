1
00:00:26,593 --> 00:00:27,728
下午好


2
00:00:29,596 --> 00:00:31,064
大家好
感谢大家能来参加讲座


3
00:00:31,131 --> 00:00:34,001
我是泰德·克热梅内克
我在Apple管理Swift团队


4
00:00:34,067 --> 00:00:37,704
阿莱克斯和我很高兴也很荣幸


5
00:00:38,138 --> 00:00:40,741
和大家讲讲在编译时使用Swift


6
00:00:41,141 --> 00:00:44,444
来发现编码的更多问题


7
00:00:45,212 --> 00:00:46,613
这是个相当宽泛的话题 所以我们


8
00:00:46,680 --> 00:00:48,882
所以我们决定主要谈两个问题


9
00:00:49,683 --> 00:00:53,654
首先是利用Swift 2中的
新语言术语供给


10
00:00:54,588 --> 00:00:58,625
以便轻松允许应用利用新的API


11
00:00:58,725 --> 00:01:00,160
与此同时部署更早的版本


12
00:01:00,594 --> 00:01:02,596
在更早的讲座中
我们简要谈过这个话题


13
00:01:02,663 --> 00:01:04,531
我们马上要深入探讨设计


14
00:01:04,598 --> 00:01:06,867
方法的理念所解决的问题


15
00:01:06,934 --> 00:01:08,535
以及如何在代码中实现最佳应用


16
00:01:09,269 --> 00:01:11,138
然后 阿莱克斯会谈谈如何


17
00:01:11,205 --> 00:01:14,441
使用富类型系统协议和枚举


18
00:01:14,508 --> 00:01:18,312
甚至还有协议扩展
以便在在自己的代码中


19
00:01:18,378 --> 00:01:20,581
执行应用不变性
并定义解决许多应用开发模板


20
00:01:23,050 --> 00:01:24,685
我们先来看第一个话题


21
00:01:24,751 --> 00:01:27,087
利用新API


22
00:01:28,589 --> 00:01:34,761
这类话题已经讲了很多遍
很多人对此都很熟悉


23
00:01:35,429 --> 00:01:37,397
对Apple而言 我们继续在


24
00:01:37,464 --> 00:01:42,836
每个OS版本中推出丰富的API


25
00:01:43,270 --> 00:01:46,673
让大家有机会在应用中构建不错的功能


26
00:01:47,174 --> 00:01:50,377
对吗？
这是我们这么做的部分原因 不是吗？


27
00:01:51,211 --> 00:01:55,482
这里的谜题是app具备已有用户 
对么？


28
00:01:55,549 --> 00:01:56,783
他们目前...


29
00:01:57,618 --> 00:01:59,353
他们不必使用最新的OS


30
00:01:59,419 --> 00:02:01,922
在iOS 有较快的使用率


31
00:02:02,322 --> 00:02:05,225
但是这不是说人人都会立刻采用


32
00:02:05,325 --> 00:02:08,529
还有些人出于各种原因完全不会使用


33
00:02:09,463 --> 00:02:13,100
那么你会面临一系列选择
你会怎么做呢？


34
00:02:14,568 --> 00:02:15,502
你是否会继续


35
00:02:15,569 --> 00:02:18,572
并要求app使用最新OS？


36
00:02:18,639 --> 00:02:22,242
好 那你获得所有的新API 
可这的确成问题


37
00:02:22,309 --> 00:02:24,411
因为你会搞砸


38
00:02:24,478 --> 00:02:25,612
要知道 你会损失用户


39
00:02:25,679 --> 00:02:27,281
这些是会购买你的app的人群


40
00:02:29,550 --> 00:02:32,085
你是否应该走到相反的极端


41
00:02:32,152 --> 00:02:34,988
控制使用新API？


42
00:02:35,055 --> 00:02:37,491
这样就会获得所支持的


43
00:02:37,558 --> 00:02:39,359
最早版本OS的最小公分母


44
00:02:39,593 --> 00:02:42,963
这样做很糟糕因为你会影响到


45
00:02:43,030 --> 00:02:45,199
原本可以向用户提供的丰富


46
00:02:45,265 --> 00:02:46,099
功能


47
00:02:47,167 --> 00:02:49,570
当然 要知道有鱼和熊掌兼得的办法


48
00:02:49,636 --> 00:02:54,308
可以采用新API与此同时还


49
00:02:54,374 --> 00:02:55,843
可以部署更早的版本


50
00:02:56,844 --> 00:03:00,380
所以很长时间以来 我们在技术上


51
00:03:00,480 --> 00:03:01,582
都支持这种做法


52
00:03:02,482 --> 00:03:05,219
当然 可以在Objective-C
和Swift中均可如此


53
00:03:05,285 --> 00:03:08,155
可是现实中 如今这是个非常


54
00:03:08,222 --> 00:03:09,590
痛苦的体验


55
00:03:16,029 --> 00:03:19,700
在Swift 2中 我们尽可能
不让它这么痛苦


56
00:03:19,766 --> 00:03:23,437
我们通过开发人员告知的当前问题


57
00:03:23,670 --> 00:03:27,074
关于部署较早版本


58
00:03:27,140 --> 00:03:29,109
并设法解决语言中的问题


59
00:03:29,176 --> 00:03:30,410
来实现这一点


60
00:03:32,412 --> 00:03:34,848
现在基本模型并未改变 对吧？


61
00:03:34,915 --> 00:03:38,919
对于开发而言在我们的平台上


62
00:03:38,986 --> 00:03:40,387
一直希望大家使用最新SDK


63
00:03:40,754 --> 00:03:43,624
对吗？这会导致应用中所有可能


64
00:03:43,690 --> 00:03:45,792
用到的API都混到了


65
00:03:46,260 --> 00:03:47,160
一起


66
00:03:47,928 --> 00:03:50,430
然后 可以切换app的部署目标


67
00:03:50,497 --> 00:03:52,533
说明你想要退回的时间


68
00:03:53,901 --> 00:03:55,569
从画面来看这样就非常简单


69
00:03:55,669 --> 00:03:57,638
就像是版本的滑动视窗


70
00:03:57,704 --> 00:03:59,506
设置最新的基底SDK


71
00:03:59,907 --> 00:04:02,543
把部署目标设置到视窗的


72
00:04:02,809 --> 00:04:04,011
最早版本 对么？


73
00:04:04,545 --> 00:04:05,612
从概念来讲 很简单


74
00:04:07,080 --> 00:04:11,752
那么在谈到在Swift 2中 


75
00:04:11,818 --> 00:04:15,689
如何采用新功能和API之前
我们先来看


76
00:04:15,756 --> 00:04:17,757
现有方法中的问题


77
00:04:18,257 --> 00:04:21,827
基本上而言 你必须编写app


78
00:04:21,894 --> 00:04:26,033
以便应对更早版本的主OS中
API缺失的问题 对吗？


79
00:04:26,834 --> 00:04:30,504
还有几个问题需要单独考虑


80
00:04:30,938 --> 00:04:33,707
整个框架的缺失类方法 


81
00:04:33,774 --> 00:04:37,611
函数 甚至部分枚举值


82
00:04:37,978 --> 00:04:39,112
在更早的版本中不得使用


83
00:04:39,613 --> 00:04:42,349
但是令人烦心的是你必须逐一


84
00:04:42,416 --> 00:04:44,451
解释所有这些问题


85
00:04:45,185 --> 00:04:47,821
对框架而言很是麻烦 要决定


86
00:04:47,888 --> 00:04:50,257
我把它连接到应用时 这个


87
00:04:50,557 --> 00:04:52,392
框架是可选项


88
00:04:52,860 --> 00:04:56,029
如果不这样做app就会在启动


89
00:04:56,096 --> 00:04:57,564
较早版本的OS时 出现问题


90
00:04:59,766 --> 00:05:02,703
然后是API本身实际运用


91
00:05:02,769 --> 00:05:05,272
我们先来看类


92
00:05:06,139 --> 00:05:08,275
基本上来说你是在编写app


93
00:05:08,342 --> 00:05:09,943
因此它会有不同表现


94
00:05:10,043 --> 00:05:11,645
这将是有条件的行为


95
00:05:11,712 --> 00:05:15,282
例如当新的API
可用app就会做些不同的事情


96
00:05:15,782 --> 00:05:18,051
因此条件逻辑并不是问题


97
00:05:18,619 --> 00:05:21,788
问题在于怎样为行为实现条件化


98
00:05:22,956 --> 00:05:25,192
在这张幻灯片上是用来检测可用性的


99
00:05:25,259 --> 00:05:26,593
典型方法


100
00:05:26,660 --> 00:05:28,929
你来查询
Objective-C的运行时间


101
00:05:28,996 --> 00:05:32,132
这个类会在运行时间出现么？


102
00:05:33,367 --> 00:05:35,636
问题是这有点谎言的味道


103
00:05:35,936 --> 00:05:38,238
对吗？我是说类可以有


104
00:05:38,705 --> 00:05:41,475
但是这不意味着你可以使用


105
00:05:42,376 --> 00:05:47,214
API会经常开始是内部API 


106
00:05:47,948 --> 00:05:49,283
在OS中 


107
00:05:49,716 --> 00:05:52,786
它们会在生成和演进的
地方呆上一阵在对外发布时


108
00:05:53,220 --> 00:05:55,923
API的行为


109
00:05:56,290 --> 00:05:58,892
可能已经完全改变


110
00:05:59,359 --> 00:06:01,628
即便这样的检测在运行时间成功了


111
00:06:02,462 --> 00:06:04,431
这也不能说明实际使用


112
00:06:04,498 --> 00:06:06,900
这款API时会绝对安全


113
00:06:07,634 --> 00:06:13,674
而是说 如果在OS版本上
你使用的时间太过于早 


114
00:06:14,141 --> 00:06:16,710
基本上会在应用中加上定时炸弹


115
00:06:16,777 --> 00:06:21,949
原本你以为API会按照一定方式
表现 现在会完全遭到破坏


116
00:06:22,115 --> 00:06:24,351
这会令开发人员多次受到打击


117
00:06:24,985 --> 00:06:27,221
因此是个严重问题


118
00:06:29,189 --> 00:06:31,992
另一个问题是太容易出错


119
00:06:32,659 --> 00:06:34,127
来看这个新款API


120
00:06:34,661 --> 00:06:36,730
通过几项特色功能


121
00:06:36,930 --> 00:06:40,834
我的代码完全有效结果却出了差错


122
00:06:41,435 --> 00:06:45,305
数据在NS数据资产之前很久引入的


123
00:06:45,572 --> 00:06:48,342
代码还会编译 若在最新的OS上检测


124
00:06:48,408 --> 00:06:50,143
它甚至会成功运行


125
00:06:50,410 --> 00:06:53,580
那么只是在更早版本的设备上


126
00:06:53,914 --> 00:06:55,516
运行代码 才会出现问题


127
00:06:55,616 --> 00:06:58,986
对吗？这与通常的测试场景完全不符


128
00:06:59,419 --> 00:07:01,255
在部分情况下


129
00:07:01,321 --> 00:07:03,123
只需要用户来发现这个问题


130
00:07:03,824 --> 00:07:07,528
即将出现的情况是
当你试图使用这个类时运行时间会崩溃


131
00:07:09,897 --> 00:07:15,102
很容易因为简单的小错出现问题


132
00:07:16,570 --> 00:07:20,174
方法和类的问题基本一样


133
00:07:20,908 --> 00:07:22,910
可能会出现输入错误


134
00:07:23,177 --> 00:07:25,045
如果检测属性的可用性


135
00:07:25,112 --> 00:07:27,681
你现在必须了解属性的选择器


136
00:07:27,748 --> 00:07:29,650
同时还要拼写正确


137
00:07:29,750 --> 00:07:32,519
此外语法也完全不同 对吗？


138
00:07:32,586 --> 00:07:34,888
来检测API但是语法不一样


139
00:07:36,089 --> 00:07:37,724
函数也有着同样问题


140
00:07:37,791 --> 00:07:39,626
你会犯同样的错误不过可以有


141
00:07:39,693 --> 00:07:41,461
其他方式来编写


142
00:07:42,196 --> 00:07:45,299
那么 如果有枚举那你就被完全骗到了


143
00:07:45,365 --> 00:07:47,668
你不知道 怎样的解决方案才合适


144
00:07:47,734 --> 00:07:50,237
选择器对映射完全没有反应


145
00:07:50,637 --> 00:07:54,274
那就要手动OS版本检测


146
00:07:54,708 --> 00:07:57,778
来看这个表格感觉就像是你希望


147
00:07:57,845 --> 00:07:59,079
改正的所有簿记问题


148
00:07:59,146 --> 00:08:00,447
都在这里


149
00:08:01,248 --> 00:08:03,717
这是个非常伤感的故事


150
00:08:07,254 --> 00:08:09,456
现在我们看到的是的确成问题的


151
00:08:09,523 --> 00:08:10,390
编程模型


152
00:08:10,457 --> 00:08:13,227
对吗？技术上可行但是很难做到


153
00:08:13,694 --> 00:08:15,329
我们希望你利用新款API


154
00:08:15,395 --> 00:08:18,465
与此同时继续支持所有的用户


155
00:08:19,933 --> 00:08:22,569
我们需要解决这些问题


156
00:08:25,005 --> 00:08:28,108
在Swift 2中情况有所改变


157
00:08:28,175 --> 00:08:29,409
把改变构建在语言当中


158
00:08:30,677 --> 00:08:34,615
要以怎样架构app为主 那么


159
00:08:35,048 --> 00:08:37,150
有其他方法可行时可以考虑


160
00:08:37,251 --> 00:08:38,684
使用这些API


161
00:08:38,751 --> 00:08:40,953
你理解 会有条件性行为


162
00:08:41,355 --> 00:08:42,890
但是你会主要关注于此


163
00:08:43,957 --> 00:08:45,759
然后有编译器作为支持


164
00:08:46,326 --> 00:08:49,897
如果用不安全的方式使用API 
就会出现错误


165
00:08:51,064 --> 00:08:53,500
还要有统一的句法这样就不必考虑


166
00:08:53,567 --> 00:08:56,436
类 方法函数甚至映射问题


167
00:08:56,503 --> 00:09:00,073
这些都在所用的句法中处理好了


168
00:09:00,140 --> 00:09:02,676
编译器了解你该用的句法


169
00:09:02,743 --> 00:09:05,546
如果你没有做对 它会告诉你正确做法


170
00:09:07,681 --> 00:09:11,151
因为编译器会一直参与其中


171
00:09:11,218 --> 00:09:12,886
在Swift中我们使用模型


172
00:09:13,420 --> 00:09:16,123
所有可选链接可以帮你来处理


173
00:09:18,759 --> 00:09:22,362
那么这样效果如何
这里是来自核心位置的部分API


174
00:09:24,498 --> 00:09:26,934
比如说 我在部署iOS 9


175
00:09:27,201 --> 00:09:29,469
因此使iOS 9 SDK


176
00:09:29,536 --> 00:09:31,505
并设置iOS 9的部署目标


177
00:09:32,773 --> 00:09:35,542
编译器可以在SDK中看到该信息


178
00:09:35,609 --> 00:09:37,411
因此这是在
Objective-C头文件中


179
00:09:37,477 --> 00:09:39,947
还可以作为
Swift中生成的界面来查看


180
00:09:40,614 --> 00:09:42,716
因此类被引入iOS 2中


181
00:09:43,450 --> 00:09:45,686
方法稍后会引入iOS 8


182
00:09:46,620 --> 00:09:48,121
因为我在运行iOS 9


183
00:09:48,222 --> 00:09:50,457
可以无条件使用这款API


184
00:09:51,558 --> 00:09:54,795
如果我在iOS 8
部署也仍然没有问题


185
00:09:55,562 --> 00:09:58,165
但是如果我一路退回iOS 7 


186
00:09:58,599 --> 00:10:01,034
编译器可以看到
正如我们可以在幻灯片上看到


187
00:10:02,002 --> 00:10:04,438
使用这种方法并不安全


188
00:10:04,505 --> 00:10:06,373
需要请求使用授权


189
00:10:09,109 --> 00:10:13,380
编译器会告诉你这是不安全代码


190
00:10:14,047 --> 00:10:15,415
是错误


191
00:10:15,482 --> 00:10:18,218
它会禁止你构建这个代码


192
00:10:19,186 --> 00:10:20,687
并会提供不错的安全性检测


193
00:10:26,660 --> 00:10:29,363
它会提供可以解决


194
00:10:29,997 --> 00:10:31,932
这一问题的不同方法


195
00:10:33,100 --> 00:10:35,502
这里有注解 你是否需要安全检测？


196
00:10:36,203 --> 00:10:38,839
会有附上的解决办法 如果接受


197
00:10:39,273 --> 00:10:40,807
代码就重写 像这样


198
00:10:42,142 --> 00:10:48,382
现在有汇编组合静态执行


199
00:10:48,448 --> 00:10:49,716
和运行时间执行


200
00:10:51,051 --> 00:10:54,121
这就是散列可用句法


201
00:10:54,821 --> 00:10:58,725
基本上 
编译器扫描可以看到代码块中的


202
00:10:59,092 --> 00:11:04,364
所有内容最新的iOS 
OS X或安全执行这些API


203
00:11:04,431 --> 00:11:05,666
所需的具体版本


204
00:11:06,099 --> 00:11:08,235
是什么？


205
00:11:09,369 --> 00:11:12,372
然后会使用在散列可用的


206
00:11:12,439 --> 00:11:15,042
所提到版本进行适当的运行时间检测


207
00:11:15,108 --> 00:11:16,977
编译器会把它插入其中


208
00:11:17,044 --> 00:11:19,346
你不必猜测如何完成 会高效完成


209
00:11:19,680 --> 00:11:22,583
并做缓存
这样就可以安全使用


210
00:11:23,517 --> 00:11:26,553
在SDK中使用该信息


211
00:11:26,620 --> 00:11:30,324
会实现高保真
因此会得到真正安全的模式


212
00:11:32,960 --> 00:11:34,228
有些人会问


213
00:11:34,595 --> 00:11:37,231
为什么要在OS版本中
进行检测呢


214
00:11:37,297 --> 00:11:39,666
不是提供过对以往内容


215
00:11:39,733 --> 00:11:41,201
所做的指南么？


216
00:11:41,935 --> 00:11:46,273
原因是做簿记实在太难


217
00:11:46,673 --> 00:11:49,776
至少当你查询运行时间时 


218
00:11:50,077 --> 00:11:53,013
你会得到部分真相 但是在很多情况下
即便是真相也会有出入


219
00:11:54,915 --> 00:11:58,919
逻辑上来讲 和app开发人员交谈


220
00:11:59,887 --> 00:12:02,489
要知道 你希望构建在app上的体验


221
00:12:02,556 --> 00:12:04,424
都发起在用户正在


222
00:12:04,491 --> 00:12:07,427
运行的主OS上 对么？


223
00:12:07,995 --> 00:12:11,532
在每个OS版本中都有一批新的API


224
00:12:12,599 --> 00:12:14,735
这些基本上定义了你可以执行的


225
00:12:15,002 --> 00:12:18,539
各种功能而用户在使用


226
00:12:18,605 --> 00:12:21,608
不同版本的OS 因此 他们在逻辑上


227
00:12:21,675 --> 00:12:25,245
打破了你的app所具备的


228
00:12:25,312 --> 00:12:27,414
行为类别 对么？


229
00:12:27,481 --> 00:12:30,951
所有这些在逻辑一致性上都有区别


230
00:12:32,052 --> 00:12:35,789
同样 它也不会检测某款API的存在


231
00:12:36,156 --> 00:12:39,193
因为你通常准备同时使用若干API


232
00:12:39,259 --> 00:12:41,128
这其实说不过


233
00:12:41,195 --> 00:12:42,863
某款API的存在并非表明其他


234
00:12:42,930 --> 00:12:44,565
也会存在


235
00:12:44,932 --> 00:12:47,467
信息位于SDK中编译器可以为你


236
00:12:47,534 --> 00:12:48,836
完成簿记工作


237
00:12:49,770 --> 00:12:52,573
编译器涉及到真正的规则改变者


238
00:12:53,140 --> 00:12:55,742
它使得可用性检测非常可靠


239
00:12:56,310 --> 00:12:59,813
可以假设编译器在做着正确的事情


240
00:13:00,047 --> 00:13:01,715
你尽可放心是在


241
00:13:01,782 --> 00:13:05,018
通过定义解决整类问题


242
00:13:05,085 --> 00:13:06,920
因为你在用编译执行


243
00:13:09,256 --> 00:13:13,026
而且自然会进入多个平台


244
00:13:13,827 --> 00:13:17,531
比如 
我之前有这个NSData资产实例


245
00:13:18,098 --> 00:13:20,968
如果
我想让代码以OS X和iOS为目标


246
00:13:21,435 --> 00:13:23,971
我可以简单扩展句法称我也在


247
00:13:24,037 --> 00:13:26,540
其他平台检测其最小可用性


248
00:13:27,574 --> 00:13:30,344
星级表明基本上在所有其他情况下


249
00:13:30,410 --> 00:13:32,513
在本例中应该是Watch OS


250
00:13:33,313 --> 00:13:34,781
我们把它放在那里显性调用


251
00:13:34,848 --> 00:13:36,717
潜在的流程控制


252
00:13:36,783 --> 00:13:39,953
对于其他没有明显提及的平台


253
00:13:40,153 --> 00:13:42,489
会执行指定条件


254
00:13:42,556 --> 00:13:45,158
基本上是真和假


255
00:13:45,526 --> 00:13:47,828
我们本想调用这些分支


256
00:13:47,895 --> 00:13:49,196
它们仍将被采用


257
00:13:49,463 --> 00:13:51,031
因此 我们想显性调用


258
00:13:51,098 --> 00:13:53,100
可读性行为


259
00:13:54,668 --> 00:13:58,105
现在可读性检测会在Swift 2中


260
00:13:58,172 --> 00:14:00,541
自然构成用于控制流的可供性


261
00:14:01,375 --> 00:14:04,845
比如 你之前已经构建了app 希望


262
00:14:04,912 --> 00:14:08,582
进行这类检测 然后执行部分功能


263
00:14:08,849 --> 00:14:11,451
否则什么都不做只要摆脱困境即可


264
00:14:12,653 --> 00:14:14,855
这与新的保安声明相结合


265
00:14:16,223 --> 00:14:18,192
可以像这样调整编码


266
00:14:18,559 --> 00:14:20,761
保安声明下面的的所有内容


267
00:14:20,827 --> 00:14:22,529
都有散列可用标签提供的


268
00:14:22,596 --> 00:14:23,830
可用性


269
00:14:29,570 --> 00:14:33,340
因此自然会找到方法


270
00:14:33,407 --> 00:14:34,975
来构成应用的因素


271
00:14:36,944 --> 00:14:38,812
比如 
你之前已经在iOS 7上做过部署


272
00:14:39,880 --> 00:14:43,517
我会把iOS 7中
可用的API代码染成绿色


273
00:14:43,917 --> 00:14:47,087
绿色条代表代码块中


274
00:14:47,154 --> 00:14:50,057
可以安全使用iOS 7或更早版本


275
00:14:50,123 --> 00:14:51,525
因此这基本上是编译器


276
00:14:52,059 --> 00:14:53,193
对世界的看法


277
00:14:54,661 --> 00:14:57,197
如果我想用iOS 8 API
我已经把它的代码


278
00:14:57,264 --> 00:14:59,700
涂成橙色 
你需要对它进行可用性检测


279
00:14:59,766 --> 00:15:01,268
否则 你会从编译器收到一个错误


280
00:15:01,902 --> 00:15:03,937
你可以认为在代码块中


281
00:15:04,004 --> 00:15:05,706
你有特权


282
00:15:05,772 --> 00:15:07,574
决定什么API可以调用


283
00:15:09,176 --> 00:15:11,912
一旦我出了代码块特权就不复存在


284
00:15:12,045 --> 00:15:14,114
就只能调用iOS 7 API


285
00:15:15,148 --> 00:15:17,885
如果我想调用iOS 9 API
我可以进行不同的检测


286
00:15:17,951 --> 00:15:20,254
这会在代码块中提供不同范围的特权


287
00:15:20,320 --> 00:15:22,256
它是极具可组合能力和可读性的模型


288
00:15:23,690 --> 00:15:25,692
比如 我在根据


289
00:15:25,759 --> 00:15:29,162
部分API是否可用构建


290
00:15:29,229 --> 00:15:31,532
具备整套不同功能的app


291
00:15:32,099 --> 00:15:33,033
我想对此进行分解


292
00:15:33,100 --> 00:15:36,270
我不是只把一束代码加入条件语句


293
00:15:36,336 --> 00:15:38,305
我希望把它分解放入不同的函数中


294
00:15:39,873 --> 00:15:40,841
这很容易做到


295
00:15:41,375 --> 00:15:42,843
可以声明另一个函数


296
00:15:42,910 --> 00:15:46,513
比如出于教学目的
我的函数使用iOS 8


297
00:15:46,880 --> 00:15:50,450
我准备从条件代码块中调用


298
00:15:51,652 --> 00:15:53,987
问题在于编译器不知道


299
00:15:54,054 --> 00:15:55,122
你要做什么要知道


300
00:15:55,189 --> 00:15:59,126
只有完成检测才能调用这个


301
00:16:00,227 --> 00:16:02,196
在默认状态下编译器会确认


302
00:16:02,763 --> 00:16:04,198
你锁定iOS 7


303
00:16:04,264 --> 00:16:06,767
我假设你在这个函数中 只使用


304
00:16:07,601 --> 00:16:08,468
iOS 7 API


305
00:16:09,903 --> 00:16:13,173
如果你想用iOS 8
API那么就要进行检测


306
00:16:14,842 --> 00:16:16,076
这不太好 对吧？


307
00:16:16,143 --> 00:16:18,979
这里并未提供方法来真正分析app


308
00:16:19,913 --> 00:16:21,615
还会导致冗余检测


309
00:16:24,251 --> 00:16:26,119
你可以告知编译器你的意图


310
00:16:27,621 --> 00:16:31,725
这样SDK本身会有这些方法和类的


311
00:16:31,792 --> 00:16:33,360
添加可用适应


312
00:16:33,427 --> 00:16:36,897
称这是可以用于API的最小OS


313
00:16:36,964 --> 00:16:40,601
在自己的代码上
也可以使用同样的注解


314
00:16:41,635 --> 00:16:44,805
表示除非已经进行过适当的


315
00:16:44,872 --> 00:16:46,740
可用性检测
否则不得调用该函数


316
00:16:47,608 --> 00:16:48,842
一旦出现这种情况


317
00:16:50,177 --> 00:16:52,312
编译器会以不同方式看待代码


318
00:16:53,814 --> 00:16:56,617
然后可以完全删除检测


319
00:16:56,683 --> 00:17:00,287
即额外的可用性检测
安全使用iOS 8 API


320
00:17:01,588 --> 00:17:02,656
这可以组合使用


321
00:17:02,723 --> 00:17:05,192
因为其他函数也有相似注解


322
00:17:05,259 --> 00:17:07,227
如果函数有着相同的API特权 


323
00:17:07,294 --> 00:17:10,631
可以直接调用它们


324
00:17:11,431 --> 00:17:14,601
如果在进行可用性检测时


325
00:17:14,701 --> 00:17:16,737
想通过更多特权调用API


326
00:17:17,771 --> 00:17:20,773
那么这样很方便构成 很容易理解


327
00:17:20,840 --> 00:17:22,742
代码的构成方法


328
00:17:25,212 --> 00:17:27,614
如大家的预期这也适用于方法


329
00:17:27,814 --> 00:17:30,150
这样可以标注类为可用


330
00:17:30,417 --> 00:17:32,586
但是具体方法 也许不可用


331
00:17:34,154 --> 00:17:37,958
如果需要 你可以在调用更可用的


332
00:17:38,025 --> 00:17:40,260
具体方法前 举例说明该类


333
00:17:40,327 --> 00:17:41,195
你需要进行检测


334
00:17:43,163 --> 00:17:46,300
在要求最小的可用性时 如果想标识


335
00:17:46,366 --> 00:17:48,168
整个类的话这样会奏效 


336
00:17:49,102 --> 00:17:52,639
如果这样做 除非进行过可用性检测


337
00:17:52,706 --> 00:17:54,274
否则甚至连举例说明类都不可能


338
00:17:55,042 --> 00:17:58,612
那你会获得API可用性


339
00:17:58,879 --> 00:18:01,582
完整的全部传递闭包


340
00:18:02,883 --> 00:18:05,652
这会自然引发 可以使用的更多技巧


341
00:18:07,521 --> 00:18:14,494
比如 
你已有较早版本中的自定义模糊视图 


342
00:18:15,362 --> 00:18:21,468
Apple会推出
更具体的UI视图子类 


343
00:18:21,602 --> 00:18:22,836
你想使用新版本


344
00:18:22,903 --> 00:18:25,806
在主OS上使用它们


345
00:18:27,641 --> 00:18:30,377
你想通过可用性保护实现这类


346
00:18:30,711 --> 00:18:34,715
运行时间多态 那么如果你在


347
00:18:34,781 --> 00:18:38,151
运行OS 要使用原生UI


348
00:18:38,585 --> 00:18:41,355
否则就要使用自定义的


349
00:18:42,356 --> 00:18:43,790
这样获得对象的客户端


350
00:18:43,857 --> 00:18:47,528
并不需要在乎你运行的OS版本


351
00:18:47,861 --> 00:18:49,930
到底是哪个


352
00:18:50,030 --> 00:18:52,666
你已经完全提供了关注点的分离


353
00:18:54,001 --> 00:18:56,069
当用到协议做同样的事情


354
00:18:56,136 --> 00:18:58,305
效果会很好可提供不同的执行


355
00:18:58,372 --> 00:19:00,941
可以有闭包不同的函数


356
00:19:01,275 --> 00:19:04,745
可以实现完全不同的新方法分析代码


357
00:19:04,811 --> 00:19:06,346
并获得你所期待的安全性


358
00:19:08,248 --> 00:19:10,651
我们觉得可用性检测相当棒


359
00:19:11,251 --> 00:19:14,988
我觉得它的确提供了具有凝结力


360
00:19:15,055 --> 00:19:20,460
的安全方法来
使用新款API并部署到更早版本


361
00:19:21,195 --> 00:19:23,897
统一的句法提供了真正安全的编程模型


362
00:19:24,665 --> 00:19:27,367
但是更重要的是它提供了
正常分析app的方法


363
00:19:27,434 --> 00:19:28,635
你可以阅读app


364
00:19:28,702 --> 00:19:31,572
可以阅读代码并理解


365
00:19:31,638 --> 00:19:33,674
可以期待不变性


366
00:19:34,441 --> 00:19:36,210
我觉得这一点 非常强大


367
00:19:37,578 --> 00:19:39,413
接下来我把讲台交给阿莱克斯


368
00:19:39,479 --> 00:19:42,449
他来介绍使用
Swift强大类型系统的其他方法


369
00:19:42,516 --> 00:19:44,885
以便在自己的应用中执行不变性


370
00:19:51,491 --> 00:19:52,392
谢谢 泰德


371
00:19:52,459 --> 00:19:54,494
大家好
我是阿莱克斯•米基科夫斯基


372
00:19:54,561 --> 00:19:56,063
是Apple的示例编码员


373
00:19:56,797 --> 00:19:58,065
在过去的一年半时间


374
00:19:58,498 --> 00:20:01,869
我都在教开发人员如何用
Swift编写Cocoa app


375
00:20:03,036 --> 00:20:08,742
我对于Swift
和Cocoa有着清晰的梦想


376
00:20:09,877 --> 00:20:13,046
怎样才能让二者在一起实现安全的


377
00:20:13,113 --> 00:20:15,749
编译时间 安全应用


378
00:20:17,150 --> 00:20:20,387
今天我想介绍我已有部分想法 


379
00:20:20,787 --> 00:20:22,689
并解释大家可以从中使用的


380
00:20:22,756 --> 00:20:24,958
部分范例并把这些概念


381
00:20:25,025 --> 00:20:27,661
运用到各自的应用当中


382
00:20:27,761 --> 00:20:30,197
这样你也可以编译时间安全代码


383
00:20:31,431 --> 00:20:34,234
现在我还没有告知大家 
但是在这些想法中


384
00:20:34,568 --> 00:20:36,770
我还想到了独角兽


385
00:20:38,138 --> 00:20:40,007
我开发了独角兽app来看一下


386
00:20:40,174 --> 00:20:45,312
我设想的不同独角兽


387
00:20:47,014 --> 00:20:50,350
首先 我想介绍我应用中的


388
00:20:51,018 --> 00:20:53,086
Asset Catalog 标识符


389
00:20:53,153 --> 00:20:56,123
每个人都在UIKit中用到它


390
00:20:57,457 --> 00:20:59,993
我的独角兽浏览app相对简单


391
00:21:00,060 --> 00:21:04,398
在Asset Catalog中
我已经加入3个独角兽图像


392
00:21:06,166 --> 00:21:09,136
我现在想看看当我从
Asset Catalog生成图像


393
00:21:09,203 --> 00:21:12,406
代码会是什么样


394
00:21:14,041 --> 00:21:15,776
你会注意到


395
00:21:15,876 --> 00:21:18,312
我在搭建的3个图像


396
00:21:18,812 --> 00:21:20,848
每个图像我都向UIKit UI


397
00:21:20,914 --> 00:21:23,717
图像API传递一个字符串


398
00:21:24,885 --> 00:21:30,190
不知道Asset Catalog 
UIKit实际上提供了怎样的资产


399
00:21:30,257 --> 00:21:31,725
所以我必须打开这些图像


400
00:21:31,792 --> 00:21:34,161
才能在应用中使用它们


401
00:21:35,162 --> 00:21:36,463
非常不巧


402
00:21:36,530 --> 00:21:40,701
因为已在Asset Catalog
定义Asset Catalog标识


403
00:21:40,767 --> 00:21:44,304
我不希望这里出现重复信息


404
00:21:45,405 --> 00:21:49,243
此外 这里我只会使用3个图像


405
00:21:50,177 --> 00:21:53,580
可是在整个应用中我会用到许许多多


406
00:21:54,314 --> 00:21:58,085
问题是很难找到你的代码中


407
00:21:58,185 --> 00:21:59,920
是否有输入错误幻灯片上是


408
00:21:59,987 --> 00:22:02,890
这些错误会引发的反应


409
00:22:02,990 --> 00:22:05,325
基于这些 
你可能会希望进行修改我明白


410
00:22:05,826 --> 00:22:10,297
但是确实很难回去把它们都找出来


411
00:22:10,364 --> 00:22:12,432
那么经典的解决方案应该是有个


412
00:22:12,499 --> 00:22:14,101
全局常数


413
00:22:14,401 --> 00:22:16,970
这样可以在应用的各个地方使用


414
00:22:17,037 --> 00:22:17,938
同样的常数


415
00:22:19,206 --> 00:22:21,008
如果使用正确那就可以把独角兽


416
00:22:21,074 --> 00:22:23,610
图像按照你的想法再找回来


417
00:22:23,677 --> 00:22:25,579
但还是要打开图像 因为编译器


418
00:22:25,913 --> 00:22:27,748
不清楚框架也不知道


419
00:22:27,814 --> 00:22:29,049
你是否会


420
00:22:29,149 --> 00:22:31,552
提供有效的常数名称


421
00:22:32,119 --> 00:22:35,522
此外 
可以提供随机的为API提供随机流


422
00:22:35,589 --> 00:22:40,060
运行时间会出现致命错误


423
00:22:41,261 --> 00:22:44,298
因为
NSUbiquity身份改变节点


424
00:22:44,364 --> 00:22:47,267
通知还是字符串可以有效传递至


425
00:22:47,334 --> 00:22:49,469
UI图像指定API


426
00:22:50,737 --> 00:22:52,840
我们来看看怎样解决这个问题


427
00:22:54,174 --> 00:22:56,844
我们要做的是严格的类型解决方案


428
00:22:56,910 --> 00:22:59,146
我们在代码中将字符串传递到各处


429
00:22:59,746 --> 00:23:02,816
我们希望的是强大的类型解决方案


430
00:23:04,551 --> 00:23:07,020
希望可以将字符串映射到


431
00:23:07,087 --> 00:23:08,355
新的类型


432
00:23:09,857 --> 00:23:13,026
这会让我们编码解决


433
00:23:13,093 --> 00:23:15,529
怎样搭建应用至


434
00:23:15,596 --> 00:23:17,064
编辑器的信息


435
00:23:17,130 --> 00:23:20,434
这样可以把非选择性UI图像


436
00:23:20,701 --> 00:23:21,702
返回到代码的各处


437
00:23:23,203 --> 00:23:24,505
解决方案就是


438
00:23:24,671 --> 00:23:28,141
针对应用进行枚举


439
00:23:28,208 --> 00:23:30,544
我们在应用中定义的枚举


440
00:23:31,545 --> 00:23:34,381
如果来看之前定义的代码


441
00:23:35,449 --> 00:23:38,218
我不希望代码是这幅样子


442
00:23:38,285 --> 00:23:42,789
我想每次生成UI图像对象都传递枚举


443
00:23:42,856 --> 00:23:44,558
这样我就不必


444
00:23:44,625 --> 00:23:48,095
在代码中打开返回值


445
00:23:48,862 --> 00:23:50,397
怎么实现呢？


446
00:23:51,665 --> 00:23:52,666
首先我希望


447
00:23:52,733 --> 00:23:58,005
定义UI图像的嵌套类型 以便在


448
00:23:58,071 --> 00:24:00,774
枚举大小写
和Asset Catalog中


449
00:24:01,141 --> 00:24:03,544
定义的字符串表达之间提供


450
00:24:03,610 --> 00:24:04,745
映射


451
00:24:05,979 --> 00:24:09,416
我们将之定义为嵌套类型


452
00:24:09,917 --> 00:24:12,853
这样可以存储在Asset
Catalog的其他资产


453
00:24:13,120 --> 00:24:14,922
也可以使用这种方法


454
00:24:16,123 --> 00:24:18,225
一旦这么做就非常简单


455
00:24:18,292 --> 00:24:22,229
我可以在枚举大小写和字符串表达之间


456
00:24:22,296 --> 00:24:23,664
提供大小写映射


457
00:24:24,164 --> 00:24:26,900
对所有其他的情况也可以这样


458
00:24:28,101 --> 00:24:31,905
这种方法的真正好处在于


459
00:24:31,972 --> 00:24:34,908
如果我不小心有输入错误 如果


460
00:24:34,975 --> 00:24:37,444
我不小心从什么地方复制粘贴了字符串


461
00:24:37,744 --> 00:24:39,646
出现了重复编译器就会


462
00:24:39,713 --> 00:24:42,282
警告或者报错 告诉我


463
00:24:42,616 --> 00:24:47,955
在枚举中出现了重复问题


464
00:24:49,156 --> 00:24:52,125
编译器可以这样帮忙 实在太好了


465
00:24:52,926 --> 00:24:54,795
现在我们已经定义了新类型


466
00:24:54,862 --> 00:24:58,265
我所需要做的就是
返回再编写便利初始化函数


467
00:24:58,332 --> 00:25:01,201
其中使用这个枚举而不是字符串


468
00:25:01,502 --> 00:25:04,171
并将枚举的原始值转至UIKit


469
00:25:04,438 --> 00:25:07,941
定义的UI图像命名初始化函数


470
00:25:09,409 --> 00:25:11,278
如果我们回来再看代码


471
00:25:11,378 --> 00:25:16,049
可以把独角兽放在所希望的任何地方


472
00:25:16,116 --> 00:25:19,419
如果我们再来看像以前
那样出现输入错误会怎样


473
00:25:19,486 --> 00:25:22,789
现在编译器可以告知出现了输入错误


474
00:25:22,990 --> 00:25:24,725
因为我们已经把应用结构的


475
00:25:24,992 --> 00:25:27,794
信息编入了代码之中


476
00:25:28,729 --> 00:25:31,265
如果修复这个问题
编译器错误也不复存在


477
00:25:32,933 --> 00:25:35,002
我们来谈谈这么做的好处


478
00:25:37,671 --> 00:25:41,308
首先是我们的常数位于中心


479
00:25:41,642 --> 00:25:45,078
如果将新的
图像加入Asset Catalog


480
00:25:45,145 --> 00:25:49,316
我准确知道该在哪里添加图像常数


481
00:25:50,918 --> 00:25:53,053
还有一个好处是这样做不会污染


482
00:25:53,120 --> 00:25:54,354
全局命名空间


483
00:25:54,421 --> 00:25:58,525
我可以有在Asset 
Catalog中定义的若干对象


484
00:25:58,592 --> 00:26:02,095
可以在其中运用这个办法


485
00:26:03,530 --> 00:26:06,433
最好的一点是 当构建UI图像对象时


486
00:26:06,500 --> 00:26:08,802
在应用中可以只用这些


487
00:26:08,869 --> 00:26:11,071
枚举情况中的一种


488
00:26:11,371 --> 00:26:13,340
所以编译器可以帮你实现这点


489
00:26:13,707 --> 00:26:16,977
现在你可以将非选择性图像返回到


490
00:26:17,044 --> 00:26:18,445
代码中的任何地方 因此不必担心


491
00:26:18,512 --> 00:26:20,247
强行打开的问题


492
00:26:20,547 --> 00:26:26,019
这是我们在独角兽
浏览器app中所用的非常


493
00:26:26,086 --> 00:26:28,188
独特的方式但我希望你们想想


494
00:26:28,255 --> 00:26:30,657
怎样在自己的代码中使用枚举


495
00:26:30,724 --> 00:26:32,960
以提供其他种类的富映射


496
00:26:33,961 --> 00:26:35,796
你们可以不只是作为字符串使用


497
00:26:35,863 --> 00:26:37,898
还可以使用整数甚至是选择器


498
00:26:38,265 --> 00:26:39,933
有很多机会


499
00:26:40,000 --> 00:26:42,569
在自己的代码中定义这些映射


500
00:26:44,404 --> 00:26:49,409
现在来深入探讨枚举 但是我想


501
00:26:49,476 --> 00:26:52,446
先说说联线标识符


502
00:26:52,513 --> 00:26:54,915
因为在代码中始终要


503
00:26:54,982 --> 00:26:55,983
使用到它


504
00:26:57,251 --> 00:27:00,320
现在 我的想法越发强烈


505
00:27:00,387 --> 00:27:03,390
我必须研制出一款app 
让我真正跟踪


506
00:27:03,824 --> 00:27:06,159
独角兽 并在运行中下载它们


507
00:27:07,361 --> 00:27:09,162
我有更复杂的应用


508
00:27:09,563 --> 00:27:12,032
如果来看故事板


509
00:27:12,432 --> 00:27:13,901
就会变得非常简单


510
00:27:14,568 --> 00:27:16,970
我只有单独的视图控制器 可以


511
00:27:17,037 --> 00:27:18,739
联线其他两个视图控制器


512
00:27:19,206 --> 00:27:23,544
对于所有这些视图控制器而言


513
00:27:23,610 --> 00:27:25,312
我定义了一个联线标识符


514
00:27:26,580 --> 00:27:29,550
我需要看看当我们覆盖


515
00:27:29,616 --> 00:27:32,419
联线准备来配置独角兽浏览器


516
00:27:32,486 --> 00:27:34,788
视图将呈现的


517
00:27:34,922 --> 00:27:37,724
视图控制器时 代码会是什么样


518
00:27:40,327 --> 00:27:43,197
我们覆盖了这种方法 执行这一点的


519
00:27:43,263 --> 00:27:45,365
经典办法是打开


520
00:27:45,432 --> 00:27:48,502
联线标识符字符串


521
00:27:49,369 --> 00:27:53,674
现在 在我使用完全相同的字符串之前


522
00:27:53,740 --> 00:27:56,810
我是按照故事板中的联线定义的字符串


523
00:27:57,344 --> 00:27:59,179
编辑器对此还一无所知


524
00:27:59,513 --> 00:28:02,316
当我只打开这两个字符串时


525
00:28:02,482 --> 00:28:03,784
编译器会告诉我


526
00:28:04,418 --> 00:28:07,454
这并非是穷尽性检测


527
00:28:07,521 --> 00:28:10,891
我必须加入默认情况
因为编译器不知道


528
00:28:11,558 --> 00:28:14,461
我已经提供了有效映射


529
00:28:15,863 --> 00:28:18,332
但是如果我加入了新的视图控制器


530
00:28:19,166 --> 00:28:22,369
必须有个全新的联线 那会怎样？


531
00:28:22,870 --> 00:28:24,271
我怎么才能知道在代码中


532
00:28:24,338 --> 00:28:25,939
哪里需要改变 这个逻辑？


533
00:28:27,241 --> 00:28:29,810
我们来看看再次通过枚举


534
00:28:29,877 --> 00:28:31,912
该怎么解决这个问题


535
00:28:33,280 --> 00:28:36,917
我定义了独角兽浏览器
视图控制器的嵌套类型


536
00:28:36,984 --> 00:28:38,485
它将代表联线标识符的情况


537
00:28:38,552 --> 00:28:41,021
和故事板字符串表达


538
00:28:41,321 --> 00:28:44,825
之间的映射


539
00:28:45,459 --> 00:28:48,595
我们来看 怎么实现用更强大的类型


540
00:28:48,662 --> 00:28:51,932
联线方法准备


541
00:28:53,600 --> 00:28:54,801
首先 我要做的是


542
00:28:54,868 --> 00:28:57,337
从故事板联线对象抓取联线


543
00:28:57,404 --> 00:28:59,139
标识符字符串


544
00:29:00,240 --> 00:29:02,476
并从原始值中构建联线


545
00:29:02,543 --> 00:29:03,677
识别符枚举


546
00:29:05,412 --> 00:29:07,181
我还会提供部分运行时间


547
00:29:07,247 --> 00:29:09,883
检测调试以防我并未


548
00:29:09,950 --> 00:29:13,353
为新的联线识别符 提供有效的


549
00:29:13,420 --> 00:29:15,355
枚举情况


550
00:29:16,290 --> 00:29:19,660
从这里 
我可以打开枚举 而不是字符串


551
00:29:20,394 --> 00:29:23,564
这非常棒 因为我必须打开


552
00:29:23,630 --> 00:29:27,835
两种情况 编译器知道我在枚举中


553
00:29:27,901 --> 00:29:31,605
只定义了两种情况
所以我必须在代码中打开


554
00:29:33,807 --> 00:29:37,711
如果我们在枚举中
添加了新的联线标识符


555
00:29:38,579 --> 00:29:40,747
编译器就会告知 我们并未


556
00:29:41,114 --> 00:29:45,853
进行穷尽性转换以便我们在枚举中


557
00:29:45,919 --> 00:29:49,122
打开的代码各处


558
00:29:49,590 --> 00:29:51,291
编译器就会告诉我们


559
00:29:51,358 --> 00:29:52,826
在哪里更新逻辑


560
00:29:53,327 --> 00:29:56,763
这对字符串解决方案来说
是个极大的好处


561
00:29:58,665 --> 00:30:01,602
我们可以这样重写联线准备


562
00:30:02,202 --> 00:30:05,305
但是 有时需要通过标识符 


563
00:30:05,372 --> 00:30:06,740
人工启动执行联线


564
00:30:08,242 --> 00:30:11,144
在本例中 我想要引入一束独角兽


565
00:30:11,211 --> 00:30:14,214
下载它们在Web上 下载图像


566
00:30:14,281 --> 00:30:15,916
显示新的视图控制器


567
00:30:16,383 --> 00:30:18,485
我们来看看 这些代码是什么样子


568
00:30:20,254 --> 00:30:23,690
那么经典的解决方案是将字符串


569
00:30:23,757 --> 00:30:26,326
传递至带有标识符方式的执行联线


570
00:30:27,694 --> 00:30:29,563
我们已经定义了这种枚举


571
00:30:29,630 --> 00:30:30,964
我们只是想使用已经提供的


572
00:30:31,031 --> 00:30:32,099
这种映射


573
00:30:32,666 --> 00:30:34,368
相反 我们想用枚举


574
00:30:35,769 --> 00:30:36,603
怎么做呢？


575
00:30:36,670 --> 00:30:38,205
其实 非常简单


576
00:30:38,272 --> 00:30:43,777
我们可以通过标识符方法定义
UIKit定义执行联线


577
00:30:44,111 --> 00:30:46,613
的过载其中采用了枚举
而不是字符串


578
00:30:47,381 --> 00:30:53,220
然后用枚举的原始值
调用UIKit 定义方法


579
00:30:53,854 --> 00:30:58,025
如果我们返回用枚举调用


580
00:30:58,825 --> 00:31:02,196
方法的代码
它完全是按照我们的预期运转


581
00:31:03,130 --> 00:31:05,232
这就是针对独角兽浏览器视图


582
00:31:05,299 --> 00:31:07,000
控制器的绝佳解决方案


583
00:31:07,935 --> 00:31:09,870
但是如果再复杂一点会怎样？


584
00:31:11,171 --> 00:31:13,807
我希望看看我们刚才做的结构


585
00:31:13,874 --> 00:31:15,542
看怎样才能把它应用到


586
00:31:15,609 --> 00:31:17,911
独角兽浏览器以外的视图控制器


587
00:31:20,314 --> 00:31:22,549
我们做的是在枚举情况


588
00:31:22,616 --> 00:31:25,452
及其故事板上的字符串表达之间


589
00:31:25,519 --> 00:31:26,453
提供映射


590
00:31:27,387 --> 00:31:30,123
我们还增加了使用该映射的


591
00:31:30,257 --> 00:31:33,093
执行 以便获得应用中


592
00:31:33,160 --> 00:31:36,930
更强大的类型系统


593
00:31:37,831 --> 00:31:39,299
但如果我们增添新的视图控制器


594
00:31:39,366 --> 00:31:40,801
我们希望做同样的事情


595
00:31:40,968 --> 00:31:45,339
需要不得不复制
所有那些工作我不希望这么做


596
00:31:46,840 --> 00:31:50,944
我真正想做的是从视图控制器提取


597
00:31:51,211 --> 00:31:54,982
执行 并定义松散映射
因为联线标识符的枚举


598
00:31:55,048 --> 00:31:59,253
会具体针对视图控制器


599
00:31:59,319 --> 00:32:03,090
通过这样做 我们可以为多种


600
00:32:03,156 --> 00:32:05,058
视图控制器使用该执行


601
00:32:05,526 --> 00:32:09,830
不论其类层次如何


602
00:32:09,897 --> 00:32:12,299
通过重复使用这个执行
可以避免许多


603
00:32:13,100 --> 00:32:15,769
糟糕的类层次


604
00:32:17,004 --> 00:32:20,007
我们会通过协议 来实现这一点


605
00:32:20,974 --> 00:32:22,409
所以我定义了一个新的协议


606
00:32:22,476 --> 00:32:24,211
我们会称之为联线处理类型


607
00:32:24,745 --> 00:32:26,280
我们的视图控制器需要与它


608
00:32:26,346 --> 00:32:27,181
相一致


609
00:32:28,515 --> 00:32:31,518
我希望定义刚提到的映射


610
00:32:32,085 --> 00:32:34,521
现在它将成为联线标识符枚举


611
00:32:35,389 --> 00:32:38,325
我们希望确保联线标识符和


612
00:32:38,392 --> 00:32:40,327
原始可显示协议相一致


613
00:32:41,261 --> 00:32:44,831
这个协议是个关于各类型支持的


614
00:32:44,898 --> 00:32:48,535
枚举的重要执行细节


615
00:32:49,369 --> 00:32:52,539
编译器可以自动为你合成


616
00:32:53,841 --> 00:32:56,543
关于协议定义就是这些


617
00:32:57,711 --> 00:33:00,714
我现在
需要用Swift 2.0的功能


618
00:33:00,781 --> 00:33:02,482
受限制的协议扩展


619
00:33:02,916 --> 00:33:04,818
来实际添加将成为我们的


620
00:33:05,018 --> 00:33:06,920
泛性可重用代码的执行


621
00:33:07,821 --> 00:33:10,657
我们将扩展联线处理类型


622
00:33:11,325 --> 00:33:12,693
接下来我们对之加以限制


623
00:33:12,759 --> 00:33:15,195
如果这些限制条件满足的话 
我们只想让执行


624
00:33:16,830 --> 00:33:18,799
加入其中


625
00:33:19,533 --> 00:33:23,070
第一个限制条件是满足协议的类型为


626
00:33:23,136 --> 00:33:26,139
UI视图控制器子类


627
00:33:26,540 --> 00:33:27,841
这将会让我们在协议扩展中


628
00:33:27,908 --> 00:33:30,010
调用UI视图


629
00:33:30,544 --> 00:33:31,812
控制器方法


630
00:33:33,013 --> 00:33:35,115
第二点是我们想确定


631
00:33:35,182 --> 00:33:38,051
联线标识符映射是位于


632
00:33:38,118 --> 00:33:40,821
映射情况和字符串之间


633
00:33:42,689 --> 00:33:45,425
我们已经定义了
有限制条件的协议扩展


634
00:33:45,492 --> 00:33:47,494
我们所需要做的就是添加执行


635
00:33:48,195 --> 00:33:51,198
我们要通过之前定义的标识符 


636
00:33:51,265 --> 00:33:55,002
采用联线现有执行 


637
00:33:55,602 --> 00:33:58,872
并将完全相同的执行加入代码


638
00:34:00,807 --> 00:34:03,277
如果我们返回
独角兽浏览器视图控制器


639
00:34:03,710 --> 00:34:06,947
我们只需在新类型中加入一致性


640
00:34:08,014 --> 00:34:11,217
我们已经满足了协议的所有
相关类型限制条件


641
00:34:11,318 --> 00:34:15,155
因为我们已经识别了这个联线


642
00:34:15,222 --> 00:34:16,056
标识符枚举


643
00:34:17,591 --> 00:34:21,360
如果我们进入处理行为方法 我们可以


644
00:34:21,428 --> 00:34:26,166
用完全相同的方式调用代码 
但我们在联线处理类型中重用执行


645
00:34:27,568 --> 00:34:29,770
我们可以这样通过标识符方式


646
00:34:29,837 --> 00:34:35,007
重用表现联线
但是要是调用联线准备


647
00:34:35,242 --> 00:34:36,510
或联线处理准备会怎样？


648
00:34:37,811 --> 00:34:40,547
我需要定义便捷方式


649
00:34:40,614 --> 00:34:42,882
其中会采用故事板对象


650
00:34:43,350 --> 00:34:46,520
并返回联线标识符枚举


651
00:34:46,587 --> 00:34:47,855
这是在协议扩展中完成


652
00:34:49,188 --> 00:34:53,092
我要再次做的是使用之前定义的执行


653
00:34:55,295 --> 00:34:56,964
返回我们用代码


654
00:34:57,030 --> 00:34:59,867
生成的联线标识符枚举


655
00:35:00,901 --> 00:35:03,070
如果来看为联线方式所做准备


656
00:35:03,136 --> 00:35:05,739
结果就变得非常简单


657
00:35:06,807 --> 00:35:10,043
我们所需要做的就是通过联线的


658
00:35:10,110 --> 00:35:13,514
联线识别符 打开结果返回
这是我们刚定义的方法我们只需要提供


659
00:35:14,248 --> 00:35:19,086
两种情况打开方法和之前的完全相同


660
00:35:19,987 --> 00:35:21,355
但是我们有这个泛型解决方案


661
00:35:22,489 --> 00:35:24,558
我们来谈谈这么做的好处


662
00:35:27,094 --> 00:35:31,965
当我们将之添加到 
联线标识符枚举中时


663
00:35:32,165 --> 00:35:34,201
编译器完全了解我们在故事板上


664
00:35:34,268 --> 00:35:36,069
定义的联线


665
00:35:37,137 --> 00:35:38,705
可以确保我们在代码中


666
00:35:38,772 --> 00:35:40,541
处理了所有可能的情况


667
00:35:41,808 --> 00:35:46,113
通过使用协议扩展
我们具有可重新使用的解决方案


668
00:35:46,180 --> 00:35:49,516
我们可以在符合
新协议的任何视图


669
00:35:49,583 --> 00:35:51,084
控制器上使用这个执行


670
00:35:52,519 --> 00:35:54,521
我们还有便捷句法


671
00:35:54,922 --> 00:35:57,958
可以在不同的


672
00:35:59,826 --> 00:36:01,128
视图控制器上使用方法句法


673
00:36:01,195 --> 00:36:02,796
不一定必须是 自由函数


674
00:36:04,064 --> 00:36:07,601
这是在独角兽浏览器app中
可以使用协议和


675
00:36:07,668 --> 00:36:10,771
有限制方式的协议扩展的 


676
00:36:11,104 --> 00:36:13,574
独特方式但是大家都有
许多其他有趣应用


677
00:36:13,941 --> 00:36:14,908
我想让大家做的是思考一下


678
00:36:14,975 --> 00:36:18,846
怎样在自己的应用中使用协议和


679
00:36:19,112 --> 00:36:22,516
相关类型限制条件来编码部分


680
00:36:22,583 --> 00:36:25,552
应用的结构到编译器这样它可以帮你


681
00:36:26,019 --> 00:36:27,387
实现编译时间安全性


682
00:36:28,488 --> 00:36:30,524
我想让你们想想


683
00:36:30,591 --> 00:36:32,259
怎样使用协议扩展


684
00:36:32,593 --> 00:36:35,462
在自己的应用中分享执行


685
00:36:35,863 --> 00:36:39,066
避免一系列糟糕的类层次问题


686
00:36:41,201 --> 00:36:45,272
泰德和我今天说得够多了
但是希望大家从中领会到


687
00:36:45,339 --> 00:36:47,140
编译器是来帮助大家的


688
00:36:49,142 --> 00:36:52,946
泰德说的是如何在新API中
安全利用这一点


689
00:36:53,280 --> 00:36:55,649
现在 这可以通过编译器大部分完成


690
00:36:56,316 --> 00:36:59,586
编译器知道有什么这不是具体针对


691
00:36:59,987 --> 00:37:01,522
哪个OS的版本


692
00:37:02,856 --> 00:37:05,926
我和大家介绍的是应用的强大类型


693
00:37:05,993 --> 00:37:07,761
强迫应用实现不变性


694
00:37:08,028 --> 00:37:09,396
并利用编译器


695
00:37:09,730 --> 00:37:11,698
让它知道应用的限制条件


696
00:37:11,765 --> 00:37:15,002
并把这些信息编入代码


697
00:37:15,435 --> 00:37:17,971
这样编译器可以帮你分析


698
00:37:18,038 --> 00:37:20,340
编译时间的问题而不是在运行时间


699
00:37:21,875 --> 00:37:23,143
若要了解更多详情


700
00:37:23,210 --> 00:37:29,149
建议大家在线观看
《基于协议的Swift编程》


701
00:37:29,983 --> 00:37:33,620
讲座 如果你自己对
Cocoa和Swift


702
00:37:33,687 --> 00:37:35,789
有明晰的梦想建议你仔细看看
这两个示例


703
00:37:35,856 --> 00:37:40,093
编目示例有联线
处理类型协议的实例


704
00:37:40,394 --> 00:37:41,562
DemoBots使用了


705
00:37:41,628 --> 00:37:45,866
在协议中使用
枚举的一系列有趣方法


706
00:37:47,100 --> 00:37:48,402
实现编译时间安全性


707
00:37:49,269 --> 00:37:51,138
若要了解更多详情可以查看


708
00:37:51,205 --> 00:37:53,006
Swift Language
Documentation


709
00:37:53,073 --> 00:37:55,676
我们还有开发人员论坛如有任何问题 


710
00:37:55,742 --> 00:37:56,877
你们也可以联系斯特凡


711
00:37:57,211 --> 00:38:00,013
感谢大家希望能在实验室见到大家

